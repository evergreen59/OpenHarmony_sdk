/******************************************************************************
 * Copyright (C) 2022, Xiaohua Semiconductor Co., Ltd. All rights reserved.
 *
 * This software component is licensed by XHSC under BSD 3-Clause license
 * (the "License"); You may not use this file except in compliance with the
 * License. You may obtain a copy of the License at:
 *                    opensource.org/licenses/BSD-3-Clause
 *
 */
/*****************************************************************************/
/*  File        HC32F4A0xG.ld                                                */
/*  Abstract    Linker script for HC32F4A0 Device with                       */
/*              1MByte FLASH, 516KByte RAM                                   */
/*  Version     V1.0                                                         */
/*  Date        2022-03-31                                                   */
/*****************************************************************************/

ENTRY(Reset_Handler)

/* Custom defines, according to section 7.7 of the user manual.
   Take OTP sector 16 for example. */
__OTP_DATA_START = 0x03000000;
__OTP_DATA_SIZE  = 2048;
__OTP_LOCK_START = 0x03001840;
__OTP_LOCK_SIZE  = 4;

/* Use contiguous memory regions for simple. */
MEMORY
{
    FLASH       (rx): ORIGIN = 0x00000000, LENGTH = 1M
    OTP_DATA    (rx): ORIGIN = __OTP_DATA_START, LENGTH = __OTP_DATA_SIZE
    OTP_LOCK    (rx): ORIGIN = __OTP_LOCK_START, LENGTH = __OTP_LOCK_SIZE
    RAM        (rwx): ORIGIN = 0x1FFE0000, LENGTH = 512K
    RAMB       (rwx): ORIGIN = 0x200F0000, LENGTH = 4K
}

SECTIONS
{
    .vectors :
    {
        . = ALIGN(8);
        KEEP(*(.vectors))
        . = ALIGN(8);
    } >FLASH

    .icg_sec 0x00000400 :
    {
        KEEP(*(.icg_sec))
    } >FLASH

    .text :
    {
        . = ALIGN(4);
        __stext = . ;
        *(.text)
        *(.text*)
        *(.glue_7)
        *(.glue_7t)
        *(.eh_frame)

        KEEP(*(.init))
        KEEP(*(.fini))
        . = ALIGN(4);
        _etext = .;
    } >FLASH

    .rodata :
    {
        . = ALIGN(4);
        *(.rodata)
        *(.rodata*)
        . = ALIGN(4);
    } >FLASH

    .hdf :
    {
        . = ALIGN(0x4) ;
        _hdf_drivers_start = .;
        KEEP(*(.hdf.driver))
        _hdf_drivers_end = .; /* define a section for hdf driver */
        . = ALIGN(0x4) ;
    } >FLASH

    .zinitcall_array :
    {
        . = ALIGN(0x4) ;
        PROVIDE_HIDDEN (__zinitcall_core_start = .);
        KEEP (*(SORT(.zinitcall.core*)))
        KEEP (*(.zinitcall.core*))
        PROVIDE_HIDDEN (__zinitcall_core_end = .);
        . = ALIGN(0x4) ;
        PROVIDE_HIDDEN (__zinitcall_device_start = .);
        KEEP (*(SORT(.zinitcall.device*)))
        KEEP (*(.zinitcall.device*))
        PROVIDE_HIDDEN (__zinitcall_device_end = .);
        . = ALIGN(0x4) ;
        PROVIDE_HIDDEN (__zinitcall_bsp_start = .);
        KEEP (*(SORT(.zinitcall.bsp*)))
        KEEP (*(.zinitcall.bsp*))
        PROVIDE_HIDDEN (__zinitcall_bsp_end = .);
        . = ALIGN(0x4) ;
        PROVIDE_HIDDEN (__zinitcall_sys_service_start = .);
        KEEP (*(SORT(.zinitcall.sys.service*)))
        KEEP (*(.zinitcall.sys.service*))
        PROVIDE_HIDDEN (__zinitcall_sys_service_end = .);
        . = ALIGN(0x4) ;
        PROVIDE_HIDDEN (__zinitcall_app_service_start = .);
        KEEP (*(SORT(.zinitcall.app.service*)))
        KEEP (*(.zinitcall.app.service*))
        PROVIDE_HIDDEN (__zinitcall_app_service_end = .);
        . = ALIGN(0x4) ;
        PROVIDE_HIDDEN (__zinitcall_sys_feature_start = .);
        KEEP (*(SORT(.zinitcall.sys.feature*)))
        KEEP (*(.zinitcall.sys.feature*))
        PROVIDE_HIDDEN (__zinitcall_sys_feature_end = .);
        . = ALIGN(0x4) ;
        PROVIDE_HIDDEN (__zinitcall_app_feature_start = .);
        KEEP (*(SORT(.zinitcall.app.feature*)))
        KEEP (*(.zinitcall.app.feature*))
        PROVIDE_HIDDEN (__zinitcall_app_feature_end = .);
        . = ALIGN(0x4) ;
        PROVIDE_HIDDEN (__zinitcall_run_start = .);
        KEEP (*(SORT(.zinitcall.run*)))
        KEEP (*(.zinitcall.run*))
        PROVIDE_HIDDEN (__zinitcall_run_end = .);
        . = ALIGN(0x4) ;
        PROVIDE_HIDDEN (__zinitcall_test_start = .);
        KEEP (*(SORT(.zinitcall.test*)))
        KEEP (*(.zinitcall.test*))
        PROVIDE_HIDDEN (__zinitcall_test_end = .);
        . = ALIGN(0x4) ;
        PROVIDE_HIDDEN (__zinitcall_exit_start = .);
        KEEP (*(SORT(.zinitcall.exit*)))
        KEEP (*(.zinitcall.exit*))
        PROVIDE_HIDDEN (__zinitcall_exit_end = .);
    } > FLASH

    .ARM.extab :
    {
        *(.ARM.extab* .gnu.linkonce.armextab.*)
    } >FLASH

    __exidx_start = .;
    .ARM.exidx :
    {
        *(.ARM.exidx* .gnu.linkonce.armexidx.*)
    } >FLASH
    __exidx_end = .;

    .preinit_array :
    {
        . = ALIGN(4);
        /* preinit data */
        PROVIDE_HIDDEN (__preinit_array_start = .);
        KEEP(*(.preinit_array))
        PROVIDE_HIDDEN (__preinit_array_end = .);
        . = ALIGN(4);
    } >FLASH

    .init_array :
    {
        . = ALIGN(4);
        /* init data */
        PROVIDE_HIDDEN (__init_array_start = .);
        KEEP(*(SORT(.init_array.*)))
        KEEP(*(.init_array))
        PROVIDE_HIDDEN (__init_array_end = .);
        . = ALIGN(4);
    } >FLASH

    .fini_array :
    {
        . = ALIGN(4);
        /* finit data */
        PROVIDE_HIDDEN (__fini_array_start = .);
        KEEP(*(SORT(.fini_array.*)))
        KEEP(*(.fini_array))
        PROVIDE_HIDDEN (__fini_array_end = .);
        . = ALIGN(4);
    } >FLASH

    __etext = ALIGN(4);

    .otp_data_sec :
    {
        KEEP(*(.otp_data_sec))
    } >OTP_DATA

    .otp_lock_sec :
    {
        KEEP(*(.otp_lock_sec))
    } >OTP_LOCK

    .data : AT (__etext)
    {
        . = ALIGN(4);
        __data_start__ = .;
        *(vtable)
        *(.data)
        *(.data*)
        . = ALIGN(4);
        *(.ramfunc)
        *(.ramfunc*)
        . = ALIGN(4);
        __data_end__ = .;
    } >RAM

    __etext_ramb = __etext + ALIGN (SIZEOF(.data), 4);
    .ramb_data : AT (__etext_ramb)
    {
        . = ALIGN(4);
        __data_start_ramb__ = .;
        *(.ramb_data)
        *(.ramb_data*)
        . = ALIGN(4);
        __data_end_ramb__ = .;
    } >RAMB

    .bss :
    {
        . = ALIGN(4);
        _sbss = .;
        __bss_start__ = _sbss;
        *(.bss)
        *(.bss*)
        *(COMMON)
        . = ALIGN(4);
        _ebss = .;
        __bss_end__ = _ebss;
    } >RAM

    .ramb_bss :
    {
        . = ALIGN(4);
        __bss_start_ramb__ = .;
        *(.ramb_bss)
        *(.ramb_bss*)
        . = ALIGN(4);
        __bss_end_ramb__ = .;
    } >RAMB

    .heap_stack (COPY) :
    {
        . = ALIGN(8);
        __end__ = .;
        PROVIDE(end = .);
        PROVIDE(_end = .);
    } >RAM

    ._stack (COPY) :
    {
        . = ALIGN(8);
        *(.stack*)

    } >RAM

    __StackTop = ORIGIN(RAM) + LENGTH(RAM);
    __StackLimit = __StackTop - SIZEOF(._stack);

    __HeapLimit = __StackLimit;
    __HeapBase = __end__;

    ASSERT(__StackLimit >= __HeapLimit, "region RAM overflowed with stack")

    __heap_start = __HeapBase;
    __heap_size = __HeapLimit - __HeapBase; 

    .ARM.attributes 0 : { *(.ARM.attributes) }

    PROVIDE(_stack = __StackTop);
    PROVIDE(_Min_Heap_Size = __HeapLimit - __HeapBase);
    PROVIDE(_Min_Stack_Size = __StackTop - __StackLimit);

    __RamEnd = ORIGIN(RAM) + LENGTH(RAM);
    ASSERT(__StackTop <= __RamEnd, "region RAM overflowed with stack")
}
