commit 773b4f18c1b9df2eae6452f6fa9f19db33286ea3
Author: zhaoxc0502 <zhaoxc0502@thundersoft.com>
Date:   Sat Jul 16 10:27:46 2022 +0800

    linux_include.patch
    
    Change-Id: Icf23f02df7b566848af808b9eeaed889d1773e71

diff --git a/include/drm/bridge/cdns-mhdp.h b/include/drm/bridge/cdns-mhdp.h
new file mode 100644
index 000000000..f3bdff5c3
--- /dev/null
+++ b/include/drm/bridge/cdns-mhdp.h
@@ -0,0 +1,921 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * Copyright (C) Fuzhou Rockchip Electronics Co.Ltd
+ * Author: Chris Zhong <zyw@rock-chips.com>
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#ifndef CDNS_MHDP_H_
+#define CDNS_MHDP_H_
+
+#include <drm/drm_bridge.h>
+#include <drm/drm_connector.h>
+#include <drm/drm_dp_helper.h>
+#include <drm/drm_dp_mst_helper.h>
+#include <media/cec.h>
+#include <linux/bitops.h>
+#include <sound/hdmi-codec.h>
+
+#define ADDR_IMEM		0x10000
+#define ADDR_DMEM		0x20000
+#define ADDR_PHY_AFE	0x80000
+
+/* APB CFG addr */
+#define APB_CTRL			0
+#define XT_INT_CTRL			0x04
+#define MAILBOX_FULL_ADDR		0x08
+#define MAILBOX_EMPTY_ADDR		0x0c
+#define MAILBOX0_WR_DATA		0x10
+#define MAILBOX0_RD_DATA		0x14
+#define KEEP_ALIVE			0x18
+#define VER_L				0x1c
+#define VER_H				0x20
+#define VER_LIB_L_ADDR			0x24
+#define VER_LIB_H_ADDR			0x28
+#define SW_DEBUG_L			0x2c
+#define SW_DEBUG_H			0x30
+#define MAILBOX_INT_MASK		0x34
+#define MAILBOX_INT_STATUS		0x38
+#define SW_CLK_L			0x3c
+#define SW_CLK_H			0x40
+#define SW_EVENTS0			0x44
+#define SW_EVENTS1			0x48
+#define SW_EVENTS2			0x4c
+#define SW_EVENTS3			0x50
+#define XT_OCD_CTRL			0x60
+#define APB_INT_MASK			0x6c
+#define APB_STATUS_MASK			0x70
+
+/* audio decoder addr */
+#define AUDIO_SRC_CNTL			0x30000
+#define AUDIO_SRC_CNFG			0x30004
+#define COM_CH_STTS_BITS		0x30008
+#define STTS_BIT_CH(x)			(0x3000c + ((x) << 2))
+#define SPDIF_CTRL_ADDR			0x3004c
+#define SPDIF_CH1_CS_3100_ADDR		0x30050
+#define SPDIF_CH1_CS_6332_ADDR		0x30054
+#define SPDIF_CH1_CS_9564_ADDR		0x30058
+#define SPDIF_CH1_CS_12796_ADDR		0x3005c
+#define SPDIF_CH1_CS_159128_ADDR	0x30060
+#define SPDIF_CH1_CS_191160_ADDR	0x30064
+#define SPDIF_CH2_CS_3100_ADDR		0x30068
+#define SPDIF_CH2_CS_6332_ADDR		0x3006c
+#define SPDIF_CH2_CS_9564_ADDR		0x30070
+#define SPDIF_CH2_CS_12796_ADDR		0x30074
+#define SPDIF_CH2_CS_159128_ADDR	0x30078
+#define SPDIF_CH2_CS_191160_ADDR	0x3007c
+#define SMPL2PKT_CNTL			0x30080
+#define SMPL2PKT_CNFG			0x30084
+#define FIFO_CNTL			0x30088
+#define FIFO_STTS			0x3008c
+
+/* source pif addr */
+#define SOURCE_PIF_WR_ADDR		0x30800
+#define SOURCE_PIF_WR_REQ		0x30804
+#define SOURCE_PIF_RD_ADDR		0x30808
+#define SOURCE_PIF_RD_REQ		0x3080c
+#define SOURCE_PIF_DATA_WR		0x30810
+#define SOURCE_PIF_DATA_RD		0x30814
+#define SOURCE_PIF_FIFO1_FLUSH		0x30818
+#define SOURCE_PIF_FIFO2_FLUSH		0x3081c
+#define SOURCE_PIF_STATUS		0x30820
+#define SOURCE_PIF_INTERRUPT_SOURCE	0x30824
+#define SOURCE_PIF_INTERRUPT_MASK	0x30828
+#define SOURCE_PIF_PKT_ALLOC_REG	0x3082c
+#define SOURCE_PIF_PKT_ALLOC_WR_EN	0x30830
+#define SOURCE_PIF_SW_RESET		0x30834
+
+/* bellow registers need access by mailbox */
+/* source phy comp */
+#define PHY_DATA_SEL			0x0818
+#define LANES_CONFIG			0x0814
+
+/* source car addr */
+#define SOURCE_HDTX_CAR			0x0900
+#define SOURCE_DPTX_CAR			0x0904
+#define SOURCE_PHY_CAR			0x0908
+#define SOURCE_CEC_CAR			0x090c
+#define SOURCE_CBUS_CAR			0x0910
+#define SOURCE_PKT_CAR			0x0918
+#define SOURCE_AIF_CAR			0x091c
+#define SOURCE_CIPHER_CAR		0x0920
+#define SOURCE_CRYPTO_CAR		0x0924
+
+/* mhdp tx_top_comp */
+#define SCHEDULER_H_SIZE		0x1000
+#define SCHEDULER_V_SIZE		0x1004
+#define HDTX_SIGNAL_FRONT_WIDTH	0x100c
+#define HDTX_SIGNAL_SYNC_WIDTH	0x1010
+#define HDTX_SIGNAL_BACK_WIDTH	0x1014
+#define HDTX_CONTROLLER			0x1018
+#define HDTX_HPD				0x1020
+#define HDTX_CLOCK_REG_0		0x1024
+#define HDTX_CLOCK_REG_1		0x1028
+
+/* clock meters addr */
+#define CM_CTRL				0x0a00
+#define CM_I2S_CTRL			0x0a04
+#define CM_SPDIF_CTRL			0x0a08
+#define CM_VID_CTRL			0x0a0c
+#define CM_LANE_CTRL			0x0a10
+#define I2S_NM_STABLE			0x0a14
+#define I2S_NCTS_STABLE			0x0a18
+#define SPDIF_NM_STABLE			0x0a1c
+#define SPDIF_NCTS_STABLE		0x0a20
+#define NMVID_MEAS_STABLE		0x0a24
+#define I2S_MEAS			0x0a40
+#define SPDIF_MEAS			0x0a80
+#define NMVID_MEAS			0x0ac0
+
+/* source vif addr */
+#define BND_HSYNC2VSYNC			0x0b00
+#define HSYNC2VSYNC_F1_L1		0x0b04
+#define HSYNC2VSYNC_F2_L1		0x0b08
+#define HSYNC2VSYNC_STATUS		0x0b0c
+#define HSYNC2VSYNC_POL_CTRL		0x0b10
+
+/* dptx phy addr */
+#define DP_TX_PHY_CONFIG_REG		0x2000
+#define DP_TX_PHY_SW_RESET		0x2004
+#define DP_TX_PHY_SCRAMBLER_SEED	0x2008
+#define DP_TX_PHY_TRAINING_01_04	0x200c
+#define DP_TX_PHY_TRAINING_05_08	0x2010
+#define DP_TX_PHY_TRAINING_09_10	0x2014
+#define TEST_COR			0x23fc
+
+/* dptx hpd addr */
+#define HPD_IRQ_DET_MIN_TIMER		0x2100
+#define HPD_IRQ_DET_MAX_TIMER		0x2104
+#define HPD_UNPLGED_DET_MIN_TIMER	0x2108
+#define HPD_STABLE_TIMER		0x210c
+#define HPD_FILTER_TIMER		0x2110
+#define HPD_EVENT_MASK			0x211c
+#define HPD_EVENT_DET			0x2120
+
+/* dpyx framer addr */
+#define DP_FRAMER_GLOBAL_CONFIG		0x2200
+#define DP_SW_RESET			0x2204
+#define DP_FRAMER_TU			0x2208
+#define DP_FRAMER_PXL_REPR		0x220c
+#define DP_FRAMER_SP			0x2210
+#define AUDIO_PACK_CONTROL		0x2214
+#define DP_VC_TABLE(x)			(0x2218 + ((x) << 2))
+#define DP_VB_ID			0x2258
+#define DP_MTPH_LVP_CONTROL		0x225c
+#define DP_MTPH_SYMBOL_VALUES		0x2260
+#define DP_MTPH_ECF_CONTROL		0x2264
+#define DP_MTPH_ACT_CONTROL		0x2268
+#define DP_MTPH_STATUS			0x226c
+#define DP_INTERRUPT_SOURCE		0x2270
+#define DP_INTERRUPT_MASK		0x2274
+#define DP_FRONT_BACK_PORCH		0x2278
+#define DP_BYTE_COUNT			0x227c
+
+/* dptx stream addr */
+#define MSA_HORIZONTAL_0		0x2280
+#define MSA_HORIZONTAL_1		0x2284
+#define MSA_VERTICAL_0			0x2288
+#define MSA_VERTICAL_1			0x228c
+#define MSA_MISC			0x2290
+#define STREAM_CONFIG			0x2294
+#define AUDIO_PACK_STATUS		0x2298
+#define VIF_STATUS			0x229c
+#define PCK_STUFF_STATUS_0		0x22a0
+#define PCK_STUFF_STATUS_1		0x22a4
+#define INFO_PACK_STATUS		0x22a8
+#define RATE_GOVERNOR_STATUS		0x22ac
+#define DP_HORIZONTAL			0x22b0
+#define DP_VERTICAL_0			0x22b4
+#define DP_VERTICAL_1			0x22b8
+#define DP_BLOCK_SDP			0x22bc
+
+/* dptx glbl addr */
+#define DPTX_LANE_EN			0x2300
+#define DPTX_ENHNCD			0x2304
+#define DPTX_INT_MASK			0x2308
+#define DPTX_INT_STATUS			0x230c
+
+/* dp aux addr */
+#define DP_AUX_HOST_CONTROL		0x2800
+#define DP_AUX_INTERRUPT_SOURCE		0x2804
+#define DP_AUX_INTERRUPT_MASK		0x2808
+#define DP_AUX_SWAP_INVERSION_CONTROL	0x280c
+#define DP_AUX_SEND_NACK_TRANSACTION	0x2810
+#define DP_AUX_CLEAR_RX			0x2814
+#define DP_AUX_CLEAR_TX			0x2818
+#define DP_AUX_TIMER_STOP		0x281c
+#define DP_AUX_TIMER_CLEAR		0x2820
+#define DP_AUX_RESET_SW			0x2824
+#define DP_AUX_DIVIDE_2M		0x2828
+#define DP_AUX_TX_PREACHARGE_LENGTH	0x282c
+#define DP_AUX_FREQUENCY_1M_MAX		0x2830
+#define DP_AUX_FREQUENCY_1M_MIN		0x2834
+#define DP_AUX_RX_PRE_MIN		0x2838
+#define DP_AUX_RX_PRE_MAX		0x283c
+#define DP_AUX_TIMER_PRESET		0x2840
+#define DP_AUX_NACK_FORMAT		0x2844
+#define DP_AUX_TX_DATA			0x2848
+#define DP_AUX_RX_DATA			0x284c
+#define DP_AUX_TX_STATUS		0x2850
+#define DP_AUX_RX_STATUS		0x2854
+#define DP_AUX_RX_CYCLE_COUNTER		0x2858
+#define DP_AUX_MAIN_STATES		0x285c
+#define DP_AUX_MAIN_TIMER		0x2860
+#define DP_AUX_AFE_OUT			0x2864
+
+/* crypto addr */
+#define CRYPTO_HDCP_REVISION		0x5800
+#define HDCP_CRYPTO_CONFIG		0x5804
+#define CRYPTO_INTERRUPT_SOURCE		0x5808
+#define CRYPTO_INTERRUPT_MASK		0x580c
+#define CRYPTO22_CONFIG			0x5818
+#define CRYPTO22_STATUS			0x581c
+#define SHA_256_DATA_IN			0x583c
+#define SHA_256_DATA_OUT_(x)		(0x5850 + ((x) << 2))
+#define AES_32_KEY_(x)			(0x5870 + ((x) << 2))
+#define AES_32_DATA_IN			0x5880
+#define AES_32_DATA_OUT_(x)		(0x5884 + ((x) << 2))
+#define CRYPTO14_CONFIG			0x58a0
+#define CRYPTO14_STATUS			0x58a4
+#define CRYPTO14_PRNM_OUT		0x58a8
+#define CRYPTO14_KM_0			0x58ac
+#define CRYPTO14_KM_1			0x58b0
+#define CRYPTO14_AN_0			0x58b4
+#define CRYPTO14_AN_1			0x58b8
+#define CRYPTO14_YOUR_KSV_0		0x58bc
+#define CRYPTO14_YOUR_KSV_1		0x58c0
+#define CRYPTO14_MI_0			0x58c4
+#define CRYPTO14_MI_1			0x58c8
+#define CRYPTO14_TI_0			0x58cc
+#define CRYPTO14_KI_0			0x58d0
+#define CRYPTO14_KI_1			0x58d4
+#define CRYPTO14_BLOCKS_NUM		0x58d8
+#define CRYPTO14_KEY_MEM_DATA_0		0x58dc
+#define CRYPTO14_KEY_MEM_DATA_1		0x58e0
+#define CRYPTO14_SHA1_MSG_DATA		0x58e4
+#define CRYPTO14_SHA1_V_VALUE_(x)	(0x58e8 + ((x) << 2))
+#define TRNG_CTRL			0x58fc
+#define TRNG_DATA_RDY			0x5900
+#define TRNG_DATA			0x5904
+
+/* cipher addr */
+#define HDCP_REVISION			0x60000
+#define INTERRUPT_SOURCE		0x60004
+#define INTERRUPT_MASK			0x60008
+#define HDCP_CIPHER_CONFIG		0x6000c
+#define AES_128_KEY_0			0x60010
+#define AES_128_KEY_1			0x60014
+#define AES_128_KEY_2			0x60018
+#define AES_128_KEY_3			0x6001c
+#define AES_128_RANDOM_0		0x60020
+#define AES_128_RANDOM_1		0x60024
+#define CIPHER14_KM_0			0x60028
+#define CIPHER14_KM_1			0x6002c
+#define CIPHER14_STATUS			0x60030
+#define CIPHER14_RI_PJ_STATUS		0x60034
+#define CIPHER_MODE			0x60038
+#define CIPHER14_AN_0			0x6003c
+#define CIPHER14_AN_1			0x60040
+#define CIPHER22_AUTH			0x60044
+#define CIPHER14_R0_DP_STATUS		0x60048
+#define CIPHER14_BOOTSTRAP		0x6004c
+
+#define DPTX_FRMR_DATA_CLK_RSTN_EN	BIT(11)
+#define DPTX_FRMR_DATA_CLK_EN		BIT(10)
+#define DPTX_PHY_DATA_RSTN_EN		BIT(9)
+#define DPTX_PHY_DATA_CLK_EN		BIT(8)
+#define DPTX_PHY_CHAR_RSTN_EN		BIT(7)
+#define DPTX_PHY_CHAR_CLK_EN		BIT(6)
+#define SOURCE_AUX_SYS_CLK_RSTN_EN	BIT(5)
+#define SOURCE_AUX_SYS_CLK_EN		BIT(4)
+#define DPTX_SYS_CLK_RSTN_EN		BIT(3)
+#define DPTX_SYS_CLK_EN			BIT(2)
+#define CFG_DPTX_VIF_CLK_RSTN_EN	BIT(1)
+#define CFG_DPTX_VIF_CLK_EN		BIT(0)
+
+#define SOURCE_PHY_RSTN_EN		BIT(1)
+#define SOURCE_PHY_CLK_EN		BIT(0)
+
+#define SOURCE_PKT_SYS_RSTN_EN		BIT(3)
+#define SOURCE_PKT_SYS_CLK_EN		BIT(2)
+#define SOURCE_PKT_DATA_RSTN_EN		BIT(1)
+#define SOURCE_PKT_DATA_CLK_EN		BIT(0)
+
+#define SPDIF_CDR_CLK_RSTN_EN		BIT(5)
+#define SPDIF_CDR_CLK_EN		BIT(4)
+#define SOURCE_AIF_SYS_RSTN_EN		BIT(3)
+#define SOURCE_AIF_SYS_CLK_EN		BIT(2)
+#define SOURCE_AIF_CLK_RSTN_EN		BIT(1)
+#define SOURCE_AIF_CLK_EN		BIT(0)
+
+#define SOURCE_CIPHER_SYSTEM_CLK_RSTN_EN	BIT(3)
+#define SOURCE_CIPHER_SYS_CLK_EN		BIT(2)
+#define SOURCE_CIPHER_CHAR_CLK_RSTN_EN		BIT(1)
+#define SOURCE_CIPHER_CHAR_CLK_EN		BIT(0)
+
+#define SOURCE_CRYPTO_SYS_CLK_RSTN_EN	BIT(1)
+#define SOURCE_CRYPTO_SYS_CLK_EN	BIT(0)
+
+#define APB_IRAM_PATH			BIT(2)
+#define APB_DRAM_PATH			BIT(1)
+#define APB_XT_RESET			BIT(0)
+
+#define MAILBOX_INT_MASK_BIT		BIT(1)
+#define PIF_INT_MASK_BIT		BIT(0)
+#define ALL_INT_MASK			3
+
+/* mailbox */
+#define MB_OPCODE_ID			0
+#define MB_MODULE_ID			1
+#define MB_SIZE_MSB_ID			2
+#define MB_SIZE_LSB_ID			3
+#define MB_DATA_ID			4
+
+#define MB_MODULE_ID_DP_TX			0x01
+#define MB_MODULE_ID_HDMI_TX		0x03
+#define MB_MODULE_ID_HDCP_TX		0x07
+#define MB_MODULE_ID_HDCP_RX		0x08
+#define MB_MODULE_ID_HDCP_GENERAL	0x09
+#define MB_MODULE_ID_GENERAL		0x0A
+
+/* general opcode */
+#define GENERAL_MAIN_CONTROL            0x01
+#define GENERAL_TEST_ECHO               0x02
+#define GENERAL_BUS_SETTINGS            0x03
+#define GENERAL_TEST_ACCESS             0x04
+#define GENERAL_WRITE_REGISTER          0x05
+#define GENERAL_WRITE_FIELD             0x06
+#define GENERAL_READ_REGISTER           0x07
+#define GENERAL_GET_HPD_STATE           0x11
+#define GENERAL_ASSERT_PHY_BUS_RESET    0x12
+#define GENERAL_DEASSERT_PHY_BUS_RESET  0x13
+#define GENERAL_LOAD_HDCP_RX            0x20
+#define GENERAL_UNLOAD_HDCP_RX          0x21
+
+/* DPTX opcode */
+#define DPTX_SET_POWER_MNG			0x00
+#define DPTX_SET_HOST_CAPABILITIES		0x01
+#define DPTX_GET_EDID				0x02
+#define DPTX_READ_DPCD				0x03
+#define DPTX_WRITE_DPCD				0x04
+#define DPTX_ENABLE_EVENT			0x05
+#define DPTX_WRITE_REGISTER			0x06
+#define DPTX_READ_REGISTER			0x07
+#define DPTX_WRITE_FIELD			0x08
+#define DPTX_TRAINING_CONTROL			0x09
+#define DPTX_READ_EVENT				0x0a
+#define DPTX_READ_LINK_STAT			0x0b
+#define DPTX_SET_VIDEO				0x0c
+#define DPTX_SET_AUDIO				0x0d
+#define DPTX_GET_LAST_AUX_STAUS			0x0e
+#define DPTX_SET_LINK_BREAK_POINT		0x0f
+#define DPTX_FORCE_LANES			0x10
+#define DPTX_HPD_STATE				0x11
+#define DPTX_ADJUST_LT				0x12
+#define DPTX_I2C_READ              0x15
+#define DPTX_I2C_WRITE             0x16
+#define DPTX_GET_LAST_I2C_STATUS   0x17
+
+
+
+/* HDMI TX opcode */
+#define HDMI_TX_READ				0x00
+#define HDMI_TX_WRITE				0x01
+#define HDMI_TX_UPDATE_READ			0x02
+#define HDMI_TX_EDID				0x03
+#define HDMI_TX_EVENTS				0x04
+#define HDMI_TX_HPD_STATUS			0x05
+#define HDMI_TX_DEBUG_ECHO			0xAA
+#define HDMI_TX_TEST				0xBB
+#define HDMI_TX_EDID_INTERNAL		0xF0
+
+/* HDCP General opcode */
+#define HDCP_GENERAL_SET_LC_128		0x00
+#define HDCP_GENERAL_SET_SEED		0x01
+
+/* HDCP TX opcode */
+#define HDCP_TX_CONFIGURATION				0x00
+#define HDCP2_TX_SET_PUBLIC_KEY_PARAMS		0x01
+#define HDCP2_TX_SET_DEBUG_RANDOM_NUMBERS	0x02
+#define HDCP2_TX_RESPOND_KM					0x03
+#define HDCP1_TX_SEND_KEYS					0x04
+#define HDCP1_TX_SEND_RANDOM_AN				0x05
+#define HDCP_TX_STATUS_CHANGE				0x06
+#define HDCP2_TX_IS_KM_STORED				0x07
+#define HDCP2_TX_STORE_KM					0x08
+#define HDCP_TX_IS_RECEIVER_ID_VALID		0x09
+#define HDCP_TX_RESPOND_RECEIVER_ID_VALID	0x0A
+#define HDCP_TX_TEST_KEYS					0x0B
+#define HDCP2_TX_SET_KM_KEY_PARAMS			0x0C
+#define HDCP_TX_SET_CP_IRQ					0x0D
+#define HDCP_TX_DO_AUTH_REQ					0x0E
+
+#define FW_STANDBY				0
+#define FW_ACTIVE				1
+
+#define MHDP_EVENT_ENABLE_HPD			BIT(0)
+#define MHDP_EVENT_ENABLE_TRAINING		BIT(1)
+
+#define LINK_TRAINING_NOT_ACTIVE		0
+#define LINK_TRAINING_RUN			1
+#define LINK_TRAINING_RESTART			2
+
+#define CONTROL_VIDEO_IDLE			0
+#define CONTROL_VIDEO_VALID			1
+
+#define TU_CNT_RST_EN				BIT(15)
+#define VIF_BYPASS_INTERLACE			BIT(13)
+#define INTERLACE_FMT_DET			BIT(12)
+#define INTERLACE_DTCT_WIN			0x20
+
+#define DP_FRAMER_SP_INTERLACE_EN		BIT(2)
+#define DP_FRAMER_SP_HSP			BIT(1)
+#define DP_FRAMER_SP_VSP			BIT(0)
+
+/* capability */
+#define AUX_HOST_INVERT				3
+#define	FAST_LT_SUPPORT				1
+#define FAST_LT_NOT_SUPPORT			0
+#define LANE_MAPPING_NORMAL			0x1b
+#define LANE_MAPPING_FLIPPED			0xe4
+#define ENHANCED				1
+#define SCRAMBLER_EN				BIT(4)
+
+#define	FULL_LT_STARTED				BIT(0)
+#define FASE_LT_STARTED				BIT(1)
+#define CLK_RECOVERY_FINISHED			BIT(2)
+#define EQ_PHASE_FINISHED			BIT(3)
+#define FASE_LT_START_FINISHED			BIT(4)
+#define CLK_RECOVERY_FAILED			BIT(5)
+#define EQ_PHASE_FAILED				BIT(6)
+#define FASE_LT_FAILED				BIT(7)
+
+#define DPTX_HPD_EVENT						   BIT(0)
+#define HDMI_TX_HPD_EVENT					   BIT(0)
+#define HDMI_RX_5V_EVENT					   BIT(0)
+#define DPTX_TRAINING_EVENT					   BIT(1)
+#define HDMI_RX_SCDC_CHANGE_EVENT			   BIT(1)
+#define HDCPTX_STATUS_EVENT					   BIT(4)
+#define HDCPRX_STATUS_EVENT					   BIT(4)
+#define HDCPTX_IS_KM_STORED_EVENT			   BIT(5)
+#define HDCPTX_STORE_KM_EVENT				   BIT(6)
+#define HDCPTX_IS_RECEIVER_ID_VALID_EVENT	   BIT(7)
+
+#define TU_SIZE					30
+#define CDNS_DP_MAX_LINK_RATE	540000
+
+#define F_HDMI_ENCODING(x) (((x) & ((1 << 2) - 1)) << 16)
+#define F_VIF_DATA_WIDTH(x) (((x) & ((1 << 2) - 1)) << 2)
+#define F_HDMI_MODE(x) (((x) & ((1 << 2) - 1)) << 0)
+#define F_GCP_EN(x) (((x) & ((1 << 1) - 1)) << 12)
+#define F_CLEAR_AVMUTE(x) (((x) & ((1 << 1) - 1)) << 14)
+#define F_DATA_EN(x) (((x) & ((1 << 1) - 1)) << 15)
+#define F_HDMI2_PREAMBLE_EN(x) (((x) & ((1 << 1) - 1)) << 18)
+#define F_PIC_3D(x) (((x) & ((1 << 4) - 1)) << 7)
+#define F_BCH_EN(x) (((x) & ((1 << 1) - 1)) << 11)
+#define F_SOURCE_PHY_MHDP_SEL(x) (((x) & ((1 << 2) - 1)) << 3)
+#define F_HPD_VALID_WIDTH(x) (((x) & ((1 << 12) - 1)) << 0)
+#define F_HPD_GLITCH_WIDTH(x) (((x) & ((1 << 8) - 1)) << 12)
+#define F_HDMI2_CTRL_IL_MODE(x) (((x) & ((1 << 1) - 1)) << 19)
+#define F_SOURCE_PHY_LANE0_SWAP(x) (((x) & ((1 << 2) - 1)) << 0)
+#define F_SOURCE_PHY_LANE1_SWAP(x) (((x) & ((1 << 2) - 1)) << 2)
+#define F_SOURCE_PHY_LANE2_SWAP(x) (((x) & ((1 << 2) - 1)) << 4)
+#define F_SOURCE_PHY_LANE3_SWAP(x) (((x) & ((1 << 2) - 1)) << 6)
+#define F_SOURCE_PHY_COMB_BYPASS(x) (((x) & ((1 << 1) - 1)) << 21)
+#define F_SOURCE_PHY_20_10(x) (((x) & ((1 << 1) - 1)) << 22)
+#define F_PKT_ALLOC_ADDRESS(x) (((x) & ((1 << 4) - 1)) << 0)
+#define F_ACTIVE_IDLE_TYPE(x) (((x) & ((1 << 1) - 1)) << 17)
+#define F_FIFO1_FLUSH(x) (((x) & ((1 << 1) - 1)) << 0)
+#define F_PKT_ALLOC_WR_EN(x) (((x) & ((1 << 1) - 1)) << 0)
+#define F_DATA_WR(x) (x)
+#define F_WR_ADDR(x) (((x) & ((1 << 4) - 1)) << 0)
+#define F_HOST_WR(x) (((x) & ((1 << 1) - 1)) << 0)
+#define F_TYPE_VALID(x) (((x) & ((1 << 1) - 1)) << 16)
+#define F_PACKET_TYPE(x) (((x) & ((1 << 8) - 1)) << 8)
+
+/* audio */
+#define AUDIO_PACK_EN				BIT(8)
+#define SAMPLING_FREQ(x)			(((x) & 0xf) << 16)
+#define ORIGINAL_SAMP_FREQ(x)			(((x) & 0xf) << 24)
+#define SYNC_WR_TO_CH_ZERO			BIT(1)
+#define I2S_DEC_START				BIT(1)
+#define AUDIO_SW_RST				BIT(0)
+#define SMPL2PKT_EN				BIT(1)
+#define MAX_NUM_CH(x)				(((x) & 0x1f) - 1)
+#define NUM_OF_I2S_PORTS(x)			((((x) / 2 - 1) & 0x3) << 5)
+#define AUDIO_TYPE_LPCM				(2 << 7)
+#define CFG_SUB_PCKT_NUM(x)			((((x) - 1) & 0x7) << 11)
+#define AUDIO_CH_NUM(x)				((((x) - 1) & 0x1f) << 2)
+#define TRANS_SMPL_WIDTH_16			0
+#define TRANS_SMPL_WIDTH_24			BIT(11)
+#define TRANS_SMPL_WIDTH_32			(2 << 11)
+#define I2S_DEC_PORT_EN(x)			(((x) & 0xf) << 17)
+#define SPDIF_ENABLE				BIT(21)
+#define SPDIF_AVG_SEL				BIT(20)
+#define SPDIF_JITTER_BYPASS			BIT(19)
+#define SPDIF_FIFO_MID_RANGE(x)			(((x) & 0xff) << 11)
+#define SPDIF_JITTER_THRSH(x)			(((x) & 0xff) << 3)
+#define SPDIF_JITTER_AVG_WIN(x)			((x) & 0x7)
+
+/* Reference cycles when using lane clock as reference */
+#define LANE_REF_CYC				0x8000
+
+#define HOTPLUG_DEBOUNCE_MS		50
+
+#define IRQ_IN    0
+#define IRQ_OUT   1
+#define IRQ_NUM   2
+
+#define cdns_mhdp_plat_call(mhdp, operation)			\
+	(!(mhdp) ? -ENODEV : (((mhdp)->plat_data && (mhdp)->plat_data->operation) ?	\
+	 (mhdp)->plat_data->operation(mhdp) : ENOIOCTLCMD))
+
+/* bus access type */
+enum {
+	BUS_TYPE_NORMAL_APB = 0,
+	BUS_TYPE_NORMAL_SAPB = 1,
+	BUS_TYPE_LOW4K_APB = 2,
+	BUS_TYPE_LOW4K_SAPB = 3,
+	BUS_TYPE_LOW4K_HDMI_RX = 4,
+};
+
+enum voltage_swing_level {
+	VOLTAGE_LEVEL_0,
+	VOLTAGE_LEVEL_1,
+	VOLTAGE_LEVEL_2,
+	VOLTAGE_LEVEL_3,
+};
+
+enum pre_emphasis_level {
+	PRE_EMPHASIS_LEVEL_0,
+	PRE_EMPHASIS_LEVEL_1,
+	PRE_EMPHASIS_LEVEL_2,
+	PRE_EMPHASIS_LEVEL_3,
+};
+
+enum pattern_set {
+	PTS1		= BIT(0),
+	PTS2		= BIT(1),
+	PTS3		= BIT(2),
+	PTS4		= BIT(3),
+	DP_NONE		= BIT(4)
+};
+
+enum vic_color_depth {
+	BCS_6 = 0x1,
+	BCS_8 = 0x2,
+	BCS_10 = 0x4,
+	BCS_12 = 0x8,
+	BCS_16 = 0x10,
+};
+
+enum vic_bt_type {
+	BT_601 = 0x0,
+	BT_709 = 0x1,
+};
+
+enum audio_format {
+	AFMT_I2S = 0,
+	AFMT_SPDIF_INT = 1,
+	AFMT_SPDIF_EXT = 2,
+	AFMT_UNUSED,
+};
+
+enum {
+	MODE_DVI,
+	MODE_HDMI_1_4,
+	MODE_HDMI_2_0,
+};
+
+struct audio_info {
+	enum audio_format format;
+	int sample_rate;
+	int channels;
+	int sample_width;
+	int connector_type;
+	bool non_pcm;
+};
+
+enum vic_pxl_encoding_format {
+	PXL_RGB = 0x1,
+	YCBCR_4_4_4 = 0x2,
+	YCBCR_4_2_2 = 0x4,
+	YCBCR_4_2_0 = 0x8,
+	Y_ONLY = 0x10,
+};
+
+enum link_training_type {
+	DP_TX_FULL_LINK_TRAINING,
+	DP_TX_FAST_LINK_TRAINING,
+	DP_TX_NO_AUX_LINK_TRAINING
+};
+
+struct video_info {
+	bool h_sync_polarity;
+	bool v_sync_polarity;
+	bool interlaced;
+	int color_depth;
+	enum vic_pxl_encoding_format color_fmt;
+};
+
+struct cdns_mhdp_host {
+	unsigned int	link_rate;
+	u8	lanes_cnt;
+	u8	volt_swing;
+	u8	pre_emphasis;
+	u8	pattern_supp;
+	u8	fast_link;
+	u8	lane_mapping;
+	u8	enhanced;
+};
+
+struct cdns_mhdp_sink {
+	unsigned int	link_rate;
+	u8	lanes_cnt;
+	u8	pattern_supp;
+	u8	fast_link;
+	u8	enhanced;
+};
+
+struct cdns_mhdp_bridge;
+struct cdns_mhdp_connector;
+
+struct cdns_mhdp_bridge {
+	struct cdns_mhdp_device *mhdp;
+	struct drm_bridge base;
+	int pbn;
+	int8_t stream_id;
+	struct cdns_mhdp_connector *connector;
+	bool is_active;
+};
+
+struct cdns_mhdp_connector {
+	struct drm_connector base;
+	struct drm_connector_state new_state;
+	bool is_mst_connector;
+	struct drm_dp_mst_port *port;
+	struct cdns_mhdp_bridge *bridge;
+};
+
+struct cdns_mhdp_cec {
+	struct cec_adapter *adap;
+	struct device *dev;
+	struct mutex *iolock;
+	void __iomem		*regs_base;
+	void __iomem		*regs_sec;
+	int bus_type;
+
+	struct cec_msg msg;
+	struct task_struct *cec_worker;
+};
+
+struct cdns_plat_data {
+	/* Vendor PHY support */
+	int (*bind)(struct platform_device *pdev,
+			struct drm_encoder *encoder,
+			struct cdns_mhdp_device *mhdp);
+	void (*unbind)(struct device *dev);
+
+	void (*plat_init)(struct cdns_mhdp_device *mhdp);
+	void (*plat_deinit)(struct cdns_mhdp_device *mhdp);
+
+	int (*phy_set)(struct cdns_mhdp_device *mhdp);
+	bool (*phy_video_valid)(struct cdns_mhdp_device *mhdp);
+	int (*firmware_init)(struct cdns_mhdp_device *mhdp);
+	void (*pclk_rate)(struct cdns_mhdp_device *mhdp);
+
+	int (*suspend)(struct cdns_mhdp_device *mhdp);
+	int (*resume)(struct cdns_mhdp_device *mhdp);
+
+	int (*power_on)(struct cdns_mhdp_device *mhdp);
+	int (*power_off)(struct cdns_mhdp_device *mhdp);
+
+	int bus_type;
+	int video_format;
+	char is_dp;
+	char *plat_name;
+};
+
+/* HDCP */
+#define MAX_STORED_KM 64
+#define HDCP_PAIRING_M_LEN 16
+#define HDCP_PAIRING_M_EKH 16
+#define HDCP_PAIRING_R_ID 5
+
+/* HDCP2_TX_SET_DEBUG_RANDOM_NUMBERS */
+#define DEBUG_RANDOM_NUMBERS_KM_LEN 16
+#define DEBUG_RANDOM_NUMBERS_RN_LEN 8
+#define DEBUG_RANDOM_NUMBERS_KS_LEN 16
+#define DEBUG_RANDOM_NUMBERS_RIV_LEN 8
+#define DEBUG_RANDOM_NUMBERS_RTX_LEN 8
+
+struct hdcp_trans_pairing_data {
+	u8 receiver_id[HDCP_PAIRING_R_ID];
+	u8 m[HDCP_PAIRING_M_LEN];
+	u8 km[DEBUG_RANDOM_NUMBERS_KM_LEN];
+	u8 ekh[HDCP_PAIRING_M_EKH];
+};
+
+enum hdmi_hdcp_state {
+	HDCP_STATE_NO_AKSV,
+	HDCP_STATE_INACTIVE,
+	HDCP_STATE_ENABLING,
+	HDCP_STATE_AUTHENTICATING,
+	HDCP_STATE_REAUTHENTICATING,
+	HDCP_STATE_AUTHENTICATED,
+	HDCP_STATE_DISABLING,
+	HDCP_STATE_AUTH_FAILED
+};
+
+struct cdns_mhdp_hdcp {
+	struct mutex mutex;
+	u64 value; /* protected by hdcp_mutex */
+	struct delayed_work check_work;
+	struct work_struct prop_work;
+	u8 state;
+	u8 cancel;
+	u8 bus_type;
+	u8 config;
+	struct hdcp_trans_pairing_data pairing[MAX_STORED_KM];
+	u8 num_paired;
+
+	u8 events;
+	u8 sink_is_repeater;
+	u8 reauth_in_progress;
+	u8 hdcp_version;
+};
+
+struct cdns_mhdp_device {
+	void __iomem		*regs_base;
+	void __iomem		*regs_sec;
+
+	int bus_type;
+
+	struct device		*dev;
+	struct drm_device *drm_dev;
+
+	struct cdns_mhdp_connector  connector;
+	struct clk		*spdif_clk;
+	struct reset_control	*spdif_rst;
+
+	struct platform_device	*audio_pdev;
+	struct audio_info	audio_info;
+
+	struct cdns_mhdp_bridge	bridge;
+	struct phy		*phy;
+
+	struct video_info	video_info;
+	struct drm_display_mode	mode;
+	const struct drm_display_mode	*valid_mode;
+	unsigned int		fw_version;
+
+	struct drm_dp_mst_topology_mgr mst_mgr;
+	struct delayed_work hotplug_work;
+
+	u32 lane_mapping;
+	bool link_up;
+	bool force_disconnected_sts;
+	bool power_up;
+	bool plugged;
+	bool force_mode_set;
+	bool is_hpd;
+	bool is_dp;
+	bool is_ls1028a;
+	struct mutex lock;
+	struct mutex api_lock;
+	struct mutex iolock;
+
+	int irq[IRQ_NUM];
+
+	union {
+		struct _dp_data {
+			u8 dpcd[DP_RECEIVER_CAP_SIZE];
+			u32 rate;
+			u8 num_lanes;
+			u8 vswing[4];
+			u8 preemphasis[4];
+			u8 force_vswing;
+			u8 force_preemphasis;
+			enum link_training_type link_training_type;
+			struct drm_dp_aux	aux;
+			struct cdns_mhdp_host	host;
+			struct cdns_mhdp_sink	sink;
+			bool is_mst;
+			bool can_mst;
+		} dp;
+		struct _hdmi_data {
+			struct cdns_mhdp_cec cec;
+			u32 char_rate;
+			u32 hdmi_type;
+		} hdmi;
+	};
+	const struct cdns_plat_data *plat_data;
+
+	hdmi_codec_plugged_cb plugged_cb;
+	struct device *codec_dev;
+	enum drm_connector_status last_connector_result;
+	struct cdns_mhdp_hdcp hdcp;
+};
+
+u32 cdns_mhdp_bus_read(struct cdns_mhdp_device *mhdp, u32 offset);
+void cdns_mhdp_bus_write(u32 val, struct cdns_mhdp_device *mhdp, u32 offset);
+void cdns_mhdp_clock_reset(struct cdns_mhdp_device *mhdp);
+void cdns_mhdp_set_fw_clk(struct cdns_mhdp_device *mhdp, unsigned long clk);
+int cdns_mhdp_load_firmware(struct cdns_mhdp_device *mhdp, const u32 *i_mem,
+			    u32 i_size, const u32 *d_mem, u32 d_size);
+int cdns_mhdp_set_firmware_active(struct cdns_mhdp_device *mhdp, bool enable);
+int cdns_mhdp_set_host_cap(struct cdns_mhdp_device *mhdp);
+int cdns_mhdp_event_config(struct cdns_mhdp_device *mhdp);
+u32 cdns_mhdp_get_event(struct cdns_mhdp_device *mhdp);
+int cdns_mhdp_dpcd_write(struct cdns_mhdp_device *mhdp, u32 addr, u8 value);
+int cdns_mhdp_dpcd_read(struct cdns_mhdp_device *mhdp,
+			u32 addr, u8 *data, u16 len);
+
+int cdns_mhdp_get_last_i2c_status(struct cdns_mhdp_device *mhdp, u8 *resp);
+int cdns_mhdp_i2c_write(struct cdns_mhdp_device *mhdp, u8 addr,
+			u8 *value, u8 mot, u16 len, u16 *respLength);
+int cdns_mhdp_i2c_read(struct cdns_mhdp_device *mhdp, u8 addr, u8 *data,
+	u16 len, u8 mot, u16 *respLength);
+int cdns_mhdp_get_edid_block(void *mhdp, u8 *edid,
+			     unsigned int block, size_t length);
+int cdns_mhdp_train_link(struct cdns_mhdp_device *mhdp);
+int cdns_mhdp_set_video_status(struct cdns_mhdp_device *mhdp, int active);
+int cdns_mhdp_config_video(struct cdns_mhdp_device *mhdp);
+int cdns_mhdp_apb_conf(struct cdns_mhdp_device *mhdp, u8 sel);
+
+/* Audio */
+int cdns_mhdp_audio_stop(struct cdns_mhdp_device *mhdp,
+			 struct audio_info *audio);
+int cdns_mhdp_audio_mute(struct cdns_mhdp_device *mhdp, bool enable);
+int cdns_mhdp_audio_config(struct cdns_mhdp_device *mhdp,
+			   struct audio_info *audio);
+int cdns_mhdp_register_audio_driver(struct device *dev);
+void cdns_mhdp_unregister_audio_driver(struct device *dev);
+
+int cdns_mhdp_reg_read(struct cdns_mhdp_device *mhdp, u32 addr);
+int cdns_mhdp_reg_write(struct cdns_mhdp_device *mhdp, u32 addr, u32 val);
+int cdns_mhdp_reg_write_bit(struct cdns_mhdp_device *mhdp, u16 addr,
+			    u8 start_bit, u8 bits_no, u32 val);
+int cdns_mhdp_adjust_lt(struct cdns_mhdp_device *mhdp, u8 nlanes,
+			u16 udelay, u8 *lanes_data,
+			u8 *dpcd);
+
+int cdns_mhdp_read_hpd(struct cdns_mhdp_device *mhdp);
+u32 cdns_phy_reg_read(struct cdns_mhdp_device *mhdp, u32 addr);
+int cdns_phy_reg_write(struct cdns_mhdp_device *mhdp, u32 addr, u32 val);
+int cdns_mhdp_mailbox_send(struct cdns_mhdp_device *mhdp, u8 module_id,
+				  u8 opcode, u16 size, u8 *message);
+int cdns_mhdp_mailbox_read_receive(struct cdns_mhdp_device *mhdp,
+					  u8 *buff, u16 buff_size);
+int cdns_mhdp_mailbox_validate_receive(struct cdns_mhdp_device *mhdp,
+					      u8 module_id, u8 opcode,
+					      u16 req_size);
+void cdns_mhdp_infoframe_set(struct cdns_mhdp_device *mhdp,
+					u8 entry_id, u8 packet_len, u8 *packet, u8 packet_type);
+int cdns_hdmi_get_edid_block(void *data, u8 *edid, u32 block, size_t length);
+int cdns_hdmi_scdc_read(struct cdns_mhdp_device *mhdp, u8 addr, u8 *data);
+int cdns_hdmi_scdc_write(struct cdns_mhdp_device *mhdp, u8 addr, u8 value);
+int cdns_hdmi_ctrl_init(struct cdns_mhdp_device *mhdp, int protocol, u32 char_rate);
+int cdns_hdmi_mode_config(struct cdns_mhdp_device *mhdp, struct drm_display_mode *mode,
+				struct video_info *video_info);
+int cdns_hdmi_disable_gcp(struct cdns_mhdp_device *mhdp);
+int cdns_hdmi_enable_gcp(struct cdns_mhdp_device *mhdp);
+
+bool cdns_mhdp_check_alive(struct cdns_mhdp_device *mhdp);
+
+/* HDMI */
+int cdns_hdmi_probe(struct platform_device *pdev,
+		 struct cdns_mhdp_device *mhdp);
+void cdns_hdmi_remove(struct platform_device *pdev);
+void cdns_hdmi_unbind(struct device *dev);
+int cdns_hdmi_bind(struct platform_device *pdev,
+			struct drm_encoder *encoder, struct cdns_mhdp_device *mhdp);
+void cdns_hdmi_set_sample_rate(struct cdns_mhdp_device *mhdp, unsigned int rate);
+void cdns_hdmi_audio_enable(struct cdns_mhdp_device *mhdp);
+void cdns_hdmi_audio_disable(struct cdns_mhdp_device *mhdp);
+
+/* DP  */
+int cdns_dp_probe(struct platform_device *pdev,
+		 struct cdns_mhdp_device *mhdp);
+void cdns_dp_remove(struct platform_device *pdev);
+void cdns_dp_unbind(struct device *dev);
+int cdns_dp_bind(struct platform_device *pdev,
+			struct drm_encoder *encoder, struct cdns_mhdp_device *mhdp);
+int cdns_hdmi_set_plugged_cb(struct cdns_mhdp_device *mhdp, hdmi_codec_plugged_cb fn,
+			     struct device *codec_dev);
+
+/* CEC */
+#ifdef CONFIG_DRM_CDNS_HDMI_CEC
+int cdns_mhdp_register_cec_driver(struct cdns_mhdp_cec *cec);
+int cdns_mhdp_unregister_cec_driver(struct cdns_mhdp_cec *cec);
+#endif
+
+#endif /* CDNS_MHDP_H_ */
diff --git a/include/drm/bridge/dw_hdmi.h b/include/drm/bridge/dw_hdmi.h
index ea34ca146..783333a08 100644
--- a/include/drm/bridge/dw_hdmi.h
+++ b/include/drm/bridge/dw_hdmi.h
@@ -121,6 +121,9 @@ struct dw_hdmi_phy_ops {
 	void (*update_hpd)(struct dw_hdmi *hdmi, void *data,
 			   bool force, bool disabled, bool rxsense);
 	void (*setup_hpd)(struct dw_hdmi *hdmi, void *data);
+	void (*enable_audio)(struct dw_hdmi *hdmi, void *data, int channel,
+			     int width, int rate, int non_pcm);
+	void (*disable_audio)(struct dw_hdmi *hdmi, void *data);
 };
 
 struct dw_hdmi_plat_data {
@@ -169,6 +172,8 @@ void dw_hdmi_setup_rx_sense(struct dw_hdmi *hdmi, bool hpd, bool rx_sense);
 
 int dw_hdmi_set_plugged_cb(struct dw_hdmi *hdmi, hdmi_codec_plugged_cb fn,
 			   struct device *codec_dev);
+void dw_hdmi_set_sample_non_pcm(struct dw_hdmi *hdmi, unsigned int non_pcm);
+void dw_hdmi_set_sample_width(struct dw_hdmi *hdmi, unsigned int width);
 void dw_hdmi_set_sample_rate(struct dw_hdmi *hdmi, unsigned int rate);
 void dw_hdmi_set_channel_count(struct dw_hdmi *hdmi, unsigned int cnt);
 void dw_hdmi_set_channel_status(struct dw_hdmi *hdmi, u8 *channel_status);
@@ -183,9 +188,11 @@ void dw_hdmi_phy_i2c_set_addr(struct dw_hdmi *hdmi, u8 address);
 void dw_hdmi_phy_i2c_write(struct dw_hdmi *hdmi, unsigned short data,
 			   unsigned char addr);
 
+void dw_hdmi_phy_reset(struct dw_hdmi *hdmi);
+
 void dw_hdmi_phy_gen2_pddq(struct dw_hdmi *hdmi, u8 enable);
 void dw_hdmi_phy_gen2_txpwron(struct dw_hdmi *hdmi, u8 enable);
-void dw_hdmi_phy_reset(struct dw_hdmi *hdmi);
+void dw_hdmi_phy_gen2_reset(struct dw_hdmi *hdmi);
 
 enum drm_connector_status dw_hdmi_phy_read_hpd(struct dw_hdmi *hdmi,
 					       void *data);
diff --git a/include/drm/bridge/fsl_imx_ldb.h b/include/drm/bridge/fsl_imx_ldb.h
new file mode 100644
index 000000000..ade80fb22
--- /dev/null
+++ b/include/drm/bridge/fsl_imx_ldb.h
@@ -0,0 +1,39 @@
+// SPDX-License-Identifier: GPL-2.0+
+/*
+ * Copyright 2020 NXP
+ */
+
+#ifndef __FSL_IMX_LDB__
+#define __FSL_IMX_LDB__
+
+#include <drm/drm_bridge.h>
+
+#define LDB_CH_NUM	2
+
+struct ldb_channel {
+	struct ldb *ldb;
+
+	struct drm_bridge bridge;
+
+	struct drm_panel *panel;
+	struct drm_bridge *next_bridge;
+
+	struct device_node *child;
+	int chno;
+	u32 bus_format;
+	bool is_valid;
+};
+
+struct ldb {
+	struct regmap *regmap;
+	struct device *dev;
+	struct ldb_channel *channel[LDB_CH_NUM];
+	unsigned int ctrl_reg;
+	u32 ldb_ctrl;
+	int output_port;
+	bool dual;
+};
+
+int ldb_bind(struct ldb *ldb, struct drm_encoder **encoder);
+
+#endif /* __FSL_IMX_LDB__ */
diff --git a/include/drm/bridge/sec_mipi_dsim.h b/include/drm/bridge/sec_mipi_dsim.h
new file mode 100644
index 000000000..f679b7ca8
--- /dev/null
+++ b/include/drm/bridge/sec_mipi_dsim.h
@@ -0,0 +1,113 @@
+/*
+ * Copyright 2018-2019 NXP
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#ifndef __SEC_MIPI_DSIM_H__
+#define __SEC_MIPI_DSIM_H__
+
+#include <drm/drm_vblank.h>
+#include <linux/bsearch.h>
+
+struct sec_mipi_dsim_dphy_timing;
+struct sec_mipi_dsim_pll;
+
+struct sec_mipi_dsim_plat_data {
+	uint32_t version;
+	uint32_t max_data_lanes;
+	uint64_t max_data_rate;
+	const struct sec_mipi_dsim_dphy_timing *dphy_timing;
+	uint32_t num_dphy_timing;
+	const struct sec_mipi_dsim_pll *dphy_pll;
+	int (*dphy_timing_cmp)(const void *key, const void *elt);
+	enum drm_mode_status (*mode_valid)(struct drm_connector *connector,
+					   struct drm_display_mode *mode);
+	int (*determine_pll_ref_rate)(u32 *rate, u32 min, u32 max);
+};
+
+/* DPHY PLL structure */
+struct sec_mipi_dsim_range {
+	uint32_t min;
+	uint32_t max;
+};
+
+struct sec_mipi_dsim_pll {
+	struct sec_mipi_dsim_range p;
+	struct sec_mipi_dsim_range m;
+	struct sec_mipi_dsim_range s;
+	struct sec_mipi_dsim_range k;
+	struct sec_mipi_dsim_range fin;
+	struct sec_mipi_dsim_range fpref;
+	struct sec_mipi_dsim_range fvco;
+};
+
+/* DPHY timings structure */
+struct sec_mipi_dsim_dphy_timing {
+	uint32_t bit_clk;	/* MHz */
+
+	uint32_t clk_prepare;
+	uint32_t clk_zero;
+	uint32_t clk_post;
+	uint32_t clk_trail;
+
+	uint32_t hs_prepare;
+	uint32_t hs_zero;
+	uint32_t hs_trail;
+
+	uint32_t lpx;
+	uint32_t hs_exit;
+};
+
+#define DSIM_DPHY_TIMING(bclk, cpre, czero, cpost, ctrail,	\
+			 hpre, hzero, htrail, lp, hexit)	\
+	.bit_clk	= bclk,					\
+	.clk_prepare	= cpre,					\
+	.clk_zero	= czero,				\
+	.clk_post	= cpost,				\
+	.clk_trail	= ctrail,				\
+	.hs_prepare	= hpre,					\
+	.hs_zero	= hzero,				\
+	.hs_trail	= htrail,				\
+	.lpx		= lp,					\
+	.hs_exit	= hexit
+
+static inline int dphy_timing_default_cmp(const void *key, const void *elt)
+{
+	const struct sec_mipi_dsim_dphy_timing *_key = key;
+	const struct sec_mipi_dsim_dphy_timing *_elt = elt;
+
+	/* find an element whose 'bit_clk' is equal to the
+	 * the key's 'bit_clk' value or, the difference
+	 * between them is less than 5.
+	 */
+	if (abs((int)(_elt->bit_clk - _key->bit_clk)) <= 5)
+		return 0;
+
+	if (_key->bit_clk < _elt->bit_clk)
+		/* search bottom half */
+		return 1;
+	else
+		/* search top half */
+		return -1;
+}
+
+int sec_mipi_dsim_check_pll_out(void *driver_private,
+				const struct drm_display_mode *mode);
+int sec_mipi_dsim_bind(struct device *dev, struct device *master, void *data,
+		       struct drm_encoder *encoder, void __iomem *base,
+		       int irq, const struct sec_mipi_dsim_plat_data *pdata);
+void sec_mipi_dsim_unbind(struct device *dev, struct device *master, void *data);
+
+void sec_mipi_dsim_suspend(struct device *dev);
+void sec_mipi_dsim_resume(struct device *dev);
+
+#endif
diff --git a/include/drm/drm_of.h b/include/drm/drm_of.h
index b9b093add..d1a6f3c87 100644
--- a/include/drm/drm_of.h
+++ b/include/drm/drm_of.h
@@ -7,6 +7,7 @@
 #include <drm/drm_bridge.h>
 #endif
 
+struct component_match;
 struct component_master_ops;
 struct component_match;
 struct device;
@@ -37,6 +38,10 @@ void drm_of_component_match_add(struct device *master,
 				struct component_match **matchptr,
 				int (*compare)(struct device *, void *),
 				struct device_node *node);
+extern int drm_of_component_probe_with_match(struct device *dev,
+			   struct component_match *match,
+			   int (*compare_of)(struct device *, void *),
+			   const struct component_master_ops *m_ops);
 int drm_of_component_probe(struct device *dev,
 			   int (*compare_of)(struct device *, void *),
 			   const struct component_master_ops *m_ops);
@@ -70,6 +75,14 @@ drm_of_component_match_add(struct device *master,
 {
 }
 
+static int drm_of_component_probe_with_match(struct device *dev,
+			   struct component_match *match,
+			   int (*compare_of)(struct device *, void *),
+			   const struct component_master_ops *m_ops)
+{
+	return -EINVAL;
+}
+
 static inline int
 drm_of_component_probe(struct device *dev,
 		       int (*compare_of)(struct device *, void *),
diff --git a/include/dt-bindings/clock/imx8-clock.h b/include/dt-bindings/clock/imx8-clock.h
index 673a8c662..2a1122928 100644
--- a/include/dt-bindings/clock/imx8-clock.h
+++ b/include/dt-bindings/clock/imx8-clock.h
@@ -7,287 +7,58 @@
 #ifndef __DT_BINDINGS_CLOCK_IMX_H
 #define __DT_BINDINGS_CLOCK_IMX_H
 
-/* SCU Clocks */
-
-#define IMX_CLK_DUMMY				0
-
-/* CPU */
-#define IMX_A35_CLK					1
-
-/* LSIO SS */
-#define IMX_LSIO_MEM_CLK				2
-#define IMX_LSIO_BUS_CLK				3
-#define IMX_LSIO_PWM0_CLK				10
-#define IMX_LSIO_PWM1_CLK				11
-#define IMX_LSIO_PWM2_CLK				12
-#define IMX_LSIO_PWM3_CLK				13
-#define IMX_LSIO_PWM4_CLK				14
-#define IMX_LSIO_PWM5_CLK				15
-#define IMX_LSIO_PWM6_CLK				16
-#define IMX_LSIO_PWM7_CLK				17
-#define IMX_LSIO_GPT0_CLK				18
-#define IMX_LSIO_GPT1_CLK				19
-#define IMX_LSIO_GPT2_CLK				20
-#define IMX_LSIO_GPT3_CLK				21
-#define IMX_LSIO_GPT4_CLK				22
-#define IMX_LSIO_FSPI0_CLK				23
-#define IMX_LSIO_FSPI1_CLK				24
-
-/* Connectivity SS */
-#define IMX_CONN_AXI_CLK_ROOT				30
-#define IMX_CONN_AHB_CLK_ROOT				31
-#define IMX_CONN_IPG_CLK_ROOT				32
-#define IMX_CONN_SDHC0_CLK				40
-#define IMX_CONN_SDHC1_CLK				41
-#define IMX_CONN_SDHC2_CLK				42
-#define IMX_CONN_ENET0_ROOT_CLK				43
-#define IMX_CONN_ENET0_BYPASS_CLK			44
-#define IMX_CONN_ENET0_RGMII_CLK			45
-#define IMX_CONN_ENET1_ROOT_CLK				46
-#define IMX_CONN_ENET1_BYPASS_CLK			47
-#define IMX_CONN_ENET1_RGMII_CLK			48
-#define IMX_CONN_GPMI_BCH_IO_CLK			49
-#define IMX_CONN_GPMI_BCH_CLK				50
-#define IMX_CONN_USB2_ACLK				51
-#define IMX_CONN_USB2_BUS_CLK				52
-#define IMX_CONN_USB2_LPM_CLK				53
-
-/* HSIO SS */
-#define IMX_HSIO_AXI_CLK				60
-#define IMX_HSIO_PER_CLK				61
-
-/* Display controller SS */
-#define IMX_DC_AXI_EXT_CLK				70
-#define IMX_DC_AXI_INT_CLK				71
-#define IMX_DC_CFG_CLK					72
-#define IMX_DC0_PLL0_CLK				80
-#define IMX_DC0_PLL1_CLK				81
-#define IMX_DC0_DISP0_CLK				82
-#define IMX_DC0_DISP1_CLK				83
-
-/* MIPI-LVDS SS */
-#define IMX_MIPI_IPG_CLK				90
-#define IMX_MIPI0_PIXEL_CLK				100
-#define IMX_MIPI0_BYPASS_CLK				101
-#define IMX_MIPI0_LVDS_PIXEL_CLK			102
-#define IMX_MIPI0_LVDS_BYPASS_CLK			103
-#define IMX_MIPI0_LVDS_PHY_CLK				104
-#define IMX_MIPI0_I2C0_CLK				105
-#define IMX_MIPI0_I2C1_CLK				106
-#define IMX_MIPI0_PWM0_CLK				107
-#define IMX_MIPI1_PIXEL_CLK				108
-#define IMX_MIPI1_BYPASS_CLK				109
-#define IMX_MIPI1_LVDS_PIXEL_CLK			110
-#define IMX_MIPI1_LVDS_BYPASS_CLK			111
-#define IMX_MIPI1_LVDS_PHY_CLK				112
-#define IMX_MIPI1_I2C0_CLK				113
-#define IMX_MIPI1_I2C1_CLK				114
-#define IMX_MIPI1_PWM0_CLK				115
-
-/* IMG SS */
-#define IMX_IMG_AXI_CLK					120
-#define IMX_IMG_IPG_CLK					121
-#define IMX_IMG_PXL_CLK					122
-
-/* MIPI-CSI SS */
-#define IMX_CSI0_CORE_CLK				130
-#define IMX_CSI0_ESC_CLK				131
-#define IMX_CSI0_PWM0_CLK				132
-#define IMX_CSI0_I2C0_CLK				133
-
-/* PARALLER CSI SS */
-#define IMX_PARALLEL_CSI_DPLL_CLK			140
-#define IMX_PARALLEL_CSI_PIXEL_CLK			141
-#define IMX_PARALLEL_CSI_MCLK_CLK			142
-
-/* VPU SS */
-#define IMX_VPU_ENC_CLK					150
-#define IMX_VPU_DEC_CLK					151
-
-/* GPU SS */
-#define IMX_GPU0_CORE_CLK				160
-#define IMX_GPU0_SHADER_CLK				161
-
-/* ADMA SS */
-#define IMX_ADMA_IPG_CLK_ROOT				165
-#define IMX_ADMA_UART0_CLK				170
-#define IMX_ADMA_UART1_CLK				171
-#define IMX_ADMA_UART2_CLK				172
-#define IMX_ADMA_UART3_CLK				173
-#define IMX_ADMA_SPI0_CLK				174
-#define IMX_ADMA_SPI1_CLK				175
-#define IMX_ADMA_SPI2_CLK				176
-#define IMX_ADMA_SPI3_CLK				177
-#define IMX_ADMA_CAN0_CLK				178
-#define IMX_ADMA_CAN1_CLK				179
-#define IMX_ADMA_CAN2_CLK				180
-#define IMX_ADMA_I2C0_CLK				181
-#define IMX_ADMA_I2C1_CLK				182
-#define IMX_ADMA_I2C2_CLK				183
-#define IMX_ADMA_I2C3_CLK				184
-#define IMX_ADMA_FTM0_CLK				185
-#define IMX_ADMA_FTM1_CLK				186
-#define IMX_ADMA_ADC0_CLK				187
-#define IMX_ADMA_PWM_CLK				188
-#define IMX_ADMA_LCD_CLK				189
-
-#define IMX_SCU_CLK_END					190
-
-/* LPCG clocks */
-
-/* LSIO SS LPCG */
-#define IMX_LSIO_LPCG_PWM0_IPG_CLK			0
-#define IMX_LSIO_LPCG_PWM0_IPG_S_CLK			1
-#define IMX_LSIO_LPCG_PWM0_IPG_HF_CLK			2
-#define IMX_LSIO_LPCG_PWM0_IPG_SLV_CLK			3
-#define IMX_LSIO_LPCG_PWM0_IPG_MSTR_CLK			4
-#define IMX_LSIO_LPCG_PWM1_IPG_CLK			5
-#define IMX_LSIO_LPCG_PWM1_IPG_S_CLK			6
-#define IMX_LSIO_LPCG_PWM1_IPG_HF_CLK			7
-#define IMX_LSIO_LPCG_PWM1_IPG_SLV_CLK			8
-#define IMX_LSIO_LPCG_PWM1_IPG_MSTR_CLK			9
-#define IMX_LSIO_LPCG_PWM2_IPG_CLK			10
-#define IMX_LSIO_LPCG_PWM2_IPG_S_CLK			11
-#define IMX_LSIO_LPCG_PWM2_IPG_HF_CLK			12
-#define IMX_LSIO_LPCG_PWM2_IPG_SLV_CLK			13
-#define IMX_LSIO_LPCG_PWM2_IPG_MSTR_CLK			14
-#define IMX_LSIO_LPCG_PWM3_IPG_CLK			15
-#define IMX_LSIO_LPCG_PWM3_IPG_S_CLK			16
-#define IMX_LSIO_LPCG_PWM3_IPG_HF_CLK			17
-#define IMX_LSIO_LPCG_PWM3_IPG_SLV_CLK			18
-#define IMX_LSIO_LPCG_PWM3_IPG_MSTR_CLK			19
-#define IMX_LSIO_LPCG_PWM4_IPG_CLK			20
-#define IMX_LSIO_LPCG_PWM4_IPG_S_CLK			21
-#define IMX_LSIO_LPCG_PWM4_IPG_HF_CLK			22
-#define IMX_LSIO_LPCG_PWM4_IPG_SLV_CLK			23
-#define IMX_LSIO_LPCG_PWM4_IPG_MSTR_CLK			24
-#define IMX_LSIO_LPCG_PWM5_IPG_CLK			25
-#define IMX_LSIO_LPCG_PWM5_IPG_S_CLK			26
-#define IMX_LSIO_LPCG_PWM5_IPG_HF_CLK			27
-#define IMX_LSIO_LPCG_PWM5_IPG_SLV_CLK			28
-#define IMX_LSIO_LPCG_PWM5_IPG_MSTR_CLK			29
-#define IMX_LSIO_LPCG_PWM6_IPG_CLK			30
-#define IMX_LSIO_LPCG_PWM6_IPG_S_CLK			31
-#define IMX_LSIO_LPCG_PWM6_IPG_HF_CLK			32
-#define IMX_LSIO_LPCG_PWM6_IPG_SLV_CLK			33
-#define IMX_LSIO_LPCG_PWM6_IPG_MSTR_CLK			34
-#define IMX_LSIO_LPCG_PWM7_IPG_CLK			35
-#define IMX_LSIO_LPCG_PWM7_IPG_S_CLK			36
-#define IMX_LSIO_LPCG_PWM7_IPG_HF_CLK			37
-#define IMX_LSIO_LPCG_PWM7_IPG_SLV_CLK			38
-#define IMX_LSIO_LPCG_PWM7_IPG_MSTR_CLK			39
-#define IMX_LSIO_LPCG_GPT0_IPG_CLK			40
-#define IMX_LSIO_LPCG_GPT0_IPG_S_CLK			41
-#define IMX_LSIO_LPCG_GPT0_IPG_HF_CLK			42
-#define IMX_LSIO_LPCG_GPT0_IPG_SLV_CLK			43
-#define IMX_LSIO_LPCG_GPT0_IPG_MSTR_CLK			44
-#define IMX_LSIO_LPCG_GPT1_IPG_CLK			45
-#define IMX_LSIO_LPCG_GPT1_IPG_S_CLK			46
-#define IMX_LSIO_LPCG_GPT1_IPG_HF_CLK			47
-#define IMX_LSIO_LPCG_GPT1_IPG_SLV_CLK			48
-#define IMX_LSIO_LPCG_GPT1_IPG_MSTR_CLK			49
-#define IMX_LSIO_LPCG_GPT2_IPG_CLK			50
-#define IMX_LSIO_LPCG_GPT2_IPG_S_CLK			51
-#define IMX_LSIO_LPCG_GPT2_IPG_HF_CLK			52
-#define IMX_LSIO_LPCG_GPT2_IPG_SLV_CLK			53
-#define IMX_LSIO_LPCG_GPT2_IPG_MSTR_CLK			54
-#define IMX_LSIO_LPCG_GPT3_IPG_CLK			55
-#define IMX_LSIO_LPCG_GPT3_IPG_S_CLK			56
-#define IMX_LSIO_LPCG_GPT3_IPG_HF_CLK			57
-#define IMX_LSIO_LPCG_GPT3_IPG_SLV_CLK			58
-#define IMX_LSIO_LPCG_GPT3_IPG_MSTR_CLK			59
-#define IMX_LSIO_LPCG_GPT4_IPG_CLK			60
-#define IMX_LSIO_LPCG_GPT4_IPG_S_CLK			61
-#define IMX_LSIO_LPCG_GPT4_IPG_HF_CLK			62
-#define IMX_LSIO_LPCG_GPT4_IPG_SLV_CLK			63
-#define IMX_LSIO_LPCG_GPT4_IPG_MSTR_CLK			64
-#define IMX_LSIO_LPCG_FSPI0_HCLK			65
-#define IMX_LSIO_LPCG_FSPI0_IPG_CLK			66
-#define IMX_LSIO_LPCG_FSPI0_IPG_S_CLK			67
-#define IMX_LSIO_LPCG_FSPI0_IPG_SFCK			68
-#define IMX_LSIO_LPCG_FSPI1_HCLK			69
-#define IMX_LSIO_LPCG_FSPI1_IPG_CLK			70
-#define IMX_LSIO_LPCG_FSPI1_IPG_S_CLK			71
-#define IMX_LSIO_LPCG_FSPI1_IPG_SFCK			72
-
-#define IMX_LSIO_LPCG_CLK_END				73
-
-/* Connectivity SS LPCG */
-#define IMX_CONN_LPCG_SDHC0_IPG_CLK			0
-#define IMX_CONN_LPCG_SDHC0_PER_CLK			1
-#define IMX_CONN_LPCG_SDHC0_HCLK			2
-#define IMX_CONN_LPCG_SDHC1_IPG_CLK			3
-#define IMX_CONN_LPCG_SDHC1_PER_CLK			4
-#define IMX_CONN_LPCG_SDHC1_HCLK			5
-#define IMX_CONN_LPCG_SDHC2_IPG_CLK			6
-#define IMX_CONN_LPCG_SDHC2_PER_CLK			7
-#define IMX_CONN_LPCG_SDHC2_HCLK			8
-#define IMX_CONN_LPCG_GPMI_APB_CLK			9
-#define IMX_CONN_LPCG_GPMI_BCH_APB_CLK			10
-#define IMX_CONN_LPCG_GPMI_BCH_IO_CLK			11
-#define IMX_CONN_LPCG_GPMI_BCH_CLK			12
-#define IMX_CONN_LPCG_APBHDMA_CLK			13
-#define IMX_CONN_LPCG_ENET0_ROOT_CLK			14
-#define IMX_CONN_LPCG_ENET0_TX_CLK			15
-#define IMX_CONN_LPCG_ENET0_AHB_CLK			16
-#define IMX_CONN_LPCG_ENET0_IPG_S_CLK			17
-#define IMX_CONN_LPCG_ENET0_IPG_CLK			18
-
-#define IMX_CONN_LPCG_ENET1_ROOT_CLK			19
-#define IMX_CONN_LPCG_ENET1_TX_CLK			20
-#define IMX_CONN_LPCG_ENET1_AHB_CLK			21
-#define IMX_CONN_LPCG_ENET1_IPG_S_CLK			22
-#define IMX_CONN_LPCG_ENET1_IPG_CLK			23
-
-#define IMX_CONN_LPCG_CLK_END				24
-
-/* ADMA SS LPCG */
-#define IMX_ADMA_LPCG_UART0_IPG_CLK			0
-#define IMX_ADMA_LPCG_UART0_BAUD_CLK			1
-#define IMX_ADMA_LPCG_UART1_IPG_CLK			2
-#define IMX_ADMA_LPCG_UART1_BAUD_CLK			3
-#define IMX_ADMA_LPCG_UART2_IPG_CLK			4
-#define IMX_ADMA_LPCG_UART2_BAUD_CLK			5
-#define IMX_ADMA_LPCG_UART3_IPG_CLK			6
-#define IMX_ADMA_LPCG_UART3_BAUD_CLK			7
-#define IMX_ADMA_LPCG_SPI0_IPG_CLK			8
-#define IMX_ADMA_LPCG_SPI1_IPG_CLK			9
-#define IMX_ADMA_LPCG_SPI2_IPG_CLK			10
-#define IMX_ADMA_LPCG_SPI3_IPG_CLK			11
-#define IMX_ADMA_LPCG_SPI0_CLK				12
-#define IMX_ADMA_LPCG_SPI1_CLK				13
-#define IMX_ADMA_LPCG_SPI2_CLK				14
-#define IMX_ADMA_LPCG_SPI3_CLK				15
-#define IMX_ADMA_LPCG_CAN0_IPG_CLK			16
-#define IMX_ADMA_LPCG_CAN0_IPG_PE_CLK			17
-#define IMX_ADMA_LPCG_CAN0_IPG_CHI_CLK			18
-#define IMX_ADMA_LPCG_CAN1_IPG_CLK			19
-#define IMX_ADMA_LPCG_CAN1_IPG_PE_CLK			20
-#define IMX_ADMA_LPCG_CAN1_IPG_CHI_CLK			21
-#define IMX_ADMA_LPCG_CAN2_IPG_CLK			22
-#define IMX_ADMA_LPCG_CAN2_IPG_PE_CLK			23
-#define IMX_ADMA_LPCG_CAN2_IPG_CHI_CLK			24
-#define IMX_ADMA_LPCG_I2C0_CLK				25
-#define IMX_ADMA_LPCG_I2C1_CLK				26
-#define IMX_ADMA_LPCG_I2C2_CLK				27
-#define IMX_ADMA_LPCG_I2C3_CLK				28
-#define IMX_ADMA_LPCG_I2C0_IPG_CLK			29
-#define IMX_ADMA_LPCG_I2C1_IPG_CLK			30
-#define IMX_ADMA_LPCG_I2C2_IPG_CLK			31
-#define IMX_ADMA_LPCG_I2C3_IPG_CLK			32
-#define IMX_ADMA_LPCG_FTM0_CLK				33
-#define IMX_ADMA_LPCG_FTM1_CLK				34
-#define IMX_ADMA_LPCG_FTM0_IPG_CLK			35
-#define IMX_ADMA_LPCG_FTM1_IPG_CLK			36
-#define IMX_ADMA_LPCG_PWM_HI_CLK			37
-#define IMX_ADMA_LPCG_PWM_IPG_CLK			38
-#define IMX_ADMA_LPCG_LCD_PIX_CLK			39
-#define IMX_ADMA_LPCG_LCD_APB_CLK			40
-#define IMX_ADMA_LPCG_DSP_ADB_CLK			41
-#define IMX_ADMA_LPCG_DSP_IPG_CLK			42
-#define IMX_ADMA_LPCG_DSP_CORE_CLK			43
-#define IMX_ADMA_LPCG_OCRAM_IPG_CLK			44
-
-#define IMX_ADMA_LPCG_CLK_END				45
+#define IMX_ADMA_ACM_AUD_CLK0_SEL			0
+#define IMX_ADMA_ACM_AUD_CLK0_CLK			1
+#define IMX_ADMA_ACM_AUD_CLK1_SEL			2
+#define IMX_ADMA_ACM_AUD_CLK1_CLK			3
+#define IMX_ADMA_ACM_MCLKOUT0_SEL			4
+#define IMX_ADMA_ACM_MCLKOUT1_SEL			5
+#define IMX_ADMA_ACM_ESAI0_MCLK_SEL			6
+#define IMX_ADMA_ACM_GPT0_MUX_CLK_SEL			7
+#define IMX_ADMA_ACM_GPT1_MUX_CLK_SEL			8
+#define IMX_ADMA_ACM_GPT2_MUX_CLK_SEL			9
+#define IMX_ADMA_ACM_GPT3_MUX_CLK_SEL			10
+#define IMX_ADMA_ACM_GPT4_MUX_CLK_SEL			11
+#define IMX_ADMA_ACM_GPT5_MUX_CLK_SEL			12
+#define IMX_ADMA_ACM_SAI0_MCLK_SEL			13
+#define IMX_ADMA_ACM_SAI1_MCLK_SEL			14
+#define IMX_ADMA_ACM_SAI2_MCLK_SEL			15
+#define IMX_ADMA_ACM_SAI3_MCLK_SEL			16
+#define IMX_ADMA_ACM_SAI4_MCLK_SEL			17
+#define IMX_ADMA_ACM_SAI5_MCLK_SEL			18
+#define IMX_ADMA_ACM_SPDIF0_TX_CLK_SEL			19
+#define IMX_ADMA_ACM_MQS_TX_CLK_SEL			20
+#define IMX_ADMA_ACM_ASRC0_MUX_CLK_SEL			21
+#define IMX_ADMA_ACM_ASRC1_MUX_CLK_SEL			22
+
+#define IMX_ADMA_EXT_AUD_MCLK0				23
+#define IMX_ADMA_EXT_AUD_MCLK1				24
+#define IMX_ADMA_ESAI0_RX_CLK				25
+#define IMX_ADMA_ESAI0_RX_HF_CLK			26
+#define IMX_ADMA_ESAI0_TX_CLK				27
+#define IMX_ADMA_ESAI0_TX_HF_CLK			28
+#define IMX_ADMA_SPDIF0_RX				29
+#define IMX_ADMA_SAI0_RX_BCLK				30
+#define IMX_ADMA_SAI0_TX_BCLK				31
+#define IMX_ADMA_SAI1_RX_BCLK				32
+#define IMX_ADMA_SAI1_TX_BCLK				33
+#define IMX_ADMA_SAI2_RX_BCLK				34
+#define IMX_ADMA_SAI3_RX_BCLK				35
+#define IMX_ADMA_SAI4_RX_BCLK				36
+#define IMX_ADMA_SAI5_TX_BCLK				37
+#define IMX_ADMA_SAI6_RX_BCLK				38
+#define IMX_ADMA_HDMI_RX_MCLK				39
+#define IMX_ADMA_SPDIF1_RX				41
+#define IMX_ADMA_ESAI1_RX_CLK				42
+#define IMX_ADMA_ESAI1_RX_HF_CLK			43
+#define IMX_ADMA_ESAI1_TX_CLK				44
+#define IMX_ADMA_ESAI1_TX_HF_CLK			45
+
+#define IMX_ADMA_ACM_ESAI1_MCLK_SEL			46
+#define IMX_ADMA_ACM_SAI6_MCLK_SEL			47
+#define IMX_ADMA_ACM_SAI7_MCLK_SEL			48
+#define IMX_ADMA_ACM_SPDIF1_TX_CLK_SEL			49
+
+#define IMX_ADMA_ACM_CLK_END				50
 
 #endif /* __DT_BINDINGS_CLOCK_IMX_H */
diff --git a/include/dt-bindings/clock/s32v234-clock.h b/include/dt-bindings/clock/s32v234-clock.h
new file mode 100644
index 000000000..1ddfae5c1
--- /dev/null
+++ b/include/dt-bindings/clock/s32v234-clock.h
@@ -0,0 +1,65 @@
+/* SPDX-License-Identifier: GPL-2.0-or-later */
+/*
+ * Copyright (C) 2015-2016 Freescale Semiconductor, Inc.
+ * Copyright (C) 2017 NXP
+ */
+
+#ifndef __DT_BINDINGS_CLOCK_S32V234_H
+#define __DT_BINDINGS_CLOCK_S32V234_H
+
+#define	S32V234_CLK_DUMMY			0
+#define	S32V234_CLK_FXOSC			1
+#define	S32V234_CLK_FIRC			2
+/* PERIPH PLL */
+#define	S32V234_CLK_PERIPHPLL_SRC_SEL		3
+#define	S32V234_CLK_PERIPHPLL_VCO		4
+#define	S32V234_CLK_PERIPHPLL_PHI0		5
+#define	S32V234_CLK_PERIPHPLL_PHI0_DIV3		6
+#define	S32V234_CLK_PERIPHPLL_PHI0_DIV5		7
+#define	S32V234_CLK_PERIPHPLL_PHI1		8
+/* LINFlexD Clock */
+#define	S32V234_CLK_LIN				9
+#define	S32V234_CLK_LIN_SEL			10
+#define	S32V234_CLK_LIN_IPG			11
+/* SDHC Clock */
+#define	S32V234_CLK_SDHC			12
+#define	S32V234_CLK_SDHC_SEL			13
+/* ENET PLL */
+#define	S32V234_CLK_ENETPLL_SRC_SEL		14
+#define	S32V234_CLK_ENETPLL_VCO			15
+#define	S32V234_CLK_ENETPLL_PHI0		16
+#define	S32V234_CLK_ENETPLL_PHI1		17
+#define	S32V234_CLK_ENETPLL_DFS0		18
+#define	S32V234_CLK_ENETPLL_DFS1		19
+#define	S32V234_CLK_ENETPLL_DFS2		20
+#define	S32V234_CLK_ENETPLL_DFS3		21
+/* System Clock */
+#define	S32V234_CLK_SYS_SEL			22
+#define	S32V234_CLK_SYS3			23
+#define	S32V234_CLK_SYS6			24
+#define	S32V234_CLK_SYS6_DIV2			25
+/* ENET Clock */
+#define	S32V234_CLK_ENET_TIME_DIV		26
+#define	S32V234_CLK_ENET_TIME_SEL		27
+#define	S32V234_CLK_ENET_DIV			28
+#define	S32V234_CLK_ENET_SEL			29
+
+#define	S32V234_CLK_ENET			30
+#define	S32V234_CLK_ENET_TIME			31
+
+/* ARM PLL */
+#define	S32V234_CLK_ARMPLL_SRC_SEL		32
+#define	S32V234_CLK_ARMPLL_VCO			33
+#define	S32V234_CLK_ARMPLL_PHI0			34
+#define	S32V234_CLK_ARMPLL_PHI1			35
+#define	S32V234_CLK_ARMPLL_DFS0			35
+#define	S32V234_CLK_ARMPLL_DFS1			36
+#define	S32V234_CLK_ARMPLL_DFS2			37
+
+/* CAN Clock */
+#define S32V234_CLK_CAN				38
+#define S32V234_CLK_CAN_SEL			39
+
+#define	S32V234_CLK_END				40
+
+#endif /* __DT_BINDINGS_CLOCK_S32V234_H */
diff --git a/include/dt-bindings/firmware/imx/rsrc.h b/include/dt-bindings/firmware/imx/rsrc.h
index 54278d5c1..09d3be9ff 100644
--- a/include/dt-bindings/firmware/imx/rsrc.h
+++ b/include/dt-bindings/firmware/imx/rsrc.h
@@ -37,10 +37,14 @@
 #define IMX_SC_R_DC_0_BLIT2		21
 #define IMX_SC_R_DC_0_BLIT_OUT		22
 #define IMX_SC_R_PERF			23
+#define IMX_SC_R_USB_1_PHY		24
 #define IMX_SC_R_DC_0_WARP		25
+#define IMX_SC_R_V2X_MU_0		26
+#define IMX_SC_R_V2X_MU_1		27
 #define IMX_SC_R_DC_0_VIDEO0		28
 #define IMX_SC_R_DC_0_VIDEO1		29
 #define IMX_SC_R_DC_0_FRAC0		30
+#define IMX_SC_R_V2X_MU_2		31
 #define IMX_SC_R_DC_0			32
 #define IMX_SC_R_GPU_2_PID0		33
 #define IMX_SC_R_DC_0_PLL_0		34
@@ -49,7 +53,10 @@
 #define IMX_SC_R_DC_1_BLIT1		37
 #define IMX_SC_R_DC_1_BLIT2		38
 #define IMX_SC_R_DC_1_BLIT_OUT		39
+#define IMX_SC_R_V2X_MU_3		40
+#define IMX_SC_R_V2X_MU_4		41
 #define IMX_SC_R_DC_1_WARP		42
+#define IMX_SC_R_SECVIO			44
 #define IMX_SC_R_DC_1_VIDEO0		45
 #define IMX_SC_R_DC_1_VIDEO1		46
 #define IMX_SC_R_DC_1_FRAC0		47
@@ -256,7 +263,6 @@
 #define IMX_SC_R_SDHC_2			250
 #define IMX_SC_R_ENET_0			251
 #define IMX_SC_R_ENET_1			252
-#define IMX_SC_R_MLB_0			253
 #define IMX_SC_R_DMA_2_CH0		254
 #define IMX_SC_R_DMA_2_CH1		255
 #define IMX_SC_R_DMA_2_CH2		256
diff --git a/include/dt-bindings/input/input.h b/include/dt-bindings/input/input.h
index bcf0ae100..221253480 100644
--- a/include/dt-bindings/input/input.h
+++ b/include/dt-bindings/input/input.h
@@ -15,4 +15,7 @@
 #define MATRIX_KEY(row, col, code)	\
 	((((row) & 0xFF) << 24) | (((col) & 0xFF) << 16) | ((code) & 0xFFFF))
 
+#define FT5416		0x54160002
+#define FT5426		0x54260002
+
 #endif /* _DT_BINDINGS_INPUT_INPUT_H */
diff --git a/include/dt-bindings/pinctrl/pads-imx8qxp.h b/include/dt-bindings/pinctrl/pads-imx8qxp.h
index fbfee7ecf..e4abcd6f7 100644
--- a/include/dt-bindings/pinctrl/pads-imx8qxp.h
+++ b/include/dt-bindings/pinctrl/pads-imx8qxp.h
@@ -747,5 +747,30 @@
 #define IMX8QXP_QSPI0B_SS1_B_LSIO_QSPI1A_SS1_B                     IMX8QXP_QSPI0B_SS1_B                  1
 #define IMX8QXP_QSPI0B_SS1_B_LSIO_KPP0_ROW3                        IMX8QXP_QSPI0B_SS1_B                  2
 #define IMX8QXP_QSPI0B_SS1_B_LSIO_GPIO3_IO24                       IMX8QXP_QSPI0B_SS1_B                  4
+#define IMX8QXP_COMP_CTL_GPIO_1V8_3V3_GPIORHB_PAD                  IMX8QXP_COMP_CTL_GPIO_1V8_3V3_GPIORHB 0
+
+/*!
+ * @name Fake Pad Mux Definitions
+ * format: name padid 0
+ */
+/*@{*/
+#define IMX8QXP_COMP_CTL_GPIO_1V8_3V3_PCIESEP_PAD          IMX8QXP_COMP_CTL_GPIO_1V8_3V3_PCIESEP         0
+#define IMX8QXP_COMP_CTL_GPIO_3V3_USB3IO_PAD               IMX8QXP_COMP_CTL_GPIO_3V3_USB3IO              0
+#define IMX8QXP_COMP_CTL_GPIO_1V8_3V3_SD1FIX0_PAD          IMX8QXP_COMP_CTL_GPIO_1V8_3V3_SD1FIX0         0
+#define IMX8QXP_COMP_CTL_GPIO_1V8_3V3_SD1FIX1_PAD          IMX8QXP_COMP_CTL_GPIO_1V8_3V3_SD1FIX1         0
+#define IMX8QXP_COMP_CTL_GPIO_1V8_3V3_VSELSEP_PAD          IMX8QXP_COMP_CTL_GPIO_1V8_3V3_VSELSEP         0
+#define IMX8QXP_COMP_CTL_GPIO_1V8_3V3_VSEL3_PAD            IMX8QXP_COMP_CTL_GPIO_1V8_3V3_VSEL3           0
+#define IMX8QXP_COMP_CTL_GPIO_1V8_3V3_ENET_ENETB0_PAD      IMX8QXP_COMP_CTL_GPIO_1V8_3V3_ENET_ENETB0     0
+#define IMX8QXP_COMP_CTL_GPIO_1V8_3V3_ENET_ENETB1_PAD      IMX8QXP_COMP_CTL_GPIO_1V8_3V3_ENET_ENETB1     0
+#define IMX8QXP_COMP_CTL_GPIO_1V8_3V3_GPIOCT_PAD           IMX8QXP_COMP_CTL_GPIO_1V8_3V3_GPIOCT          0
+#define IMX8QXP_COMP_CTL_GPIO_1V8_3V3_GPIORHB_PAD          IMX8QXP_COMP_CTL_GPIO_1V8_3V3_GPIORHB         0
+#define IMX8QXP_COMP_CTL_GPIO_1V8_3V3_GPIORHK_PAD          IMX8QXP_COMP_CTL_GPIO_1V8_3V3_GPIORHK         0
+#define IMX8QXP_COMP_CTL_GPIO_1V8_3V3_GPIORHT_PAD          IMX8QXP_COMP_CTL_GPIO_1V8_3V3_GPIORHT         0
+#define IMX8QXP_COMP_CTL_GPIO_1V8_3V3_GPIOLH_PAD           IMX8QXP_COMP_CTL_GPIO_1V8_3V3_GPIOLH          0
+#define IMX8QXP_COMP_CTL_GPIO_1V8_3V3_MIPIDSIGPIO_PAD      IMX8QXP_COMP_CTL_GPIO_1V8_3V3_MIPIDSIGPIO     0
+#define IMX8QXP_COMP_CTL_GPIO_1V8_3V3_GPIORHD_PAD          IMX8QXP_COMP_CTL_GPIO_1V8_3V3_GPIORHD         0
+#define IMX8QXP_COMP_CTL_GPIO_1V8_3V3_QSPI0A_PAD           IMX8QXP_COMP_CTL_GPIO_1V8_3V3_QSPI0A          0
+#define IMX8QXP_COMP_CTL_GPIO_1V8_3V3_QSPI0B_PAD           IMX8QXP_COMP_CTL_GPIO_1V8_3V3_QSPI0B          0
+/*@}*/
 
 #endif /* _IMX8QXP_PADS_H */
diff --git a/include/dt-bindings/pinctrl/s32v234-pinctrl.h b/include/dt-bindings/pinctrl/s32v234-pinctrl.h
new file mode 100644
index 000000000..8736d556a
--- /dev/null
+++ b/include/dt-bindings/pinctrl/s32v234-pinctrl.h
@@ -0,0 +1,1173 @@
+/* SPDX-License-Identifier: GPL-2.0-or-later */
+/*
+ * Copyright 2015-2016 by Freescale Semiconductor
+ * Copyright 2016-2017, 2019 NXP
+ */
+
+#ifndef __DT_BINDINGS_S32V234_PINCTRL_H__
+#define __DT_BINDINGS_S32V234_PINCTRL_H__
+
+/*
+ * Use to set PAD control
+ */
+#define PAD_CTL_DCYLE_TRIM_OFS      (22)
+#define PAD_CTL_DCYLE_TRIM_NONE     (0 << PAD_CTL_DCYLE_TRIM_OFS)
+#define PAD_CTL_DCYLE_TRIM_LEFT     (1 << PAD_CTL_DCYLE_TRIM_OFS)
+#define PAD_CTL_DCYLE_TRIM_RIGHT    (2 << PAD_CTL_DCYLE_TRIM_OFS)
+
+#define PAD_CTL_OBE         (1 << 21)
+#define PAD_CTL_ODE         (1 << 20)
+#define PAD_CTL_IBE         (1 << 19)
+#define PAD_CTL_HYS         (1 << 18)
+#define PAD_CTL_INV         (1 << 17)
+#define PAD_CTL_PKE         (1 << 16)
+
+#define PAD_CTL_SRE_OFS             (14)
+#define PAD_CTL_SRE_LOW_50HZ        (0 << PAD_CTL_SRE_OFS)
+#define PAD_CTL_SRE_LOW_100MHZ      (1 << PAD_CTL_SRE_OFS)
+/* The manual reports the same value for SRE = 01 and SRE = 10 */
+#define PAD_CTL_SRE_HIGH_100MHZ     (2 << PAD_CTL_SRE_OFS)
+#define PAD_CTL_SRE_HIGH_200MHZ     (3 << PAD_CTL_SRE_OFS)
+
+#define PAD_CTL_PUE             (1 << 13)
+
+#define PAD_CTL_PUS_OFS         (11)
+#define PAD_CTL_PUS_100K_DOWN   (0 << PAD_CTL_PUS_OFS)
+#define PAD_CTL_PUS_50K_UP      (1 << PAD_CTL_PUS_OFS)
+#define PAD_CTL_PUS_100K_UP     (2 << PAD_CTL_PUS_OFS)
+#define PAD_CTL_PUS_33K_UP      (3 << PAD_CTL_PUS_OFS)
+#define PAD_CTL_PUS_MASK        (3 << PAD_CTL_PUS_OFS)
+
+#define PAD_CTL_DSE_OFS         (8)
+#define PAD_CTL_DSE_OUT_DISABLE (0 << PAD_CTL_DSE_OFS)
+#define PAD_CTL_DSE_240         (1 << PAD_CTL_DSE_OFS)
+#define PAD_CTL_DSE_120         (2 << PAD_CTL_DSE_OFS)
+#define PAD_CTL_DSE_80          (3 << PAD_CTL_DSE_OFS)
+#define PAD_CTL_DSE_60          (4 << PAD_CTL_DSE_OFS)
+#define PAD_CTL_DSE_48          (5 << PAD_CTL_DSE_OFS)
+#define PAD_CTL_DSE_40          (6 << PAD_CTL_DSE_OFS)
+#define PAD_CTL_DSE_34          (7 << PAD_CTL_DSE_OFS)
+#define PAD_CTL_DSE_MASK        (7 << PAD_CTL_DSE_OFS)
+
+#define PAD_CTL_CRPOINT_TRIM    (3 << 6)
+
+#define PAD_CTL_SMC             (1 << 5)
+
+#define PAD_CTL_MUX_MODE_ALT0   (0)
+#define PAD_CTL_MUX_MODE_ALT1   (1)
+#define PAD_CTL_MUX_MODE_ALT2   (2)
+#define PAD_CTL_MUX_MODE_ALT3   (3)
+#define PAD_CTL_MUX_MODE_ALT4   (4)
+#define PAD_CTL_MUX_MODE_ALT5   (5)
+#define PAD_CTL_MUX_MODE_ALT6   (6)
+#define PAD_CTL_MUX_MODE_ALT7   (7)
+#define PAD_CTL_MUX_MODE_MASK   (0xF)
+
+/* UART configuration */
+#define PAD_CTL_UART_TX         (PAD_CTL_OBE | PAD_CTL_PUS_100K_UP |\
+				PAD_CTL_DSE_60 | PAD_CTL_SRE_LOW_100MHZ |\
+				PAD_CTL_MUX_MODE_ALT1)
+#define PAD_CTL_UART_RX_MSCR    (PAD_CTL_PUE | PAD_CTL_IBE |\
+				PAD_CTL_DCYLE_TRIM_RIGHT)
+#define PAD_CTL_UART_RX_IMCR    (PAD_CTL_MUX_MODE_ALT2)
+
+/* CAN0 configuration */
+#define PAD_CTL_CAN_FD0_TX      (PAD_CTL_OBE | PAD_CTL_PUS_50K_UP |\
+				PAD_CTL_PUE | PAD_CTL_DSE_34 |\
+				PAD_CTL_MUX_MODE_ALT1)
+#define PAD_CTL_CAN_FD0_RX_MSCR (PAD_CTL_PUE | PAD_CTL_IBE | PAD_CTL_PUS_50K_UP)
+#define PAD_CTL_CAN_FD0_RX_IMCR (PAD_CTL_MUX_MODE_ALT2)
+
+/* CAN1 configuration */
+#define PAD_CTL_CAN_FD1_TX      (PAD_CTL_OBE | PAD_CTL_PUS_50K_UP |\
+				PAD_CTL_PUE | PAD_CTL_DSE_34 |\
+				PAD_CTL_MUX_MODE_ALT1)
+#define PAD_CTL_CAN_FD1_RX_MSCR (PAD_CTL_PUE | PAD_CTL_IBE | PAD_CTL_PUS_50K_UP)
+#define PAD_CTL_CAN_FD1_RX_IMCR (PAD_CTL_MUX_MODE_ALT3)
+
+/* USDHC configuration  */
+#define PAD_CTL_USDHC_BASE      (PAD_CTL_SRE_HIGH_200MHZ | PAD_CTL_OBE | \
+				PAD_CTL_DSE_34 | PAD_CTL_PKE |  \
+				PAD_CTL_IBE | PAD_CTL_PUS_100K_UP | PAD_CTL_PUE)
+#define PAD_CTL_USDHC_CMD       (PAD_CTL_USDHC_BASE | PAD_CTL_MUX_MODE_ALT1)
+#define PAD_CTL_USDHC_CLK       (PAD_CTL_USDHC_BASE | PAD_CTL_MUX_MODE_ALT2)
+#define PAD_CTL_USDHC_DAT0_3    (PAD_CTL_USDHC_BASE | PAD_CTL_MUX_MODE_ALT2)
+#define PAD_CTL_USDHC_DAT4_7    (PAD_CTL_USDHC_BASE | PAD_CTL_MUX_MODE_ALT3)
+
+/* QSPI configuration */
+#define PAD_CTL_QSPI_BASE         (PAD_CTL_SRE_HIGH_200MHZ | PAD_CTL_OBE | \
+				  PAD_CTL_DSE_34 | PAD_CTL_IBE)
+#define PAD_CTL_QSPI_CLK_BASE     (PAD_CTL_SRE_HIGH_200MHZ | PAD_CTL_DSE_34 | \
+				  PAD_CTL_PUS_100K_UP | PAD_CTL_OBE)
+#define PAD_CTL_QSPI_CK2_MUX      PAD_CTL_MUX_MODE_ALT1
+#define PAD_CTL_QSPI_A_SCK_MUX    PAD_CTL_MUX_MODE_ALT1
+#define PAD_CTL_QSPI_B_SCK_MUX    PAD_CTL_MUX_MODE_ALT1
+#define PAD_CTL_QSPI_A_CS0_MUX    PAD_CTL_MUX_MODE_ALT1
+#define PAD_CTL_QSPI_B_CS0_MUX    PAD_CTL_MUX_MODE_ALT1
+#define PAD_CTL_QSPI_A_CS1_MUX    PAD_CTL_MUX_MODE_ALT1
+#define PAD_CTL_QSPI_B_CS1_MUX    PAD_CTL_MUX_MODE_ALT1
+#define PAD_CTL_QSPI_A_DQS        (PAD_CTL_SRE_HIGH_200MHZ | PAD_CTL_IBE | \
+				  PAD_CTL_PUS_100K_DOWN | PAD_CTL_PUE | \
+				  PAD_CTL_PKE)
+#define PAD_CTL_QSPI_A_DATA0_3    (PAD_CTL_QSPI_BASE | PAD_CTL_MUX_MODE_ALT1)
+#define PAD_CTL_QSPI_A_DATA4_7    (PAD_CTL_QSPI_BASE | PAD_CTL_MUX_MODE_ALT2)
+#define PAD_CTL_QSPI_B_DATA0_3    (PAD_CTL_QSPI_BASE | PAD_CTL_MUX_MODE_ALT1)
+
+/* EIRQ configuration */
+#define PAD_CTL_EIRQ              PAD_CTL_MUX_MODE_ALT2
+
+/* I2C0 - Serial Data Input PA15 */
+#define PAD_CTL_I2C0_MSCR_SDA_PA15    (PAD_CTL_MUX_MODE_ALT1 | PAD_CTL_OBE | \
+				      PAD_CTL_IBE | PAD_CTL_ODE | \
+				      PAD_CTL_DSE_34)
+#define PAD_CTL_I2C0_IMCR_SDA_PA15    (PAD_CTL_MUX_MODE_ALT2)
+
+/* I2C0 - Serial Clock Input PB0 */
+#define PAD_CTL_I2C0_MSCR_SCLK_PB0    (PAD_CTL_MUX_MODE_ALT1 | PAD_CTL_OBE | \
+				      PAD_CTL_IBE | PAD_CTL_ODE | \
+				      PAD_CTL_DSE_34)
+#define PAD_CTL_I2C0_IMCR_SCLK_PB0    (PAD_CTL_MUX_MODE_ALT2)
+
+/* I2C0 - Serial Data Input PG3 */
+#define PAD_CTL_I2C0_MSCR_SDA_PG3     (PAD_CTL_MUX_MODE_ALT2 | PAD_CTL_OBE | \
+				      PAD_CTL_IBE | PAD_CTL_ODE | \
+				      PAD_CTL_DSE_34)
+#define PAD_CTL_I2C0_IMCR_SDA_PG3     (PAD_CTL_MUX_MODE_ALT3)
+
+/* I2C0 - Serial Clock Input PG4 */
+#define PAD_CTL_I2C0_MSCR_SCLK_PG4    (PAD_CTL_MUX_MODE_ALT2 | PAD_CTL_OBE | \
+				      PAD_CTL_IBE | PAD_CTL_ODE | \
+				      PAD_CTL_DSE_34)
+#define PAD_CTL_I2C0_IMCR_SCLK_PG4    (PAD_CTL_MUX_MODE_ALT3)
+
+/* I2C1 - Serial Data Input */
+#define  PAD_CTL_I2C1_MSCR_SDA  (PAD_CTL_MUX_MODE_ALT2 | PAD_CTL_OBE | \
+				PAD_CTL_IBE | PAD_CTL_ODE | PAD_CTL_DSE_34)
+#define PAD_CTL_I2C1_IMCR_SDA   (PAD_CTL_MUX_MODE_ALT3)
+
+/* I2C1 - Serial Clock Input */
+#define  PAD_CTL_I2C1_MSCR_SCLK (PAD_CTL_MUX_MODE_ALT2 | PAD_CTL_OBE | \
+				PAD_CTL_IBE | PAD_CTL_ODE | PAD_CTL_DSE_34)
+#define PAD_CTL_I2C1_IMCR_SCLK  (PAD_CTL_MUX_MODE_ALT3)
+
+/* I2C2 - Serial Data Input */
+#define  PAD_CTL_I2C2_MSCR_SDA  (PAD_CTL_MUX_MODE_ALT1 | PAD_CTL_OBE | \
+				PAD_CTL_IBE | PAD_CTL_ODE | PAD_CTL_DSE_34)
+#define PAD_CTL_I2C2_IMCR_SDA   (PAD_CTL_MUX_MODE_ALT2)
+
+/* I2C2 - Serial Clock Input */
+#define  PAD_CTL_I2C2_MSCR_SCLK (PAD_CTL_MUX_MODE_ALT1 | PAD_CTL_OBE | \
+				PAD_CTL_IBE | PAD_CTL_ODE | PAD_CTL_DSE_34)
+#define PAD_CTL_I2C2_IMCR_SCLK  (PAD_CTL_MUX_MODE_ALT2)
+
+/* ENET CFG1 = 0x203701 */
+#define PAD_CTL_ENET_CFG1       (PAD_CTL_DSE_34 | PAD_CTL_PUS_100K_UP | PAD_CTL_PUE | \
+                                PAD_CTL_OBE | PAD_CTL_MUX_MODE_ALT1)
+
+/* ENET CFG2 = 0x20c701 */
+#define PAD_CTL_ENET_CFG2       (PAD_CTL_DSE_34 | PAD_CTL_SRE_HIGH_200MHZ | \
+                                PAD_CTL_OBE | PAD_CTL_MUX_MODE_ALT1)
+
+/* ENET CFG3 = 0x28c701 */
+#define PAD_CTL_ENET_CFG3       (PAD_CTL_DSE_34 | PAD_CTL_SRE_HIGH_200MHZ | \
+                                PAD_CTL_OBE | PAD_CTL_IBE | PAD_CTL_MUX_MODE_ALT1)
+
+/* ENET CFG7 = 0x8c700 */
+#define PAD_CTL_ENET_CFG4       (PAD_CTL_DSE_34 | PAD_CTL_SRE_HIGH_200MHZ | PAD_CTL_IBE)
+
+/* DCU CFG = 0x20C101 */
+#define PAD_CTL_DCU_CFG         (PAD_CTL_DSE_80 | PAD_CTL_SRE_HIGH_200MHZ | \
+				PAD_CTL_OBE | PAD_CTL_IBE | \
+				PAD_CTL_MUX_MODE_ALT1)
+
+#define PAD_CTL_DCU_CLK_CFG_DSE_DISABLE (PAD_CTL_SRE_HIGH_200MHZ | \
+					PAD_CTL_OBE | PAD_CTL_IBE | \
+					PAD_CTL_MUX_MODE_ALT1)
+
+/* VIU IMCR = 0x00000002 */
+#define PAD_CTL_VIU_CFG         (PAD_CTL_MUX_MODE_ALT2)
+
+/* VIU MSCR = 0x00000002 */
+#define PAD_CTL_VIU_IBE         (PAD_CTL_IBE)
+
+/* SPI 0-3 */
+#define PAD_CTL_SPI_MSCR_CSx    (PAD_CTL_OBE | PAD_CTL_PUS_100K_UP | \
+				PAD_CTL_DSE_34 | PAD_CTL_PUE)
+
+#define PAD_CTL_SPI_MSCR_SCK    (PAD_CTL_OBE | PAD_CTL_DSE_34 | \
+				PAD_CTL_MUX_MODE_ALT1)
+
+#define PAD_CTL_SPI_MSCR_SOUT   (PAD_CTL_OBE | PAD_CTL_DSE_34 | \
+				PAD_CTL_MUX_MODE_ALT1)
+
+#define PAD_CTL_SPI_MSCR_SIN    (PAD_CTL_PUE | PAD_CTL_IBE | \
+				PAD_CTL_PUS_50K_UP)
+
+#define PAD_CTL_SPI_IMCR_SIN    (PAD_CTL_MUX_MODE_ALT2)
+
+/* MSCR register numbers associated to port or function */
+#define S32V234_MSCR_PA0        0
+#define S32V234_MSCR_PA1        1
+#define S32V234_MSCR_PA2        2
+#define S32V234_MSCR_PA3        3
+#define S32V234_MSCR_PA4        4
+#define S32V234_MSCR_PA5        5
+#define S32V234_MSCR_PA6        6
+#define S32V234_MSCR_PA7        7
+#define S32V234_MSCR_PA8        8
+#define S32V234_MSCR_PA9        9
+#define S32V234_MSCR_PA10       10
+#define S32V234_MSCR_PA11       11
+#define S32V234_MSCR_PA12       12
+#define S32V234_MSCR_PA13       13
+#define S32V234_MSCR_PA14       14
+#define S32V234_MSCR_PA15       15
+#define S32V234_MSCR_PB0        16
+#define S32V234_MSCR_PB1        17
+#define S32V234_MSCR_PB2        18
+#define S32V234_MSCR_PB3        19
+#define S32V234_MSCR_PB4        20
+#define S32V234_MSCR_PB5        21
+#define S32V234_MSCR_PB6        22
+#define S32V234_MSCR_PB7        23
+#define S32V234_MSCR_PB8        24
+#define S32V234_MSCR_PB9        25
+#define S32V234_MSCR_PB10       26
+#define S32V234_MSCR_PB11       27
+#define S32V234_MSCR_PB12       28
+#define S32V234_MSCR_PB13       29
+#define S32V234_MSCR_PB14       30
+#define S32V234_MSCR_PB15       31
+#define S32V234_MSCR_PC0        32
+#define S32V234_MSCR_PC1        33
+#define S32V234_MSCR_PC2        34
+#define S32V234_MSCR_PC3        35
+#define S32V234_MSCR_PC4        36
+#define S32V234_MSCR_PC5        37
+#define S32V234_MSCR_PC6        38
+#define S32V234_MSCR_PC7        39
+#define S32V234_MSCR_PC8        40
+#define S32V234_MSCR_PC9        41
+#define S32V234_MSCR_PC10       42
+#define S32V234_MSCR_PC11       43
+#define S32V234_MSCR_PC12       44
+#define S32V234_MSCR_PC13       45
+#define S32V234_MSCR_PC14       46
+#define S32V234_MSCR_PC15       47
+#define S32V234_MSCR_PD0        48
+#define S32V234_MSCR_PD1        49
+#define S32V234_MSCR_PD2        50
+#define S32V234_MSCR_PD3        51
+#define S32V234_MSCR_PD4        52
+#define S32V234_MSCR_PD5        53
+#define S32V234_MSCR_PD6        54
+#define S32V234_MSCR_PD7        55
+#define S32V234_MSCR_PD8        56
+#define S32V234_MSCR_PD9        57
+#define S32V234_MSCR_PD10       58
+#define S32V234_MSCR_PD11       59
+#define S32V234_MSCR_PD12       60
+#define S32V234_MSCR_PD13       61
+#define S32V234_MSCR_PD14       62
+#define S32V234_MSCR_PD15       63
+#define S32V234_MSCR_PE0        64
+#define S32V234_MSCR_PE1        65
+#define S32V234_MSCR_PE2        66
+#define S32V234_MSCR_PE3        67
+#define S32V234_MSCR_PE4        68
+#define S32V234_MSCR_PE5        69
+#define S32V234_MSCR_PE6        70
+#define S32V234_MSCR_PE7        71
+#define S32V234_MSCR_PE8        72
+#define S32V234_MSCR_PE9        73
+#define S32V234_MSCR_PE10       74
+#define S32V234_MSCR_PE11       75
+#define S32V234_MSCR_PE12       76
+#define S32V234_MSCR_PE13       77
+#define S32V234_MSCR_PE14       78
+#define S32V234_MSCR_PE15       79
+#define S32V234_MSCR_PF0        80
+#define S32V234_MSCR_PF1        81
+#define S32V234_MSCR_PF2        82
+#define S32V234_MSCR_PF3        83
+#define S32V234_MSCR_PF4        84
+#define S32V234_MSCR_PF5        85
+#define S32V234_MSCR_PF6        86
+#define S32V234_MSCR_PF7        87
+#define S32V234_MSCR_PF8        88
+#define S32V234_MSCR_PF9        89
+#define S32V234_MSCR_PF10       90
+#define S32V234_MSCR_PF11       91
+#define S32V234_MSCR_PF12       92
+#define S32V234_MSCR_PF13       93
+#define S32V234_MSCR_PF14       94
+#define S32V234_MSCR_PF15       95
+#define S32V234_MSCR_PG0        96
+#define S32V234_MSCR_PG1        97
+#define S32V234_MSCR_PG2        98
+#define S32V234_MSCR_PG3        99
+#define S32V234_MSCR_PG4        100
+#define S32V234_MSCR_PG5        101
+#define S32V234_MSCR_PG6        102
+#define S32V234_MSCR_PG7        103
+#define S32V234_MSCR_PG8        104
+#define S32V234_MSCR_PG9        105
+#define S32V234_MSCR_PG10       106
+#define S32V234_MSCR_PG11       107
+#define S32V234_MSCR_PG12       108
+#define S32V234_MSCR_PG13       109
+#define S32V234_MSCR_PG14       110
+#define S32V234_MSCR_PG15       111
+#define S32V234_MSCR_PH0        112
+#define S32V234_MSCR_PH1        113
+#define S32V234_MSCR_PH2        114
+#define S32V234_MSCR_PH3        115
+#define S32V234_MSCR_PH4        116
+#define S32V234_MSCR_PH5        117
+#define S32V234_MSCR_PH6        118
+#define S32V234_MSCR_PH7        119
+#define S32V234_MSCR_PH8        120
+#define S32V234_MSCR_PH9        121
+#define S32V234_MSCR_PH10       122
+#define S32V234_MSCR_PH11       123
+#define S32V234_MSCR_PH12       124
+#define S32V234_MSCR_PH13       125
+#define S32V234_MSCR_PH14       126
+#define S32V234_MSCR_PH15       127
+#define S32V234_MSCR_PJ0        128
+#define S32V234_MSCR_PJ1        129
+#define S32V234_MSCR_PJ2        130
+#define S32V234_MSCR_PJ3        131
+#define S32V234_MSCR_PJ4        132
+#define S32V234_MSCR_PJ5        133
+#define S32V234_MSCR_PJ6        134
+#define S32V234_MSCR_PJ7        135
+#define S32V234_MSCR_PJ8        136
+#define S32V234_MSCR_PJ9        137
+#define S32V234_MSCR_PJ10       138
+#define S32V234_MSCR_PJ11       139
+#define S32V234_MSCR_PJ12       140
+#define S32V234_MSCR_PJ13       141
+#define S32V234_MSCR_PJ14       142
+#define S32V234_MSCR_PJ15       143
+#define S32V234_MSCR_PK0        144
+#define S32V234_MSCR_PK1        145
+#define S32V234_MSCR_PK2        146
+#define S32V234_MSCR_PK3        147
+#define S32V234_MSCR_PK4        148
+#define S32V234_MSCR_PK5        149
+#define S32V234_MSCR_PK6        150
+#define S32V234_MSCR_PK7        151
+#define S32V234_MSCR_PK8        152
+#define S32V234_MSCR_PK9        153
+#define S32V234_MSCR_PK10       154
+#define S32V234_MSCR_PK11       155
+#define S32V234_MSCR_PK12       156
+#define S32V234_MSCR_PK13       157
+#define S32V234_MSCR_PK14       158
+#define S32V234_MSCR_PK15       159
+#define S32V234_MSCR_PL0        160
+#define S32V234_MSCR_PL1        161
+#define S32V234_MSCR_PL2        162
+#define S32V234_MSCR_PL3        163
+#define S32V234_MSCR_PL4        164
+#define S32V234_MSCR_PL5        165
+#define S32V234_MSCR_PL8        166
+
+#define S32V234_IMCR_FlexTimer0_CH0    512
+#define S32V234_IMCR_FlexTimer0_CH1    513
+#define S32V234_IMCR_FlexTimer0_CH2    514
+#define S32V234_IMCR_FlexTimer0_CH3    515
+#define S32V234_IMCR_FlexTimer0_CH4    516
+#define S32V234_IMCR_FlexTimer0_CH5    517
+#define S32V234_IMCR_FlexTimer0_EXTCLK 520
+#define S32V234_IMCR_FlexTimer1_CH0    521
+#define S32V234_IMCR_FlexTimer1_CH1    522
+#define S32V234_IMCR_FlexTimer1_CH2    523
+#define S32V234_IMCR_FlexTimer1_CH3    524
+#define S32V234_IMCR_FlexTimer1_CH4    525
+#define S32V234_IMCR_FlexTimer1_CH5    526
+#define S32V234_IMCR_FlexTimer1_EXTCLK 529
+#define S32V234_IMCR_LFAST_REF_CLK     550
+#define S32V234_IMCR_BOOT_BOOTMOD0     570
+#define S32V234_IMCR_BOOT_BOOTMOD1     571
+#define S32V234_IMCR_SIUL_EIRQ0        590
+#define S32V234_IMCR_SIUL_EIRQ1        591
+#define S32V234_IMCR_SIUL_EIRQ2        592
+#define S32V234_IMCR_SIUL_EIRQ3        593
+#define S32V234_IMCR_SIUL_EIRQ4        594
+#define S32V234_IMCR_SIUL_EIRQ5        595
+#define S32V234_IMCR_SIUL_EIRQ6        596
+#define S32V234_IMCR_SIUL_EIRQ7        597
+#define S32V234_IMCR_SIUL_EIRQ8        598
+#define S32V234_IMCR_SIUL_EIRQ9        599
+#define S32V234_IMCR_SIUL_EIRQ10       600
+#define S32V234_IMCR_SIUL_EIRQ11       601
+#define S32V234_IMCR_SIUL_EIRQ12       602
+#define S32V234_IMCR_SIUL_EIRQ13       603
+#define S32V234_IMCR_SIUL_EIRQ14       604
+#define S32V234_IMCR_SIUL_EIRQ15       605
+#define S32V234_IMCR_SIUL_EIRQ16       606
+#define S32V234_IMCR_SIUL_EIRQ17       607
+#define S32V234_IMCR_SIUL_EIRQ18       608
+#define S32V234_IMCR_SIUL_EIRQ19       609
+#define S32V234_IMCR_SIUL_EIRQ20       610
+#define S32V234_IMCR_SIUL_EIRQ21       611
+#define S32V234_IMCR_SIUL_EIRQ22       612
+#define S32V234_IMCR_SIUL_EIRQ23       613
+#define S32V234_IMCR_SIUL_EIRQ24       614
+#define S32V234_IMCR_SIUL_EIRQ25       615
+#define S32V234_IMCR_SIUL_EIRQ26       616
+#define S32V234_IMCR_SIUL_EIRQ27       617
+#define S32V234_IMCR_SIUL_EIRQ28       618
+#define S32V234_IMCR_SIUL_EIRQ29       619
+#define S32V234_IMCR_SIUL_EIRQ30       620
+#define S32V234_IMCR_SIUL_EIRQ31       621
+#define S32V234_IMCR_VIU0_HSYNC        622
+#define S32V234_IMCR_VIU0_VSYNC        623
+#define S32V234_IMCR_VIU0_PCLK         624
+#define S32V234_IMCR_VIU0_D4           629
+#define S32V234_IMCR_VIU0_D5           630
+#define S32V234_IMCR_VIU0_D6           631
+#define S32V234_IMCR_VIU0_D7           632
+#define S32V234_IMCR_VIU0_D8           633
+#define S32V234_IMCR_VIU0_D9           634
+#define S32V234_IMCR_VIU0_D10          635
+#define S32V234_IMCR_VIU0_D11          636
+#define S32V234_IMCR_VIU0_D12          637
+#define S32V234_IMCR_VIU0_D13          638
+#define S32V234_IMCR_VIU0_D14          639
+#define S32V234_IMCR_VIU0_D15          640
+#define S32V234_IMCR_VIU0_D16          641
+#define S32V234_IMCR_VIU0_D17          642
+#define S32V234_IMCR_VIU0_D18          643
+#define S32V234_IMCR_VIU0_D19          644
+#define S32V234_IMCR_VIU0_D20          645
+#define S32V234_IMCR_VIU0_D21          646
+#define S32V234_IMCR_VIU0_D22          647
+#define S32V234_IMCR_VIU0_D23          648
+#define S32V234_IMCR_VIU1_HSYNC        657
+#define S32V234_IMCR_VIU1_VSYNC        658
+#define S32V234_IMCR_VIU1_PCLK         659
+#define S32V234_IMCR_VIU1_D8           668
+#define S32V234_IMCR_VIU1_D9           669
+#define S32V234_IMCR_VIU1_D10          670
+#define S32V234_IMCR_VIU1_D11          671
+#define S32V234_IMCR_VIU1_D12          672
+#define S32V234_IMCR_VIU1_D13          673
+#define S32V234_IMCR_VIU1_D14          674
+#define S32V234_IMCR_VIU1_D15          675
+#define S32V234_IMCR_VIU1_D16          676
+#define S32V234_IMCR_VIU1_D17          677
+#define S32V234_IMCR_VIU1_D18          678
+#define S32V234_IMCR_VIU1_D19          679
+#define S32V234_IMCR_VIU1_D20          680
+#define S32V234_IMCR_VIU1_D21          681
+#define S32V234_IMCR_VIU1_D22          682
+#define S32V234_IMCR_VIU1_D23          683
+#define S32V234_IMCR_CAN_FD0_RXD       700
+#define S32V234_IMCR_CAN_FD1_RXD       701
+#define S32V234_IMCR_UART0_RXD         712
+#define S32V234_IMCR_UART1_RXD         714
+#define S32V234_IMCR_IIC0_CLK          780
+#define S32V234_IMCR_IIC0_DATA         781
+#define S32V234_IMCR_IIC1_CLK          782
+#define S32V234_IMCR_IIC1_DATA         783
+#define S32V234_IMCR_IIC2_CLK          784
+#define S32V234_IMCR_IIC2_DATA         785
+#define S32V234_IMCR_SPI0_SIN          800
+#define S32V234_IMCR_SPI0_SCK          801
+#define S32V234_IMCR_SPI0_CS0          802
+#define S32V234_IMCR_SPI1_SIN          803
+#define S32V234_IMCR_SPI1_SCK          804
+#define S32V234_IMCR_SPI1_CS0          805
+#define S32V234_IMCR_SPI2_SIN          806
+#define S32V234_IMCR_SPI2_SCK          807
+#define S32V234_IMCR_SPI2_CS0          808
+#define S32V234_IMCR_SPI3_SIN          809
+#define S32V234_IMCR_SPI3_SCK          810
+#define S32V234_IMCR_SPI3_CS0          811
+#define S32V234_IMCR_QSPI_A_DQS        819
+#define S32V234_IMCR_QSPI_A_DATA0      820
+#define S32V234_IMCR_QSPI_A_DATA1      821
+#define S32V234_IMCR_QSPI_A_DATA2      822
+#define S32V234_IMCR_QSPI_A_DATA3      823
+#define S32V234_IMCR_QSPI_A_DATA4      824
+#define S32V234_IMCR_QSPI_A_DATA5      825
+#define S32V234_IMCR_QSPI_A_DATA6      826
+#define S32V234_IMCR_QSPI_A_DATA7      827
+#define S32V234_IMCR_QSPI_B_DQS        828
+#define S32V234_IMCR_QSPI_B_DATA0      829
+#define S32V234_IMCR_QSPI_B_DATA1      830
+#define S32V234_IMCR_QSPI_B_DATA2      831
+#define S32V234_IMCR_QSPI_B_DATA3      832
+#define S32V234_IMCR_USDHC_WP          900
+#define S32V234_IMCR_USDHC_CMD         901
+#define S32V234_IMCR_USDHC_CLK         902
+#define S32V234_IMCR_USDHC_DAT0        903
+#define S32V234_IMCR_USDHC_DAT1        904
+#define S32V234_IMCR_USDHC_DAT2        905
+#define S32V234_IMCR_USDHC_DAT3        906
+#define S32V234_IMCR_USDHC_DAT4        907
+#define S32V234_IMCR_USDHC_DAT5        908
+#define S32V234_IMCR_USDHC_DAT6        909
+#define S32V234_IMCR_USDHC_DAT7        910
+#define S32V234_IMCR_Ethernet_RX_ER    970
+#define S32V234_IMCR_Ethernet_COL      971
+#define S32V234_IMCR_Ethernet_CRS      972
+#define S32V234_IMCR_Ethernet_RX_DV    973
+#define S32V234_IMCR_Ethernet_RX_D0    974
+#define S32V234_IMCR_Ethernet_RX_D1    975
+#define S32V234_IMCR_Ethernet_RX_D2    976
+#define S32V234_IMCR_Ethernet_RX_D3    977
+#define S32V234_IMCR_Ethernet_TX_CLK   978
+#define S32V234_IMCR_Ethernet_RX_CLK   979
+#define S32V234_IMCR_Ethernet_MDIO     981
+#define S32V234_IMCR_Ethernet_TIMER0   982
+#define S32V234_IMCR_Ethernet_TIMER1   983
+#define S32V234_IMCR_Ethernet_TIMER2   984
+#define S32V234_IMCR_FlexRay_CA_RX     1012
+#define S32V234_IMCR_FlexRay_CB_RX     1013
+#define S32V234_IMCR_SSE_IN0           1018
+#define S32V234_IMCR_SSE_IN1           1019
+#define S32V234_IMCR_SSE_IN2           1020
+#define S32V234_IMCR_SSE_IN3           1021
+
+/* Format of pins: MSCR_IDX PAD_CONFIGURATION If you know the IMCR_IDX
+ * instead of MSCR_IDX, add 512 to it as the Reference Manual states.
+ */
+
+/* UART configuration */
+#define S32V234_PAD_PA12__UART0_TXD     S32V234_MSCR_PA12 PAD_CTL_UART_TX
+#define S32V234_PAD_PA11__UART0_RXD_OUT S32V234_MSCR_PA11 PAD_CTL_UART_RX_MSCR
+#define S32V234_PAD_PA11__UART0_RXD_IN  S32V234_IMCR_UART0_RXD \
+					PAD_CTL_UART_RX_IMCR
+
+#define S32V234_PAD_PA14__UART1_TXD     S32V234_MSCR_PA14 PAD_CTL_UART_TX
+#define S32V234_PAD_PA13__UART1_RXD_OUT S32V234_MSCR_PA13 PAD_CTL_UART_RX_MSCR
+#define S32V234_PAD_PA13__UART1_RXD_IN  S32V234_IMCR_UART1_RXD \
+					PAD_CTL_UART_RX_IMCR
+
+/* CAN0 configuration */
+#define S32V234_PAD_PA2__CAN_FD0_TXD     S32V234_MSCR_PA2 PAD_CTL_CAN_FD0_TX
+#define S32V234_PAD_PA3__CAN_FD0_RXD_OUT S32V234_MSCR_PA3 \
+					 PAD_CTL_CAN_FD0_RX_MSCR
+#define S32V234_PAD_PA3__CAN_FD0_RXD_IN  S32V234_IMCR_CAN_FD0_RXD \
+					 PAD_CTL_CAN_FD0_RX_IMCR
+
+/* CAN1 configuration */
+#define S32V234_PAD_PA4__CAN_FD1_TXD     S32V234_MSCR_PA4 PAD_CTL_CAN_FD1_TX
+#define S32V234_PAD_PA5__CAN_FD1_RXD_OUT S32V234_MSCR_PA5 \
+					 PAD_CTL_CAN_FD1_RX_MSCR
+#define S32V234_PAD_PA5__CAN_FD1_RXD_IN  S32V234_IMCR_CAN_FD1_RXD \
+					 PAD_CTL_CAN_FD1_RX_IMCR
+
+/* uSDHC configuration */
+#define S32V234_PAD_PK6__USDHC_CLK_OUT   S32V234_MSCR_PK6 PAD_CTL_USDHC_CLK
+#define S32V234_PAD_PK6__USDHC_CLK_IN    S32V234_IMCR_USDHC_CLK \
+					 PAD_CTL_MUX_MODE_ALT3
+
+#define S32V234_PAD_PK7__USDHC_CMD_OUT   S32V234_MSCR_PK7 PAD_CTL_USDHC_CMD
+#define S32V234_PAD_PK7__USDHC_CMD_IN    S32V234_IMCR_USDHC_CMD \
+					 PAD_CTL_MUX_MODE_ALT3
+
+#define S32V234_PAD_PK8__USDHC_DAT0_OUT  S32V234_MSCR_PK8 PAD_CTL_USDHC_DAT0_3
+#define S32V234_PAD_PK8__USDHC_DAT0_IN   S32V234_IMCR_USDHC_DAT0 \
+					 PAD_CTL_MUX_MODE_ALT3
+
+#define S32V234_PAD_PK9__USDHC_DAT1_OUT  S32V234_MSCR_PK9 PAD_CTL_USDHC_DAT0_3
+#define S32V234_PAD_PK9__USDHC_DAT1_IN   S32V234_IMCR_USDHC_DAT1 \
+					 PAD_CTL_MUX_MODE_ALT3
+
+#define S32V234_PAD_PK10__USDHC_DAT2_OUT S32V234_MSCR_PK10 PAD_CTL_USDHC_DAT0_3
+#define S32V234_PAD_PK10__USDHC_DAT2_IN  S32V234_IMCR_USDHC_DAT2 \
+					 PAD_CTL_MUX_MODE_ALT3
+
+#define S32V234_PAD_PK11__USDHC_DAT3_OUT S32V234_MSCR_PK11 PAD_CTL_USDHC_DAT0_3
+#define S32V234_PAD_PK11__USDHC_DAT3_IN  S32V234_IMCR_USDHC_DAT3 \
+					 PAD_CTL_MUX_MODE_ALT3
+
+#define S32V234_PAD_PK15__USDHC_DAT4_OUT S32V234_MSCR_PK15 PAD_CTL_USDHC_DAT4_7
+#define S32V234_PAD_PK15__USDHC_DAT4_IN  S32V234_IMCR_USDHC_DAT4 \
+					 PAD_CTL_MUX_MODE_ALT3
+
+#define S32V234_PAD_PL0__USDHC_DAT5_OUT  S32V234_MSCR_PL0 PAD_CTL_USDHC_DAT4_7
+#define S32V234_PAD_PL0__USDHC_DAT5_IN   S32V234_IMCR_USDHC_DAT5 \
+					 PAD_CTL_MUX_MODE_ALT3
+
+#define S32V234_PAD_PL1__USDHC_DAT6_OUT  S32V234_MSCR_PL1 PAD_CTL_USDHC_DAT4_7
+#define S32V234_PAD_PL1__USDHC_DAT6_IN   S32V234_IMCR_USDHC_DAT6 \
+					 PAD_CTL_MUX_MODE_ALT3
+
+#define S32V234_PAD_PL2__USDHC_DAT7_OUT  S32V234_MSCR_PL2 PAD_CTL_USDHC_DAT4_7
+#define S32V234_PAD_PL2__USDHC_DAT7_IN   S32V234_IMCR_USDHC_DAT7 \
+					 PAD_CTL_MUX_MODE_ALT3
+
+/* QSPI configuration */
+#define S32V234_PAD_PK7__QSPI_A_DQS        S32V234_IMCR_QSPI_A_DQS \
+					   PAD_CTL_MUX_MODE_ALT2
+#define S32V234_PAD_PK14__QSPI_B_DQS       S32V234_IMCR_QSPI_B_DQS \
+					   PAD_CTL_MUX_MODE_ALT2
+
+#define S32V234_PAD_PK8__QSPI_A_DATA0_IN   S32V234_IMCR_QSPI_A_DATA0 \
+					   PAD_CTL_MUX_MODE_ALT2
+#define S32V234_PAD_PK8__QSPI_A_DATA0_OUT  S32V234_MSCR_PK8 \
+					   PAD_CTL_QSPI_A_DATA0_3
+
+#define S32V234_PAD_PK9__QSPI_A_DATA1_IN   S32V234_IMCR_QSPI_A_DATA1 \
+					   PAD_CTL_MUX_MODE_ALT2
+#define S32V234_PAD_PK9__QSPI_A_DATA1_OUT  S32V234_MSCR_PK9 \
+					   PAD_CTL_QSPI_A_DATA0_3
+
+#define S32V234_PAD_PK10__QSPI_A_DATA2_IN  S32V234_IMCR_QSPI_A_DATA2 \
+					   PAD_CTL_MUX_MODE_ALT2
+#define S32V234_PAD_PK10__QSPI_A_DATA2_OUT S32V234_MSCR_PK10 \
+					   PAD_CTL_QSPI_A_DATA0_3
+
+#define S32V234_PAD_PK11__QSPI_A_DATA3_IN  S32V234_IMCR_QSPI_A_DATA3 \
+					   PAD_CTL_MUX_MODE_ALT2
+#define S32V234_PAD_PK11__QSPI_A_DATA3_OUT S32V234_MSCR_PK11 \
+					   PAD_CTL_QSPI_A_DATA0_3
+
+#define S32V234_PAD_PK15__QSPI_A_DATA4_IN  S32V234_IMCR_QSPI_A_DATA4 \
+					   PAD_CTL_MUX_MODE_ALT2
+#define S32V234_PAD_PK15__QSPI_A_DATA4_OUT S32V234_MSCR_PK15 \
+					   PAD_CTL_QSPI_A_DATA4_7
+
+#define S32V234_PAD_PL0__QSPI_A_DATA5_IN   S32V234_IMCR_QSPI_A_DATA5 \
+					   PAD_CTL_MUX_MODE_ALT2
+#define S32V234_PAD_PL0__QSPI_A_DATA5_OUT  S32V234_MSCR_PL0 \
+					   PAD_CTL_QSPI_A_DATA4_7
+
+#define S32V234_PAD_PL1__QSPI_A_DATA6_IN   S32V234_IMCR_QSPI_A_DATA6 \
+					   PAD_CTL_MUX_MODE_ALT2
+#define S32V234_PAD_PL1__QSPI_A_DATA6_OUT  S32V234_MSCR_PL1 \
+					   PAD_CTL_QSPI_A_DATA4_7
+
+#define S32V234_PAD_PL2__QSPI_A_DATA7_IN   S32V234_IMCR_QSPI_A_DATA7 \
+					   PAD_CTL_MUX_MODE_ALT2
+#define S32V234_PAD_PL2__QSPI_A_DATA7_OUT  S32V234_MSCR_PL2 \
+					   PAD_CTL_QSPI_A_DATA4_7
+
+#define S32V234_PAD_PK15__QSPI_B_DATA0_IN  S32V234_IMCR_QSPI_B_DATA0 \
+					   PAD_CTL_MUX_MODE_ALT2
+#define S32V234_PAD_PK15__QSPI_B_DATA0_OUT S32V234_MSCR_PK15 \
+					   PAD_CTL_QSPI_B_DATA0_3
+
+#define S32V234_PAD_PL0__QSPI_B_DATA1_IN   S32V234_IMCR_QSPI_B_DATA1 \
+					   PAD_CTL_MUX_MODE_ALT2
+#define S32V234_PAD_PL0__QSPI_B_DATA1_OUT  S32V234_MSCR_PL0 \
+					   PAD_CTL_QSPI_B_DATA0_3
+
+#define S32V234_PAD_PL1__QSPI_B_DATA2_IN   S32V234_IMCR_QSPI_B_DATA2 \
+					   PAD_CTL_MUX_MODE_ALT2
+#define S32V234_PAD_PL1__QSPI_B_DATA2_OUT  S32V234_MSCR_PL1 \
+					   PAD_CTL_QSPI_B_DATA0_3
+
+#define S32V234_PAD_PL2__QSPI_B_DATA3_IN   S32V234_IMCR_QSPI_B_DATA3 \
+					   PAD_CTL_MUX_MODE_ALT2
+#define S32V234_PAD_PL2__QSPI_B_DATA3_OUT  S32V234_MSCR_PL2 \
+					   PAD_CTL_QSPI_B_DATA0_3
+
+#define S32V234_PAD_PF12__QSPI_A_CS1       S32V234_MSCR_PF12 \
+					   (PAD_CTL_QSPI_CLK_BASE | \
+					   PAD_CTL_QSPI_A_CS1_MUX)
+#define S32V234_PAD_PF13__QSPI_B_CS1       S32V234_MSCR_PF13 \
+					   (PAD_CTL_QSPI_CLK_BASE | \
+					   PAD_CTL_QSPI_B_CS1_MUX)
+
+#define S32V234_PAD_PK5__QSPI_A_CS0        S32V234_MSCR_PK5 \
+					   (PAD_CTL_QSPI_CLK_BASE | \
+					   PAD_CTL_QSPI_A_CS0_MUX)
+#define S32V234_PAD_PK6__QSPI_A_SCK        S32V234_MSCR_PK6 \
+					   (PAD_CTL_QSPI_CLK_BASE | \
+					   PAD_CTL_QSPI_A_SCK_MUX)
+
+#define S32V234_PAD_PK12__QSPI_B_CS0       S32V234_MSCR_PK12 \
+					   (PAD_CTL_QSPI_CLK_BASE | \
+					   PAD_CTL_QSPI_B_CS0_MUX)
+#define S32V234_PAD_PK13__QSPI_B_SCK       S32V234_MSCR_PK13 \
+					   (PAD_CTL_QSPI_CLK_BASE | \
+					   PAD_CTL_QSPI_B_SCK_MUX)
+
+#define S32V234_PAD_PK13__QSPI_CK2         S32V234_MSCR_PK13 \
+					   (PAD_CTL_QSPI_CLK_BASE | \
+					   PAD_CTL_QSPI_CK2_MUX)
+
+/* I2C configuration */
+#define S32V234_PAD_PA15__I2C0_DATA_OUT S32V234_MSCR_PA15 \
+					PAD_CTL_I2C0_MSCR_SDA_PA15
+#define S32V234_PAD_PA15__I2C0_DATA_IN  S32V234_IMCR_IIC0_DATA \
+					PAD_CTL_I2C0_IMCR_SDA_PA15
+
+#define S32V234_PAD_PB0__I2C0_SCLK_OUT  S32V234_MSCR_PB0 \
+					PAD_CTL_I2C0_MSCR_SCLK_PB0
+#define S32V234_PAD_PB0__I2C0_SCLK_IN   S32V234_IMCR_IIC0_CLK \
+					PAD_CTL_I2C0_IMCR_SCLK_PB0
+
+#define S32V234_PAD_PG3__I2C0_DATA_OUT  S32V234_MSCR_PG3 \
+					PAD_CTL_I2C0_MSCR_SDA_PG3
+#define S32V234_PAD_PG3__I2C0_DATA_IN   S32V234_IMCR_IIC0_DATA \
+					PAD_CTL_I2C0_IMCR_SDA_PG3
+
+#define S32V234_PAD_PG4__I2C0_SCLK_OUT  S32V234_MSCR_PG4 \
+					PAD_CTL_I2C0_MSCR_SCLK_PG4
+#define S32V234_PAD_PG4__I2C0_SCLK_IN   S32V234_IMCR_IIC0_CLK \
+					PAD_CTL_I2C0_IMCR_SCLK_PG4
+
+#define S32V234_PAD_PG5__I2C1_DATA_OUT  S32V234_MSCR_PG5 \
+					PAD_CTL_I2C1_MSCR_SDA
+#define S32V234_PAD_PG5__I2C1_DATA_IN   S32V234_IMCR_IIC1_DATA \
+					PAD_CTL_I2C1_IMCR_SDA
+
+#define S32V234_PAD_PG6__I2C1_SCLK_OUT  S32V234_MSCR_PG6 \
+					PAD_CTL_I2C1_MSCR_SCLK
+#define S32V234_PAD_PG6__I2C1_SCLK_IN   S32V234_IMCR_IIC1_CLK \
+					PAD_CTL_I2C1_IMCR_SCLK
+
+#define S32V234_PAD_PB3__I2C2_DATA_OUT  S32V234_MSCR_PB3 \
+					PAD_CTL_I2C2_MSCR_SDA
+#define S32V234_PAD_PB3__I2C2_DATA_IN   S32V234_IMCR_IIC2_DATA \
+					PAD_CTL_I2C2_IMCR_SDA
+
+#define S32V234_PAD_PB4__I2C2_SCLK_OUT  S32V234_MSCR_PB4 \
+					PAD_CTL_I2C2_MSCR_SCLK
+#define S32V234_PAD_PB4__I2C2_SCLK_IN   S32V234_IMCR_IIC2_CLK \
+					PAD_CTL_I2C2_IMCR_SCLK
+
+/* ENET configuration */
+#define S32V234_PAD_PC13__MDC       S32V234_MSCR_PC13 PAD_CTL_ENET_CFG2
+
+#define S32V234_PAD_PC14__MDIO_OUT  S32V234_MSCR_PC14 PAD_CTL_ENET_CFG3
+#define S32v234_PAD_PC14__MDIO_IN   S32V234_IMCR_Ethernet_MDIO \
+				    PAD_CTL_MUX_MODE_ALT2
+
+#define S32V234_PAD_PC15__TXCLK_OUT S32V234_MSCR_PC15 PAD_CTL_ENET_CFG1
+#define S32V234_PAD_PC15__TXCLK_IN  S32V234_IMCR_Ethernet_TX_CLK \
+				    PAD_CTL_MUX_MODE_ALT2
+
+#define S32V234_PAD_PD0__RXCLK_OUT  S32V234_MSCR_PD0 PAD_CTL_ENET_CFG4
+#define S32V234_PAD_PD0__RXCLK_IN   S32V234_IMCR_Ethernet_RX_CLK \
+				    PAD_CTL_MUX_MODE_ALT2
+
+#define S32V234_PAD_PD1__RX_D0_OUT  S32V234_MSCR_PD1 PAD_CTL_ENET_CFG4
+#define S32V234_PAD_PD1__RX_D0_IN   S32V234_IMCR_Ethernet_RX_D0 \
+				    PAD_CTL_MUX_MODE_ALT2
+
+#define S32V234_PAD_PD2__RX_D1_OUT  S32V234_MSCR_PD2 PAD_CTL_ENET_CFG4
+#define S32V234_PAD_PD2__RX_D1_IN   S32V234_IMCR_Ethernet_RX_D1 \
+				    PAD_CTL_MUX_MODE_ALT2
+
+#define S32V234_PAD_PD3__RX_D2_OUT  S32V234_MSCR_PD3 PAD_CTL_ENET_CFG4
+#define S32V234_PAD_PD3__RX_D2_IN   S32V234_IMCR_Ethernet_RX_D2 \
+				    PAD_CTL_MUX_MODE_ALT2
+
+#define S32V234_PAD_PD4__RX_D3_OUT  S32V234_MSCR_PD4 PAD_CTL_ENET_CFG4
+#define S32V234_PAD_PD4__RX_D3_IN   S32V234_IMCR_Ethernet_RX_D3 \
+				    PAD_CTL_MUX_MODE_ALT2
+
+#define S32V234_PAD_PD4__RX_DV_OUT  S32V234_MSCR_PD5 PAD_CTL_ENET_CFG4
+#define S32V234_PAD_PD4__RX_DV_IN   S32V234_IMCR_Ethernet_RX_DV \
+				    PAD_CTL_MUX_MODE_ALT2
+
+#define S32V234_PAD_PD7__TX_D0_OUT  S32V234_MSCR_PD7  PAD_CTL_ENET_CFG2
+#define S32V234_PAD_PD8__TX_D1_OUT  S32V234_MSCR_PD8  PAD_CTL_ENET_CFG2
+#define S32V234_PAD_PD9__TX_D2_OUT  S32V234_MSCR_PD9  PAD_CTL_ENET_CFG2
+#define S32V234_PAD_PD10__TX_D3_OUT S32V234_MSCR_PD10 PAD_CTL_ENET_CFG2
+#define S32V234_PAD_PD11__TX_EN_OUT S32V234_MSCR_PD11 PAD_CTL_ENET_CFG2
+
+/* 2D ACE DCU */
+#define S32V234_PAD_PH8__DCU_HSYNC_C1 S32V234_MSCR_PH8  PAD_CTL_DCU_CFG
+#define S32V234_PAD_PH9__DCU_VSYNC_C2 S32V234_MSCR_PH9  PAD_CTL_DCU_CFG
+#define S32V234_PAD_PH10__DCU_DE_C3   S32V234_MSCR_PH10 PAD_CTL_DCU_CFG
+
+#define S32V234_PAD_PH12__DCU_PCLK_D1_DSE_DISABLE S32V234_MSCR_PH12 \
+					PAD_CTL_DCU_CLK_CFG_DSE_DISABLE
+#define S32V234_PAD_PH12__DCU_PCLK_D1_DSE_240     S32V234_MSCR_PH12 \
+					(PAD_CTL_DCU_CLK_CFG_DSE_DISABLE | \
+					PAD_CTL_DSE_240)
+#define S32V234_PAD_PH12__DCU_PCLK_D1_DSE_120     S32V234_MSCR_PH12 \
+					(PAD_CTL_DCU_CLK_CFG_DSE_DISABLE | \
+					PAD_CTL_DSE_120)
+#define S32V234_PAD_PH12__DCU_PCLK_D1_DSE_80      S32V234_MSCR_PH12 \
+					(PAD_CTL_DCU_CLK_CFG_DSE_DISABLE | \
+					PAD_CTL_DSE_80)
+#define S32V234_PAD_PH12__DCU_PCLK_D1_DSE_60      S32V234_MSCR_PH12 \
+					(PAD_CTL_DCU_CLK_CFG_DSE_DISABLE | \
+					PAD_CTL_DSE_60)
+#define S32V234_PAD_PH12__DCU_PCLK_D1_DSE_48      S32V234_MSCR_PH12 \
+					(PAD_CTL_DCU_CLK_CFG_DSE_DISABLE | \
+					PAD_CTL_DSE_48)
+#define S32V234_PAD_PH12__DCU_PCLK_D1_DSE_40      S32V234_MSCR_PH12 \
+					(PAD_CTL_DCU_CLK_CFG_DSE_DISABLE | \
+					PAD_CTL_DSE_40)
+#define S32V234_PAD_PH12__DCU_PCLK_D1_DSE_34      S32V234_MSCR_PH12 \
+					(PAD_CTL_DCU_CLK_CFG_DSE_DISABLE | \
+					PAD_CTL_DSE_34)
+
+#define S32V234_PAD_PH13__DCU_R0_D2  S32V234_MSCR_PH13 PAD_CTL_DCU_CFG
+#define S32V234_PAD_PH14__DCU_R1_D3  S32V234_MSCR_PH14 PAD_CTL_DCU_CFG
+#define S32V234_PAD_PH15__DCU_R2_D4  S32V234_MSCR_PH15 PAD_CTL_DCU_CFG
+#define S32V234_PAD_PJ0__DCU_R3_D5   S32V234_MSCR_PJ0  PAD_CTL_DCU_CFG
+#define S32V234_PAD_PJ1__DCU_R4_D6   S32V234_MSCR_PJ1  PAD_CTL_DCU_CFG
+#define S32V234_PAD_PJ2__DCU_R5_D7   S32V234_MSCR_PJ2  PAD_CTL_DCU_CFG
+#define S32V234_PAD_PJ3__DCU_R6_D8   S32V234_MSCR_PJ3  PAD_CTL_DCU_CFG
+#define S32V234_PAD_PJ4__DCU_R7_D9   S32V234_MSCR_PJ4  PAD_CTL_DCU_CFG
+
+#define S32V234_PAD_PJ5__DCU_G0_D10  S32V234_MSCR_PJ5  PAD_CTL_DCU_CFG
+#define S32V234_PAD_PJ6__DCU_G1_D11  S32V234_MSCR_PJ6  PAD_CTL_DCU_CFG
+#define S32V234_PAD_PJ7__DCU_G2_D12  S32V234_MSCR_PJ7  PAD_CTL_DCU_CFG
+#define S32V234_PAD_PJ8__DCU_G3_D13  S32V234_MSCR_PJ8  PAD_CTL_DCU_CFG
+#define S32V234_PAD_PJ9__DCU_G4_D14  S32V234_MSCR_PJ9  PAD_CTL_DCU_CFG
+#define S32V234_PAD_PJ10__DCU_G5_D15 S32V234_MSCR_PJ10 PAD_CTL_DCU_CFG
+#define S32V234_PAD_PJ11__DCU_G6_D16 S32V234_MSCR_PJ11 PAD_CTL_DCU_CFG
+#define S32V234_PAD_PJ12__DCU_G7_D17 S32V234_MSCR_PJ12 PAD_CTL_DCU_CFG
+
+#define S32V234_PAD_PJ13__DCU_B0_D18 S32V234_MSCR_PJ13 PAD_CTL_DCU_CFG
+#define S32V234_PAD_PJ14__DCU_B1_D19 S32V234_MSCR_PJ14 PAD_CTL_DCU_CFG
+#define S32V234_PAD_PJ15__DCU_B2_D20 S32V234_MSCR_PJ15 PAD_CTL_DCU_CFG
+#define S32V234_PAD_PK0__DCU_B3_D21  S32V234_MSCR_PK0  PAD_CTL_DCU_CFG
+#define S32V234_PAD_PK1__DCU_B4_D22  S32V234_MSCR_PK1  PAD_CTL_DCU_CFG
+#define S32V234_PAD_PK2__DCU_B5_D23  S32V234_MSCR_PK2  PAD_CTL_DCU_CFG
+#define S32V234_PAD_PK3__DCU_B6_D24  S32V234_MSCR_PK3  PAD_CTL_DCU_CFG
+#define S32V234_PAD_PK4__DCU_B7_D25  S32V234_MSCR_PK4  PAD_CTL_DCU_CFG
+
+/* VIULite0 */
+#define S32V234_PAD_PD13__VIU0_EN    S32V234_MSCR_PD13       PAD_CTL_VIU_IBE
+#define S32V234_PAD_PD13__VIU0_PCLK  S32V234_IMCR_VIU0_PCLK  PAD_CTL_VIU_CFG
+#define S32V234_PAD_PD14__VIU0_EN    S32V234_MSCR_PD14       PAD_CTL_VIU_IBE
+#define S32V234_PAD_PD14__VIU0_HSYNC S32V234_IMCR_VIU0_HSYNC PAD_CTL_VIU_CFG
+#define S32V234_PAD_PD15__VIU0_EN    S32V234_MSCR_PD15       PAD_CTL_VIU_IBE
+#define S32V234_PAD_PD15__VIU0_VSYNC S32V234_IMCR_VIU0_VSYNC PAD_CTL_VIU_CFG
+
+#define S32V234_PAD_PF3__VIU_EN      S32V234_MSCR_PF3        PAD_CTL_VIU_IBE
+#define S32V234_PAD_PF3__VIU0_D4     S32V234_IMCR_VIU0_D4    PAD_CTL_VIU_CFG
+#define S32V234_PAD_PF4__VIU_EN      S32V234_MSCR_PF4        PAD_CTL_VIU_IBE
+#define S32V234_PAD_PF4__VIU0_D5     S32V234_IMCR_VIU0_D5    PAD_CTL_VIU_CFG
+#define S32V234_PAD_PF5__VIU_EN      S32V234_MSCR_PF5        PAD_CTL_VIU_IBE
+#define S32V234_PAD_PF5__VIU0_D6     S32V234_IMCR_VIU0_D6    PAD_CTL_VIU_CFG
+#define S32V234_PAD_PF6__VIU_EN      S32V234_MSCR_PF6        PAD_CTL_VIU_IBE
+#define S32V234_PAD_PF6__VIU0_D7     S32V234_IMCR_VIU0_D7    PAD_CTL_VIU_CFG
+#define S32V234_PAD_PE0__VIU0_EN     S32V234_MSCR_PE0        PAD_CTL_VIU_IBE
+#define S32V234_PAD_PE0__VIU0_D8     S32V234_IMCR_VIU0_D8    PAD_CTL_VIU_CFG
+#define S32V234_PAD_PE1__VIU0_EN     S32V234_MSCR_PE1        PAD_CTL_VIU_IBE
+#define S32V234_PAD_PE1__VIU0_D9     S32V234_IMCR_VIU0_D9    PAD_CTL_VIU_CFG
+#define S32V234_PAD_PE2__VIU0_EN     S32V234_MSCR_PE2        PAD_CTL_VIU_IBE
+#define S32V234_PAD_PE2__VIU0_D10    S32V234_IMCR_VIU0_D10   PAD_CTL_VIU_CFG
+#define S32V234_PAD_PE3__VIU0_EN     S32V234_MSCR_PE3        PAD_CTL_VIU_IBE
+#define S32V234_PAD_PE3__VIU0_D11    S32V234_IMCR_VIU0_D11   PAD_CTL_VIU_CFG
+#define S32V234_PAD_PE4__VIU0_EN     S32V234_MSCR_PE4        PAD_CTL_VIU_IBE
+#define S32V234_PAD_PE4__VIU0_D12    S32V234_IMCR_VIU0_D12   PAD_CTL_VIU_CFG
+#define S32V234_PAD_PE5__VIU0_EN     S32V234_MSCR_PE5        PAD_CTL_VIU_IBE
+#define S32V234_PAD_PE5__VIU0_D13    S32V234_IMCR_VIU0_D13   PAD_CTL_VIU_CFG
+#define S32V234_PAD_PE6__VIU0_EN     S32V234_MSCR_PE6        PAD_CTL_VIU_IBE
+#define S32V234_PAD_PE6__VIU0_D14    S32V234_IMCR_VIU0_D14   PAD_CTL_VIU_CFG
+#define S32V234_PAD_PE7__VIU0_EN     S32V234_MSCR_PE7        PAD_CTL_VIU_IBE
+#define S32V234_PAD_PE7__VIU0_D15    S32V234_IMCR_VIU0_D15   PAD_CTL_VIU_CFG
+#define S32V234_PAD_PE8__VIU0_EN     S32V234_MSCR_PE8        PAD_CTL_VIU_IBE
+#define S32V234_PAD_PE8__VIU0_D16    S32V234_IMCR_VIU0_D16   PAD_CTL_VIU_CFG
+#define S32V234_PAD_PE9__VIU0_EN     S32V234_MSCR_PE9        PAD_CTL_VIU_IBE
+#define S32V234_PAD_PE9__VIU0_D17    S32V234_IMCR_VIU0_D17   PAD_CTL_VIU_CFG
+#define S32V234_PAD_PE10__VIU0_EN    S32V234_MSCR_PE10       PAD_CTL_VIU_IBE
+#define S32V234_PAD_PE10__VIU0_D18   S32V234_IMCR_VIU0_D18   PAD_CTL_VIU_CFG
+#define S32V234_PAD_PE11__VIU0_EN    S32V234_MSCR_PE11       PAD_CTL_VIU_IBE
+#define S32V234_PAD_PE11__VIU0_D19   S32V234_IMCR_VIU0_D19   PAD_CTL_VIU_CFG
+#define S32V234_PAD_PE12__VIU0_EN    S32V234_MSCR_PE12       PAD_CTL_VIU_IBE
+#define S32V234_PAD_PE12__VIU0_D20   S32V234_IMCR_VIU0_D20   PAD_CTL_VIU_CFG
+#define S32V234_PAD_PE13__VIU0_EN    S32V234_MSCR_PE13       PAD_CTL_VIU_IBE
+#define S32V234_PAD_PE13__VIU0_D21   S32V234_IMCR_VIU0_D21   PAD_CTL_VIU_CFG
+#define S32V234_PAD_PE14__VIU0_EN    S32V234_MSCR_PE14       PAD_CTL_VIU_IBE
+#define S32V234_PAD_PE14__VIU0_D22   S32V234_IMCR_VIU0_D22   PAD_CTL_VIU_CFG
+#define S32V234_PAD_PE15__VIU0_EN    S32V234_MSCR_PE15       PAD_CTL_VIU_IBE
+#define S32V234_PAD_PE15__VIU0_D23   S32V234_IMCR_VIU0_D23   PAD_CTL_VIU_CFG
+
+/* VIULite1 */
+#define S32V234_PAD_PF0__VIU1_EN    S32V234_MSCR_PF0        PAD_CTL_VIU_IBE
+#define S32V234_PAD_PF0__VIU1_PCLK  S32V234_IMCR_VIU1_PCLK  PAD_CTL_VIU_CFG
+#define S32V234_PAD_PF1__VIU1_EN    S32V234_MSCR_PF1        PAD_CTL_VIU_IBE
+#define S32V234_PAD_PF1__VIU1_HSYNC S32V234_IMCR_VIU1_HSYNC PAD_CTL_VIU_CFG
+#define S32V234_PAD_PF2__VIU1_EN    S32V234_MSCR_PF2        PAD_CTL_VIU_IBE
+#define S32V234_PAD_PF2__VIU1_VSYNC S32V234_IMCR_VIU1_VSYNC PAD_CTL_VIU_CFG
+
+#define S32V234_PAD_PF3__VIU_EN     S32V234_MSCR_PF3        PAD_CTL_VIU_IBE
+#define S32V234_PAD_PF3__VIU1_D8    S32V234_IMCR_VIU1_D8    PAD_CTL_VIU_CFG
+#define S32V234_PAD_PF4__VIU_EN     S32V234_MSCR_PF4        PAD_CTL_VIU_IBE
+#define S32V234_PAD_PF4__VIU1_D9    S32V234_IMCR_VIU1_D9    PAD_CTL_VIU_CFG
+#define S32V234_PAD_PF5__VIU_EN     S32V234_MSCR_PF5        PAD_CTL_VIU_IBE
+#define S32V234_PAD_PF5__VIU1_D10   S32V234_IMCR_VIU1_D10   PAD_CTL_VIU_CFG
+#define S32V234_PAD_PF6__VIU_EN     S32V234_MSCR_PF6        PAD_CTL_VIU_IBE
+#define S32V234_PAD_PF6__VIU1_D11   S32V234_IMCR_VIU1_D11   PAD_CTL_VIU_CFG
+#define S32V234_PAD_PF7__VIU1_EN    S32V234_MSCR_PF7        PAD_CTL_VIU_IBE
+#define S32V234_PAD_PF7__VIU1_D12   S32V234_IMCR_VIU1_D12   PAD_CTL_VIU_CFG
+#define S32V234_PAD_PF8__VIU1_EN    S32V234_MSCR_PF8        PAD_CTL_VIU_IBE
+#define S32V234_PAD_PF8__VIU1_D13   S32V234_IMCR_VIU1_D13   PAD_CTL_VIU_CFG
+#define S32V234_PAD_PF9__VIU1_EN    S32V234_MSCR_PF9        PAD_CTL_VIU_IBE
+#define S32V234_PAD_PF9__VIU1_D14   S32V234_IMCR_VIU1_D14   PAD_CTL_VIU_CFG
+#define S32V234_PAD_PF10__VIU1_EN   S32V234_MSCR_PF10       PAD_CTL_VIU_IBE
+#define S32V234_PAD_PF10__VIU1_D15  S32V234_IMCR_VIU1_D15   PAD_CTL_VIU_CFG
+#define S32V234_PAD_PF11__VIU1_EN   S32V234_MSCR_PF11       PAD_CTL_VIU_IBE
+#define S32V234_PAD_PF11__VIU1_D16  S32V234_IMCR_VIU1_D16   PAD_CTL_VIU_CFG
+#define S32V234_PAD_PF12__VIU1_EN   S32V234_MSCR_PF12       PAD_CTL_VIU_IBE
+#define S32V234_PAD_PF12__VIU1_D17  S32V234_IMCR_VIU1_D17   PAD_CTL_VIU_CFG
+#define S32V234_PAD_PF13__VIU1_EN   S32V234_MSCR_PF13       PAD_CTL_VIU_IBE
+#define S32V234_PAD_PF13__VIU1_D18  S32V234_IMCR_VIU1_D18   PAD_CTL_VIU_CFG
+#define S32V234_PAD_PF14__VIU1_EN   S32V234_MSCR_PF14       PAD_CTL_VIU_IBE
+#define S32V234_PAD_PF14__VIU1_D19  S32V234_IMCR_VIU1_D19   PAD_CTL_VIU_CFG
+#define S32V234_PAD_PF15__VIU1_EN   S32V234_MSCR_PF15       PAD_CTL_VIU_IBE
+#define S32V234_PAD_PF15__VIU1_D20  S32V234_IMCR_VIU1_D20   PAD_CTL_VIU_CFG
+#define S32V234_PAD_PG0__VIU1_EN    S32V234_MSCR_PG0        PAD_CTL_VIU_IBE
+#define S32V234_PAD_PG0__VIU1_D21   S32V234_IMCR_VIU1_D21   PAD_CTL_VIU_CFG
+#define S32V234_PAD_PG1__VIU1_EN    S32V234_MSCR_PG1        PAD_CTL_VIU_IBE
+#define S32V234_PAD_PG1__VIU1_D22   S32V234_IMCR_VIU1_D22   PAD_CTL_VIU_CFG
+#define S32V234_PAD_PG2__VIU1_EN    S32V234_MSCR_PG2        PAD_CTL_VIU_IBE
+#define S32V234_PAD_PG2__VIU1_D23   S32V234_IMCR_VIU1_D23   PAD_CTL_VIU_CFG
+
+/* SPI 0-3 */
+#define S32V234_PAD_PB6__SPI0_SOUT_OUT  S32V234_MSCR_PB6 PAD_CTL_SPI_MSCR_SOUT
+#define S32V234_PAD_PB7__SPI0_SIN_OUT   S32V234_MSCR_PB7 PAD_CTL_SPI_MSCR_SIN
+#define S32V234_PAD_PB7__SPI0_SIN_IN    S32V234_IMCR_SPI0_SIN \
+					PAD_CTL_SPI_IMCR_SIN
+#define S32V234_PAD_PB5__SPI0_SCK_OUT   S32V234_MSCR_PB5 PAD_CTL_SPI_MSCR_SCK
+#define S32V234_PAD_PB8__SPI0_CS0_OUT   S32V234_MSCR_PB8 \
+					(PAD_CTL_SPI_MSCR_CSx | \
+					PAD_CTL_MUX_MODE_ALT1)
+#define S32V234_PAD_PC0__SPI0_CS4_OUT   S32V234_MSCR_PC0 \
+					(PAD_CTL_SPI_MSCR_CSx | \
+					PAD_CTL_MUX_MODE_ALT3)
+#define S32V234_PAD_PC1__SPI0_CS5_OUT   S32V234_MSCR_PC1 \
+					(PAD_CTL_SPI_MSCR_CSx | \
+					PAD_CTL_MUX_MODE_ALT3)
+#define S32V234_PAD_PC2__SPI0_CS6_OUT   S32V234_MSCR_PC2 \
+					(PAD_CTL_SPI_MSCR_CSx | \
+					PAD_CTL_MUX_MODE_ALT3)
+#define S32V234_PAD_PC3__SPI0_CS7_OUT   S32V234_MSCR_PC3 \
+					(PAD_CTL_SPI_MSCR_CSx | \
+					PAD_CTL_MUX_MODE_ALT2)
+
+#define S32V234_PAD_PB10__SPI1_SOUT_OUT S32V234_MSCR_PB10 PAD_CTL_SPI_MSCR_SOUT
+#define S32V234_PAD_PB11__SPI1_SIN_OUT  S32V234_MSCR_PB11 PAD_CTL_SPI_MSCR_SIN
+#define S32V234_PAD_PB11__SPI1_SIN_IN   S32V234_IMCR_SPI1_SIN \
+					PAD_CTL_SPI_IMCR_SIN
+#define S32V234_PAD_PB9__SPI1_SCK_OUT   S32V234_MSCR_PB9 PAD_CTL_SPI_MSCR_SCK
+#define S32V234_PAD_PB12__SPI1_CS0_OUT  S32V234_MSCR_PB12 \
+					(PAD_CTL_SPI_MSCR_CSx | \
+					PAD_CTL_MUX_MODE_ALT1)
+
+#define S32V234_PAD_PB14__SPI2_SOUT_OUT S32V234_MSCR_PB14 PAD_CTL_SPI_MSCR_SOUT
+#define S32V234_PAD_PB15__SPI2_SIN_OUT  S32V234_MSCR_PB15 PAD_CTL_SPI_MSCR_SIN
+#define S32V234_PAD_PB15__SPI2_SIN_IN   S32V234_IMCR_SPI2_SIN \
+					PAD_CTL_SPI_IMCR_SIN
+#define S32V234_PAD_P13__SPI2_SCK_OUT   S32V234_MSCR_PB13 PAD_CTL_SPI_MSCR_SCK
+#define S32V234_PAD_PC0__SPI2_CS0_OUT   S32V234_MSCR_PC0 \
+					(PAD_CTL_SPI_MSCR_CSx | \
+					PAD_CTL_MUX_MODE_ALT1)
+
+#define S32V234_PAD_PC2__SPI3_SOUT_OUT  S32V234_MSCR_PC2 PAD_CTL_SPI_MSCR_SOUT
+#define S32V234_PAD_PC3__SPI3_SIN_OUT   S32V234_MSCR_PC3 PAD_CTL_SPI_MSCR_SIN
+#define S32V234_PAD_PC3__SPI3_SIN_IN    S32V234_IMCR_SPI3_SIN \
+					PAD_CTL_SPI_IMCR_SIN
+#define S32V234_PAD_PC1__SPI3_SCK_OUT   S32V234_MSCR_PC1 PAD_CTL_SPI_MSCR_SCK
+#define S32V234_PAD_PC4__SPI3_CS0_OUT   S32V234_MSCR_PC4 \
+					(PAD_CTL_SPI_MSCR_CSx | \
+					PAD_CTL_MUX_MODE_ALT1)
+
+/* SIUL2 GPIOs */
+#define S32V234_PAD_PA0__SIUL_GPIO0    S32V234_MSCR_PA0  PAD_CTL_MUX_MODE_ALT0
+#define S32V234_PAD_PA1__SIUL_GPIO1    S32V234_MSCR_PA1  PAD_CTL_MUX_MODE_ALT0
+#define S32V234_PAD_PA2__SIUL_GPIO2    S32V234_MSCR_PA2  PAD_CTL_MUX_MODE_ALT0
+#define S32V234_PAD_PA3__SIUL_GPIO3    S32V234_MSCR_PA3  PAD_CTL_MUX_MODE_ALT0
+#define S32V234_PAD_PA4__SIUL_GPIO4    S32V234_MSCR_PA4  PAD_CTL_MUX_MODE_ALT0
+#define S32V234_PAD_PA5__SIUL_GPIO5    S32V234_MSCR_PA5  PAD_CTL_MUX_MODE_ALT0
+#define S32V234_PAD_PA6__SIUL_GPIO6    S32V234_MSCR_PA6  PAD_CTL_MUX_MODE_ALT0
+#define S32V234_PAD_PA7__SIUL_GPIO7    S32V234_MSCR_PA7  PAD_CTL_MUX_MODE_ALT0
+#define S32V234_PAD_PA8__SIUL_GPIO8    S32V234_MSCR_PA8  PAD_CTL_MUX_MODE_ALT0
+#define S32V234_PAD_PA9__SIUL_GPIO9    S32V234_MSCR_PA9  PAD_CTL_MUX_MODE_ALT0
+#define S32V234_PAD_PA10__SIUL_GPIO10  S32V234_MSCR_PA10 PAD_CTL_MUX_MODE_ALT0
+#define S32V234_PAD_PA11__SIUL_GPIO11  S32V234_MSCR_PA11 PAD_CTL_MUX_MODE_ALT0
+#define S32V234_PAD_PA12__SIUL_GPIO12  S32V234_MSCR_PA12 PAD_CTL_MUX_MODE_ALT0
+#define S32V234_PAD_PA13__SIUL_GPIO13  S32V234_MSCR_PA13 PAD_CTL_MUX_MODE_ALT0
+#define S32V234_PAD_PA14__SIUL_GPIO14  S32V234_MSCR_PA14 PAD_CTL_MUX_MODE_ALT0
+#define S32V234_PAD_PA15__SIUL_GPIO15  S32V234_MSCR_PA15 PAD_CTL_MUX_MODE_ALT0
+#define S32V234_PAD_PB0__SIUL_GPIO16   S32V234_MSCR_PB0  PAD_CTL_MUX_MODE_ALT0
+#define S32V234_PAD_PB1__SIUL_GPIO17   S32V234_MSCR_PB1  PAD_CTL_MUX_MODE_ALT0
+#define S32V234_PAD_PB2__SIUL_GPIO18   S32V234_MSCR_PB2  PAD_CTL_MUX_MODE_ALT0
+#define S32V234_PAD_PB3__SIUL_GPIO19   S32V234_MSCR_PB3  PAD_CTL_MUX_MODE_ALT0
+#define S32V234_PAD_PB4__SIUL_GPIO20   S32V234_MSCR_PB4  PAD_CTL_MUX_MODE_ALT0
+#define S32V234_PAD_PB5__SIUL_GPIO21   S32V234_MSCR_PB5  PAD_CTL_MUX_MODE_ALT0
+#define S32V234_PAD_PB6__SIUL_GPIO22   S32V234_MSCR_PB6  PAD_CTL_MUX_MODE_ALT0
+#define S32V234_PAD_PB7__SIUL_GPIO23   S32V234_MSCR_PB7  PAD_CTL_MUX_MODE_ALT0
+#define S32V234_PAD_PB8__SIUL_GPIO24   S32V234_MSCR_PB8  PAD_CTL_MUX_MODE_ALT0
+#define S32V234_PAD_PB9__SIUL_GPIO25   S32V234_MSCR_PB9  PAD_CTL_MUX_MODE_ALT0
+#define S32V234_PAD_PB10__SIUL_GPIO26  S32V234_MSCR_PB10 PAD_CTL_MUX_MODE_ALT0
+#define S32V234_PAD_PB11__SIUL_GPIO27  S32V234_MSCR_PB11 PAD_CTL_MUX_MODE_ALT0
+#define S32V234_PAD_PB12__SIUL_GPIO28  S32V234_MSCR_PB12 PAD_CTL_MUX_MODE_ALT0
+#define S32V234_PAD_PB13__SIUL_GPIO29  S32V234_MSCR_PB13 PAD_CTL_MUX_MODE_ALT0
+#define S32V234_PAD_PB14__SIUL_GPIO30  S32V234_MSCR_PB14 PAD_CTL_MUX_MODE_ALT0
+#define S32V234_PAD_PB15__SIUL_GPIO31  S32V234_MSCR_PB15 PAD_CTL_MUX_MODE_ALT0
+#define S32V234_PAD_PC0__SIUL_GPIO32   S32V234_MSCR_PC0  PAD_CTL_MUX_MODE_ALT0
+#define S32V234_PAD_PC1__SIUL_GPIO33   S32V234_MSCR_PC1  PAD_CTL_MUX_MODE_ALT0
+#define S32V234_PAD_PC2__SIUL_GPIO34   S32V234_MSCR_PC2  PAD_CTL_MUX_MODE_ALT0
+#define S32V234_PAD_PC3__SIUL_GPIO35   S32V234_MSCR_PC3  PAD_CTL_MUX_MODE_ALT0
+#define S32V234_PAD_PC4__SIUL_GPIO36   S32V234_MSCR_PC4  PAD_CTL_MUX_MODE_ALT0
+#define S32V234_PAD_PC5__SIUL_GPIO37   S32V234_MSCR_PC5  PAD_CTL_MUX_MODE_ALT0
+#define S32V234_PAD_PC6__SIUL_GPIO38   S32V234_MSCR_PC6  PAD_CTL_MUX_MODE_ALT0
+#define S32V234_PAD_PC7__SIUL_GPIO39   S32V234_MSCR_PC7  PAD_CTL_MUX_MODE_ALT0
+#define S32V234_PAD_PC8__SIUL_GPIO40   S32V234_MSCR_PC8  PAD_CTL_MUX_MODE_ALT0
+#define S32V234_PAD_PC9__SIUL_GPIO41   S32V234_MSCR_PC9  PAD_CTL_MUX_MODE_ALT0
+#define S32V234_PAD_PC10__SIUL_GPIO42  S32V234_MSCR_PC10 PAD_CTL_MUX_MODE_ALT0
+#define S32V234_PAD_PC11__SIUL_GPIO43  S32V234_MSCR_PC11 PAD_CTL_MUX_MODE_ALT0
+#define S32V234_PAD_PC12__SIUL_GPIO44  S32V234_MSCR_PC12 PAD_CTL_MUX_MODE_ALT0
+#define S32V234_PAD_PC13__SIUL_GPIO45  S32V234_MSCR_PC13 PAD_CTL_MUX_MODE_ALT0
+#define S32V234_PAD_PC14__SIUL_GPIO46  S32V234_MSCR_PC14 PAD_CTL_MUX_MODE_ALT0
+#define S32V234_PAD_PC15__SIUL_GPIO47  S32V234_MSCR_PC15 PAD_CTL_MUX_MODE_ALT0
+#define S32V234_PAD_PD0__SIUL_GPIO48   S32V234_MSCR_PD0  PAD_CTL_MUX_MODE_ALT0
+#define S32V234_PAD_PD1__SIUL_GPIO49   S32V234_MSCR_PD1  PAD_CTL_MUX_MODE_ALT0
+#define S32V234_PAD_PD2__SIUL_GPIO50   S32V234_MSCR_PD2  PAD_CTL_MUX_MODE_ALT0
+#define S32V234_PAD_PD3__SIUL_GPIO51   S32V234_MSCR_PD3  PAD_CTL_MUX_MODE_ALT0
+#define S32V234_PAD_PD4__SIUL_GPIO52   S32V234_MSCR_PD4  PAD_CTL_MUX_MODE_ALT0
+#define S32V234_PAD_PD5__SIUL_GPIO53   S32V234_MSCR_PD5  PAD_CTL_MUX_MODE_ALT0
+#define S32V234_PAD_PD6__SIUL_GPIO54   S32V234_MSCR_PD6  PAD_CTL_MUX_MODE_ALT0
+#define S32V234_PAD_PD7__SIUL_GPIO55   S32V234_MSCR_PD7  PAD_CTL_MUX_MODE_ALT0
+#define S32V234_PAD_PD8__SIUL_GPIO56   S32V234_MSCR_PD8  PAD_CTL_MUX_MODE_ALT0
+#define S32V234_PAD_PD9__SIUL_GPIO57   S32V234_MSCR_PD9  PAD_CTL_MUX_MODE_ALT0
+#define S32V234_PAD_PD10__SIUL_GPIO58  S32V234_MSCR_PD10 PAD_CTL_MUX_MODE_ALT0
+#define S32V234_PAD_PD11__SIUL_GPIO59  S32V234_MSCR_PD11 PAD_CTL_MUX_MODE_ALT0
+#define S32V234_PAD_PD12__SIUL_GPIO60  S32V234_MSCR_PD12 PAD_CTL_MUX_MODE_ALT0
+#define S32V234_PAD_PD13__SIUL_GPIO61  S32V234_MSCR_PD13 PAD_CTL_MUX_MODE_ALT0
+#define S32V234_PAD_PD14__SIUL_GPIO62  S32V234_MSCR_PD14 PAD_CTL_MUX_MODE_ALT0
+#define S32V234_PAD_PD15__SIUL_GPIO63  S32V234_MSCR_PD15 PAD_CTL_MUX_MODE_ALT0
+#define S32V234_PAD_PE0__SIUL_GPIO64   S32V234_MSCR_PE0  PAD_CTL_MUX_MODE_ALT0
+#define S32V234_PAD_PE1__SIUL_GPIO65   S32V234_MSCR_PE1  PAD_CTL_MUX_MODE_ALT0
+#define S32V234_PAD_PE2__SIUL_GPIO66   S32V234_MSCR_PE2  PAD_CTL_MUX_MODE_ALT0
+#define S32V234_PAD_PE3__SIUL_GPIO67   S32V234_MSCR_PE3  PAD_CTL_MUX_MODE_ALT0
+#define S32V234_PAD_PE4__SIUL_GPIO68   S32V234_MSCR_PE4  PAD_CTL_MUX_MODE_ALT0
+#define S32V234_PAD_PE5__SIUL_GPIO69   S32V234_MSCR_PE5  PAD_CTL_MUX_MODE_ALT0
+#define S32V234_PAD_PE6__SIUL_GPIO70   S32V234_MSCR_PE6  PAD_CTL_MUX_MODE_ALT0
+#define S32V234_PAD_PE7__SIUL_GPIO71   S32V234_MSCR_PE7  PAD_CTL_MUX_MODE_ALT0
+#define S32V234_PAD_PE8__SIUL_GPIO72   S32V234_MSCR_PE8  PAD_CTL_MUX_MODE_ALT0
+#define S32V234_PAD_PE9__SIUL_GPIO73   S32V234_MSCR_PE9  PAD_CTL_MUX_MODE_ALT0
+#define S32V234_PAD_PE10__SIUL_GPIO74  S32V234_MSCR_PE10 PAD_CTL_MUX_MODE_ALT0
+#define S32V234_PAD_PE11__SIUL_GPIO75  S32V234_MSCR_PE11 PAD_CTL_MUX_MODE_ALT0
+#define S32V234_PAD_PE12__SIUL_GPIO76  S32V234_MSCR_PE12 PAD_CTL_MUX_MODE_ALT0
+#define S32V234_PAD_PE13__SIUL_GPIO77  S32V234_MSCR_PE13 PAD_CTL_MUX_MODE_ALT0
+#define S32V234_PAD_PE14__SIUL_GPIO78  S32V234_MSCR_PE14 PAD_CTL_MUX_MODE_ALT0
+#define S32V234_PAD_PE15__SIUL_GPIO79  S32V234_MSCR_PE15 PAD_CTL_MUX_MODE_ALT0
+#define S32V234_PAD_PF0__SIUL_GPIO80   S32V234_MSCR_PF0  PAD_CTL_MUX_MODE_ALT0
+#define S32V234_PAD_PF1__SIUL_GPIO81   S32V234_MSCR_PF1  PAD_CTL_MUX_MODE_ALT0
+#define S32V234_PAD_PF2__SIUL_GPIO82   S32V234_MSCR_PF2  PAD_CTL_MUX_MODE_ALT0
+#define S32V234_PAD_PF3__SIUL_GPIO83   S32V234_MSCR_PF3  PAD_CTL_MUX_MODE_ALT0
+#define S32V234_PAD_PF4__SIUL_GPIO84   S32V234_MSCR_PF4  PAD_CTL_MUX_MODE_ALT0
+#define S32V234_PAD_PF5__SIUL_GPIO85   S32V234_MSCR_PF5  PAD_CTL_MUX_MODE_ALT0
+#define S32V234_PAD_PF6__SIUL_GPIO86   S32V234_MSCR_PF6  PAD_CTL_MUX_MODE_ALT0
+#define S32V234_PAD_PF7__SIUL_GPIO87   S32V234_MSCR_PF7  PAD_CTL_MUX_MODE_ALT0
+#define S32V234_PAD_PF8__SIUL_GPIO88   S32V234_MSCR_PF8  PAD_CTL_MUX_MODE_ALT0
+#define S32V234_PAD_PF9__SIUL_GPIO89   S32V234_MSCR_PF9  PAD_CTL_MUX_MODE_ALT0
+#define S32V234_PAD_PF10__SIUL_GPIO90  S32V234_MSCR_PF10 PAD_CTL_MUX_MODE_ALT0
+#define S32V234_PAD_PF11__SIUL_GPIO91  S32V234_MSCR_PF11 PAD_CTL_MUX_MODE_ALT0
+#define S32V234_PAD_PF12__SIUL_GPIO92  S32V234_MSCR_PF12 PAD_CTL_MUX_MODE_ALT0
+#define S32V234_PAD_PF13__SIUL_GPIO93  S32V234_MSCR_PF13 PAD_CTL_MUX_MODE_ALT0
+#define S32V234_PAD_PF14__SIUL_GPIO94  S32V234_MSCR_PF14 PAD_CTL_MUX_MODE_ALT0
+#define S32V234_PAD_PF15__SIUL_GPIO95  S32V234_MSCR_PF15 PAD_CTL_MUX_MODE_ALT0
+#define S32V234_PAD_PG0__SIUL_GPIO96   S32V234_MSCR_PG0  PAD_CTL_MUX_MODE_ALT0
+#define S32V234_PAD_PG1__SIUL_GPIO97   S32V234_MSCR_PG1  PAD_CTL_MUX_MODE_ALT0
+#define S32V234_PAD_PG2__SIUL_GPIO98   S32V234_MSCR_PG2  PAD_CTL_MUX_MODE_ALT0
+#define S32V234_PAD_PG3__SIUL_GPIO99   S32V234_MSCR_PG3  PAD_CTL_MUX_MODE_ALT0
+#define S32V234_PAD_PG4__SIUL_GPIO100  S32V234_MSCR_PG4  PAD_CTL_MUX_MODE_ALT0
+#define S32V234_PAD_PG5__SIUL_GPIO101  S32V234_MSCR_PG5  PAD_CTL_MUX_MODE_ALT0
+#define S32V234_PAD_PG6__SIUL_GPIO102  S32V234_MSCR_PG6  PAD_CTL_MUX_MODE_ALT0
+#define S32V234_PAD_PG7__SIUL_GPIO103  S32V234_MSCR_PG7  PAD_CTL_MUX_MODE_ALT0
+#define S32V234_PAD_PG8__SIUL_GPIO104  S32V234_MSCR_PG8  PAD_CTL_MUX_MODE_ALT0
+#define S32V234_PAD_PG9__SIUL_GPIO105  S32V234_MSCR_PG9  PAD_CTL_MUX_MODE_ALT0
+#define S32V234_PAD_PG10__SIUL_GPIO106 S32V234_MSCR_PG10 PAD_CTL_MUX_MODE_ALT0
+#define S32V234_PAD_PG11__SIUL_GPIO107 S32V234_MSCR_PG11 PAD_CTL_MUX_MODE_ALT0
+#define S32V234_PAD_PG12__SIUL_GPIO108 S32V234_MSCR_PG12 PAD_CTL_MUX_MODE_ALT0
+#define S32V234_PAD_PG13__SIUL_GPIO109 S32V234_MSCR_PG13 PAD_CTL_MUX_MODE_ALT0
+#define S32V234_PAD_PG14__SIUL_GPIO110 S32V234_MSCR_PG14 PAD_CTL_MUX_MODE_ALT0
+#define S32V234_PAD_PG15__SIUL_GPIO111 S32V234_MSCR_PG15 PAD_CTL_MUX_MODE_ALT0
+#define S32V234_PAD_PH0__SIUL_GPIO112  S32V234_MSCR_PH0  PAD_CTL_MUX_MODE_ALT0
+#define S32V234_PAD_PH1__SIUL_GPIO113  S32V234_MSCR_PH1  PAD_CTL_MUX_MODE_ALT0
+#define S32V234_PAD_PH2__SIUL_GPIO114  S32V234_MSCR_PH2  PAD_CTL_MUX_MODE_ALT0
+#define S32V234_PAD_PH3__SIUL_GPIO115  S32V234_MSCR_PH3  PAD_CTL_MUX_MODE_ALT0
+#define S32V234_PAD_PH4__SIUL_GPIO116  S32V234_MSCR_PH4  PAD_CTL_MUX_MODE_ALT0
+#define S32V234_PAD_PH5__SIUL_GPIO117  S32V234_MSCR_PH5  PAD_CTL_MUX_MODE_ALT0
+#define S32V234_PAD_PH6__SIUL_GPIO118  S32V234_MSCR_PH6  PAD_CTL_MUX_MODE_ALT0
+#define S32V234_PAD_PH7__SIUL_GPIO119  S32V234_MSCR_PH7  PAD_CTL_MUX_MODE_ALT0
+#define S32V234_PAD_PH8__SIUL_GPIO120  S32V234_MSCR_PH8  PAD_CTL_MUX_MODE_ALT0
+#define S32V234_PAD_PH9__SIUL_GPIO121  S32V234_MSCR_PH9  PAD_CTL_MUX_MODE_ALT0
+#define S32V234_PAD_PH10__SIUL_GPIO122 S32V234_MSCR_PH10 PAD_CTL_MUX_MODE_ALT0
+#define S32V234_PAD_PH11__SIUL_GPIO123 S32V234_MSCR_PH11 PAD_CTL_MUX_MODE_ALT0
+#define S32V234_PAD_PH12__SIUL_GPIO124 S32V234_MSCR_PH12 PAD_CTL_MUX_MODE_ALT0
+#define S32V234_PAD_PH13__SIUL_GPIO125 S32V234_MSCR_PH13 PAD_CTL_MUX_MODE_ALT0
+#define S32V234_PAD_PH14__SIUL_GPIO126 S32V234_MSCR_PH14 PAD_CTL_MUX_MODE_ALT0
+#define S32V234_PAD_PH15__SIUL_GPIO127 S32V234_MSCR_PH15 PAD_CTL_MUX_MODE_ALT0
+#define S32V234_PAD_PJ0__SIUL_GPIO128  S32V234_MSCR_PJ0  PAD_CTL_MUX_MODE_ALT0
+#define S32V234_PAD_PJ1__SIUL_GPIO129  S32V234_MSCR_PJ1  PAD_CTL_MUX_MODE_ALT0
+#define S32V234_PAD_PJ2__SIUL_GPIO130  S32V234_MSCR_PJ2  PAD_CTL_MUX_MODE_ALT0
+#define S32V234_PAD_PJ3__SIUL_GPIO131  S32V234_MSCR_PJ3  PAD_CTL_MUX_MODE_ALT0
+#define S32V234_PAD_PJ4__SIUL_GPIO132  S32V234_MSCR_PJ4  PAD_CTL_MUX_MODE_ALT0
+#define S32V234_PAD_PJ5__SIUL_GPIO133  S32V234_MSCR_PJ5  PAD_CTL_MUX_MODE_ALT0
+#define S32V234_PAD_PJ6__SIUL_GPIO134  S32V234_MSCR_PJ6  PAD_CTL_MUX_MODE_ALT0
+#define S32V234_PAD_PJ7__SIUL_GPIO135  S32V234_MSCR_PJ7  PAD_CTL_MUX_MODE_ALT0
+#define S32V234_PAD_PJ8__SIUL_GPIO136  S32V234_MSCR_PJ8  PAD_CTL_MUX_MODE_ALT0
+#define S32V234_PAD_PJ9__SIUL_GPIO137  S32V234_MSCR_PJ9  PAD_CTL_MUX_MODE_ALT0
+#define S32V234_PAD_PJ10__SIUL_GPIO138 S32V234_MSCR_PJ10 PAD_CTL_MUX_MODE_ALT0
+#define S32V234_PAD_PJ11__SIUL_GPIO139 S32V234_MSCR_PJ11 PAD_CTL_MUX_MODE_ALT0
+#define S32V234_PAD_PJ12__SIUL_GPIO140 S32V234_MSCR_PJ12 PAD_CTL_MUX_MODE_ALT0
+#define S32V234_PAD_PJ13__SIUL_GPIO141 S32V234_MSCR_PJ13 PAD_CTL_MUX_MODE_ALT0
+#define S32V234_PAD_PJ14__SIUL_GPIO142 S32V234_MSCR_PJ14 PAD_CTL_MUX_MODE_ALT0
+#define S32V234_PAD_PJ15__SIUL_GPIO143 S32V234_MSCR_PJ15 PAD_CTL_MUX_MODE_ALT0
+#define S32V234_PAD_PK0__SIUL_GPIO144  S32V234_MSCR_PK0  PAD_CTL_MUX_MODE_ALT0
+#define S32V234_PAD_PK1__SIUL_GPIO145  S32V234_MSCR_PK1  PAD_CTL_MUX_MODE_ALT0
+#define S32V234_PAD_PK2__SIUL_GPIO146  S32V234_MSCR_PK2  PAD_CTL_MUX_MODE_ALT0
+#define S32V234_PAD_PK3__SIUL_GPIO147  S32V234_MSCR_PK3  PAD_CTL_MUX_MODE_ALT0
+#define S32V234_PAD_PK4__SIUL_GPIO148  S32V234_MSCR_PK4  PAD_CTL_MUX_MODE_ALT0
+#define S32V234_PAD_PK5__SIUL_GPIO149  S32V234_MSCR_PK5  PAD_CTL_MUX_MODE_ALT0
+#define S32V234_PAD_PK6__SIUL_GPIO150  S32V234_MSCR_PK6  PAD_CTL_MUX_MODE_ALT0
+#define S32V234_PAD_PK7__SIUL_GPIO151  S32V234_MSCR_PK7  PAD_CTL_MUX_MODE_ALT0
+#define S32V234_PAD_PK8__SIUL_GPIO152  S32V234_MSCR_PK8  PAD_CTL_MUX_MODE_ALT0
+#define S32V234_PAD_PK9__SIUL_GPIO153  S32V234_MSCR_PK9  PAD_CTL_MUX_MODE_ALT0
+#define S32V234_PAD_PK10__SIUL_GPIO154 S32V234_MSCR_PK10 PAD_CTL_MUX_MODE_ALT0
+#define S32V234_PAD_PK11__SIUL_GPIO155 S32V234_MSCR_PK11 PAD_CTL_MUX_MODE_ALT0
+#define S32V234_PAD_PK12__SIUL_GPIO156 S32V234_MSCR_PK12 PAD_CTL_MUX_MODE_ALT0
+#define S32V234_PAD_PK13__SIUL_GPIO157 S32V234_MSCR_PK13 PAD_CTL_MUX_MODE_ALT0
+#define S32V234_PAD_PK14__SIUL_GPIO158 S32V234_MSCR_PK14 PAD_CTL_MUX_MODE_ALT0
+#define S32V234_PAD_PK15__SIUL_GPIO159 S32V234_MSCR_PK15 PAD_CTL_MUX_MODE_ALT0
+#define S32V234_PAD_PL0__SIUL_GPIO160  S32V234_MSCR_PL0  PAD_CTL_MUX_MODE_ALT0
+#define S32V234_PAD_PL1__SIUL_GPIO161  S32V234_MSCR_PL1  PAD_CTL_MUX_MODE_ALT0
+#define S32V234_PAD_PL2__SIUL_GPIO162  S32V234_MSCR_PL2  PAD_CTL_MUX_MODE_ALT0
+
+/* SIUL2 EIRQ pins */
+#define S32V234_PAD_PA0__SIUL_EIRQ0   S32V234_IMCR_SIUL_EIRQ0  PAD_CTL_EIRQ
+#define S32V234_PAD_PA1__SIUL_EIRQ1   S32V234_IMCR_SIUL_EIRQ1  PAD_CTL_EIRQ
+#define S32V234_PAD_PA2__SIUL_EIRQ2   S32V234_IMCR_SIUL_EIRQ2  PAD_CTL_EIRQ
+#define S32V234_PAD_PA3__SIUL_EIRQ3   S32V234_IMCR_SIUL_EIRQ3  PAD_CTL_EIRQ
+#define S32V234_PAD_PA4__SIUL_EIRQ4   S32V234_IMCR_SIUL_EIRQ4  PAD_CTL_EIRQ
+#define S32V234_PAD_PA5__SIUL_EIRQ5   S32V234_IMCR_SIUL_EIRQ5  PAD_CTL_EIRQ
+#define S32V234_PAD_PA6__SIUL_EIRQ6   S32V234_IMCR_SIUL_EIRQ6  PAD_CTL_EIRQ
+#define S32V234_PAD_PA7__SIUL_EIRQ7   S32V234_IMCR_SIUL_EIRQ7  PAD_CTL_EIRQ
+#define S32V234_PAD_PA8__SIUL_EIRQ8   S32V234_IMCR_SIUL_EIRQ8  PAD_CTL_EIRQ
+#define S32V234_PAD_PA9__SIUL_EIRQ9   S32V234_IMCR_SIUL_EIRQ9  PAD_CTL_EIRQ
+#define S32V234_PAD_PA10__SIUL_EIRQ10 S32V234_IMCR_SIUL_EIRQ10 PAD_CTL_EIRQ
+#define S32V234_PAD_PA11__SIUL_EIRQ11 S32V234_IMCR_SIUL_EIRQ11 PAD_CTL_EIRQ
+#define S32V234_PAD_PA12__SIUL_EIRQ12 S32V234_IMCR_SIUL_EIRQ12 PAD_CTL_EIRQ
+#define S32V234_PAD_PA13__SIUL_EIRQ13 S32V234_IMCR_SIUL_EIRQ13 PAD_CTL_EIRQ
+#define S32V234_PAD_PA14__SIUL_EIRQ14 S32V234_IMCR_SIUL_EIRQ14 PAD_CTL_EIRQ
+#define S32V234_PAD_PA15__SIUL_EIRQ15 S32V234_IMCR_SIUL_EIRQ15 PAD_CTL_EIRQ
+#define S32V234_PAD_PB0__SIUL_EIRQ16  S32V234_IMCR_SIUL_EIRQ16 PAD_CTL_EIRQ
+#define S32V234_PAD_PB1__SIUL_EIRQ17  S32V234_IMCR_SIUL_EIRQ17 PAD_CTL_EIRQ
+#define S32V234_PAD_PB2__SIUL_EIRQ18  S32V234_IMCR_SIUL_EIRQ18 PAD_CTL_EIRQ
+#define S32V234_PAD_PB3__SIUL_EIRQ19  S32V234_IMCR_SIUL_EIRQ19 PAD_CTL_EIRQ
+#define S32V234_PAD_PB4__SIUL_EIRQ20  S32V234_IMCR_SIUL_EIRQ20 PAD_CTL_EIRQ
+#define S32V234_PAD_PB5__SIUL_EIRQ21  S32V234_IMCR_SIUL_EIRQ21 PAD_CTL_EIRQ
+#define S32V234_PAD_PB6__SIUL_EIRQ22  S32V234_IMCR_SIUL_EIRQ22 PAD_CTL_EIRQ
+#define S32V234_PAD_PB7__SIUL_EIRQ23  S32V234_IMCR_SIUL_EIRQ23 PAD_CTL_EIRQ
+#define S32V234_PAD_PB8__SIUL_EIRQ24  S32V234_IMCR_SIUL_EIRQ24 PAD_CTL_EIRQ
+#define S32V234_PAD_PB9__SIUL_EIRQ25  S32V234_IMCR_SIUL_EIRQ25 PAD_CTL_EIRQ
+#define S32V234_PAD_PB10__SIUL_EIRQ26 S32V234_IMCR_SIUL_EIRQ26 PAD_CTL_EIRQ
+#define S32V234_PAD_PB11__SIUL_EIRQ27 S32V234_IMCR_SIUL_EIRQ27 PAD_CTL_EIRQ
+#define S32V234_PAD_PB12__SIUL_EIRQ28 S32V234_IMCR_SIUL_EIRQ28 PAD_CTL_EIRQ
+#define S32V234_PAD_PB13__SIUL_EIRQ29 S32V234_IMCR_SIUL_EIRQ29 PAD_CTL_EIRQ
+#define S32V234_PAD_PB14__SIUL_EIRQ30 S32V234_IMCR_SIUL_EIRQ30 PAD_CTL_EIRQ
+#define S32V234_PAD_PB15__SIUL_EIRQ31 S32V234_IMCR_SIUL_EIRQ31 PAD_CTL_EIRQ
+
+#endif /* __DT_BINDINGS_S32V234_PINCTRL_H__ */
diff --git a/include/dt-bindings/reset/imx-hdmimix-reset.h b/include/dt-bindings/reset/imx-hdmimix-reset.h
new file mode 100644
index 000000000..6a6f726a0
--- /dev/null
+++ b/include/dt-bindings/reset/imx-hdmimix-reset.h
@@ -0,0 +1,21 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Copyright 2020 NXP.
+ */
+
+#ifndef DT_BINDING_RESET_IMX_HDMIMIX_H
+#define DT_BINDING_RESET_IMX_HDMIMIX_H
+
+#define IMX_HDMIMIX_HDMI_TX_RESET		0x0
+#define IMX_HDMIMIX_HDMI_PHY_RESET		0x1
+#define IMX_HDMIMIX_HDMI_PAI_RESET		0x2
+#define IMX_HDMIMIX_HDMI_PVI_RESET		0x3
+#define IMX_HDMIMIX_HDMI_TRNG_RESET		0x4
+#define IMX_HDMIMIX_IRQ_STEER_RESET		0x5
+#define IMX_HDMIMIX_HDMI_HDCP_RESET		0x6
+#define IMX_HDMIMIX_LCDIF_RESET			0x7
+
+#define IMX_HDMIMIX_RESET_NUM		8
+
+#endif
+
diff --git a/include/dt-bindings/reset/imx8mm-dispmix.h b/include/dt-bindings/reset/imx8mm-dispmix.h
new file mode 100644
index 000000000..3af137b1b
--- /dev/null
+++ b/include/dt-bindings/reset/imx8mm-dispmix.h
@@ -0,0 +1,49 @@
+/*
+ * Copyright 2019 NXP
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#ifndef __IMX8MM_DISPMIX_H__
+#define __IMX8MM_DISPMIX_H__
+
+/* DISPMIX soft reset */
+#define IMX8MM_CSI_BRIDGE_CHIP_RESET			0
+#define IMX8MM_CSI_BRIDGE_IPG_HARD_ASYNC_RESET		1
+#define IMX8MM_CSI_BRIDGE_CSI_HRESET			2
+#define IMX8MM_CAMERA_PIXEL_RESET			3
+#define IMX8MM_MIPI_CSI_I_PRESET			4
+#define IMX8MM_MIPI_DSI_I_PRESET			5
+#define IMX8MM_BUS_RSTN_BLK_SYNC			6
+#define IMX8MM_DISPMIX_SFT_RSTN_NUM			7
+
+/* DISPMIX clock soft enable */
+#define IMX8MM_CSI_BRIDGE_CSI_HCLK_EN			0
+#define IMX8MM_CSI_BRIDGE_SPU_CLK_EN			1
+#define IMX8MM_CSI_BRIDGE_MEM_WRAPPER_CLK_EN		2
+#define IMX8MM_CSI_BRIDGE_IPG_CLK_EN			3
+#define IMX8MM_CSI_BRIDGE_IPG_CLK_S_EN			4
+#define IMX8MM_CSI_BRIDGE_IPG_CLK_S_RAW_EN		5
+#define IMX8MM_LCDIF_APB_CLK_EN				6
+#define IMX8MM_LCDIF_PIXEL_CLK_EN			7
+#define IMX8MM_MIPI_DSI_PCLK_EN				8
+#define IMX8MM_MIPI_DSI_CLKREF_EN			9
+#define IMX8MM_MIPI_CSI_ACLK_EN				10
+#define IMX8MM_MIPI_CSI_PCLK_EN				11
+#define IMX8MM_BUS_BLK_CLK_EN				12
+#define IMX8MM_DISPMIX_CLK_EN_NUM			13
+
+/* MIPI reset */
+#define IMX8MM_MIPI_S_RESET				0
+#define IMX8MM_MIPI_M_RESET				1
+#define IMX8MM_MIPI_RESET_NUM				2
+
+#endif
diff --git a/include/dt-bindings/reset/imx8mn-dispmix.h b/include/dt-bindings/reset/imx8mn-dispmix.h
new file mode 100644
index 000000000..8703ebe7d
--- /dev/null
+++ b/include/dt-bindings/reset/imx8mn-dispmix.h
@@ -0,0 +1,47 @@
+/*
+ * Copyright 2019 NXP
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#ifndef __IMX8MN_DISPMIX_H__
+#define __IMX8MN_DISPMIX_H__
+
+/* DISPMIX soft reset */
+#define IMX8MN_MIPI_DSI_PCLK_RESET			0
+#define IMX8MN_MIPI_DSI_CLKREF_RESET			1
+#define IMX8MN_MIPI_CSI_PCLK_RESET			2
+#define IMX8MN_MIPI_CSI_ACLK_RESET			3
+#define IMX8MN_LCDIF_PIXEL_CLK_RESET			4
+#define IMX8MN_LCDIF_APB_CLK_RESET			5
+#define IMX8MN_ISI_PROC_CLK_RESET			6
+#define IMX8MN_ISI_APB_CLK_RESET			7
+#define IMX8MN_BUS_BLK_CLK_RESET			8
+#define IMX8MN_DISPMIX_SFT_RSTN_NUM			9
+
+/* DISPMIX clock soft enable */
+#define IMX8MN_MIPI_DSI_PCLK_EN				0
+#define IMX8MN_MIPI_DSI_CLKREF_EN			1
+#define IMX8MN_MIPI_CSI_PCLK_EN				2
+#define IMX8MN_MIPI_CSI_ACLK_EN				3
+#define IMX8MN_LCDIF_PIXEL_CLK_EN			4
+#define IMX8MN_LCDIF_APB_CLK_EN				5
+#define IMX8MN_ISI_PROC_CLK_EN				6
+#define IMX8MN_ISI_APB_CLK_EN				7
+#define IMX8MN_BUS_BLK_CLK_EN				8
+#define IMX8MN_DISPMIX_CLK_EN_NUM			9
+
+/* MIPI reset */
+#define IMX8MN_MIPI_S_RESET				0
+#define IMX8MN_MIPI_M_RESET				1
+#define IMX8MN_MIPI_RESET_NUM				2
+
+#endif
diff --git a/include/dt-bindings/reset/imx8mq-reset.h b/include/dt-bindings/reset/imx8mq-reset.h
index 705870693..5d201c000 100644
--- a/include/dt-bindings/reset/imx8mq-reset.h
+++ b/include/dt-bindings/reset/imx8mq-reset.h
@@ -61,7 +61,9 @@
 #define IMX8MQ_RESET_SW_M4C_RST			50
 #define IMX8MQ_RESET_SW_M4P_RST			51
 #define IMX8MQ_RESET_M4_ENABLE			52
+#define IMX8MQ_RESET_PCIE_CTRL_APPS_CLK_REQ	53	/* i.MX8M PCIe CTL CLK REQ */
+#define IMX8MQ_RESET_PCIE2_CTRL_APPS_CLK_REQ	54	/* i.MX8M PCIe CTL CLK REQ */
 
-#define IMX8MQ_RESET_NUM			53
+#define IMX8MQ_RESET_NUM			55
 
 #endif
diff --git a/include/dt-bindings/soc/imx8_hsio.h b/include/dt-bindings/soc/imx8_hsio.h
new file mode 100644
index 000000000..3cf1056b6
--- /dev/null
+++ b/include/dt-bindings/soc/imx8_hsio.h
@@ -0,0 +1,31 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * Copyright 2019 NXP
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#ifndef __DT_BINDINGS_IMX8_HSIO_H
+#define __DT_BINDINGS_IMX8_HSIO_H
+
+/*
+ * imx8qm hsio has pciea, pcieb and sata modules, and hsio
+ * can be configured to the following different work modes.
+ * 1 - pciea 2 lanes and one sata ahci port.
+ * 2 - pciea 1 lane, pcieb 1 lane and one sata ahci port.
+ * 3 - pciea 2 lanes, pcieb 1 lane.
+ * Choose one mode, refer to the exact hardware board design.
+ */
+#define		PCIEAX2SATA		1
+#define		PCIEAX1PCIEBX1SATA	2
+#define		PCIEAX2PCIEBX1		3
+
+#endif /* __DT_BINDINGS_IMX8_HSIO_H */
diff --git a/include/keys/secure-type.h b/include/keys/secure-type.h
new file mode 100644
index 000000000..5b7a5f144
--- /dev/null
+++ b/include/keys/secure-type.h
@@ -0,0 +1,33 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * Copyright (C) 2018 NXP.
+ *
+ */
+
+#ifndef _KEYS_SECURE_TYPE_H
+#define _KEYS_SECURE_TYPE_H
+
+#include <linux/key.h>
+#include <linux/rcupdate.h>
+
+/* Minimum key size to be used is 32 bytes and maximum key size fixed
+ * is 128 bytes.
+ * Blob size to be kept is Maximum key size + blob header added by CAAM.
+ */
+
+#define MIN_KEY_SIZE                    32
+#define MAX_KEY_SIZE                    128
+#define BLOB_HEADER_SIZE		48
+
+#define MAX_BLOB_SIZE                   (MAX_KEY_SIZE + BLOB_HEADER_SIZE)
+
+struct secure_key_payload {
+	struct rcu_head rcu;
+	unsigned int key_len;
+	unsigned int blob_len;
+	unsigned char key[MAX_KEY_SIZE + 1];
+	unsigned char blob[MAX_BLOB_SIZE];
+};
+
+extern struct key_type key_type_secure;
+#endif
diff --git a/include/linux/acpi.h b/include/linux/acpi.h
index fdb1d5262..3effd73dd 100644
--- a/include/linux/acpi.h
+++ b/include/linux/acpi.h
@@ -703,6 +703,8 @@ static inline u64 acpi_arch_get_root_pointer(void)
 }
 #endif
 
+int acpi_get_local_address(acpi_handle handle, u32 *addr);
+
 #else	/* !CONFIG_ACPI */
 
 #define acpi_disabled 1
@@ -953,6 +955,11 @@ static inline struct acpi_device *acpi_resource_consumer(struct resource *res)
 	return NULL;
 }
 
+static inline int acpi_get_local_address(acpi_handle handle, u32 *addr)
+{
+	return -ENODEV;
+}
+
 #endif	/* !CONFIG_ACPI */
 
 #ifdef CONFIG_ACPI_HOTPLUG_IOAPIC
diff --git a/include/linux/acpi_mdio.h b/include/linux/acpi_mdio.h
new file mode 100644
index 000000000..0a24ab7cb
--- /dev/null
+++ b/include/linux/acpi_mdio.h
@@ -0,0 +1,26 @@
+/* SPDX-License-Identifier: GPL-2.0-only */
+/*
+ * ACPI helper for the MDIO (Ethernet PHY) API
+ */
+
+#ifndef __LINUX_ACPI_MDIO_H
+#define __LINUX_ACPI_MDIO_H
+
+#include <linux/phy.h>
+
+#if IS_ENABLED(CONFIG_ACPI_MDIO)
+int acpi_mdiobus_register(struct mii_bus *mdio, struct fwnode_handle *fwnode);
+#else /* CONFIG_ACPI_MDIO */
+static inline int
+acpi_mdiobus_register(struct mii_bus *mdio, struct fwnode_handle *fwnode)
+{
+	/*
+	 * Fall back to mdiobus_register() function to register a bus.
+	 * This way, we don't have to keep compat bits around in drivers.
+	 */
+
+	return mdiobus_register(mdio);
+}
+#endif
+
+#endif /* __LINUX_ACPI_MDIO_H */
diff --git a/include/linux/backing-dev.h b/include/linux/backing-dev.h
index 44df4fcef..f71e6cfde 100644
--- a/include/linux/backing-dev.h
+++ b/include/linux/backing-dev.h
@@ -118,6 +118,15 @@ int bdi_set_max_ratio(struct backing_dev_info *bdi, unsigned int max_ratio);
 #define BDI_CAP_WRITEBACK		(1 << 0)
 #define BDI_CAP_WRITEBACK_ACCT		(1 << 1)
 #define BDI_CAP_STRICTLIMIT		(1 << 2)
+#define BDI_CAP_NO_ACCT_DIRTY	0x00000001
+#define BDI_CAP_NO_WRITEBACK	0x00000002
+#define BDI_CAP_NO_ACCT_WB	0x00000004
+#define BDI_CAP_STABLE_WRITES	0x00000008
+#define BDI_CAP_CGROUP_WRITEBACK 0x00000020
+#define BDI_CAP_SYNCHRONOUS_IO	0x00000040
+
+#define BDI_CAP_NO_ACCT_AND_WRITEBACK \
+	(BDI_CAP_NO_WRITEBACK | BDI_CAP_NO_ACCT_DIRTY | BDI_CAP_NO_ACCT_WB)
 
 extern struct backing_dev_info noop_backing_dev_info;
 
diff --git a/include/linux/busfreq-imx.h b/include/linux/busfreq-imx.h
new file mode 100644
index 000000000..41896226a
--- /dev/null
+++ b/include/linux/busfreq-imx.h
@@ -0,0 +1,58 @@
+/*
+ * Copyright 2012-2016 Freescale Semiconductor, Inc. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#ifndef __ASM_ARCH_MXC_BUSFREQ_H__
+#define __ASM_ARCH_MXC_BUSFREQ_H__
+
+#include <linux/notifier.h>
+#include <linux/regulator/consumer.h>
+
+/*
+ * This enumerates busfreq low power mode entry and exit.
+ */
+enum busfreq_event {
+	LOW_BUSFREQ_ENTER,
+	LOW_BUSFREQ_EXIT,
+};
+
+/*
+ * This enumerates the system bus and ddr frequencies in various modes.
+ * BUS_FREQ_HIGH - DDR @ 528MHz, AHB @ 132MHz.
+ * BUS_FREQ_MED - DDR @ 400MHz, AHB @ 132MHz
+ * BUS_FREQ_AUDIO - DDR @ 50MHz/100MHz, AHB @ 24MHz.
+ * BUS_FREQ_LOW  - DDR @ 24MHz, AHB @ 24MHz.
+ * BUS_FREQ_ULTRA_LOW - DDR @ 1MHz, AHB - 3MHz.
+ *
+ * Drivers need to request/release the bus/ddr frequencies based on
+ * their performance requirements. Drivers cannot request/release
+ * BUS_FREQ_ULTRA_LOW mode as this mode is automatically entered from
+ * either BUS_FREQ_AUDIO or BUS_FREQ_LOW
+ * modes.
+ */
+enum bus_freq_mode {
+	BUS_FREQ_HIGH,
+	BUS_FREQ_MED,
+	BUS_FREQ_AUDIO,
+	BUS_FREQ_LOW,
+	BUS_FREQ_ULTRA_LOW,
+};
+
+#if defined(CONFIG_HAVE_IMX_BUSFREQ) && !defined(CONFIG_ARM64)
+extern struct regulator *arm_reg;
+extern struct regulator *soc_reg;
+void request_bus_freq(enum bus_freq_mode mode);
+void release_bus_freq(enum bus_freq_mode mode);
+int register_busfreq_notifier(struct notifier_block *nb);
+int unregister_busfreq_notifier(struct notifier_block *nb);
+int get_bus_freq_mode(void);
+#elif defined(CONFIG_HAVE_IMX_BUSFREQ)
+void request_bus_freq(enum bus_freq_mode mode);
+void release_bus_freq(enum bus_freq_mode mode);
+int get_bus_freq_mode(void);
+#endif
+#endif
diff --git a/include/linux/clk-provider.h b/include/linux/clk-provider.h
index 03a5de5f9..d98e41f9f 100644
--- a/include/linux/clk-provider.h
+++ b/include/linux/clk-provider.h
@@ -32,6 +32,7 @@
 #define CLK_OPS_PARENT_ENABLE	BIT(12)
 /* duty cycle call may be forwarded to the parent clock */
 #define CLK_DUTY_CYCLE_PARENT	BIT(13)
+#define CLK_SET_PARENT_NOCACHE	BIT(14) /* do not use the cached clk parent */
 
 struct clk;
 struct clk_hw;
diff --git a/include/linux/device.h b/include/linux/device.h
index 5dc0f81e4..4f7e0c85e 100644
--- a/include/linux/device.h
+++ b/include/linux/device.h
@@ -818,6 +818,7 @@ int device_online(struct device *dev);
 void set_primary_fwnode(struct device *dev, struct fwnode_handle *fwnode);
 void set_secondary_fwnode(struct device *dev, struct fwnode_handle *fwnode);
 void device_set_of_node_from_dev(struct device *dev, const struct device *dev2);
+void device_set_node(struct device *dev, struct fwnode_handle *fwnode);
 
 static inline int dev_num_vf(struct device *dev)
 {
diff --git a/include/linux/device_cooling.h b/include/linux/device_cooling.h
new file mode 100644
index 000000000..18d9e3b90
--- /dev/null
+++ b/include/linux/device_cooling.h
@@ -0,0 +1,45 @@
+/*
+ * Copyright (C) 2013-2015 Freescale Semiconductor, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ */
+
+#ifndef __DEVICE_THERMAL_H__
+#define __DEVICE_THERMAL_H__
+
+#include <linux/thermal.h>
+
+#ifdef CONFIG_DEVICE_THERMAL
+int register_devfreq_cooling_notifier(struct notifier_block *nb);
+int unregister_devfreq_cooling_notifier(struct notifier_block *nb);
+struct thermal_cooling_device *devfreq_cooling_register(void);
+void devfreq_cooling_unregister(struct thermal_cooling_device *cdev);
+#else
+static inline
+int register_devfreq_cooling_notifier(struct notifier_block *nb)
+{
+	return 0;
+}
+
+static inline
+int unregister_devfreq_cooling_notifier(struct notifier_block *nb)
+{
+	return 0;
+}
+
+static inline
+struct thermal_cooling_device *devfreq_cooling_register(void)
+{
+	return NULL;
+}
+
+static inline
+void devfreq_cooling_unregister(struct thermal_cooling_device *cdev)
+{
+	return;
+}
+#endif
+#endif /* __DEVICE_THERMAL_H__ */
diff --git a/include/linux/dmaengine.h b/include/linux/dmaengine.h
index dd357a747..493a047ed 100644
--- a/include/linux/dmaengine.h
+++ b/include/linux/dmaengine.h
@@ -418,6 +418,9 @@ enum dma_slave_buswidth {
  * @slave_id: Slave requester id. Only valid for slave channels. The dma
  * slave peripheral will have unique id as dma requester which need to be
  * pass as slave config.
+ * @peripheral_config: peripheral configuration for programming peripheral
+ * for dmaengine transfer
+ * @peripheral_size: peripheral configuration buffer size
  *
  * This struct is passed in as configuration data to a DMA engine
  * in order to set up a certain channel for DMA transport at runtime.
@@ -443,6 +446,8 @@ struct dma_slave_config {
 	u32 dst_port_window_size;
 	bool device_fc;
 	unsigned int slave_id;
+	void *peripheral_config;
+	size_t peripheral_size;
 };
 
 /**
diff --git a/include/linux/fb.h b/include/linux/fb.h
index ecfbcc055..640ed9ca4 100644
--- a/include/linux/fb.h
+++ b/include/linux/fb.h
@@ -127,7 +127,19 @@ struct fb_cursor_user {
 /*	The resolution of the passed in fb_info about to change */
 #define FB_EVENT_MODE_CHANGE		0x01
 
-#ifdef CONFIG_GUMSTIX_AM200EPD
+#ifdef CONFIG_FB_MXC_HDMI
+/* only used by mxc_hdmi.c */
+/*     The display on this fb_info is being suspended, no access to the
+ *     framebuffer is allowed any more after that call returns
+ */
+#define FB_EVENT_SUSPEND               0x02
+/*     The display on this fb_info was resumed, you can restore the display
+ *     if you own it
+ */
+#define FB_EVENT_RESUME                        0x03
+#endif
+
+#if (defined CONFIG_GUMSTIX_AM200EPD) || (defined CONFIG_FB_MXC_HDMI) || (defined CONFIG_FB_MXS_SII902X)
 /* only used by mach-pxa/am200epd.c */
 #define FB_EVENT_FB_REGISTERED          0x05
 #define FB_EVENT_FB_UNREGISTERED        0x06
diff --git a/include/linux/firmware/imx/dsp.h b/include/linux/firmware/imx/dsp.h
index 7562099c9..4f7895a3b 100644
--- a/include/linux/firmware/imx/dsp.h
+++ b/include/linux/firmware/imx/dsp.h
@@ -55,6 +55,9 @@ static inline void *imx_dsp_get_data(struct imx_dsp_ipc *ipc)
 
 int imx_dsp_ring_doorbell(struct imx_dsp_ipc *dsp, unsigned int chan_idx);
 
+struct mbox_chan *imx_dsp_request_channel(struct imx_dsp_ipc *ipc, int idx);
+void imx_dsp_free_channel(struct imx_dsp_ipc *ipc, int idx);
+
 #else
 
 static inline int imx_dsp_ring_doorbell(struct imx_dsp_ipc *ipc,
@@ -63,5 +66,12 @@ static inline int imx_dsp_ring_doorbell(struct imx_dsp_ipc *ipc,
 	return -ENOTSUPP;
 }
 
+struct mbox_chan *imx_dsp_request_channel(struct imx_dsp_ipc *ipc, int idx)
+{
+	return ERR_PTR(-EOPNOTSUPP);
+}
+
+void imx_dsp_free_channel(struct imx_dsp_ipc *ipc, int idx) { }
+
 #endif
 #endif /* _IMX_DSP_IPC_H */
diff --git a/include/linux/firmware/imx/ipc.h b/include/linux/firmware/imx/ipc.h
index 891057434..9c13c6e6d 100644
--- a/include/linux/firmware/imx/ipc.h
+++ b/include/linux/firmware/imx/ipc.h
@@ -25,6 +25,8 @@ enum imx_sc_rpc_svc {
 	IMX_SC_RPC_SVC_PAD = 6,
 	IMX_SC_RPC_SVC_MISC = 7,
 	IMX_SC_RPC_SVC_IRQ = 8,
+	IMX_SC_RPC_SVC_SECO = 9,
+	IMX_SC_RPC_SVC_ABORT = 10,
 };
 
 struct imx_sc_rpc_msg {
@@ -34,6 +36,7 @@ struct imx_sc_rpc_msg {
 	uint8_t func;
 };
 
+#if IS_ENABLED(CONFIG_IMX_SCU)
 /*
  * This is an function to send an RPC message over an IPC channel.
  * It is called by client-side SCFW API function shims.
@@ -55,4 +58,17 @@ int imx_scu_call_rpc(struct imx_sc_ipc *ipc, void *msg, bool have_resp);
  * @return Returns an error code (0 = success, failed if < 0)
  */
 int imx_scu_get_handle(struct imx_sc_ipc **ipc);
+#else
+static inline int
+imx_scu_call_rpc(struct imx_sc_ipc *ipc, void *msg, bool have_resp)
+{
+	return -EIO;
+
+}
+
+static inline int imx_scu_get_handle(struct imx_sc_ipc **ipc)
+{
+	return -EIO;
+}
+#endif
 #endif /* _SC_IPC_H */
diff --git a/include/linux/firmware/imx/s4.h b/include/linux/firmware/imx/s4.h
new file mode 100644
index 000000000..9e34923ae
--- /dev/null
+++ b/include/linux/firmware/imx/s4.h
@@ -0,0 +1,20 @@
+/* SPDX-License-Identifier: GPL-2.0+ */
+/*
+ * Copyright 2021 NXP
+ *
+ * Header file for the IPC implementation.
+ */
+
+#ifndef _S4_IPC_H
+#define _S4_IPC_H
+
+struct imx_s4_ipc;
+
+struct imx_s4_rpc_msg {
+	uint8_t ver;
+	uint8_t size;
+	uint8_t cmd;
+	uint8_t tag;
+} __packed;
+
+#endif /* _S4_IPC_H */
diff --git a/include/linux/firmware/imx/sci.h b/include/linux/firmware/imx/sci.h
index 22c76571a..2ca969eba 100644
--- a/include/linux/firmware/imx/sci.h
+++ b/include/linux/firmware/imx/sci.h
@@ -15,10 +15,15 @@
 #include <linux/firmware/imx/svc/misc.h>
 #include <linux/firmware/imx/svc/pm.h>
 #include <linux/firmware/imx/svc/rm.h>
+#include <linux/firmware/imx/svc/seco.h>
+
+#define IMX_SC_IRQ_GROUP_WAKE       3U /* Wakeup interrupts */
+#define IMX_SC_IRQ_SECVIO            BIT(6)    /* Security violation */
 
 int imx_scu_enable_general_irq_channel(struct device *dev);
 int imx_scu_irq_register_notifier(struct notifier_block *nb);
 int imx_scu_irq_unregister_notifier(struct notifier_block *nb);
 int imx_scu_irq_group_enable(u8 group, u32 mask, u8 enable);
+int imx_scu_irq_get_status(u8 group, u32 *irq_status);
 int imx_scu_soc_init(struct device *dev);
 #endif /* _SC_SCI_H */
diff --git a/include/linux/firmware/imx/seco_mu_ioctl.h b/include/linux/firmware/imx/seco_mu_ioctl.h
new file mode 100644
index 000000000..bd8402b47
--- /dev/null
+++ b/include/linux/firmware/imx/seco_mu_ioctl.h
@@ -0,0 +1,50 @@
+/* SPDX-License-Identifier: (GPL-2.0 WITH Linux-syscall-note) OR BSD-3-Clause*/
+/*
+ * Copyright 2019-2020 NXP
+ */
+
+#ifndef SECO_MU_IOCTL_H
+#define SECO_MU_IOCTL_H
+
+/* IOCTL definitions. */
+struct seco_mu_ioctl_setup_iobuf {
+	u8 *user_buf;
+	u32 length;
+	u32 flags;
+	u64 seco_addr;
+};
+
+struct seco_mu_ioctl_shared_mem_cfg {
+	u32 base_offset;
+	u32 size;
+};
+
+struct seco_mu_ioctl_get_mu_info {
+	u8 seco_mu_idx;
+	u8 interrupt_idx;
+	u8 tz;
+	u8 did;
+};
+
+struct seco_mu_ioctl_signed_message {
+	u8 *message;
+	u32 msg_size;
+	u32 error_code;
+};
+
+#define SECO_MU_IO_FLAGS_IS_INPUT	(0x01u)
+#define SECO_MU_IO_FLAGS_USE_SEC_MEM	(0x02u)
+#define SECO_MU_IO_FLAGS_USE_SHORT_ADDR	(0x04u)
+
+#define SECO_MU_IOCTL			0x0A /* like MISC_MAJOR. */
+#define SECO_MU_IOCTL_ENABLE_CMD_RCV	_IO(SECO_MU_IOCTL, 0x01)
+#define SECO_MU_IOCTL_SHARED_BUF_CFG	_IOW(SECO_MU_IOCTL, 0x02, \
+			struct seco_mu_ioctl_shared_mem_cfg)
+#define SECO_MU_IOCTL_SETUP_IOBUF	_IOWR(SECO_MU_IOCTL, 0x03, \
+			struct seco_mu_ioctl_setup_iobuf)
+#define SECO_MU_IOCTL_GET_MU_INFO	_IOR(SECO_MU_IOCTL, 0x04, \
+			struct seco_mu_ioctl_get_mu_info)
+#define SECO_MU_IOCTL_SIGNED_MESSAGE	_IOWR(SECO_MU_IOCTL, 0x05, \
+			struct seco_mu_ioctl_signed_message)
+
+#endif
diff --git a/include/linux/firmware/imx/sentnl_base_msg.h b/include/linux/firmware/imx/sentnl_base_msg.h
new file mode 100644
index 000000000..0592fbcf8
--- /dev/null
+++ b/include/linux/firmware/imx/sentnl_base_msg.h
@@ -0,0 +1,36 @@
+/* SPDX-License-Identifier: GPL-2.0+ */
+/*
+ * Copyright 2021 NXP
+ */
+
+#ifndef SENTNL_BASE_MSG_H
+#define SENTNL_BASE_MSG_H
+
+#define MAX_RECV_SIZE 31
+#define MAX_RECV_SIZE_BYTES (MAX_RECV_SIZE * sizeof(u32))
+#define MAX_MESSAGE_SIZE 31
+#define MAX_MESSAGE_SIZE_BYTES (MAX_MESSAGE_SIZE * sizeof(u32))
+
+#define MESSAGING_VERSION_6		0x6
+
+#define SENTNL_OEM_CNTN_AUTH_REQ	0x87
+#define SENTNL_VERIFY_IMAGE_REQ		0x88
+#define SENTNL_RELEASE_CONTAINER_REQ	0x89
+#define SENTNL_READ_FUSE_REQ		0x97
+#define OTP_UNIQ_ID			0x01
+#define OTFAD_CONFIG			0x2
+
+#define SENTNL_VERSION			0x6
+#define SENTNL_SUCCESS_IND		0xD6
+#define SENTNL_FAILURE_IND		0x29
+
+#define SENTNL_MSG_DATA_NUM		10
+
+#define SENTNL_OEM_CNTN_AUTH_REQ_SIZE	3
+#define SENTNL_VERIFY_IMAGE_REQ_SIZE	2
+#define SENTNL_REL_CONTAINER_REQ_SIZE	1
+
+
+int read_common_fuse(uint16_t fuse_index, u32 *value);
+
+#endif
diff --git a/include/linux/firmware/imx/sentnl_mu_ioctl.h b/include/linux/firmware/imx/sentnl_mu_ioctl.h
new file mode 100644
index 000000000..eda727aa8
--- /dev/null
+++ b/include/linux/firmware/imx/sentnl_mu_ioctl.h
@@ -0,0 +1,51 @@
+/* SPDX-License-Identifier: (GPL-2.0 WITH Linux-syscall-note) OR BSD-3-Clause*/
+/*
+ * Copyright 2019-2021 NXP
+ */
+
+#ifndef SENTNL_MU_IOCTL_H
+#define SENTNL_MU_IOCTL_H
+
+/* IOCTL definitions. */
+
+struct sentnl_mu_ioctl_setup_iobuf {
+	u8 *user_buf;
+	u32 length;
+	u32 flags;
+	u64 sentnl_addr;
+};
+
+struct sentnl_mu_ioctl_shared_mem_cfg {
+	u32 base_offset;
+	u32 size;
+};
+
+struct sentnl_mu_ioctl_get_mu_info {
+	u8 sentnl_mu_id;
+	u8 interrupt_idx;
+	u8 tz;
+	u8 did;
+};
+
+struct sentnl_mu_ioctl_signed_message {
+	u8 *message;
+	u32 msg_size;
+	u32 error_code;
+};
+
+#define SENTNL_MU_IO_FLAGS_IS_INTPUT		(0x01u)
+#define SENTNL_MU_IO_FLAGS_USE_SEC_MEM		(0x02u)
+#define SENTNL_MU_IO_FLAGS_USE_SHORT_ADDR	(0x04u)
+
+#define SENTNL_MU_IOCTL			0x0A /* like MISC_MAJOR. */
+#define SENTNL_MU_IOCTL_ENABLE_CMD_RCV	_IO(SENTNL_MU_IOCTL, 0x01)
+#define SENTNL_MU_IOCTL_SHARED_BUF_CFG	_IOW(SENTNL_MU_IOCTL, 0x02, \
+					struct sentnl_mu_ioctl_shared_mem_cfg)
+#define SENTNL_MU_IOCTL_SETUP_IOBUF	_IOWR(SENTNL_MU_IOCTL, 0x03, \
+					struct sentnl_mu_ioctl_setup_iobuf)
+#define SENTNL_MU_IOCTL_GET_MU_INFO	_IOR(SENTNL_MU_IOCTL, 0x04, \
+					struct sentnl_mu_ioctl_get_mu_info)
+#define SENTNL_MU_IOCTL_SIGNED_MESSAGE	_IOWR(SENTNL_MU_IOCTL, 0x05, \
+					struct sentnl_mu_ioctl_signed_message)
+
+#endif
diff --git a/include/linux/firmware/imx/svc/misc.h b/include/linux/firmware/imx/svc/misc.h
index 031dd4d3c..981f204b8 100644
--- a/include/linux/firmware/imx/svc/misc.h
+++ b/include/linux/firmware/imx/svc/misc.h
@@ -46,13 +46,45 @@ enum imx_misc_func {
  * Control Functions
  */
 
+#if IS_ENABLED(CONFIG_IMX_SCU)
 int imx_sc_misc_set_control(struct imx_sc_ipc *ipc, u32 resource,
 			    u8 ctrl, u32 val);
 
+int imx_sc_misc_set_dma_group(struct imx_sc_ipc *ipc, u32 resource,
+			    u32 val);
+
 int imx_sc_misc_get_control(struct imx_sc_ipc *ipc, u32 resource,
 			    u8 ctrl, u32 *val);
 
 int imx_sc_pm_cpu_start(struct imx_sc_ipc *ipc, u32 resource,
 			bool enable, u64 phys_addr);
+#else
+static inline int
+imx_sc_misc_set_control(struct imx_sc_ipc *ipc, u32 resource,
+			u8 ctrl, u32 val)
+{
+	return -EIO;
+}
+
+static inline int
+imx_sc_misc_set_dma_group(struct imx_sc_ipc *ipc, u32 resource,
+			  u32 val)
+{
+	return -EIO;
+}
+
+static inline int
+imx_sc_misc_get_control(struct imx_sc_ipc *ipc, u32 resource,
+			u8 ctrl, u32 *val)
+{
+	return -EIO;
+}
+
+static inline int imx_sc_pm_cpu_start(struct imx_sc_ipc *ipc, u32 resource,
+				      bool enable, u64 phys_addr)
+{
+	return -EIO;
+}
+#endif
 
 #endif /* _SC_MISC_API_H */
diff --git a/include/linux/firmware/imx/svc/rm.h b/include/linux/firmware/imx/svc/rm.h
index 456b6a59d..4798c36d9 100644
--- a/include/linux/firmware/imx/svc/rm.h
+++ b/include/linux/firmware/imx/svc/rm.h
@@ -59,11 +59,49 @@ enum imx_sc_rm_func {
 
 #if IS_ENABLED(CONFIG_IMX_SCU)
 bool imx_sc_rm_is_resource_owned(struct imx_sc_ipc *ipc, u16 resource);
+int imx_sc_rm_get_partition(struct imx_sc_ipc *ipc, u8 *pt);
+int imx_sc_rm_find_memreg(struct imx_sc_ipc *ipc, u8 *mr, u64 addr_start,
+			  u64 addr_end);
+int imx_sc_rm_get_resource_owner(struct imx_sc_ipc *ipc, u16 resource, u8 *pt);
+int imx_sc_rm_set_memreg_permissions(struct imx_sc_ipc *ipc, u8 mr,
+				     u8 pt, u8 perm);
+int imx_sc_rm_get_did(struct imx_sc_ipc *ipc, u8 *did);
 #else
 static inline bool
 imx_sc_rm_is_resource_owned(struct imx_sc_ipc *ipc, u16 resource)
 {
 	return true;
 }
+
+static inline int imx_sc_rm_get_partition(struct imx_sc_ipc *ipc, u8 *pt)
+{
+	return -ENOENT;
+}
+
+static inline
+int imx_sc_rm_find_memreg(struct imx_sc_ipc *ipc, u8 *mr, u64 addr_start,
+			  u64 addr_end)
+{
+	return -EOPNOTSUPP;
+}
+
+static inline
+int imx_sc_rm_get_resource_owner(struct imx_sc_ipc *ipc, u16 resource, u8 *pt)
+{
+	return -EOPNOTSUPP;
+}
+
+static inline
+int imx_sc_rm_set_memreg_permissions(struct imx_sc_ipc *ipc, u8 mr,
+				     u8 pt, u8 perm)
+{
+	return -EOPNOTSUPP;
+}
+
+static inline
+int imx_sc_rm_get_did(struct imx_sc_ipc *ipc, u8 *did)
+{
+	return -EOPNOTSUPP;
+}
 #endif
 #endif
diff --git a/include/linux/firmware/imx/svc/seco.h b/include/linux/firmware/imx/svc/seco.h
new file mode 100644
index 000000000..d0dd803a1
--- /dev/null
+++ b/include/linux/firmware/imx/svc/seco.h
@@ -0,0 +1,77 @@
+/* SPDX-License-Identifier: GPL-2.0+ */
+/*
+ * Copyright 2020 NXP
+ *
+ * Header file containing the public API for the System Controller (SC)
+ * Security Controller (SECO) function.
+ *
+ * SECO_SVC (SVC) Security Controller Service
+ *
+ * Module for the Security Controller (SECO) service.
+ */
+
+#ifndef _SC_SECO_API_H
+#define _SC_SECO_API_H
+
+#include <linux/errno.h>
+#include <linux/firmware/imx/sci.h>
+
+/*
+ * This type is used to indicate RPC RM function calls.
+ */
+enum imx_sc_seco_func {
+	IMX_SC_SECO_FUNC_UNKNOWN = 0,
+	IMX_SC_SECO_FUNC_BUILD_INFO = 16,
+	IMX_SC_SECO_FUNC_SAB_MSG = 23,
+	IMX_SC_SECO_FUNC_SECVIO_ENABLE = 25,
+	IMX_SC_SECO_FUNC_SECVIO_CONFIG = 26,
+	IMX_SC_SECO_FUNC_SECVIO_DGO_CONFIG = 27,
+};
+
+#if IS_ENABLED(CONFIG_IMX_SCU)
+int imx_sc_seco_build_info(struct imx_sc_ipc *ipc, uint32_t *version,
+			   uint32_t *commit);
+int imx_sc_seco_sab_msg(struct imx_sc_ipc *ipc, u64 smsg_addr);
+int imx_sc_seco_secvio_enable(struct imx_sc_ipc *ipc);
+int imx_sc_seco_secvio_config(struct imx_sc_ipc *ipc, u8 id, u8 access,
+			      u32 *data0, u32 *data1, u32 *data2, u32 *data3,
+			      u32 *data4, u8 size);
+int imx_sc_seco_secvio_dgo_config(struct imx_sc_ipc *ipc, u8 id, u8 access,
+				  u32 *data);
+#else /* IS_ENABLED(CONFIG_IMX_SCU) */
+static inline
+int imx_sc_seco_build_info(struct imx_sc_ipc *ipc, uint32_t *version,
+			   uint32_t *commit)
+{
+	return -EOPNOTSUPP;
+}
+
+static inline
+int imx_sc_seco_sab_msg(struct imx_sc_ipc *ipc, u64 smsg_addr)
+{
+	return -EOPNOTSUPP;
+}
+
+static inline
+int imx_sc_seco_secvio_enable(struct imx_sc_ipc *ipc)
+{
+	return -EOPNOTSUPP;
+}
+
+static inline
+int imx_sc_seco_secvio_config(struct imx_sc_ipc *ipc, u8 id, u8 access,
+			      u32 *data0, u32 *data1, u32 *data2, u32 *data3,
+			      u32 *data4, u8 size)
+{
+	return -EOPNOTSUPP;
+}
+
+static inline
+int imx_sc_seco_secvio_dgo_config(struct imx_sc_ipc *ipc, u8 id, u8 access,
+				  u32 *data)
+{
+	return -EOPNOTSUPP;
+}
+#endif /* IS_ENABLED(CONFIG_IMX_SCU) */
+
+#endif /* _SC_SECO_API_H */
diff --git a/include/linux/fsl/mc.h b/include/linux/fsl/mc.h
index db244874e..d5264fc6f 100644
--- a/include/linux/fsl/mc.h
+++ b/include/linux/fsl/mc.h
@@ -13,6 +13,7 @@
 #include <linux/device.h>
 #include <linux/mod_devicetable.h>
 #include <linux/interrupt.h>
+#include <uapi/linux/fsl_mc.h>
 
 #define FSL_MC_VENDOR_FREESCALE	0x1957
 
@@ -220,11 +221,6 @@ struct mc_cmd_header {
 	__le16 cmd_id;
 };
 
-struct fsl_mc_command {
-	__le64 header;
-	__le64 params[MC_CMD_NUM_OF_PARAMS];
-};
-
 enum mc_cmd_status {
 	MC_CMD_STATUS_OK = 0x0, /* Completed successfully */
 	MC_CMD_STATUS_READY = 0x1, /* Ready to be processed */
@@ -625,6 +621,20 @@ int dpcon_reset(struct fsl_mc_io *mc_io,
 		u32 cmd_flags,
 		u16 token);
 
+int fsl_mc_obj_open(struct fsl_mc_io *mc_io,
+		    u32 cmd_flags,
+		    int obj_id,
+		    char *obj_type,
+		    u16 *token);
+
+int fsl_mc_obj_close(struct fsl_mc_io *mc_io,
+		     u32 cmd_flags,
+		     u16 token);
+
+int fsl_mc_obj_reset(struct fsl_mc_io *mc_io,
+		     u32 cmd_flags,
+		     u16 token);
+
 /**
  * struct dpcon_attr - Structure representing DPCON attributes
  * @id: DPCON object ID
diff --git a/include/linux/fsl/svr.h b/include/linux/fsl/svr.h
new file mode 100644
index 000000000..e95c8f43a
--- /dev/null
+++ b/include/linux/fsl/svr.h
@@ -0,0 +1,97 @@
+/*
+ * MPC85xx cpu type detection
+ *
+ * Copyright 2011-2012 Freescale Semiconductor, Inc.
+ *
+ * This is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ */
+
+#ifndef FSL_SVR_H
+#define FSL_SVR_H
+
+#define SVR_REV(svr)	((svr) & 0xFF)		/* SOC design resision */
+#define SVR_MAJ(svr)	(((svr) >>  4) & 0xF)	/* Major revision field*/
+#define SVR_MIN(svr)	(((svr) >>  0) & 0xF)	/* Minor revision field*/
+
+/* Some parts define SVR[0:23] as the SOC version */
+#define SVR_SOC_VER(svr) (((svr) >> 8) & 0xFFF7FF)	/* SOC Version fields */
+
+#define SVR_8533	0x803400
+#define SVR_8535	0x803701
+#define SVR_8536	0x803700
+#define SVR_8540	0x803000
+#define SVR_8541	0x807200
+#define SVR_8543	0x803200
+#define SVR_8544	0x803401
+#define SVR_8545	0x803102
+#define SVR_8547	0x803101
+#define SVR_8548	0x803100
+#define SVR_8555	0x807100
+#define SVR_8560	0x807000
+#define SVR_8567	0x807501
+#define SVR_8568	0x807500
+#define SVR_8569	0x808000
+#define SVR_8572	0x80E000
+#define SVR_P1010	0x80F100
+#define SVR_P1011	0x80E500
+#define SVR_P1012	0x80E501
+#define SVR_P1013	0x80E700
+#define SVR_P1014	0x80F101
+#define SVR_P1017	0x80F700
+#define SVR_P1020	0x80E400
+#define SVR_P1021	0x80E401
+#define SVR_P1022	0x80E600
+#define SVR_P1023	0x80F600
+#define SVR_P1024	0x80E402
+#define SVR_P1025	0x80E403
+#define SVR_P2010	0x80E300
+#define SVR_P2020	0x80E200
+#define SVR_P2040	0x821000
+#define SVR_P2041	0x821001
+#define SVR_P3041	0x821103
+#define SVR_P4040	0x820100
+#define SVR_P4080	0x820000
+#define SVR_P5010	0x822100
+#define SVR_P5020	0x822000
+#define SVR_P5021	0X820500
+#define SVR_P5040	0x820400
+#define SVR_T4240	0x824000
+#define SVR_T4120	0x824001
+#define SVR_T4160	0x824100
+#define SVR_T4080	0x824102
+#define SVR_C291	0x850000
+#define SVR_C292	0x850020
+#define SVR_C293	0x850030
+#define SVR_B4860	0X868000
+#define SVR_G4860	0x868001
+#define SVR_G4060	0x868003
+#define SVR_B4440	0x868100
+#define SVR_G4440	0x868101
+#define SVR_B4420	0x868102
+#define SVR_B4220	0x868103
+#define SVR_T1040	0x852000
+#define SVR_T1041	0x852001
+#define SVR_T1042	0x852002
+#define SVR_T1020	0x852100
+#define SVR_T1021	0x852101
+#define SVR_T1022	0x852102
+#define SVR_T1023	0x854100
+#define SVR_T1024	0x854000
+#define SVR_T2080	0x853000
+#define SVR_T2081	0x853100
+
+#define SVR_8610	0x80A000
+#define SVR_8641	0x809000
+#define SVR_8641D	0x809001
+
+#define SVR_9130	0x860001
+#define SVR_9131	0x860000
+#define SVR_9132	0x861000
+#define SVR_9232	0x861400
+
+#define SVR_Unknown	0xFFFFFF
+
+#endif
diff --git a/include/linux/fsl_bman.h b/include/linux/fsl_bman.h
new file mode 100644
index 000000000..43942221f
--- /dev/null
+++ b/include/linux/fsl_bman.h
@@ -0,0 +1,532 @@
+/* Copyright 2008-2012 Freescale Semiconductor, Inc.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef FSL_BMAN_H
+#define FSL_BMAN_H
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/* Last updated for v00.79 of the BG */
+
+/* Portal processing (interrupt) sources */
+#define BM_PIRQ_RCRI	0x00000002	/* RCR Ring (below threshold) */
+#define BM_PIRQ_BSCN	0x00000001	/* Buffer depletion State Change */
+
+/* This wrapper represents a bit-array for the depletion state of the 64 Bman
+ * buffer pools. */
+struct bman_depletion {
+	u32 __state[2];
+};
+#define BMAN_DEPLETION_EMPTY { { 0x00000000, 0x00000000 } }
+#define BMAN_DEPLETION_FULL { { 0xffffffff, 0xffffffff } }
+#define __bmdep_word(x) ((x) >> 5)
+#define __bmdep_shift(x) ((x) & 0x1f)
+#define __bmdep_bit(x) (0x80000000 >> __bmdep_shift(x))
+static inline void bman_depletion_init(struct bman_depletion *c)
+{
+	c->__state[0] = c->__state[1] = 0;
+}
+static inline void bman_depletion_fill(struct bman_depletion *c)
+{
+	c->__state[0] = c->__state[1] = ~0;
+}
+static inline int bman_depletion_get(const struct bman_depletion *c, u8 bpid)
+{
+	return c->__state[__bmdep_word(bpid)] & __bmdep_bit(bpid);
+}
+static inline void bman_depletion_set(struct bman_depletion *c, u8 bpid)
+{
+	c->__state[__bmdep_word(bpid)] |= __bmdep_bit(bpid);
+}
+static inline void bman_depletion_unset(struct bman_depletion *c, u8 bpid)
+{
+	c->__state[__bmdep_word(bpid)] &= ~__bmdep_bit(bpid);
+}
+
+/* ------------------------------------------------------- */
+/* --- Bman data structures (and associated constants) --- */
+
+/* Represents s/w corenet portal mapped data structures */
+struct bm_rcr_entry;	/* RCR (Release Command Ring) entries */
+struct bm_mc_command;	/* MC (Management Command) command */
+struct bm_mc_result;	/* MC result */
+
+/* Code-reduction, define a wrapper for 48-bit buffers. In cases where a buffer
+ * pool id specific to this buffer is needed (BM_RCR_VERB_CMD_BPID_MULTI,
+ * BM_MCC_VERB_ACQUIRE), the 'bpid' field is used. */
+struct bm_buffer {
+	union {
+		struct {
+#if __BYTE_ORDER__ == __ORDER_BIG_ENDIAN__
+			u8 __reserved1;
+			u8 bpid;
+			u16 hi; /* High 16-bits of 48-bit address */
+			u32 lo; /* Low 32-bits of 48-bit address */
+#else
+			u32 lo;
+			u16 hi;
+			u8 bpid;
+			u8 __reserved;
+#endif
+		};
+		struct {
+#if __BYTE_ORDER__ == __ORDER_BIG_ENDIAN__
+			u64 __notaddress:16;
+			u64 addr:48;
+#else
+			u64 addr:48;
+			u64 __notaddress:16;
+#endif
+		};
+		u64 opaque;
+	};
+} __aligned(8);
+static inline u64 bm_buffer_get64(const struct bm_buffer *buf)
+{
+	return buf->addr;
+}
+static inline dma_addr_t bm_buf_addr(const struct bm_buffer *buf)
+{
+	return (dma_addr_t)buf->addr;
+}
+/* Macro, so we compile better if 'v' isn't always 64-bit */
+#define bm_buffer_set64(buf, v) \
+	do { \
+		struct bm_buffer *__buf931 = (buf); \
+		__buf931->hi = upper_32_bits(v); \
+		__buf931->lo = lower_32_bits(v); \
+	} while (0)
+
+/* See 1.5.3.5.4: "Release Command" */
+struct bm_rcr_entry {
+	union {
+		struct {
+			u8 __dont_write_directly__verb;
+			u8 bpid; /* used with BM_RCR_VERB_CMD_BPID_SINGLE */
+			u8 __reserved1[62];
+		};
+		struct bm_buffer bufs[8];
+	};
+} __packed;
+#define BM_RCR_VERB_VBIT		0x80
+#define BM_RCR_VERB_CMD_MASK		0x70	/* one of two values; */
+#define BM_RCR_VERB_CMD_BPID_SINGLE	0x20
+#define BM_RCR_VERB_CMD_BPID_MULTI	0x30
+#define BM_RCR_VERB_BUFCOUNT_MASK	0x0f	/* values 1..8 */
+
+/* See 1.5.3.1: "Acquire Command" */
+/* See 1.5.3.2: "Query Command" */
+struct bm_mcc_acquire {
+	u8 bpid;
+	u8 __reserved1[62];
+} __packed;
+struct bm_mcc_query {
+	u8 __reserved2[63];
+} __packed;
+struct bm_mc_command {
+	u8 __dont_write_directly__verb;
+	union {
+		struct bm_mcc_acquire acquire;
+		struct bm_mcc_query query;
+	};
+} __packed;
+#define BM_MCC_VERB_VBIT		0x80
+#define BM_MCC_VERB_CMD_MASK		0x70	/* where the verb contains; */
+#define BM_MCC_VERB_CMD_ACQUIRE		0x10
+#define BM_MCC_VERB_CMD_QUERY		0x40
+#define BM_MCC_VERB_ACQUIRE_BUFCOUNT	0x0f	/* values 1..8 go here */
+
+/* See 1.5.3.3: "Acquire Response" */
+/* See 1.5.3.4: "Query Response" */
+struct bm_pool_state {
+	u8 __reserved1[32];
+	/* "availability state" and "depletion state" */
+	struct {
+		u8 __reserved1[8];
+		/* Access using bman_depletion_***() */
+		struct bman_depletion state;
+	} as, ds;
+};
+struct bm_mc_result {
+	union {
+		struct {
+			u8 verb;
+			u8 __reserved1[63];
+		};
+		union {
+			struct {
+				u8 __reserved1;
+				u8 bpid;
+				u8 __reserved2[62];
+			};
+			struct bm_buffer bufs[8];
+		} acquire;
+		struct bm_pool_state query;
+	};
+} __packed;
+#define BM_MCR_VERB_VBIT		0x80
+#define BM_MCR_VERB_CMD_MASK		BM_MCC_VERB_CMD_MASK
+#define BM_MCR_VERB_CMD_ACQUIRE		BM_MCC_VERB_CMD_ACQUIRE
+#define BM_MCR_VERB_CMD_QUERY		BM_MCC_VERB_CMD_QUERY
+#define BM_MCR_VERB_CMD_ERR_INVALID	0x60
+#define BM_MCR_VERB_CMD_ERR_ECC		0x70
+#define BM_MCR_VERB_ACQUIRE_BUFCOUNT	BM_MCC_VERB_ACQUIRE_BUFCOUNT /* 0..8 */
+/* Determine the "availability state" of pool 'p' from a query result 'r' */
+#define BM_MCR_QUERY_AVAILABILITY(r, p)	\
+		bman_depletion_get(&r->query.as.state, p)
+/* Determine the "depletion state" of pool 'p' from a query result 'r' */
+#define BM_MCR_QUERY_DEPLETION(r, p)	\
+		bman_depletion_get(&r->query.ds.state, p)
+
+/*******************************************************************/
+/* Managed (aka "shared" or "mux/demux") portal, high-level i/face */
+/*******************************************************************/
+
+	/* Portal and Buffer Pools */
+	/* ----------------------- */
+/* Represents a managed portal */
+struct bman_portal;
+
+/* This object type represents Bman buffer pools. */
+struct bman_pool;
+
+struct bman_portal_config {
+	/* This is used for any "core-affine" portals, ie. default portals
+	 * associated to the corresponding cpu. -1 implies that there is no core
+	 * affinity configured. */
+	int cpu;
+	/* portal interrupt line */
+	int irq;
+	/* the unique index of this portal */
+	u32 index;
+	/* Is this portal shared? (If so, it has coarser locking and demuxes
+	 * processing on behalf of other CPUs.) */
+	int is_shared;
+	/* These are the buffer pool IDs that may be used via this portal. */
+	struct bman_depletion mask;
+};
+
+/* This callback type is used when handling pool depletion entry/exit. The
+ * 'cb_ctx' value is the opaque value associated with the pool object in
+ * bman_new_pool(). 'depleted' is non-zero on depletion-entry, and zero on
+ * depletion-exit. */
+typedef void (*bman_cb_depletion)(struct bman_portal *bm,
+			struct bman_pool *pool, void *cb_ctx, int depleted);
+
+/* This struct specifies parameters for a bman_pool object. */
+struct bman_pool_params {
+	/* index of the buffer pool to encapsulate (0-63), ignored if
+	 * BMAN_POOL_FLAG_DYNAMIC_BPID is set. */
+	u32 bpid;
+	/* bit-mask of BMAN_POOL_FLAG_*** options */
+	u32 flags;
+	/* depletion-entry/exit callback, if BMAN_POOL_FLAG_DEPLETION is set */
+	bman_cb_depletion cb;
+	/* opaque user value passed as a parameter to 'cb' */
+	void *cb_ctx;
+	/* depletion-entry/exit thresholds, if BMAN_POOL_FLAG_THRESH is set. NB:
+	 * this is only allowed if BMAN_POOL_FLAG_DYNAMIC_BPID is used *and*
+	 * when run in the control plane (which controls Bman CCSR). This array
+	 * matches the definition of bm_pool_set(). */
+	u32 thresholds[4];
+};
+
+/* Flags to bman_new_pool() */
+#define BMAN_POOL_FLAG_NO_RELEASE    0x00000001 /* can't release to pool */
+#define BMAN_POOL_FLAG_ONLY_RELEASE  0x00000002 /* can only release to pool */
+#define BMAN_POOL_FLAG_DEPLETION     0x00000004 /* track depletion entry/exit */
+#define BMAN_POOL_FLAG_DYNAMIC_BPID  0x00000008 /* (de)allocate bpid */
+#define BMAN_POOL_FLAG_THRESH        0x00000010 /* set depletion thresholds */
+#define BMAN_POOL_FLAG_STOCKPILE     0x00000020 /* stockpile to reduce hw ops */
+
+/* Flags to bman_release() */
+#ifdef CONFIG_FSL_DPA_CAN_WAIT
+#define BMAN_RELEASE_FLAG_WAIT       0x00000001 /* wait if RCR is full */
+#define BMAN_RELEASE_FLAG_WAIT_INT   0x00000002 /* if we wait, interruptible? */
+#ifdef CONFIG_FSL_DPA_CAN_WAIT_SYNC
+#define BMAN_RELEASE_FLAG_WAIT_SYNC  0x00000004 /* if wait, until consumed? */
+#endif
+#endif
+#define BMAN_RELEASE_FLAG_NOW        0x00000008 /* issue immediate release */
+
+/* Flags to bman_acquire() */
+#define BMAN_ACQUIRE_FLAG_STOCKPILE  0x00000001 /* no hw op, stockpile only */
+
+	/* Portal Management */
+	/* ----------------- */
+/**
+ * bman_get_portal_config - get portal configuration settings
+ *
+ * This returns a read-only view of the current cpu's affine portal settings.
+ */
+const struct bman_portal_config *bman_get_portal_config(void);
+
+/**
+ * bman_irqsource_get - return the portal work that is interrupt-driven
+ *
+ * Returns a bitmask of BM_PIRQ_**I processing sources that are currently
+ * enabled for interrupt handling on the current cpu's affine portal. These
+ * sources will trigger the portal interrupt and the interrupt handler (or a
+ * tasklet/bottom-half it defers to) will perform the corresponding processing
+ * work. The bman_poll_***() functions will only process sources that are not in
+ * this bitmask. If the current CPU is sharing a portal hosted on another CPU,
+ * this always returns zero.
+ */
+u32 bman_irqsource_get(void);
+
+/**
+ * bman_irqsource_add - add processing sources to be interrupt-driven
+ * @bits: bitmask of BM_PIRQ_**I processing sources
+ *
+ * Adds processing sources that should be interrupt-driven (rather than
+ * processed via bman_poll_***() functions). Returns zero for success, or
+ * -EINVAL if the current CPU is sharing a portal hosted on another CPU. */
+int bman_irqsource_add(u32 bits);
+
+/**
+ * bman_irqsource_remove - remove processing sources from being interrupt-driven
+ * @bits: bitmask of BM_PIRQ_**I processing sources
+ *
+ * Removes processing sources from being interrupt-driven, so that they will
+ * instead be processed via bman_poll_***() functions. Returns zero for success,
+ * or -EINVAL if the current CPU is sharing a portal hosted on another CPU. */
+int bman_irqsource_remove(u32 bits);
+
+/**
+ * bman_affine_cpus - return a mask of cpus that have affine portals
+ */
+const cpumask_t *bman_affine_cpus(void);
+
+/**
+ * bman_poll_slow - process anything that isn't interrupt-driven.
+ *
+ * This function does any portal processing that isn't interrupt-driven. If the
+ * current CPU is sharing a portal hosted on another CPU, this function will
+ * return -EINVAL, otherwise the return value is a bitmask of BM_PIRQ_* sources
+ * indicating what interrupt sources were actually processed by the call.
+ *
+ * NB, unlike the legacy wrapper bman_poll(), this function will
+ * deterministically check for the presence of portal processing work and do it,
+ * which implies some latency even if there's nothing to do. The bman_poll()
+ * wrapper on the other hand (like the qman_poll() wrapper) attenuates this by
+ * checking for (and doing) portal processing infrequently. Ie. such that
+ * qman_poll() and bman_poll() can be called from core-processing loops. Use
+ * bman_poll_slow() when you yourself are deciding when to incur the overhead of
+ * processing.
+ */
+u32 bman_poll_slow(void);
+
+/**
+ * bman_poll - process anything that isn't interrupt-driven.
+ *
+ * Dispatcher logic on a cpu can use this to trigger any maintenance of the
+ * affine portal. This function does whatever processing is not triggered by
+ * interrupts. This is a legacy wrapper that can be used in core-processing
+ * loops but mitigates the performance overhead of portal processing by
+ * adaptively bypassing true portal processing most of the time. (Processing is
+ * done once every 10 calls if the previous processing revealed that work needed
+ * to be done, or once very 1000 calls if the previous processing revealed no
+ * work needed doing.) If you wish to control this yourself, call
+ * bman_poll_slow() instead, which always checks for portal processing work.
+ */
+void bman_poll(void);
+
+/**
+ * bman_rcr_is_empty - Determine if portal's RCR is empty
+ *
+ * For use in situations where a cpu-affine caller needs to determine when all
+ * releases for the local portal have been processed by Bman but can't use the
+ * BMAN_RELEASE_FLAG_WAIT_SYNC flag to do this from the final bman_release().
+ * The function forces tracking of RCR consumption (which normally doesn't
+ * happen until release processing needs to find space to put new release
+ * commands), and returns zero if the ring still has unprocessed entries,
+ * non-zero if it is empty.
+ */
+int bman_rcr_is_empty(void);
+
+/**
+ * bman_alloc_bpid_range - Allocate a contiguous range of BPIDs
+ * @result: is set by the API to the base BPID of the allocated range
+ * @count: the number of BPIDs required
+ * @align: required alignment of the allocated range
+ * @partial: non-zero if the API can return fewer than @count BPIDs
+ *
+ * Returns the number of buffer pools allocated, or a negative error code. If
+ * @partial is non zero, the allocation request may return a smaller range of
+ * BPs than requested (though alignment will be as requested). If @partial is
+ * zero, the return value will either be 'count' or negative.
+ */
+int bman_alloc_bpid_range(u32 *result, u32 count, u32 align, int partial);
+static inline int bman_alloc_bpid(u32 *result)
+{
+	int ret = bman_alloc_bpid_range(result, 1, 0, 0);
+	return (ret > 0) ? 0 : ret;
+}
+
+/**
+ * bman_release_bpid_range - Release the specified range of buffer pool IDs
+ * @bpid: the base BPID of the range to deallocate
+ * @count: the number of BPIDs in the range
+ *
+ * This function can also be used to seed the allocator with ranges of BPIDs
+ * that it can subsequently allocate from.
+ */
+void bman_release_bpid_range(u32 bpid, unsigned int count);
+static inline void bman_release_bpid(u32 bpid)
+{
+	bman_release_bpid_range(bpid, 1);
+}
+
+int bman_reserve_bpid_range(u32 bpid, unsigned int count);
+static inline int bman_reserve_bpid(u32 bpid)
+{
+	return bman_reserve_bpid_range(bpid, 1);
+}
+
+void bman_seed_bpid_range(u32 bpid, unsigned int count);
+
+
+int bman_shutdown_pool(u32 bpid);
+
+	/* Pool management */
+	/* --------------- */
+/**
+ * bman_new_pool - Allocates a Buffer Pool object
+ * @params: parameters specifying the buffer pool ID and behaviour
+ *
+ * Creates a pool object for the given @params. A portal and the depletion
+ * callback field of @params are only used if the BMAN_POOL_FLAG_DEPLETION flag
+ * is set. NB, the fields from @params are copied into the new pool object, so
+ * the structure provided by the caller can be released or reused after the
+ * function returns.
+ */
+struct bman_pool *bman_new_pool(const struct bman_pool_params *params);
+
+/**
+ * bman_free_pool - Deallocates a Buffer Pool object
+ * @pool: the pool object to release
+ *
+ */
+void bman_free_pool(struct bman_pool *pool);
+
+/**
+ * bman_get_params - Returns a pool object's parameters.
+ * @pool: the pool object
+ *
+ * The returned pointer refers to state within the pool object so must not be
+ * modified and can no longer be read once the pool object is destroyed.
+ */
+const struct bman_pool_params *bman_get_params(const struct bman_pool *pool);
+
+/**
+ * bman_release - Release buffer(s) to the buffer pool
+ * @pool: the buffer pool object to release to
+ * @bufs: an array of buffers to release
+ * @num: the number of buffers in @bufs (1-8)
+ * @flags: bit-mask of BMAN_RELEASE_FLAG_*** options
+ *
+ * Adds the given buffers to RCR entries. If the portal @p was created with the
+ * "COMPACT" flag, then it will be using a compaction algorithm to improve
+ * utilisation of RCR. As such, these buffers may join an existing ring entry
+ * and/or it may not be issued right away so as to allow future releases to join
+ * the same ring entry. Use the BMAN_RELEASE_FLAG_NOW flag to override this
+ * behaviour by committing the RCR entry (or entries) right away. If the RCR
+ * ring is full, the function will return -EBUSY unless BMAN_RELEASE_FLAG_WAIT
+ * is selected, in which case it will sleep waiting for space to become
+ * available in RCR. If the function receives a signal before such time (and
+ * BMAN_RELEASE_FLAG_WAIT_INT is set), the function returns -EINTR. Otherwise,
+ * it returns zero.
+ */
+int bman_release(struct bman_pool *pool, const struct bm_buffer *bufs, u8 num,
+			u32 flags);
+
+/**
+ * bman_acquire - Acquire buffer(s) from a buffer pool
+ * @pool: the buffer pool object to acquire from
+ * @bufs: array for storing the acquired buffers
+ * @num: the number of buffers desired (@bufs is at least this big)
+ *
+ * Issues an "Acquire" command via the portal's management command interface.
+ * The return value will be the number of buffers obtained from the pool, or a
+ * negative error code if a h/w error or pool starvation was encountered. In
+ * the latter case, the content of @bufs is undefined.
+ */
+int bman_acquire(struct bman_pool *pool, struct bm_buffer *bufs, u8 num,
+			u32 flags);
+
+/**
+ * bman_flush_stockpile - Flush stockpile buffer(s) to the buffer pool
+ * @pool: the buffer pool object the stockpile belongs
+ * @flags: bit-mask of BMAN_RELEASE_FLAG_*** options
+ *
+ * Adds stockpile buffers to RCR entries until the stockpile is empty.
+ * The return value will be a negative error code if a h/w error occurred.
+ * If BMAN_RELEASE_FLAG_NOW flag is passed and RCR ring is full,
+ * -EAGAIN will be returned.
+ */
+int bman_flush_stockpile(struct bman_pool *pool, u32 flags);
+
+/**
+ * bman_query_pools - Query all buffer pool states
+ * @state: storage for the queried availability and depletion states
+ */
+int bman_query_pools(struct bm_pool_state *state);
+
+#ifdef CONFIG_FSL_BMAN_CONFIG
+/**
+ * bman_query_free_buffers - Query how many free buffers are in buffer pool
+ * @pool: the buffer pool object to query
+ *
+ * Return the number of the free buffers
+ */
+u32 bman_query_free_buffers(struct bman_pool *pool);
+
+/**
+ * bman_update_pool_thresholds - Change the buffer pool's depletion thresholds
+ * @pool: the buffer pool object to which the thresholds will be set
+ * @thresholds: the new thresholds
+ */
+int bman_update_pool_thresholds(struct bman_pool *pool, const u32 *thresholds);
+#endif
+
+/**
+ * The below bman_p_***() variant might be called in a situation that the cpu
+ * which the portal affine to is not online yet.
+ * @bman_portal specifies which portal the API will use.
+*/
+int bman_p_irqsource_add(struct bman_portal *p, __maybe_unused u32 bits);
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* FSL_BMAN_H */
diff --git a/include/linux/fsl_ifc.h b/include/linux/fsl_ifc.h
index 0af96a45e..d8c1908c6 100644
--- a/include/linux/fsl_ifc.h
+++ b/include/linux/fsl_ifc.h
@@ -846,6 +846,11 @@ struct fsl_ifc_ctrl {
 	u32 nand_stat;
 	wait_queue_head_t nand_wait;
 	bool little_endian;
+#ifdef CONFIG_PM_SLEEP
+	/*save regs when system goes to deep sleep*/
+	struct fsl_ifc_global		*saved_gregs;
+	struct fsl_ifc_runtime		*saved_rregs;
+#endif
 };
 
 extern struct fsl_ifc_ctrl *fsl_ifc_ctrl_dev;
diff --git a/include/linux/fsl_qman.h b/include/linux/fsl_qman.h
new file mode 100644
index 000000000..e39a17c2b
--- /dev/null
+++ b/include/linux/fsl_qman.h
@@ -0,0 +1,3910 @@
+/* Copyright 2008-2012 Freescale Semiconductor, Inc.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef FSL_QMAN_H
+#define FSL_QMAN_H
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/* Last updated for v00.800 of the BG */
+
+/* Hardware constants */
+#define QM_CHANNEL_SWPORTAL0 0
+#define QMAN_CHANNEL_POOL1 0x21
+#define QMAN_CHANNEL_CAAM 0x80
+#define QMAN_CHANNEL_PME 0xa0
+#define QMAN_CHANNEL_POOL1_REV3 0x401
+#define QMAN_CHANNEL_CAAM_REV3 0x840
+#define QMAN_CHANNEL_PME_REV3 0x860
+#define QMAN_CHANNEL_DCE 0x8a0
+#define QMAN_CHANNEL_DCE_QMANREV312 0x880
+extern u16 qm_channel_pool1;
+extern u16 qm_channel_caam;
+extern u16 qm_channel_pme;
+extern u16 qm_channel_dce;
+enum qm_dc_portal {
+	qm_dc_portal_fman0 = 0,
+	qm_dc_portal_fman1 = 1,
+	qm_dc_portal_caam = 2,
+	qm_dc_portal_pme = 3,
+	qm_dc_portal_rman = 4,
+	qm_dc_portal_dce = 5
+};
+
+/* Portal processing (interrupt) sources */
+#define QM_PIRQ_CCSCI	0x00200000	/* CEETM Congestion State Change */
+#define QM_PIRQ_CSCI	0x00100000	/* Congestion State Change */
+#define QM_PIRQ_EQCI	0x00080000	/* Enqueue Command Committed */
+#define QM_PIRQ_EQRI	0x00040000	/* EQCR Ring (below threshold) */
+#define QM_PIRQ_DQRI	0x00020000	/* DQRR Ring (non-empty) */
+#define QM_PIRQ_MRI	0x00010000	/* MR Ring (non-empty) */
+/* This mask contains all the interrupt sources that need handling except DQRI,
+ * ie. that if present should trigger slow-path processing. */
+#define QM_PIRQ_SLOW	(QM_PIRQ_CSCI | QM_PIRQ_EQCI | QM_PIRQ_EQRI | \
+			QM_PIRQ_MRI | QM_PIRQ_CCSCI)
+
+/* --- Clock speed --- */
+/* A qman driver instance may or may not know the current qman clock speed.
+ * However, certain CEETM calculations may not be possible if this is not known.
+ * The 'set' function will only succeed (return zero) if the driver did not
+ * already know the clock speed. Likewise, the 'get' function will only succeed
+ * if the driver does know the clock speed (either because it knew when booting,
+ * or was told via 'set'). In cases where software is running on a driver
+ * instance that does not know the clock speed (eg. on a hypervised data-plane),
+ * and the user can obtain the current qman clock speed by other means (eg. from
+ * a message sent from the control-plane), then the 'set' function can be used
+ * to enable rate-calculations in a driver where it would otherwise not be
+ * possible. */
+int qm_get_clock(u64 *clock_hz);
+int qm_set_clock(u64 clock_hz);
+
+/* For qman_static_dequeue_*** APIs */
+#define QM_SDQCR_CHANNELS_POOL_MASK	0x00007fff
+/* for n in [1,15] */
+#define QM_SDQCR_CHANNELS_POOL(n)	(0x00008000 >> (n))
+/* for conversion from n of qm_channel */
+static inline u32 QM_SDQCR_CHANNELS_POOL_CONV(u16 channel)
+{
+	return QM_SDQCR_CHANNELS_POOL(channel + 1 - qm_channel_pool1);
+}
+
+/* For qman_volatile_dequeue(); Choose one PRECEDENCE. EXACT is optional. Use
+ * NUMFRAMES(n) (6-bit) or NUMFRAMES_TILLEMPTY to fill in the frame-count. Use
+ * FQID(n) to fill in the frame queue ID. */
+#define QM_VDQCR_PRECEDENCE_VDQCR	0x0
+#define QM_VDQCR_PRECEDENCE_SDQCR	0x80000000
+#define QM_VDQCR_EXACT			0x40000000
+#define QM_VDQCR_NUMFRAMES_MASK		0x3f000000
+#define QM_VDQCR_NUMFRAMES_SET(n)	(((n) & 0x3f) << 24)
+#define QM_VDQCR_NUMFRAMES_GET(n)	(((n) >> 24) & 0x3f)
+#define QM_VDQCR_NUMFRAMES_TILLEMPTY	QM_VDQCR_NUMFRAMES_SET(0)
+
+
+/* ------------------------------------------------------- */
+/* --- Qman data structures (and associated constants) --- */
+
+/* Represents s/w corenet portal mapped data structures */
+struct qm_eqcr_entry;	/* EQCR (EnQueue Command Ring) entries */
+struct qm_dqrr_entry;	/* DQRR (DeQueue Response Ring) entries */
+struct qm_mr_entry;	/* MR (Message Ring) entries */
+struct qm_mc_command;	/* MC (Management Command) command */
+struct qm_mc_result;	/* MC result */
+
+/* See David Lapp's "Frame formats" document, "dpateam", Jan 07, 2008 */
+#define QM_FD_FORMAT_SG		0x4
+#define QM_FD_FORMAT_LONG	0x2
+#define QM_FD_FORMAT_COMPOUND	0x1
+enum qm_fd_format {
+	/* 'contig' implies a contiguous buffer, whereas 'sg' implies a
+	 * scatter-gather table. 'big' implies a 29-bit length with no offset
+	 * field, otherwise length is 20-bit and offset is 9-bit. 'compound'
+	 * implies a s/g-like table, where each entry itself represents a frame
+	 * (contiguous or scatter-gather) and the 29-bit "length" is
+	 * interpreted purely for congestion calculations, ie. a "congestion
+	 * weight". */
+	qm_fd_contig = 0,
+	qm_fd_contig_big = QM_FD_FORMAT_LONG,
+	qm_fd_sg = QM_FD_FORMAT_SG,
+	qm_fd_sg_big = QM_FD_FORMAT_SG | QM_FD_FORMAT_LONG,
+	qm_fd_compound = QM_FD_FORMAT_COMPOUND
+};
+
+/* Capitalised versions are un-typed but can be used in static expressions */
+#define QM_FD_CONTIG	0
+#define QM_FD_CONTIG_BIG QM_FD_FORMAT_LONG
+#define QM_FD_SG	QM_FD_FORMAT_SG
+#define QM_FD_SG_BIG	(QM_FD_FORMAT_SG | QM_FD_FORMAT_LONG)
+#define QM_FD_COMPOUND	QM_FD_FORMAT_COMPOUND
+
+/* See 1.5.1.1: "Frame Descriptor (FD)" */
+struct qm_fd {
+	union {
+		struct {
+#if __BYTE_ORDER__ == __ORDER_BIG_ENDIAN__
+			u8 dd:2;	/* dynamic debug */
+			u8 liodn_offset:6;
+			u8 bpid:8;	/* Buffer Pool ID */
+			u8 eliodn_offset:4;
+			u8 __reserved:4;
+			u8 addr_hi;	/* high 8-bits of 40-bit address */
+			u32 addr_lo;	/* low 32-bits of 40-bit address */
+#else
+			u32 addr_lo;    /* low 32-bits of 40-bit address */
+			u8 addr_hi;     /* high 8-bits of 40-bit address */
+			u8 __reserved:4;
+			u8 eliodn_offset:4;
+			u8 bpid:8;      /* Buffer Pool ID */
+			u8 liodn_offset:6;
+			u8 dd:2;        /* dynamic debug */
+#endif
+		};
+		struct {
+#if __BYTE_ORDER__ == __ORDER_BIG_ENDIAN__
+			u64 __notaddress:24;
+			u64 addr:40;
+#else
+			u64 addr:40;
+			u64 __notaddress:24;
+#endif
+		};
+		u64 opaque_addr;
+	};
+	/* The 'format' field indicates the interpretation of the remaining 29
+	 * bits of the 32-bit word. For packing reasons, it is duplicated in the
+	 * other union elements. Note, union'd structs are difficult to use with
+	 * static initialisation under gcc, in which case use the "opaque" form
+	 * with one of the macros. */
+	union {
+		/* For easier/faster copying of this part of the fd (eg. from a
+		 * DQRR entry to an EQCR entry) copy 'opaque' */
+		u32 opaque;
+		/* If 'format' is _contig or _sg, 20b length and 9b offset */
+		struct {
+#if __BYTE_ORDER__ == __ORDER_BIG_ENDIAN__
+			enum qm_fd_format format:3;
+			u16 offset:9;
+			u32 length20:20;
+#else
+			u32 length20:20;
+			u16 offset:9;
+			enum qm_fd_format format:3;
+#endif
+		};
+		/* If 'format' is _contig_big or _sg_big, 29b length */
+		struct {
+#if __BYTE_ORDER__ == __ORDER_BIG_ENDIAN__
+			enum qm_fd_format _format1:3;
+			u32 length29:29;
+#else
+			u32 length29:29;
+			enum qm_fd_format _format1:3;
+#endif
+		};
+		/* If 'format' is _compound, 29b "congestion weight" */
+		struct {
+#if __BYTE_ORDER__ == __ORDER_BIG_ENDIAN__
+			enum qm_fd_format _format2:3;
+			u32 cong_weight:29;
+#else
+			u32 cong_weight:29;
+			enum qm_fd_format _format2:3;
+#endif
+		};
+	};
+	union {
+		u32 cmd;
+		u32 status;
+	};
+} __aligned(8);
+#define QM_FD_DD_NULL		0x00
+#define QM_FD_PID_MASK		0x3f
+static inline u64 qm_fd_addr_get64(const struct qm_fd *fd)
+{
+	return fd->addr;
+}
+
+static inline dma_addr_t qm_fd_addr(const struct qm_fd *fd)
+{
+	return (dma_addr_t)fd->addr;
+}
+/* Macro, so we compile better if 'v' isn't always 64-bit */
+#define qm_fd_addr_set64(fd, v) \
+	do { \
+		struct qm_fd *__fd931 = (fd); \
+		__fd931->addr = v; \
+	} while (0)
+
+/* For static initialisation of FDs (which is complicated by the use of unions
+ * in "struct qm_fd"), use the following macros. Note that;
+ * - 'dd', 'pid' and 'bpid' are ignored because there's no static initialisation
+ *   use-case),
+ * - use capitalised QM_FD_*** formats for static initialisation.
+ */
+#define QM_FD_FMT_20(cmd, addr_hi, addr_lo, fmt, off, len) \
+	{ 0, 0, 0, 0, 0, addr_hi, addr_lo, \
+	{ (((fmt)&0x7) << 29) | (((off)&0x1ff) << 20) | ((len)&0xfffff) }, \
+	{ cmd } }
+#define QM_FD_FMT_29(cmd, addr_hi, addr_lo, fmt, len) \
+	{ 0, 0, 0, 0, 0, addr_hi, addr_lo, \
+	{ (((fmt)&0x7) << 29) | ((len)&0x1fffffff) }, \
+	{ cmd } }
+
+/* See 2.2.1.3 Multi-Core Datapath Acceleration Architecture */
+#define QM_SG_OFFSET_MASK 0x1FFF
+struct qm_sg_entry {
+	union {
+		struct {
+#if __BYTE_ORDER__ == __ORDER_BIG_ENDIAN__
+			u8 __reserved1[3];
+			u8 addr_hi;	/* high 8-bits of 40-bit address */
+			u32 addr_lo;	/* low 32-bits of 40-bit address */
+#else
+			u32 addr_lo;	/* low 32-bits of 40-bit address */
+			u8 addr_hi;	/* high 8-bits of 40-bit address */
+			u8 __reserved1[3];
+#endif
+		};
+		struct {
+#if __BYTE_ORDER__ == __ORDER_BIG_ENDIAN__
+			u64 __notaddress:24;
+			u64 addr:40;
+#else
+			u64 addr:40;
+			u64 __notaddress:24;
+#endif
+		};
+		u64 opaque;
+	};
+	union {
+		struct {
+#if __BYTE_ORDER__ == __ORDER_BIG_ENDIAN__
+			u32 extension:1;	/* Extension bit */
+			u32 final:1;		/* Final bit */
+			u32 length:30;
+#else
+			u32 length:30;
+			u32 final:1;            /* Final bit */
+			u32 extension:1;        /* Extension bit */
+#endif
+		};
+		u32 sgt_efl;
+	};
+	u8 __reserved2;
+	u8 bpid;
+	union {
+		struct {
+#if __BYTE_ORDER__ == __ORDER_BIG_ENDIAN__
+			u16 __reserved3:3;
+			u16 offset:13;
+#else
+			u16 offset:13;
+			u16 __reserved3:3;
+#endif
+		};
+		u16 opaque_offset;
+	};
+} __packed;
+union qm_sg_efl {
+	struct {
+#if __BYTE_ORDER__ == __ORDER_BIG_ENDIAN__
+		u32 extension:1;	/* Extension bit */
+		u32 final:1;		/* Final bit */
+		u32 length:30;
+#else
+		u32 length:30;
+		u32 final:1;            /* Final bit */
+		u32 extension:1;        /* Extension bit */
+#endif
+	};
+	u32 efl;
+};
+static inline dma_addr_t qm_sg_addr(const struct qm_sg_entry *sg)
+{
+	return (dma_addr_t)be64_to_cpu(sg->opaque) & 0xffffffffffULL;
+}
+static inline u8 qm_sg_entry_get_ext(const struct qm_sg_entry *sg)
+{
+	union qm_sg_efl u;
+
+	u.efl = be32_to_cpu(sg->sgt_efl);
+	return u.extension;
+}
+static inline u8 qm_sg_entry_get_final(const struct qm_sg_entry *sg)
+{
+	union qm_sg_efl u;
+
+	u.efl = be32_to_cpu(sg->sgt_efl);
+	return u.final;
+}
+static inline u32 qm_sg_entry_get_len(const struct qm_sg_entry *sg)
+{
+	union qm_sg_efl u;
+
+	u.efl = be32_to_cpu(sg->sgt_efl);
+	return u.length;
+}
+static inline u8 qm_sg_entry_get_bpid(const struct qm_sg_entry *sg)
+{
+	return sg->bpid;
+}
+static inline u16 qm_sg_entry_get_offset(const struct qm_sg_entry *sg)
+{
+	u32 opaque_offset = be16_to_cpu(sg->opaque_offset);
+
+	return opaque_offset & 0x1fff;
+}
+
+/* Macro, so we compile better if 'v' isn't always 64-bit */
+#define qm_sg_entry_set64(sg, v) \
+	do { \
+		struct qm_sg_entry *__sg931 = (sg); \
+		__sg931->opaque = cpu_to_be64(v); \
+	} while (0)
+#define qm_sg_entry_set_ext(sg, v) \
+	do { \
+		union qm_sg_efl __u932; \
+		__u932.efl = be32_to_cpu((sg)->sgt_efl); \
+		__u932.extension = v; \
+		(sg)->sgt_efl = cpu_to_be32(__u932.efl); \
+	} while (0)
+#define qm_sg_entry_set_final(sg, v) \
+	do { \
+		union qm_sg_efl __u933; \
+		__u933.efl = be32_to_cpu((sg)->sgt_efl); \
+		__u933.final = v; \
+		(sg)->sgt_efl = cpu_to_be32(__u933.efl); \
+	} while (0)
+#define qm_sg_entry_set_len(sg, v) \
+	do { \
+		union qm_sg_efl __u934; \
+		__u934.efl = be32_to_cpu((sg)->sgt_efl); \
+		__u934.length = v; \
+		(sg)->sgt_efl = cpu_to_be32(__u934.efl); \
+	} while (0)
+#define qm_sg_entry_set_bpid(sg, v) \
+	do { \
+		struct qm_sg_entry *__u935 = (sg); \
+		__u935->bpid = v; \
+	} while (0)
+#define qm_sg_entry_set_offset(sg, v) \
+	do { \
+		struct qm_sg_entry *__u936 = (sg); \
+		__u936->opaque_offset = cpu_to_be16(v); \
+	} while (0)
+
+/* See 1.5.8.1: "Enqueue Command" */
+struct qm_eqcr_entry {
+	u8 __dont_write_directly__verb;
+	u8 dca;
+	u16 seqnum;
+	u32 orp;	/* 24-bit */
+	u32 fqid;	/* 24-bit */
+	u32 tag;
+	struct qm_fd fd;
+	u8 __reserved3[32];
+} __packed;
+#define QM_EQCR_VERB_VBIT		0x80
+#define QM_EQCR_VERB_CMD_MASK		0x61	/* but only one value; */
+#define QM_EQCR_VERB_CMD_ENQUEUE	0x01
+#define QM_EQCR_VERB_COLOUR_MASK	0x18	/* 4 possible values; */
+#define QM_EQCR_VERB_COLOUR_GREEN	0x00
+#define QM_EQCR_VERB_COLOUR_YELLOW	0x08
+#define QM_EQCR_VERB_COLOUR_RED		0x10
+#define QM_EQCR_VERB_COLOUR_OVERRIDE	0x18
+#define QM_EQCR_VERB_INTERRUPT		0x04	/* on command consumption */
+#define QM_EQCR_VERB_ORP		0x02	/* enable order restoration */
+#define QM_EQCR_DCA_ENABLE		0x80
+#define QM_EQCR_DCA_PARK		0x40
+#define QM_EQCR_DCA_IDXMASK		0x0f	/* "DQRR::idx" goes here */
+#define QM_EQCR_SEQNUM_NESN		0x8000	/* Advance NESN */
+#define QM_EQCR_SEQNUM_NLIS		0x4000	/* More fragments to come */
+#define QM_EQCR_SEQNUM_SEQMASK		0x3fff	/* sequence number goes here */
+#define QM_EQCR_FQID_NULL		0	/* eg. for an ORP seqnum hole */
+
+/* See 1.5.8.2: "Frame Dequeue Response" */
+struct qm_dqrr_entry {
+	u8 verb;
+	u8 stat;
+	u16 seqnum;	/* 15-bit */
+	u8 tok;
+	u8 __reserved2[3];
+	u32 fqid;	/* 24-bit */
+	u32 contextB;
+	struct qm_fd fd;
+	u8 __reserved4[32];
+};
+#define QM_DQRR_VERB_VBIT		0x80
+#define QM_DQRR_VERB_MASK		0x7f	/* where the verb contains; */
+#define QM_DQRR_VERB_FRAME_DEQUEUE	0x60	/* "this format" */
+#define QM_DQRR_STAT_FQ_EMPTY		0x80	/* FQ empty */
+#define QM_DQRR_STAT_FQ_HELDACTIVE	0x40	/* FQ held active */
+#define QM_DQRR_STAT_FQ_FORCEELIGIBLE	0x20	/* FQ was force-eligible'd */
+#define QM_DQRR_STAT_FD_VALID		0x10	/* has a non-NULL FD */
+#define QM_DQRR_STAT_UNSCHEDULED	0x02	/* Unscheduled dequeue */
+#define QM_DQRR_STAT_DQCR_EXPIRED	0x01	/* VDQCR or PDQCR expired*/
+
+/* See 1.5.8.3: "ERN Message Response" */
+/* See 1.5.8.4: "FQ State Change Notification" */
+struct qm_mr_entry {
+	u8 verb;
+	union {
+		struct {
+			u8 dca;
+			u16 seqnum;
+			u8 rc;		/* Rejection Code */
+			u32 orp:24;
+			u32 fqid;	/* 24-bit */
+			u32 tag;
+			struct qm_fd fd;
+		} __packed ern;
+		struct {
+#if __BYTE_ORDER__ == __ORDER_BIG_ENDIAN__
+			u8 colour:2;	/* See QM_MR_DCERN_COLOUR_* */
+			u8 __reserved1:3;
+			enum qm_dc_portal portal:3;
+#else
+			enum qm_dc_portal portal:3;
+			u8 __reserved1:3;
+			u8 colour:2;	/* See QM_MR_DCERN_COLOUR_* */
+#endif
+			u16 __reserved2;
+			u8 rc;		/* Rejection Code */
+			u32 __reserved3:24;
+			u32 fqid;	/* 24-bit */
+			u32 tag;
+			struct qm_fd fd;
+		} __packed dcern;
+		struct {
+			u8 fqs;		/* Frame Queue Status */
+			u8 __reserved1[6];
+			u32 fqid;	/* 24-bit */
+			u32 contextB;
+			u8 __reserved2[16];
+		} __packed fq;		/* FQRN/FQRNI/FQRL/FQPN */
+	};
+	u8 __reserved2[32];
+} __packed;
+#define QM_MR_VERB_VBIT			0x80
+/* The "ern" VERB bits match QM_EQCR_VERB_*** so aren't reproduced here. ERNs
+ * originating from direct-connect portals ("dcern") use 0x20 as a verb which
+ * would be invalid as a s/w enqueue verb. A s/w ERN can be distinguished from
+ * the other MR types by noting if the 0x20 bit is unset. */
+#define QM_MR_VERB_TYPE_MASK		0x27
+#define QM_MR_VERB_DC_ERN		0x20
+#define QM_MR_VERB_FQRN			0x21
+#define QM_MR_VERB_FQRNI		0x22
+#define QM_MR_VERB_FQRL			0x23
+#define QM_MR_VERB_FQPN			0x24
+#define QM_MR_RC_MASK			0xf0	/* contains one of; */
+#define QM_MR_RC_CGR_TAILDROP		0x00
+#define QM_MR_RC_WRED			0x10
+#define QM_MR_RC_ERROR			0x20
+#define QM_MR_RC_ORPWINDOW_EARLY	0x30
+#define QM_MR_RC_ORPWINDOW_LATE		0x40
+#define QM_MR_RC_FQ_TAILDROP		0x50
+#define QM_MR_RC_ORPWINDOW_RETIRED	0x60
+#define QM_MR_RC_ORP_ZERO		0x70
+#define QM_MR_FQS_ORLPRESENT		0x02	/* ORL fragments to come */
+#define QM_MR_FQS_NOTEMPTY		0x01	/* FQ has enqueued frames */
+#define QM_MR_DCERN_COLOUR_GREEN	0x00
+#define QM_MR_DCERN_COLOUR_YELLOW	0x01
+#define QM_MR_DCERN_COLOUR_RED		0x02
+#define QM_MR_DCERN_COLOUR_OVERRIDE	0x03
+
+/* An identical structure of FQD fields is present in the "Init FQ" command and
+ * the "Query FQ" result, it's suctioned out into the "struct qm_fqd" type.
+ * Within that, the 'stashing' and 'taildrop' pieces are also factored out, the
+ * latter has two inlines to assist with converting to/from the mant+exp
+ * representation. */
+struct qm_fqd_stashing {
+	/* See QM_STASHING_EXCL_<...> */
+#if __BYTE_ORDER__ == __ORDER_BIG_ENDIAN__
+	u8 exclusive;
+	u8 __reserved1:2;
+	/* Numbers of cachelines */
+	u8 annotation_cl:2;
+	u8 data_cl:2;
+	u8 context_cl:2;
+#else
+	u8 context_cl:2;
+	u8 data_cl:2;
+	u8 annotation_cl:2;
+	u8 __reserved1:2;
+	u8 exclusive;
+#endif
+} __packed;
+struct qm_fqd_taildrop {
+#if __BYTE_ORDER__ == __ORDER_BIG_ENDIAN__
+	u16 __reserved1:3;
+	u16 mant:8;
+	u16 exp:5;
+#else
+	u16 exp:5;
+	u16 mant:8;
+	u16 __reserved1:3;
+#endif
+} __packed;
+struct qm_fqd_oac {
+	/* See QM_OAC_<...> */
+#if __BYTE_ORDER__ == __ORDER_BIG_ENDIAN__
+	u8 oac:2; /* "Overhead Accounting Control" */
+	u8 __reserved1:6;
+#else
+	u8 __reserved1:6;
+	u8 oac:2; /* "Overhead Accounting Control" */
+#endif
+	/* Two's-complement value (-128 to +127) */
+	signed char oal; /* "Overhead Accounting Length" */
+} __packed;
+struct qm_fqd {
+	union {
+		u8 orpc;
+		struct {
+#if __BYTE_ORDER__ == __ORDER_BIG_ENDIAN__
+			u8 __reserved1:2;
+			u8 orprws:3;
+			u8 oa:1;
+			u8 olws:2;
+#else
+			u8 olws:2;
+			u8 oa:1;
+			u8 orprws:3;
+			u8 __reserved1:2;
+#endif
+		} __packed;
+	};
+	u8 cgid;
+	u16 fq_ctrl;	/* See QM_FQCTRL_<...> */
+	union {
+		u16 dest_wq;
+		struct {
+#if __BYTE_ORDER__ == __ORDER_BIG_ENDIAN__
+			u16 channel:13; /* qm_channel */
+			u16 wq:3;
+#else
+			u16 wq:3;
+			u16 channel:13; /* qm_channel */
+#endif
+		} __packed dest;
+	};
+#if __BYTE_ORDER__ == __ORDER_BIG_ENDIAN__
+	u16 __reserved2:1;
+	u16 ics_cred:15;
+#else
+	u16 __reserved2:1;
+	u16 ics_cred:15;
+#endif
+	/* For "Initialize Frame Queue" commands, the write-enable mask
+	 * determines whether 'td' or 'oac_init' is observed. For query
+	 * commands, this field is always 'td', and 'oac_query' (below) reflects
+	 * the Overhead ACcounting values. */
+	union {
+		struct qm_fqd_taildrop td;
+		struct qm_fqd_oac oac_init;
+	};
+	u32 context_b;
+	union {
+		/* Treat it as 64-bit opaque */
+		u64 opaque;
+		struct {
+#if __BYTE_ORDER__ == __ORDER_BIG_ENDIAN__
+			u32 hi;
+			u32 lo;
+#else
+			u32 lo;
+			u32 hi;
+#endif
+		};
+		/* Treat it as s/w portal stashing config */
+		/* See 1.5.6.7.1: "FQD Context_A field used for [...] */
+		struct {
+#if __BYTE_ORDER__ == __ORDER_BIG_ENDIAN__
+			struct qm_fqd_stashing stashing;
+			/* 48-bit address of FQ context to
+			 * stash, must be cacheline-aligned */
+			u16 context_hi;
+			u32 context_lo;
+#else
+			u32 context_lo;
+			u16 context_hi;
+			struct qm_fqd_stashing stashing;
+#endif
+		} __packed;
+	} context_a;
+	struct qm_fqd_oac oac_query;
+} __packed;
+/* 64-bit converters for context_hi/lo */
+static inline u64 qm_fqd_stashing_get64(const struct qm_fqd *fqd)
+{
+	return ((u64)fqd->context_a.context_hi << 32) |
+		(u64)fqd->context_a.context_lo;
+}
+static inline dma_addr_t qm_fqd_stashing_addr(const struct qm_fqd *fqd)
+{
+	return (dma_addr_t)qm_fqd_stashing_get64(fqd);
+}
+static inline u64 qm_fqd_context_a_get64(const struct qm_fqd *fqd)
+{
+	return ((u64)fqd->context_a.hi << 32) |
+		(u64)fqd->context_a.lo;
+}
+/* Macro, so we compile better when 'v' isn't necessarily 64-bit */
+#define qm_fqd_stashing_set64(fqd, v) \
+	do { \
+		struct qm_fqd *__fqd931 = (fqd); \
+		__fqd931->context_a.context_hi = upper_32_bits(v); \
+		__fqd931->context_a.context_lo = lower_32_bits(v); \
+	} while (0)
+#define qm_fqd_context_a_set64(fqd, v) \
+	do { \
+		struct qm_fqd *__fqd931 = (fqd); \
+		__fqd931->context_a.hi = upper_32_bits(v); \
+		__fqd931->context_a.lo = lower_32_bits(v); \
+	} while (0)
+/* convert a threshold value into mant+exp representation */
+static inline int qm_fqd_taildrop_set(struct qm_fqd_taildrop *td, u32 val,
+					int roundup)
+{
+	u32 e = 0;
+	int oddbit = 0;
+	if (val > 0xe0000000)
+		return -ERANGE;
+	while (val > 0xff) {
+		oddbit = val & 1;
+		val >>= 1;
+		e++;
+		if (roundup && oddbit)
+			val++;
+	}
+	td->exp = e;
+	td->mant = val;
+	return 0;
+}
+/* and the other direction */
+static inline u32 qm_fqd_taildrop_get(const struct qm_fqd_taildrop *td)
+{
+	return (u32)td->mant << td->exp;
+}
+
+/* See 1.5.2.2: "Frame Queue Descriptor (FQD)" */
+/* Frame Queue Descriptor (FQD) field 'fq_ctrl' uses these constants */
+#define QM_FQCTRL_MASK		0x07ff	/* 'fq_ctrl' flags; */
+#define QM_FQCTRL_CGE		0x0400	/* Congestion Group Enable */
+#define QM_FQCTRL_TDE		0x0200	/* Tail-Drop Enable */
+#define QM_FQCTRL_ORP		0x0100	/* ORP Enable */
+#define QM_FQCTRL_CTXASTASHING	0x0080	/* Context-A stashing */
+#define QM_FQCTRL_CPCSTASH	0x0040	/* CPC Stash Enable */
+#define QM_FQCTRL_FORCESFDR	0x0008	/* High-priority SFDRs */
+#define QM_FQCTRL_AVOIDBLOCK	0x0004	/* Don't block active */
+#define QM_FQCTRL_HOLDACTIVE	0x0002	/* Hold active in portal */
+#define QM_FQCTRL_PREFERINCACHE	0x0001	/* Aggressively cache FQD */
+#define QM_FQCTRL_LOCKINCACHE	QM_FQCTRL_PREFERINCACHE /* older naming */
+
+/* See 1.5.6.7.1: "FQD Context_A field used for [...] */
+/* Frame Queue Descriptor (FQD) field 'CONTEXT_A' uses these constants */
+#define QM_STASHING_EXCL_ANNOTATION	0x04
+#define QM_STASHING_EXCL_DATA		0x02
+#define QM_STASHING_EXCL_CTX		0x01
+
+/* See 1.5.5.3: "Intra Class Scheduling" */
+/* FQD field 'OAC' (Overhead ACcounting) uses these constants */
+#define QM_OAC_ICS		0x2 /* Accounting for Intra-Class Scheduling */
+#define QM_OAC_CG		0x1 /* Accounting for Congestion Groups */
+
+/* See 1.5.8.4: "FQ State Change Notification" */
+/* This struct represents the 32-bit "WR_PARM_[GYR]" parameters in CGR fields
+ * and associated commands/responses. The WRED parameters are calculated from
+ * these fields as follows;
+ *   MaxTH = MA * (2 ^ Mn)
+ *   Slope = SA / (2 ^ Sn)
+ *    MaxP = 4 * (Pn + 1)
+ */
+struct qm_cgr_wr_parm {
+	union {
+		u32 word;
+		struct {
+#if __BYTE_ORDER__ == __ORDER_BIG_ENDIAN__
+			u32 MA:8;
+			u32 Mn:5;
+			u32 SA:7; /* must be between 64-127 */
+			u32 Sn:6;
+			u32 Pn:6;
+#else
+			u32 Pn:6;
+			u32 Sn:6;
+			u32 SA:7; /* must be between 64-127 */
+			u32 Mn:5;
+			u32 MA:8;
+#endif
+		} __packed;
+	};
+} __packed;
+/* This struct represents the 13-bit "CS_THRES" CGR field. In the corresponding
+ * management commands, this is padded to a 16-bit structure field, so that's
+ * how we represent it here. The congestion state threshold is calculated from
+ * these fields as follows;
+ *   CS threshold = TA * (2 ^ Tn)
+ */
+struct qm_cgr_cs_thres {
+	union {
+		u16 hword;
+		struct {
+#if __BYTE_ORDER__ == __ORDER_BIG_ENDIAN__
+			u16 __reserved:3;
+			u16 TA:8;
+			u16 Tn:5;
+#else
+			u16 Tn:5;
+			u16 TA:8;
+			u16 __reserved:3;
+#endif
+		} __packed;
+	};
+} __packed;
+/* This identical structure of CGR fields is present in the "Init/Modify CGR"
+ * commands and the "Query CGR" result. It's suctioned out here into its own
+ * struct. */
+struct __qm_mc_cgr {
+	struct qm_cgr_wr_parm wr_parm_g;
+	struct qm_cgr_wr_parm wr_parm_y;
+	struct qm_cgr_wr_parm wr_parm_r;
+	u8 wr_en_g;	/* boolean, use QM_CGR_EN */
+	u8 wr_en_y;	/* boolean, use QM_CGR_EN */
+	u8 wr_en_r;	/* boolean, use QM_CGR_EN */
+	u8 cscn_en;	/* boolean, use QM_CGR_EN */
+	union {
+		struct {
+#if __BYTE_ORDER__ == __ORDER_BIG_ENDIAN__
+			u16 cscn_targ_upd_ctrl; /* use QM_CSCN_TARG_UDP_ */
+			u16 cscn_targ_dcp_low;  /* CSCN_TARG_DCP low-16bits */
+#else
+			u16 cscn_targ_dcp_low;  /* CSCN_TARG_DCP low-16bits */
+			u16 cscn_targ_upd_ctrl; /* use QM_CSCN_TARG_UDP_ */
+#endif
+		};
+		u32 cscn_targ;	/* use QM_CGR_TARG_* */
+	};
+	u8 cstd_en;	/* boolean, use QM_CGR_EN */
+	u8 cs;		/* boolean, only used in query response */
+	union {
+		/* use qm_cgr_cs_thres_set64() */
+		struct qm_cgr_cs_thres cs_thres;
+		u16 __cs_thres;
+	};
+	u8 mode;	/* QMAN_CGR_MODE_FRAME not supported in rev1.0 */
+} __packed;
+#define QM_CGR_EN		0x01 /* For wr_en_*, cscn_en, cstd_en */
+#define QM_CGR_TARG_UDP_CTRL_WRITE_BIT	0x8000 /* value written to portal bit*/
+#define QM_CGR_TARG_UDP_CTRL_DCP	0x4000 /* 0: SWP, 1: DCP */
+#define QM_CGR_TARG_PORTAL(n)	(0x80000000 >> (n)) /* s/w portal, 0-9 */
+#define QM_CGR_TARG_FMAN0	0x00200000 /* direct-connect portal: fman0 */
+#define QM_CGR_TARG_FMAN1	0x00100000 /*                      : fman1 */
+/* Convert CGR thresholds to/from "cs_thres" format */
+static inline u64 qm_cgr_cs_thres_get64(const struct qm_cgr_cs_thres *th)
+{
+	return (u64)th->TA << th->Tn;
+}
+static inline int qm_cgr_cs_thres_set64(struct qm_cgr_cs_thres *th, u64 val,
+					int roundup)
+{
+	u32 e = 0;
+	int oddbit = 0;
+	while (val > 0xff) {
+		oddbit = val & 1;
+		val >>= 1;
+		e++;
+		if (roundup && oddbit)
+			val++;
+	}
+	th->Tn = e;
+	th->TA = val;
+	return 0;
+}
+
+/* See 1.5.8.5.1: "Initialize FQ" */
+/* See 1.5.8.5.2: "Query FQ" */
+/* See 1.5.8.5.3: "Query FQ Non-Programmable Fields" */
+/* See 1.5.8.5.4: "Alter FQ State Commands " */
+/* See 1.5.8.6.1: "Initialize/Modify CGR" */
+/* See 1.5.8.6.2: "CGR Test Write" */
+/* See 1.5.8.6.3: "Query CGR" */
+/* See 1.5.8.6.4: "Query Congestion Group State" */
+struct qm_mcc_initfq {
+	u8 __reserved1;
+	u16 we_mask;	/* Write Enable Mask */
+	u32 fqid;	/* 24-bit */
+	u16 count;	/* Initialises 'count+1' FQDs */
+	struct qm_fqd fqd; /* the FQD fields go here */
+	u8 __reserved3[30];
+} __packed;
+struct qm_mcc_queryfq {
+	u8 __reserved1[3];
+	u32 fqid;	/* 24-bit */
+	u8 __reserved2[56];
+} __packed;
+struct qm_mcc_queryfq_np {
+	u8 __reserved1[3];
+	u32 fqid;	/* 24-bit */
+	u8 __reserved2[56];
+} __packed;
+struct qm_mcc_alterfq {
+	u8 __reserved1[3];
+	u32 fqid;	/* 24-bit */
+	u8 __reserved2;
+	u8 count;	/* number of consecutive FQID */
+	u8 __reserved3[10];
+	u32 context_b;	/* frame queue context b */
+	u8 __reserved4[40];
+} __packed;
+struct qm_mcc_initcgr {
+	u8 __reserved1;
+	u16 we_mask;	/* Write Enable Mask */
+	struct __qm_mc_cgr cgr;	/* CGR fields */
+	u8 __reserved2[2];
+	u8 cgid;
+	u8 __reserved4[32];
+} __packed;
+struct qm_mcc_cgrtestwrite {
+	u8 __reserved1[2];
+	u8 i_bcnt_hi:8;/* high 8-bits of 40-bit "Instant" */
+	u32 i_bcnt_lo;	/* low 32-bits of 40-bit */
+	u8 __reserved2[23];
+	u8 cgid;
+	u8 __reserved3[32];
+} __packed;
+struct qm_mcc_querycgr {
+	u8 __reserved1[30];
+	u8 cgid;
+	u8 __reserved2[32];
+} __packed;
+struct qm_mcc_querycongestion {
+	u8 __reserved[63];
+} __packed;
+struct qm_mcc_querywq {
+	u8 __reserved;
+	/* select channel if verb != QUERYWQ_DEDICATED */
+	union {
+		u16 channel_wq; /* ignores wq (3 lsbits) */
+		struct {
+#if __BYTE_ORDER__ == __ORDER_BIG_ENDIAN__
+			u16 id:13; /* qm_channel */
+			u16 __reserved1:3;
+#else
+			u16 __reserved1:3;
+			u16 id:13; /* qm_channel */
+#endif
+		} __packed channel;
+	};
+	u8 __reserved2[60];
+} __packed;
+
+struct qm_mcc_ceetm_lfqmt_config {
+	u8 __reserved1[4];
+	u32 lfqid:24;
+	u8 __reserved2[2];
+	u16 cqid;
+	u8 __reserved3[2];
+	u16 dctidx;
+	u8 __reserved4[48];
+} __packed;
+
+struct qm_mcc_ceetm_lfqmt_query {
+	u8 __reserved1[4];
+	u32 lfqid:24;
+	u8 __reserved2[56];
+} __packed;
+
+struct qm_mcc_ceetm_cq_config {
+	u8 __reserved1;
+	u16 cqid;
+	u8 dcpid;
+	u8 __reserved2;
+	u16 ccgid;
+	u8 __reserved3[56];
+} __packed;
+
+struct qm_mcc_ceetm_cq_query {
+	u8 __reserved1;
+	u16 cqid;
+	u8 dcpid;
+	u8 __reserved2[59];
+} __packed;
+
+struct qm_mcc_ceetm_dct_config {
+	u8 __reserved1;
+	u16 dctidx;
+	u8 dcpid;
+	u8 __reserved2[15];
+	u32 context_b;
+	u64 context_a;
+	u8 __reserved3[32];
+} __packed;
+
+struct qm_mcc_ceetm_dct_query {
+	u8 __reserved1;
+	u16 dctidx;
+	u8 dcpid;
+	u8 __reserved2[59];
+} __packed;
+
+struct qm_mcc_ceetm_class_scheduler_config {
+	u8 __reserved1;
+	u16 cqcid;
+	u8 dcpid;
+	u8 __reserved2[6];
+#if __BYTE_ORDER__ == __ORDER_BIG_ENDIAN__
+	u8 gpc_reserved:1;
+	u8 gpc_combine_flag:1;
+	u8 gpc_prio_b:3;
+	u8 gpc_prio_a:3;
+#else
+	u8 gpc_prio_a:3;
+	u8 gpc_prio_b:3;
+	u8 gpc_combine_flag:1;
+	u8 gpc_reserved:1;
+#endif
+	u16 crem;
+	u16 erem;
+	u8 w[8];
+	u8 __reserved3[40];
+} __packed;
+
+struct qm_mcc_ceetm_class_scheduler_query {
+	u8 __reserved1;
+	u16 cqcid;
+	u8 dcpid;
+	u8 __reserved2[59];
+} __packed;
+
+#define CEETM_COMMAND_CHANNEL_MAPPING	(0 << 12)
+#define CEETM_COMMAND_SP_MAPPING	(1 << 12)
+#define CEETM_COMMAND_CHANNEL_SHAPER	(2 << 12)
+#define CEETM_COMMAND_LNI_SHAPER	(3 << 12)
+#define CEETM_COMMAND_TCFC		(4 << 12)
+
+#define CEETM_CCGRID_MASK	0x01FF
+#define CEETM_CCGR_CM_CONFIGURE	(0 << 14)
+#define CEETM_CCGR_DN_CONFIGURE	(1 << 14)
+#define CEETM_CCGR_TEST_WRITE	(2 << 14)
+#define CEETM_CCGR_CM_QUERY	(0 << 14)
+#define CEETM_CCGR_DN_QUERY	(1 << 14)
+#define CEETM_CCGR_DN_QUERY_FLUSH	(2 << 14)
+#define CEETM_QUERY_CONGESTION_STATE (3 << 14)
+
+struct qm_mcc_ceetm_mapping_shaper_tcfc_config {
+	u8 __reserved1;
+	u16 cid;
+	u8 dcpid;
+	union {
+		struct {
+#if __BYTE_ORDER__ == __ORDER_BIG_ENDIAN__
+			u8 map_shaped:1;
+			u8 map_reserved:4;
+			u8 map_lni_id:3;
+#else
+			u8 map_lni_id:3;
+			u8 map_reserved:4;
+			u8 map_shaped:1;
+#endif
+			u8 __reserved2[58];
+		} __packed channel_mapping;
+		struct {
+#if __BYTE_ORDER__ == __ORDER_BIG_ENDIAN__
+			u8 map_reserved:5;
+			u8 map_lni_id:3;
+#else
+			u8 map_lni_id:3;
+			u8 map_reserved:5;
+#endif
+			u8 __reserved2[58];
+		} __packed sp_mapping;
+		struct {
+#if __BYTE_ORDER__ == __ORDER_BIG_ENDIAN__
+			u8 cpl:1;
+			u8 cpl_reserved:2;
+			u8 oal:5;
+#else
+			u8 oal:5;
+			u8 cpl_reserved:2;
+			u8 cpl:1;
+#endif
+			u32 crtcr:24;
+			u32 ertcr:24;
+			u16 crtbl;
+			u16 ertbl;
+			u8 mps;	/* This will be hardcoded by driver with 60 */
+			u8 __reserved2[47];
+		} __packed shaper_config;
+		struct {
+			u8 __reserved2[11];
+			u64 lnitcfcc;
+			u8 __reserved3[40];
+		} __packed tcfc_config;
+	};
+} __packed;
+
+struct qm_mcc_ceetm_mapping_shaper_tcfc_query {
+	u8 __reserved1;
+	u16 cid;
+	u8 dcpid;
+	u8 __reserved2[59];
+} __packed;
+
+struct qm_mcc_ceetm_ccgr_config {
+	u8 __reserved1;
+	u16 ccgrid;
+	u8 dcpid;
+	u8 __reserved2;
+	u16 we_mask;
+	union {
+		struct {
+#if __BYTE_ORDER__ == __ORDER_BIG_ENDIAN__
+			u8 ctl_reserved:1;
+			u8 ctl_wr_en_g:1;
+			u8 ctl_wr_en_y:1;
+			u8 ctl_wr_en_r:1;
+			u8 ctl_td_en:1;
+			u8 ctl_td_mode:1;
+			u8 ctl_cscn_en:1;
+			u8 ctl_mode:1;
+#else
+			u8 ctl_mode:1;
+			u8 ctl_cscn_en:1;
+			u8 ctl_td_mode:1;
+			u8 ctl_td_en:1;
+			u8 ctl_wr_en_r:1;
+			u8 ctl_wr_en_y:1;
+			u8 ctl_wr_en_g:1;
+			u8 ctl_reserved:1;
+#endif
+			u8 cdv;
+			u16 cscn_tupd;
+			u8 oal;
+			u8 __reserved3;
+			struct qm_cgr_cs_thres cs_thres;
+			struct qm_cgr_cs_thres cs_thres_x;
+			struct qm_cgr_cs_thres td_thres;
+			struct qm_cgr_wr_parm wr_parm_g;
+			struct qm_cgr_wr_parm wr_parm_y;
+			struct qm_cgr_wr_parm wr_parm_r;
+		} __packed cm_config;
+		struct {
+			u8 dnc;
+			u8 dn0;
+			u8 dn1;
+			u64 dnba:40;
+			u8 __reserved3[2];
+			u16 dnth_0;
+			u8 __reserved4[2];
+			u16 dnth_1;
+			u8 __reserved5[8];
+		} __packed dn_config;
+		struct {
+			u8 __reserved3[3];
+			u64 i_cnt:40;
+			u8 __reserved4[16];
+		} __packed test_write;
+	};
+	u8 __reserved5[32];
+} __packed;
+
+struct qm_mcc_ceetm_ccgr_query {
+	u8 __reserved1;
+	u16 ccgrid;
+	u8 dcpid;
+	u8 __reserved2[59];
+} __packed;
+
+struct qm_mcc_ceetm_cq_peek_pop_xsfdrread {
+	u8 __reserved1;
+	u16 cqid;
+	u8 dcpid;
+	u8 ct;
+	u16 xsfdr;
+	u8 __reserved2[56];
+} __packed;
+
+#define CEETM_QUERY_DEQUEUE_STATISTICS 0x00
+#define CEETM_QUERY_DEQUEUE_CLEAR_STATISTICS 0x01
+#define CEETM_WRITE_DEQUEUE_STATISTICS 0x02
+#define CEETM_QUERY_REJECT_STATISTICS 0x03
+#define CEETM_QUERY_REJECT_CLEAR_STATISTICS 0x04
+#define CEETM_WRITE_REJECT_STATISTICS 0x05
+struct qm_mcc_ceetm_statistics_query_write {
+	u8 __reserved1;
+	u16 cid;
+	u8 dcpid;
+	u8 ct;
+	u8 __reserved2[13];
+	u64 frm_cnt:40;
+	u8 __reserved3[2];
+	u64 byte_cnt:48;
+	u8 __reserved[32];
+} __packed;
+
+struct qm_mc_command {
+	u8 __dont_write_directly__verb;
+	union {
+		struct qm_mcc_initfq initfq;
+		struct qm_mcc_queryfq queryfq;
+		struct qm_mcc_queryfq_np queryfq_np;
+		struct qm_mcc_alterfq alterfq;
+		struct qm_mcc_initcgr initcgr;
+		struct qm_mcc_cgrtestwrite cgrtestwrite;
+		struct qm_mcc_querycgr querycgr;
+		struct qm_mcc_querycongestion querycongestion;
+		struct qm_mcc_querywq querywq;
+		struct qm_mcc_ceetm_lfqmt_config lfqmt_config;
+		struct qm_mcc_ceetm_lfqmt_query lfqmt_query;
+		struct qm_mcc_ceetm_cq_config cq_config;
+		struct qm_mcc_ceetm_cq_query cq_query;
+		struct qm_mcc_ceetm_dct_config dct_config;
+		struct qm_mcc_ceetm_dct_query dct_query;
+		struct qm_mcc_ceetm_class_scheduler_config csch_config;
+		struct qm_mcc_ceetm_class_scheduler_query csch_query;
+		struct qm_mcc_ceetm_mapping_shaper_tcfc_config mst_config;
+		struct qm_mcc_ceetm_mapping_shaper_tcfc_query mst_query;
+		struct qm_mcc_ceetm_ccgr_config ccgr_config;
+		struct qm_mcc_ceetm_ccgr_query ccgr_query;
+		struct qm_mcc_ceetm_cq_peek_pop_xsfdrread cq_ppxr;
+		struct qm_mcc_ceetm_statistics_query_write stats_query_write;
+	};
+} __packed;
+#define QM_MCC_VERB_VBIT		0x80
+#define QM_MCC_VERB_MASK		0x7f	/* where the verb contains; */
+#define QM_MCC_VERB_INITFQ_PARKED	0x40
+#define QM_MCC_VERB_INITFQ_SCHED	0x41
+#define QM_MCC_VERB_QUERYFQ		0x44
+#define QM_MCC_VERB_QUERYFQ_NP		0x45	/* "non-programmable" fields */
+#define QM_MCC_VERB_QUERYWQ		0x46
+#define QM_MCC_VERB_QUERYWQ_DEDICATED	0x47
+#define QM_MCC_VERB_ALTER_SCHED		0x48	/* Schedule FQ */
+#define QM_MCC_VERB_ALTER_FE		0x49	/* Force Eligible FQ */
+#define QM_MCC_VERB_ALTER_RETIRE	0x4a	/* Retire FQ */
+#define QM_MCC_VERB_ALTER_OOS		0x4b	/* Take FQ out of service */
+#define QM_MCC_VERB_ALTER_FQXON		0x4d	/* FQ XON */
+#define QM_MCC_VERB_ALTER_FQXOFF	0x4e	/* FQ XOFF */
+#define QM_MCC_VERB_INITCGR		0x50
+#define QM_MCC_VERB_MODIFYCGR		0x51
+#define QM_MCC_VERB_CGRTESTWRITE	0x52
+#define QM_MCC_VERB_QUERYCGR		0x58
+#define QM_MCC_VERB_QUERYCONGESTION	0x59
+/* INITFQ-specific flags */
+#define QM_INITFQ_WE_MASK		0x01ff	/* 'Write Enable' flags; */
+#define QM_INITFQ_WE_OAC		0x0100
+#define QM_INITFQ_WE_ORPC		0x0080
+#define QM_INITFQ_WE_CGID		0x0040
+#define QM_INITFQ_WE_FQCTRL		0x0020
+#define QM_INITFQ_WE_DESTWQ		0x0010
+#define QM_INITFQ_WE_ICSCRED		0x0008
+#define QM_INITFQ_WE_TDTHRESH		0x0004
+#define QM_INITFQ_WE_CONTEXTB		0x0002
+#define QM_INITFQ_WE_CONTEXTA		0x0001
+/* INITCGR/MODIFYCGR-specific flags */
+#define QM_CGR_WE_MASK			0x07ff	/* 'Write Enable Mask'; */
+#define QM_CGR_WE_WR_PARM_G		0x0400
+#define QM_CGR_WE_WR_PARM_Y		0x0200
+#define QM_CGR_WE_WR_PARM_R		0x0100
+#define QM_CGR_WE_WR_EN_G		0x0080
+#define QM_CGR_WE_WR_EN_Y		0x0040
+#define QM_CGR_WE_WR_EN_R		0x0020
+#define QM_CGR_WE_CSCN_EN		0x0010
+#define QM_CGR_WE_CSCN_TARG		0x0008
+#define QM_CGR_WE_CSTD_EN		0x0004
+#define QM_CGR_WE_CS_THRES		0x0002
+#define QM_CGR_WE_MODE			0x0001
+
+/* See 1.5.9.7 CEETM Management Commands */
+#define QM_CEETM_VERB_LFQMT_CONFIG	0x70
+#define QM_CEETM_VERB_LFQMT_QUERY	0x71
+#define QM_CEETM_VERB_CQ_CONFIG		0x72
+#define QM_CEETM_VERB_CQ_QUERY		0x73
+#define QM_CEETM_VERB_DCT_CONFIG	0x74
+#define QM_CEETM_VERB_DCT_QUERY		0x75
+#define QM_CEETM_VERB_CLASS_SCHEDULER_CONFIG		0x76
+#define QM_CEETM_VERB_CLASS_SCHEDULER_QUERY		0x77
+#define QM_CEETM_VERB_MAPPING_SHAPER_TCFC_CONFIG	0x78
+#define QM_CEETM_VERB_MAPPING_SHAPER_TCFC_QUERY		0x79
+#define QM_CEETM_VERB_CCGR_CONFIG			0x7A
+#define QM_CEETM_VERB_CCGR_QUERY			0x7B
+#define QM_CEETM_VERB_CQ_PEEK_POP_XFDRREAD		0x7C
+#define QM_CEETM_VERB_STATISTICS_QUERY_WRITE		0x7D
+
+/* See 1.5.8.5.1: "Initialize FQ" */
+/* See 1.5.8.5.2: "Query FQ" */
+/* See 1.5.8.5.3: "Query FQ Non-Programmable Fields" */
+/* See 1.5.8.5.4: "Alter FQ State Commands " */
+/* See 1.5.8.6.1: "Initialize/Modify CGR" */
+/* See 1.5.8.6.2: "CGR Test Write" */
+/* See 1.5.8.6.3: "Query CGR" */
+/* See 1.5.8.6.4: "Query Congestion Group State" */
+struct qm_mcr_initfq {
+	u8 __reserved1[62];
+} __packed;
+struct qm_mcr_queryfq {
+	u8 __reserved1[8];
+	struct qm_fqd fqd;	/* the FQD fields are here */
+	u8 __reserved2[30];
+} __packed;
+struct qm_mcr_queryfq_np {
+	u8 __reserved1;
+	u8 state;	/* QM_MCR_NP_STATE_*** */
+#if __BYTE_ORDER__ == __ORDER_BIG_ENDIAN__
+	u8 __reserved2;
+	u32 fqd_link:24;
+	u16 __reserved3:2;
+	u16 odp_seq:14;
+	u16 __reserved4:2;
+	u16 orp_nesn:14;
+	u16 __reserved5:1;
+	u16 orp_ea_hseq:15;
+	u16 __reserved6:1;
+	u16 orp_ea_tseq:15;
+	u8 __reserved7;
+	u32 orp_ea_hptr:24;
+	u8 __reserved8;
+	u32 orp_ea_tptr:24;
+	u8 __reserved9;
+	u32 pfdr_hptr:24;
+	u8 __reserved10;
+	u32 pfdr_tptr:24;
+	u8 __reserved11[5];
+	u8 __reserved12:7;
+	u8 is:1;
+	u16 ics_surp;
+	u32 byte_cnt;
+	u8 __reserved13;
+	u32 frm_cnt:24;
+	u32 __reserved14;
+	u16 ra1_sfdr;	/* QM_MCR_NP_RA1_*** */
+	u16 ra2_sfdr;	/* QM_MCR_NP_RA2_*** */
+	u16 __reserved15;
+	u16 od1_sfdr;	/* QM_MCR_NP_OD1_*** */
+	u16 od2_sfdr;	/* QM_MCR_NP_OD2_*** */
+	u16 od3_sfdr;	/* QM_MCR_NP_OD3_*** */
+#else
+	u8 __reserved2;
+	u32 fqd_link:24;
+
+	u16 odp_seq:14;
+	u16 __reserved3:2;
+
+	u16 orp_nesn:14;
+	u16 __reserved4:2;
+
+	u16 orp_ea_hseq:15;
+	u16 __reserved5:1;
+
+	u16 orp_ea_tseq:15;
+	u16 __reserved6:1;
+
+	u8 __reserved7;
+	u32 orp_ea_hptr:24;
+
+	u8 __reserved8;
+	u32 orp_ea_tptr:24;
+
+	u8 __reserved9;
+	u32 pfdr_hptr:24;
+
+	u8 __reserved10;
+	u32 pfdr_tptr:24;
+
+	u8 __reserved11[5];
+	u8 is:1;
+	u8 __reserved12:7;
+	u16 ics_surp;
+	u32 byte_cnt;
+	u8 __reserved13;
+	u32 frm_cnt:24;
+	u32 __reserved14;
+	u16 ra1_sfdr;	/* QM_MCR_NP_RA1_*** */
+	u16 ra2_sfdr;	/* QM_MCR_NP_RA2_*** */
+	u16 __reserved15;
+	u16 od1_sfdr;	/* QM_MCR_NP_OD1_*** */
+	u16 od2_sfdr;	/* QM_MCR_NP_OD2_*** */
+	u16 od3_sfdr;	/* QM_MCR_NP_OD3_*** */
+#endif
+} __packed;
+
+
+struct qm_mcr_alterfq {
+	u8 fqs;		/* Frame Queue Status */
+	u8 __reserved1[61];
+} __packed;
+struct qm_mcr_initcgr {
+	u8 __reserved1[62];
+} __packed;
+struct qm_mcr_cgrtestwrite {
+	u16 __reserved1;
+	struct __qm_mc_cgr cgr; /* CGR fields */
+	u8 __reserved2[3];
+	u32 __reserved3:24;
+	u32 i_bcnt_hi:8;/* high 8-bits of 40-bit "Instant" */
+	u32 i_bcnt_lo;	/* low 32-bits of 40-bit */
+	u32 __reserved4:24;
+	u32 a_bcnt_hi:8;/* high 8-bits of 40-bit "Average" */
+	u32 a_bcnt_lo;	/* low 32-bits of 40-bit */
+	u16 lgt;	/* Last Group Tick */
+	u16 wr_prob_g;
+	u16 wr_prob_y;
+	u16 wr_prob_r;
+	u8 __reserved5[8];
+} __packed;
+struct qm_mcr_querycgr {
+	u16 __reserved1;
+	struct __qm_mc_cgr cgr; /* CGR fields */
+	u8 __reserved2[3];
+	union {
+		struct {
+#if __BYTE_ORDER__ == __ORDER_BIG_ENDIAN__
+			u32 __reserved3:24;
+			u32 i_bcnt_hi:8;/* high 8-bits of 40-bit "Instant" */
+			u32 i_bcnt_lo;	/* low 32-bits of 40-bit */
+#else
+			u32 i_bcnt_lo;	/* low 32-bits of 40-bit */
+			u32 i_bcnt_hi:8;/* high 8-bits of 40-bit "Instant" */
+			u32 __reserved3:24;
+#endif
+		};
+		u64 i_bcnt;
+	};
+	union {
+		struct {
+#if __BYTE_ORDER__ == __ORDER_BIG_ENDIAN__
+			u32 __reserved4:24;
+			u32 a_bcnt_hi:8;/* high 8-bits of 40-bit "Average" */
+			u32 a_bcnt_lo;	/* low 32-bits of 40-bit */
+#else
+			u32 a_bcnt_lo;	/* low 32-bits of 40-bit */
+			u32 a_bcnt_hi:8;/* high 8-bits of 40-bit "Average" */
+			u32 __reserved4:24;
+#endif
+		};
+		u64 a_bcnt;
+	};
+	union {
+		u32 cscn_targ_swp[4];
+		u8 __reserved5[16];
+	};
+} __packed;
+static inline u64 qm_mcr_querycgr_i_get64(const struct qm_mcr_querycgr *q)
+{
+	return be64_to_cpu(q->i_bcnt);
+}
+static inline u64 qm_mcr_querycgr_a_get64(const struct qm_mcr_querycgr *q)
+{
+	return be64_to_cpu(q->a_bcnt);
+}
+static inline u64 qm_mcr_cgrtestwrite_i_get64(
+					const struct qm_mcr_cgrtestwrite *q)
+{
+	return be64_to_cpu(((u64)q->i_bcnt_hi << 32) | (u64)q->i_bcnt_lo);
+}
+static inline u64 qm_mcr_cgrtestwrite_a_get64(
+					const struct qm_mcr_cgrtestwrite *q)
+{
+	return be64_to_cpu(((u64)q->a_bcnt_hi << 32) | (u64)q->a_bcnt_lo);
+}
+/* Macro, so we compile better if 'v' isn't always 64-bit */
+#define qm_mcr_querycgr_i_set64(q, v) \
+	do { \
+		struct qm_mcr_querycgr *__q931 = (fd); \
+		__q931->i_bcnt_hi = upper_32_bits(v); \
+		__q931->i_bcnt_lo = lower_32_bits(v); \
+	} while (0)
+#define qm_mcr_querycgr_a_set64(q, v) \
+	do { \
+		struct qm_mcr_querycgr *__q931 = (fd); \
+		__q931->a_bcnt_hi = upper_32_bits(v); \
+		__q931->a_bcnt_lo = lower_32_bits(v); \
+	} while (0)
+struct __qm_mcr_querycongestion {
+	u32 __state[8];
+};
+struct qm_mcr_querycongestion {
+	u8 __reserved[30];
+	/* Access this struct using QM_MCR_QUERYCONGESTION() */
+	struct __qm_mcr_querycongestion state;
+} __packed;
+struct qm_mcr_querywq {
+	union {
+		u16 channel_wq; /* ignores wq (3 lsbits) */
+		struct {
+#if __BYTE_ORDER__ == __ORDER_BIG_ENDIAN__
+			u16 id:13; /* qm_channel */
+			u16 __reserved:3;
+#else
+			u16 __reserved:3;
+			u16 id:13; /* qm_channel */
+#endif
+		} __packed channel;
+	};
+	u8 __reserved[28];
+	u32 wq_len[8];
+} __packed;
+
+/* QMAN CEETM Management Command Response */
+struct qm_mcr_ceetm_lfqmt_config {
+	u8 __reserved1[62];
+} __packed;
+struct qm_mcr_ceetm_lfqmt_query {
+	u8 __reserved1[8];
+	u16 cqid;
+	u8 __reserved2[2];
+	u16 dctidx;
+	u8 __reserved3[2];
+	u16 ccgid;
+	u8 __reserved4[44];
+} __packed;
+
+struct qm_mcr_ceetm_cq_config {
+	u8 __reserved1[62];
+} __packed;
+
+struct qm_mcr_ceetm_cq_query {
+	u8 __reserved1[4];
+	u16 ccgid;
+	u16 state;
+	u32 pfdr_hptr:24;
+	u32 pfdr_tptr:24;
+	u16 od1_xsfdr;
+	u16 od2_xsfdr;
+	u16 od3_xsfdr;
+	u16 od4_xsfdr;
+	u16 od5_xsfdr;
+	u16 od6_xsfdr;
+	u16 ra1_xsfdr;
+	u16 ra2_xsfdr;
+	u8 __reserved2;
+	u32 frm_cnt:24;
+	u8 __reserved333[28];
+} __packed;
+
+struct qm_mcr_ceetm_dct_config {
+	u8 __reserved1[62];
+} __packed;
+
+struct qm_mcr_ceetm_dct_query {
+	u8 __reserved1[18];
+	u32 context_b;
+	u64 context_a;
+	u8 __reserved2[32];
+} __packed;
+
+struct qm_mcr_ceetm_class_scheduler_config {
+	u8 __reserved1[62];
+} __packed;
+
+struct qm_mcr_ceetm_class_scheduler_query {
+	u8 __reserved1[9];
+#if __BYTE_ORDER__ == __ORDER_BIG_ENDIAN__
+	u8 gpc_reserved:1;
+	u8 gpc_combine_flag:1;
+	u8 gpc_prio_b:3;
+	u8 gpc_prio_a:3;
+#else
+	u8 gpc_prio_a:3;
+	u8 gpc_prio_b:3;
+	u8 gpc_combine_flag:1;
+	u8 gpc_reserved:1;
+#endif
+	u16 crem;
+	u16 erem;
+	u8 w[8];
+	u8 __reserved2[5];
+	u32 wbfslist:24;
+	u32 d8;
+	u32 d9;
+	u32 d10;
+	u32 d11;
+	u32 d12;
+	u32 d13;
+	u32 d14;
+	u32 d15;
+} __packed;
+
+struct qm_mcr_ceetm_mapping_shaper_tcfc_config {
+	u16 cid;
+	u8 __reserved2[60];
+} __packed;
+
+struct qm_mcr_ceetm_mapping_shaper_tcfc_query {
+	u16 cid;
+	u8 __reserved1;
+	union {
+		struct {
+#if __BYTE_ORDER__ == __ORDER_BIG_ENDIAN__
+			u8 map_shaped:1;
+			u8 map_reserved:4;
+			u8 map_lni_id:3;
+#else
+			u8 map_lni_id:3;
+			u8 map_reserved:4;
+			u8 map_shaped:1;
+#endif
+			u8 __reserved2[58];
+		} __packed channel_mapping_query;
+		struct {
+#if __BYTE_ORDER__ == __ORDER_BIG_ENDIAN__
+			u8 map_reserved:5;
+			u8 map_lni_id:3;
+#else
+			u8 map_lni_id:3;
+			u8 map_reserved:5;
+#endif
+			u8 __reserved2[58];
+		} __packed sp_mapping_query;
+		struct {
+#if __BYTE_ORDER__ == __ORDER_BIG_ENDIAN__
+			u8 cpl:1;
+			u8 cpl_reserved:2;
+			u8 oal:5;
+#else
+			u8 oal:5;
+			u8 cpl_reserved:2;
+			u8 cpl:1;
+#endif
+			u32 crtcr:24;
+			u32 ertcr:24;
+			u16 crtbl;
+			u16 ertbl;
+			u8 mps;
+			u8 __reserved2[15];
+			u32 crat;
+			u32 erat;
+			u8 __reserved3[24];
+		} __packed shaper_query;
+		struct {
+			u8 __reserved1[11];
+			u64 lnitcfcc;
+			u8 __reserved3[40];
+		} __packed tcfc_query;
+	};
+} __packed;
+
+struct qm_mcr_ceetm_ccgr_config {
+	u8 __reserved1[46];
+	union {
+		u8 __reserved2[8];
+		struct {
+			u16 timestamp;
+			u16 wr_porb_g;
+			u16 wr_prob_y;
+			u16 wr_prob_r;
+		} __packed test_write;
+	};
+	u8 __reserved3[8];
+} __packed;
+
+struct qm_mcr_ceetm_ccgr_query {
+	u8 __reserved1[6];
+	union {
+		struct {
+#if __BYTE_ORDER__ == __ORDER_BIG_ENDIAN__
+			u8 ctl_reserved:1;
+			u8 ctl_wr_en_g:1;
+			u8 ctl_wr_en_y:1;
+			u8 ctl_wr_en_r:1;
+			u8 ctl_td_en:1;
+			u8 ctl_td_mode:1;
+			u8 ctl_cscn_en:1;
+			u8 ctl_mode:1;
+#else
+			u8 ctl_mode:1;
+			u8 ctl_cscn_en:1;
+			u8 ctl_td_mode:1;
+			u8 ctl_td_en:1;
+			u8 ctl_wr_en_r:1;
+			u8 ctl_wr_en_y:1;
+			u8 ctl_wr_en_g:1;
+			u8 ctl_reserved:1;
+#endif
+			u8 cdv;
+			u8 __reserved2[2];
+			u8 oal;
+			u8 __reserved3;
+			struct qm_cgr_cs_thres cs_thres;
+			struct qm_cgr_cs_thres cs_thres_x;
+			struct qm_cgr_cs_thres td_thres;
+			struct qm_cgr_wr_parm wr_parm_g;
+			struct qm_cgr_wr_parm wr_parm_y;
+			struct qm_cgr_wr_parm wr_parm_r;
+			u16 cscn_targ_dcp;
+			u8 dcp_lsn;
+			u64 i_cnt:40;
+			u8 __reserved4[3];
+			u64 a_cnt:40;
+			u32 cscn_targ_swp[4];
+		} __packed cm_query;
+		struct {
+			u8 dnc;
+			u8 dn0;
+			u8 dn1;
+			u64 dnba:40;
+			u8 __reserved2[2];
+			u16 dnth_0;
+			u8 __reserved3[2];
+			u16 dnth_1;
+			u8 __reserved4[10];
+			u16 dnacc_0;
+			u8 __reserved5[2];
+			u16 dnacc_1;
+			u8 __reserved6[24];
+		} __packed dn_query;
+		struct {
+			u8 __reserved2[24];
+			struct  __qm_mcr_querycongestion state;
+		} __packed congestion_state;
+
+	};
+} __packed;
+
+struct qm_mcr_ceetm_cq_peek_pop_xsfdrread {
+	u8 stat;
+	u8 __reserved1[11];
+	u16 dctidx;
+	struct qm_fd fd;
+	u8 __reserved2[32];
+} __packed;
+
+struct qm_mcr_ceetm_statistics_query {
+	u8 __reserved1[17];
+	u64 frm_cnt:40;
+	u8 __reserved2[2];
+	u64 byte_cnt:48;
+	u8 __reserved3[32];
+} __packed;
+
+struct qm_mc_result {
+	u8 verb;
+	u8 result;
+	union {
+		struct qm_mcr_initfq initfq;
+		struct qm_mcr_queryfq queryfq;
+		struct qm_mcr_queryfq_np queryfq_np;
+		struct qm_mcr_alterfq alterfq;
+		struct qm_mcr_initcgr initcgr;
+		struct qm_mcr_cgrtestwrite cgrtestwrite;
+		struct qm_mcr_querycgr querycgr;
+		struct qm_mcr_querycongestion querycongestion;
+		struct qm_mcr_querywq querywq;
+		struct qm_mcr_ceetm_lfqmt_config lfqmt_config;
+		struct qm_mcr_ceetm_lfqmt_query lfqmt_query;
+		struct qm_mcr_ceetm_cq_config cq_config;
+		struct qm_mcr_ceetm_cq_query cq_query;
+		struct qm_mcr_ceetm_dct_config dct_config;
+		struct qm_mcr_ceetm_dct_query dct_query;
+		struct qm_mcr_ceetm_class_scheduler_config csch_config;
+		struct qm_mcr_ceetm_class_scheduler_query csch_query;
+		struct qm_mcr_ceetm_mapping_shaper_tcfc_config mst_config;
+		struct qm_mcr_ceetm_mapping_shaper_tcfc_query mst_query;
+		struct qm_mcr_ceetm_ccgr_config ccgr_config;
+		struct qm_mcr_ceetm_ccgr_query ccgr_query;
+		struct qm_mcr_ceetm_cq_peek_pop_xsfdrread cq_ppxr;
+		struct qm_mcr_ceetm_statistics_query stats_query;
+	};
+} __packed;
+
+#define QM_MCR_VERB_RRID		0x80
+#define QM_MCR_VERB_MASK		QM_MCC_VERB_MASK
+#define QM_MCR_VERB_INITFQ_PARKED	QM_MCC_VERB_INITFQ_PARKED
+#define QM_MCR_VERB_INITFQ_SCHED	QM_MCC_VERB_INITFQ_SCHED
+#define QM_MCR_VERB_QUERYFQ		QM_MCC_VERB_QUERYFQ
+#define QM_MCR_VERB_QUERYFQ_NP		QM_MCC_VERB_QUERYFQ_NP
+#define QM_MCR_VERB_QUERYWQ		QM_MCC_VERB_QUERYWQ
+#define QM_MCR_VERB_QUERYWQ_DEDICATED	QM_MCC_VERB_QUERYWQ_DEDICATED
+#define QM_MCR_VERB_ALTER_SCHED		QM_MCC_VERB_ALTER_SCHED
+#define QM_MCR_VERB_ALTER_FE		QM_MCC_VERB_ALTER_FE
+#define QM_MCR_VERB_ALTER_RETIRE	QM_MCC_VERB_ALTER_RETIRE
+#define QM_MCR_VERB_ALTER_OOS		QM_MCC_VERB_ALTER_OOS
+#define QM_MCR_RESULT_NULL		0x00
+#define QM_MCR_RESULT_OK		0xf0
+#define QM_MCR_RESULT_ERR_FQID		0xf1
+#define QM_MCR_RESULT_ERR_FQSTATE	0xf2
+#define QM_MCR_RESULT_ERR_NOTEMPTY	0xf3	/* OOS fails if FQ is !empty */
+#define QM_MCR_RESULT_ERR_BADCHANNEL	0xf4
+#define QM_MCR_RESULT_PENDING		0xf8
+#define QM_MCR_RESULT_ERR_BADCOMMAND	0xff
+#define QM_MCR_NP_STATE_FE		0x10
+#define QM_MCR_NP_STATE_R		0x08
+#define QM_MCR_NP_STATE_MASK		0x07	/* Reads FQD::STATE; */
+#define QM_MCR_NP_STATE_OOS		0x00
+#define QM_MCR_NP_STATE_RETIRED		0x01
+#define QM_MCR_NP_STATE_TEN_SCHED	0x02
+#define QM_MCR_NP_STATE_TRU_SCHED	0x03
+#define QM_MCR_NP_STATE_PARKED		0x04
+#define QM_MCR_NP_STATE_ACTIVE		0x05
+#define QM_MCR_NP_PTR_MASK		0x07ff	/* for RA[12] & OD[123] */
+#define QM_MCR_NP_RA1_NRA(v)		(((v) >> 14) & 0x3)	/* FQD::NRA */
+#define QM_MCR_NP_RA2_IT(v)		(((v) >> 14) & 0x1)	/* FQD::IT */
+#define QM_MCR_NP_OD1_NOD(v)		(((v) >> 14) & 0x3)	/* FQD::NOD */
+#define QM_MCR_NP_OD3_NPC(v)		(((v) >> 14) & 0x3)	/* FQD::NPC */
+#define QM_MCR_FQS_ORLPRESENT		0x02	/* ORL fragments to come */
+#define QM_MCR_FQS_NOTEMPTY		0x01	/* FQ has enqueued frames */
+/* This extracts the state for congestion group 'n' from a query response.
+ * Eg.
+ *   u8 cgr = [...];
+ *   struct qm_mc_result *res = [...];
+ *   printf("congestion group %d congestion state: %d\n", cgr,
+ *       QM_MCR_QUERYCONGESTION(&res->querycongestion.state, cgr));
+ */
+#define __CGR_WORD(num)		(num >> 5)
+#define __CGR_SHIFT(num)	(num & 0x1f)
+#define __CGR_NUM		(sizeof(struct __qm_mcr_querycongestion) << 3)
+static inline int QM_MCR_QUERYCONGESTION(struct __qm_mcr_querycongestion *p,
+					u8 cgr)
+{
+	return p->__state[__CGR_WORD(cgr)] & (0x80000000 >> __CGR_SHIFT(cgr));
+}
+
+
+/*********************/
+/* Utility interface */
+/*********************/
+
+/* Represents an allocator over a range of FQIDs. NB, accesses are not locked,
+ * spinlock them yourself if needed. */
+struct qman_fqid_pool;
+
+/* Create/destroy a FQID pool, num must be a multiple of 32. NB, _destroy()
+ * always succeeds, but returns non-zero if there were "leaked" FQID
+ * allocations. */
+struct qman_fqid_pool *qman_fqid_pool_create(u32 fqid_start, u32 num);
+int qman_fqid_pool_destroy(struct qman_fqid_pool *pool);
+/* Alloc/free a FQID from the range. _alloc() returns zero for success. */
+int qman_fqid_pool_alloc(struct qman_fqid_pool *pool, u32 *fqid);
+void qman_fqid_pool_free(struct qman_fqid_pool *pool, u32 fqid);
+u32 qman_fqid_pool_used(struct qman_fqid_pool *pool);
+
+/*******************************************************************/
+/* Managed (aka "shared" or "mux/demux") portal, high-level i/face */
+/*******************************************************************/
+
+	/* Portal and Frame Queues */
+	/* ----------------------- */
+/* Represents a managed portal */
+struct qman_portal;
+
+/* This object type represents Qman frame queue descriptors (FQD), it is
+ * cacheline-aligned, and initialised by qman_create_fq(). The structure is
+ * defined further down. */
+struct qman_fq;
+
+/* This object type represents a Qman congestion group, it is defined further
+ * down. */
+struct qman_cgr;
+
+struct qman_portal_config {
+	/* If the caller enables DQRR stashing (and thus wishes to operate the
+	 * portal from only one cpu), this is the logical CPU that the portal
+	 * will stash to. Whether stashing is enabled or not, this setting is
+	 * also used for any "core-affine" portals, ie. default portals
+	 * associated to the corresponding cpu. -1 implies that there is no core
+	 * affinity configured. */
+	int cpu;
+	/* portal interrupt line */
+	int irq;
+	/* the unique index of this portal */
+	u32 index;
+	/* Is this portal shared? (If so, it has coarser locking and demuxes
+	 * processing on behalf of other CPUs.) */
+	int is_shared;
+	/* The portal's dedicated channel id, use this value for initialising
+	 * frame queues to target this portal when scheduled. */
+	u16 channel;
+	/* A mask of which pool channels this portal has dequeue access to
+	 * (using QM_SDQCR_CHANNELS_POOL(n) for the bitmask) */
+	u32 pools;
+};
+
+/* This enum, and the callback type that returns it, are used when handling
+ * dequeued frames via DQRR. Note that for "null" callbacks registered with the
+ * portal object (for handling dequeues that do not demux because contextB is
+ * NULL), the return value *MUST* be qman_cb_dqrr_consume. */
+enum qman_cb_dqrr_result {
+	/* DQRR entry can be consumed */
+	qman_cb_dqrr_consume,
+	/* Like _consume, but requests parking - FQ must be held-active */
+	qman_cb_dqrr_park,
+	/* Does not consume, for DCA mode only. This allows out-of-order
+	 * consumes by explicit calls to qman_dca() and/or the use of implicit
+	 * DCA via EQCR entries. */
+	qman_cb_dqrr_defer,
+	/* Stop processing without consuming this ring entry. Exits the current
+	 * qman_poll_dqrr() or interrupt-handling, as appropriate. If within an
+	 * interrupt handler, the callback would typically call
+	 * qman_irqsource_remove(QM_PIRQ_DQRI) before returning this value,
+	 * otherwise the interrupt will reassert immediately. */
+	qman_cb_dqrr_stop,
+	/* Like qman_cb_dqrr_stop, but consumes the current entry. */
+	qman_cb_dqrr_consume_stop
+};
+typedef enum qman_cb_dqrr_result (*qman_cb_dqrr)(struct qman_portal *qm,
+					struct qman_fq *fq,
+					const struct qm_dqrr_entry *dqrr);
+
+/* This callback type is used when handling ERNs, FQRNs and FQRLs via MR. They
+ * are always consumed after the callback returns. */
+typedef void (*qman_cb_mr)(struct qman_portal *qm, struct qman_fq *fq,
+				const struct qm_mr_entry *msg);
+
+/* This callback type is used when handling DCP ERNs */
+typedef void (*qman_cb_dc_ern)(struct qman_portal *qm,
+				const struct qm_mr_entry *msg);
+
+/* s/w-visible states. Ie. tentatively scheduled + truly scheduled + active +
+ * held-active + held-suspended are just "sched". Things like "retired" will not
+ * be assumed until it is complete (ie. QMAN_FQ_STATE_CHANGING is set until
+ * then, to indicate it's completing and to gate attempts to retry the retire
+ * command). Note, park commands do not set QMAN_FQ_STATE_CHANGING because it's
+ * technically impossible in the case of enqueue DCAs (which refer to DQRR ring
+ * index rather than the FQ that ring entry corresponds to), so repeated park
+ * commands are allowed (if you're silly enough to try) but won't change FQ
+ * state, and the resulting park notifications move FQs from "sched" to
+ * "parked". */
+enum qman_fq_state {
+	qman_fq_state_oos,
+	qman_fq_state_parked,
+	qman_fq_state_sched,
+	qman_fq_state_retired
+};
+
+/* Frame queue objects (struct qman_fq) are stored within memory passed to
+ * qman_create_fq(), as this allows stashing of caller-provided demux callback
+ * pointers at no extra cost to stashing of (driver-internal) FQ state. If the
+ * caller wishes to add per-FQ state and have it benefit from dequeue-stashing,
+ * they should;
+ *
+ * (a) extend the qman_fq structure with their state; eg.
+ *
+ *     // myfq is allocated and driver_fq callbacks filled in;
+ *     struct my_fq {
+ *         struct qman_fq base;
+ *         int an_extra_field;
+ *         [ ... add other fields to be associated with each FQ ...]
+ *     } *myfq = some_my_fq_allocator();
+ *     struct qman_fq *fq = qman_create_fq(fqid, flags, &myfq->base);
+ *
+ *     // in a dequeue callback, access extra fields from 'fq' via a cast;
+ *     struct my_fq *myfq = (struct my_fq *)fq;
+ *     do_something_with(myfq->an_extra_field);
+ *     [...]
+ *
+ * (b) when and if configuring the FQ for context stashing, specify how ever
+ *     many cachelines are required to stash 'struct my_fq', to accelerate not
+ *     only the Qman driver but the callback as well.
+ */
+
+struct qman_fq_cb {
+	qman_cb_dqrr dqrr;      /* for dequeued frames */
+	qman_cb_mr ern;         /* for s/w ERNs */
+	qman_cb_mr fqs;         /* frame-queue state changes*/
+};
+
+struct qman_fq {
+	/* Caller of qman_create_fq() provides these demux callbacks */
+	struct qman_fq_cb cb;
+	/* These are internal to the driver, don't touch. In particular, they
+	 * may change, be removed, or extended (so you shouldn't rely on
+	 * sizeof(qman_fq) being a constant). */
+	spinlock_t fqlock;
+	u32 fqid;
+	volatile unsigned long flags;
+	enum qman_fq_state state;
+	int cgr_groupid;
+	struct rb_node node;
+#ifdef CONFIG_FSL_QMAN_FQ_LOOKUP
+	u32 key;
+#endif
+};
+
+/* This callback type is used when handling congestion group entry/exit.
+ * 'congested' is non-zero on congestion-entry, and zero on congestion-exit. */
+typedef void (*qman_cb_cgr)(struct qman_portal *qm,
+			struct qman_cgr *cgr, int congested);
+
+struct qman_cgr {
+	/* Set these prior to qman_create_cgr() */
+	u32 cgrid; /* 0..255, but u32 to allow specials like -1, 256, etc.*/
+	qman_cb_cgr cb;
+	/* These are private to the driver */
+	u16 chan; /* portal channel this object is created on */
+	struct list_head node;
+};
+
+/* Flags to qman_create_fq() */
+#define QMAN_FQ_FLAG_NO_ENQUEUE      0x00000001 /* can't enqueue */
+#define QMAN_FQ_FLAG_NO_MODIFY       0x00000002 /* can only enqueue */
+#define QMAN_FQ_FLAG_TO_DCPORTAL     0x00000004 /* consumed by CAAM/PME/Fman */
+#define QMAN_FQ_FLAG_LOCKED          0x00000008 /* multi-core locking */
+#define QMAN_FQ_FLAG_AS_IS           0x00000010 /* query h/w state */
+#define QMAN_FQ_FLAG_DYNAMIC_FQID    0x00000020 /* (de)allocate fqid */
+
+/* Flags to qman_destroy_fq() */
+#define QMAN_FQ_DESTROY_PARKED       0x00000001 /* FQ can be parked or OOS */
+
+/* Flags from qman_fq_state() */
+#define QMAN_FQ_STATE_CHANGING       0x80000000 /* 'state' is changing */
+#define QMAN_FQ_STATE_NE             0x40000000 /* retired FQ isn't empty */
+#define QMAN_FQ_STATE_ORL            0x20000000 /* retired FQ has ORL */
+#define QMAN_FQ_STATE_BLOCKOOS       0xe0000000 /* if any are set, no OOS */
+#define QMAN_FQ_STATE_CGR_EN         0x10000000 /* CGR enabled */
+#define QMAN_FQ_STATE_VDQCR          0x08000000 /* being volatile dequeued */
+
+/* Flags to qman_init_fq() */
+#define QMAN_INITFQ_FLAG_SCHED       0x00000001 /* schedule rather than park */
+#define QMAN_INITFQ_FLAG_LOCAL       0x00000004 /* set dest portal */
+
+/* Flags to qman_volatile_dequeue() */
+#ifdef CONFIG_FSL_DPA_CAN_WAIT
+#define QMAN_VOLATILE_FLAG_WAIT      0x00000001 /* wait if VDQCR is in use */
+#define QMAN_VOLATILE_FLAG_WAIT_INT  0x00000002 /* if wait, interruptible? */
+#define QMAN_VOLATILE_FLAG_FINISH    0x00000004 /* wait till VDQCR completes */
+#endif
+
+/* Flags to qman_enqueue(). NB, the strange numbering is to align with hardware,
+ * bit-wise. (NB: the PME API is sensitive to these precise numberings too, so
+ * any change here should be audited in PME.) */
+#ifdef CONFIG_FSL_DPA_CAN_WAIT
+#define QMAN_ENQUEUE_FLAG_WAIT       0x00010000 /* wait if EQCR is full */
+#define QMAN_ENQUEUE_FLAG_WAIT_INT   0x00020000 /* if wait, interruptible? */
+#ifdef CONFIG_FSL_DPA_CAN_WAIT_SYNC
+#define QMAN_ENQUEUE_FLAG_WAIT_SYNC  0x00000004 /* if wait, until consumed? */
+#endif
+#endif
+#define QMAN_ENQUEUE_FLAG_WATCH_CGR  0x00080000 /* watch congestion state */
+#define QMAN_ENQUEUE_FLAG_DCA        0x00008000 /* perform enqueue-DCA */
+#define QMAN_ENQUEUE_FLAG_DCA_PARK   0x00004000 /* If DCA, requests park */
+#define QMAN_ENQUEUE_FLAG_DCA_PTR(p)		/* If DCA, p is DQRR entry */ \
+		(((u32)(p) << 2) & 0x00000f00)
+#define QMAN_ENQUEUE_FLAG_C_GREEN    0x00000000 /* choose one C_*** flag */
+#define QMAN_ENQUEUE_FLAG_C_YELLOW   0x00000008
+#define QMAN_ENQUEUE_FLAG_C_RED      0x00000010
+#define QMAN_ENQUEUE_FLAG_C_OVERRIDE 0x00000018
+/* For the ORP-specific qman_enqueue_orp() variant;
+ * - this flag indicates "Not Last In Sequence", ie. all but the final fragment
+ *   of a frame. */
+#define QMAN_ENQUEUE_FLAG_NLIS       0x01000000
+/* - this flag performs no enqueue but fills in an ORP sequence number that
+ *   would otherwise block it (eg. if a frame has been dropped). */
+#define QMAN_ENQUEUE_FLAG_HOLE       0x02000000
+/* - this flag performs no enqueue but advances NESN to the given sequence
+ *   number. */
+#define QMAN_ENQUEUE_FLAG_NESN       0x04000000
+
+/* Flags to qman_modify_cgr() */
+#define QMAN_CGR_FLAG_USE_INIT       0x00000001
+#define QMAN_CGR_MODE_FRAME          0x00000001
+
+	/* Portal Management */
+	/* ----------------- */
+/**
+ * qman_get_portal_config - get portal configuration settings
+ *
+ * This returns a read-only view of the current cpu's affine portal settings.
+ */
+const struct qman_portal_config *qman_get_portal_config(void);
+
+/**
+ * qman_irqsource_get - return the portal work that is interrupt-driven
+ *
+ * Returns a bitmask of QM_PIRQ_**I processing sources that are currently
+ * enabled for interrupt handling on the current cpu's affine portal. These
+ * sources will trigger the portal interrupt and the interrupt handler (or a
+ * tasklet/bottom-half it defers to) will perform the corresponding processing
+ * work. The qman_poll_***() functions will only process sources that are not in
+ * this bitmask. If the current CPU is sharing a portal hosted on another CPU,
+ * this always returns zero.
+ */
+u32 qman_irqsource_get(void);
+
+/**
+ * qman_irqsource_add - add processing sources to be interrupt-driven
+ * @bits: bitmask of QM_PIRQ_**I processing sources
+ *
+ * Adds processing sources that should be interrupt-driven (rather than
+ * processed via qman_poll_***() functions). Returns zero for success, or
+ * -EINVAL if the current CPU is sharing a portal hosted on another CPU.
+ */
+int qman_irqsource_add(u32 bits);
+
+/**
+ * qman_irqsource_remove - remove processing sources from being interrupt-driven
+ * @bits: bitmask of QM_PIRQ_**I processing sources
+ *
+ * Removes processing sources from being interrupt-driven, so that they will
+ * instead be processed via qman_poll_***() functions. Returns zero for success,
+ * or -EINVAL if the current CPU is sharing a portal hosted on another CPU.
+ */
+int qman_irqsource_remove(u32 bits);
+
+/**
+ * qman_affine_cpus - return a mask of cpus that have affine portals
+ */
+const cpumask_t *qman_affine_cpus(void);
+
+/**
+ * qman_affine_channel - return the channel ID of an portal
+ * @cpu: the cpu whose affine portal is the subject of the query
+ *
+ * If @cpu is -1, the affine portal for the current CPU will be used. It is a
+ * bug to call this function for any value of @cpu (other than -1) that is not a
+ * member of the mask returned from qman_affine_cpus().
+ */
+u16 qman_affine_channel(int cpu);
+
+/**
+ * qman_get_affine_portal - return the portal pointer affine to cpu
+ * @cpu: the cpu whose affine portal is the subject of the query
+ *
+ */
+void *qman_get_affine_portal(int cpu);
+
+/**
+ * qman_poll_dqrr - process DQRR (fast-path) entries
+ * @limit: the maximum number of DQRR entries to process
+ *
+ * Use of this function requires that DQRR processing not be interrupt-driven.
+ * Ie. the value returned by qman_irqsource_get() should not include
+ * QM_PIRQ_DQRI. If the current CPU is sharing a portal hosted on another CPU,
+ * this function will return -EINVAL, otherwise the return value is >=0 and
+ * represents the number of DQRR entries processed.
+ */
+int qman_poll_dqrr(unsigned int limit);
+
+/**
+ * qman_poll_slow - process anything (except DQRR) that isn't interrupt-driven.
+ *
+ * This function does any portal processing that isn't interrupt-driven. If the
+ * current CPU is sharing a portal hosted on another CPU, this function will
+ * return (u32)-1, otherwise the return value is a bitmask of QM_PIRQ_* sources
+ * indicating what interrupt sources were actually processed by the call.
+ */
+u32 qman_poll_slow(void);
+
+/**
+ * qman_poll - legacy wrapper for qman_poll_dqrr() and qman_poll_slow()
+ *
+ * Dispatcher logic on a cpu can use this to trigger any maintenance of the
+ * affine portal. There are two classes of portal processing in question;
+ * fast-path (which involves demuxing dequeue ring (DQRR) entries and tracking
+ * enqueue ring (EQCR) consumption), and slow-path (which involves EQCR
+ * thresholds, congestion state changes, etc). This function does whatever
+ * processing is not triggered by interrupts.
+ *
+ * Note, if DQRR and some slow-path processing are poll-driven (rather than
+ * interrupt-driven) then this function uses a heuristic to determine how often
+ * to run slow-path processing - as slow-path processing introduces at least a
+ * minimum latency each time it is run, whereas fast-path (DQRR) processing is
+ * close to zero-cost if there is no work to be done. Applications can tune this
+ * behaviour themselves by using qman_poll_dqrr() and qman_poll_slow() directly
+ * rather than going via this wrapper.
+ */
+void qman_poll(void);
+
+/**
+ * qman_stop_dequeues - Stop h/w dequeuing to the s/w portal
+ *
+ * Disables DQRR processing of the portal. This is reference-counted, so
+ * qman_start_dequeues() must be called as many times as qman_stop_dequeues() to
+ * truly re-enable dequeuing.
+ */
+void qman_stop_dequeues(void);
+
+/**
+ * qman_start_dequeues - (Re)start h/w dequeuing to the s/w portal
+ *
+ * Enables DQRR processing of the portal. This is reference-counted, so
+ * qman_start_dequeues() must be called as many times as qman_stop_dequeues() to
+ * truly re-enable dequeuing.
+ */
+void qman_start_dequeues(void);
+
+/**
+ * qman_static_dequeue_add - Add pool channels to the portal SDQCR
+ * @pools: bit-mask of pool channels, using QM_SDQCR_CHANNELS_POOL(n)
+ *
+ * Adds a set of pool channels to the portal's static dequeue command register
+ * (SDQCR). The requested pools are limited to those the portal has dequeue
+ * access to.
+ */
+void qman_static_dequeue_add(u32 pools);
+
+/**
+ * qman_static_dequeue_del - Remove pool channels from the portal SDQCR
+ * @pools: bit-mask of pool channels, using QM_SDQCR_CHANNELS_POOL(n)
+ *
+ * Removes a set of pool channels from the portal's static dequeue command
+ * register (SDQCR). The requested pools are limited to those the portal has
+ * dequeue access to.
+ */
+void qman_static_dequeue_del(u32 pools);
+
+/**
+ * qman_static_dequeue_get - return the portal's current SDQCR
+ *
+ * Returns the portal's current static dequeue command register (SDQCR). The
+ * entire register is returned, so if only the currently-enabled pool channels
+ * are desired, mask the return value with QM_SDQCR_CHANNELS_POOL_MASK.
+ */
+u32 qman_static_dequeue_get(void);
+
+/**
+ * qman_dca - Perform a Discrete Consumption Acknowledgement
+ * @dq: the DQRR entry to be consumed
+ * @park_request: indicates whether the held-active @fq should be parked
+ *
+ * Only allowed in DCA-mode portals, for DQRR entries whose handler callback had
+ * previously returned 'qman_cb_dqrr_defer'. NB, as with the other APIs, this
+ * does not take a 'portal' argument but implies the core affine portal from the
+ * cpu that is currently executing the function. For reasons of locking, this
+ * function must be called from the same CPU as that which processed the DQRR
+ * entry in the first place.
+ */
+void qman_dca(struct qm_dqrr_entry *dq, int park_request);
+
+/**
+ * qman_eqcr_is_empty - Determine if portal's EQCR is empty
+ *
+ * For use in situations where a cpu-affine caller needs to determine when all
+ * enqueues for the local portal have been processed by Qman but can't use the
+ * QMAN_ENQUEUE_FLAG_WAIT_SYNC flag to do this from the final qman_enqueue().
+ * The function forces tracking of EQCR consumption (which normally doesn't
+ * happen until enqueue processing needs to find space to put new enqueue
+ * commands), and returns zero if the ring still has unprocessed entries,
+ * non-zero if it is empty.
+ */
+int qman_eqcr_is_empty(void);
+
+/**
+ * qman_set_dc_ern - Set the handler for DCP enqueue rejection notifications
+ * @handler: callback for processing DCP ERNs
+ * @affine: whether this handler is specific to the locally affine portal
+ *
+ * If a hardware block's interface to Qman (ie. its direct-connect portal, or
+ * DCP) is configured not to receive enqueue rejections, then any enqueues
+ * through that DCP that are rejected will be sent to a given software portal.
+ * If @affine is non-zero, then this handler will only be used for DCP ERNs
+ * received on the portal affine to the current CPU. If multiple CPUs share a
+ * portal and they all call this function, they will be setting the handler for
+ * the same portal! If @affine is zero, then this handler will be global to all
+ * portals handled by this instance of the driver. Only those portals that do
+ * not have their own affine handler will use the global handler.
+ */
+void qman_set_dc_ern(qman_cb_dc_ern handler, int affine);
+
+	/* FQ management */
+	/* ------------- */
+/**
+ * qman_create_fq - Allocates a FQ
+ * @fqid: the index of the FQD to encapsulate, must be "Out of Service"
+ * @flags: bit-mask of QMAN_FQ_FLAG_*** options
+ * @fq: memory for storing the 'fq', with callbacks filled in
+ *
+ * Creates a frame queue object for the given @fqid, unless the
+ * QMAN_FQ_FLAG_DYNAMIC_FQID flag is set in @flags, in which case a FQID is
+ * dynamically allocated (or the function fails if none are available). Once
+ * created, the caller should not touch the memory at 'fq' except as extended to
+ * adjacent memory for user-defined fields (see the definition of "struct
+ * qman_fq" for more info). NO_MODIFY is only intended for enqueuing to
+ * pre-existing frame-queues that aren't to be otherwise interfered with, it
+ * prevents all other modifications to the frame queue. The TO_DCPORTAL flag
+ * causes the driver to honour any contextB modifications requested in the
+ * qm_init_fq() API, as this indicates the frame queue will be consumed by a
+ * direct-connect portal (PME, CAAM, or Fman). When frame queues are consumed by
+ * software portals, the contextB field is controlled by the driver and can't be
+ * modified by the caller. If the AS_IS flag is specified, management commands
+ * will be used on portal @p to query state for frame queue @fqid and construct
+ * a frame queue object based on that, rather than assuming/requiring that it be
+ * Out of Service.
+ */
+int qman_create_fq(u32 fqid, u32 flags, struct qman_fq *fq);
+
+/**
+ * qman_destroy_fq - Deallocates a FQ
+ * @fq: the frame queue object to release
+ * @flags: bit-mask of QMAN_FQ_FREE_*** options
+ *
+ * The memory for this frame queue object ('fq' provided in qman_create_fq()) is
+ * not deallocated but the caller regains ownership, to do with as desired. The
+ * FQ must be in the 'out-of-service' state unless the QMAN_FQ_FREE_PARKED flag
+ * is specified, in which case it may also be in the 'parked' state.
+ */
+void qman_destroy_fq(struct qman_fq *fq, u32 flags);
+
+/**
+ * qman_fq_fqid - Queries the frame queue ID of a FQ object
+ * @fq: the frame queue object to query
+ */
+u32 qman_fq_fqid(struct qman_fq *fq);
+
+/**
+ * qman_fq_state - Queries the state of a FQ object
+ * @fq: the frame queue object to query
+ * @state: pointer to state enum to return the FQ scheduling state
+ * @flags: pointer to state flags to receive QMAN_FQ_STATE_*** bitmask
+ *
+ * Queries the state of the FQ object, without performing any h/w commands.
+ * This captures the state, as seen by the driver, at the time the function
+ * executes.
+ */
+void qman_fq_state(struct qman_fq *fq, enum qman_fq_state *state, u32 *flags);
+
+/**
+ * qman_init_fq - Initialises FQ fields, leaves the FQ "parked" or "scheduled"
+ * @fq: the frame queue object to modify, must be 'parked' or new.
+ * @flags: bit-mask of QMAN_INITFQ_FLAG_*** options
+ * @opts: the FQ-modification settings, as defined in the low-level API
+ *
+ * The @opts parameter comes from the low-level portal API. Select
+ * QMAN_INITFQ_FLAG_SCHED in @flags to cause the frame queue to be scheduled
+ * rather than parked. NB, @opts can be NULL.
+ *
+ * Note that some fields and options within @opts may be ignored or overwritten
+ * by the driver;
+ * 1. the 'count' and 'fqid' fields are always ignored (this operation only
+ * affects one frame queue: @fq).
+ * 2. the QM_INITFQ_WE_CONTEXTB option of the 'we_mask' field and the associated
+ * 'fqd' structure's 'context_b' field are sometimes overwritten;
+ *   - if @fq was not created with QMAN_FQ_FLAG_TO_DCPORTAL, then context_b is
+ *     initialised to a value used by the driver for demux.
+ *   - if context_b is initialised for demux, so is context_a in case stashing
+ *     is requested (see item 4).
+ * (So caller control of context_b is only possible for TO_DCPORTAL frame queue
+ * objects.)
+ * 3. if @flags contains QMAN_INITFQ_FLAG_LOCAL, the 'fqd' structure's
+ * 'dest::channel' field will be overwritten to match the portal used to issue
+ * the command. If the WE_DESTWQ write-enable bit had already been set by the
+ * caller, the channel workqueue will be left as-is, otherwise the write-enable
+ * bit is set and the workqueue is set to a default of 4. If the "LOCAL" flag
+ * isn't set, the destination channel/workqueue fields and the write-enable bit
+ * are left as-is.
+ * 4. if the driver overwrites context_a/b for demux, then if
+ * QM_INITFQ_WE_CONTEXTA is set, the driver will only overwrite
+ * context_a.address fields and will leave the stashing fields provided by the
+ * user alone, otherwise it will zero out the context_a.stashing fields.
+ */
+int qman_init_fq(struct qman_fq *fq, u32 flags, struct qm_mcc_initfq *opts);
+
+/**
+ * qman_schedule_fq - Schedules a FQ
+ * @fq: the frame queue object to schedule, must be 'parked'
+ *
+ * Schedules the frame queue, which must be Parked, which takes it to
+ * Tentatively-Scheduled or Truly-Scheduled depending on its fill-level.
+ */
+int qman_schedule_fq(struct qman_fq *fq);
+
+/**
+ * qman_retire_fq - Retires a FQ
+ * @fq: the frame queue object to retire
+ * @flags: FQ flags (as per qman_fq_state) if retirement completes immediately
+ *
+ * Retires the frame queue. This returns zero if it succeeds immediately, +1 if
+ * the retirement was started asynchronously, otherwise it returns negative for
+ * failure. When this function returns zero, @flags is set to indicate whether
+ * the retired FQ is empty and/or whether it has any ORL fragments (to show up
+ * as ERNs). Otherwise the corresponding flags will be known when a subsequent
+ * FQRN message shows up on the portal's message ring.
+ *
+ * NB, if the retirement is asynchronous (the FQ was in the Truly Scheduled or
+ * Active state), the completion will be via the message ring as a FQRN - but
+ * the corresponding callback may occur before this function returns!! Ie. the
+ * caller should be prepared to accept the callback as the function is called,
+ * not only once it has returned.
+ */
+int qman_retire_fq(struct qman_fq *fq, u32 *flags);
+
+/**
+ * qman_oos_fq - Puts a FQ "out of service"
+ * @fq: the frame queue object to be put out-of-service, must be 'retired'
+ *
+ * The frame queue must be retired and empty, and if any order restoration list
+ * was released as ERNs at the time of retirement, they must all be consumed.
+ */
+int qman_oos_fq(struct qman_fq *fq);
+
+/**
+ * qman_fq_flow_control - Set the XON/XOFF state of a FQ
+ * @fq: the frame queue object to be set to XON/XOFF state, must not be 'oos',
+ * or 'retired' or 'parked' state
+ * @xon: boolean to set fq in XON or XOFF state
+ *
+ * The frame should be in Tentatively Scheduled state or Truly Schedule sate,
+ * otherwise the IFSI interrupt will be asserted.
+ */
+int qman_fq_flow_control(struct qman_fq *fq, int xon);
+
+/**
+ * qman_query_fq - Queries FQD fields (via h/w query command)
+ * @fq: the frame queue object to be queried
+ * @fqd: storage for the queried FQD fields
+ */
+int qman_query_fq(struct qman_fq *fq, struct qm_fqd *fqd);
+
+/**
+ * qman_query_fq_np - Queries non-programmable FQD fields
+ * @fq: the frame queue object to be queried
+ * @np: storage for the queried FQD fields
+ */
+int qman_query_fq_np(struct qman_fq *fq, struct qm_mcr_queryfq_np *np);
+
+/**
+ * qman_query_wq - Queries work queue lengths
+ * @query_dedicated: If non-zero, query length of WQs in the channel dedicated
+ *		to this software portal. Otherwise, query length of WQs in a
+ *		channel  specified in wq.
+ * @wq: storage for the queried WQs lengths. Also specified the channel to
+ *	to query if query_dedicated is zero.
+ */
+int qman_query_wq(u8 query_dedicated, struct qm_mcr_querywq *wq);
+
+/**
+ * qman_volatile_dequeue - Issue a volatile dequeue command
+ * @fq: the frame queue object to dequeue from
+ * @flags: a bit-mask of QMAN_VOLATILE_FLAG_*** options
+ * @vdqcr: bit mask of QM_VDQCR_*** options, as per qm_dqrr_vdqcr_set()
+ *
+ * Attempts to lock access to the portal's VDQCR volatile dequeue functionality.
+ * The function will block and sleep if QMAN_VOLATILE_FLAG_WAIT is specified and
+ * the VDQCR is already in use, otherwise returns non-zero for failure. If
+ * QMAN_VOLATILE_FLAG_FINISH is specified, the function will only return once
+ * the VDQCR command has finished executing (ie. once the callback for the last
+ * DQRR entry resulting from the VDQCR command has been called). If not using
+ * the FINISH flag, completion can be determined either by detecting the
+ * presence of the QM_DQRR_STAT_UNSCHEDULED and QM_DQRR_STAT_DQCR_EXPIRED bits
+ * in the "stat" field of the "struct qm_dqrr_entry" passed to the FQ's dequeue
+ * callback, or by waiting for the QMAN_FQ_STATE_VDQCR bit to disappear from the
+ * "flags" retrieved from qman_fq_state().
+ */
+int qman_volatile_dequeue(struct qman_fq *fq, u32 flags, u32 vdqcr);
+
+/**
+ * qman_enqueue - Enqueue a frame to a frame queue
+ * @fq: the frame queue object to enqueue to
+ * @fd: a descriptor of the frame to be enqueued
+ * @flags: bit-mask of QMAN_ENQUEUE_FLAG_*** options
+ *
+ * Fills an entry in the EQCR of portal @qm to enqueue the frame described by
+ * @fd. The descriptor details are copied from @fd to the EQCR entry, the 'pid'
+ * field is ignored. The return value is non-zero on error, such as ring full
+ * (and FLAG_WAIT not specified), congestion avoidance (FLAG_WATCH_CGR
+ * specified), etc. If the ring is full and FLAG_WAIT is specified, this
+ * function will block. If FLAG_INTERRUPT is set, the EQCI bit of the portal
+ * interrupt will assert when Qman consumes the EQCR entry (subject to "status
+ * disable", "enable", and "inhibit" registers). If FLAG_DCA is set, Qman will
+ * perform an implied "discrete consumption acknowledgement" on the dequeue
+ * ring's (DQRR) entry, at the ring index specified by the FLAG_DCA_IDX(x)
+ * macro. (As an alternative to issuing explicit DCA actions on DQRR entries,
+ * this implicit DCA can delay the release of a "held active" frame queue
+ * corresponding to a DQRR entry until Qman consumes the EQCR entry - providing
+ * order-preservation semantics in packet-forwarding scenarios.) If FLAG_DCA is
+ * set, then FLAG_DCA_PARK can also be set to imply that the DQRR consumption
+ * acknowledgement should "park request" the "held active" frame queue. Ie.
+ * when the portal eventually releases that frame queue, it will be left in the
+ * Parked state rather than Tentatively Scheduled or Truly Scheduled. If the
+ * portal is watching congestion groups, the QMAN_ENQUEUE_FLAG_WATCH_CGR flag
+ * is requested, and the FQ is a member of a congestion group, then this
+ * function returns -EAGAIN if the congestion group is currently congested.
+ * Note, this does not eliminate ERNs, as the async interface means we can be
+ * sending enqueue commands to an un-congested FQ that becomes congested before
+ * the enqueue commands are processed, but it does minimise needless thrashing
+ * of an already busy hardware resource by throttling many of the to-be-dropped
+ * enqueues "at the source".
+ */
+int qman_enqueue(struct qman_fq *fq, const struct qm_fd *fd, u32 flags);
+
+typedef int (*qman_cb_precommit) (void *arg);
+/**
+ * qman_enqueue_precommit - Enqueue a frame to a frame queue and call cb
+ * @fq: the frame queue object to enqueue to
+ * @fd: a descriptor of the frame to be enqueued
+ * @flags: bit-mask of QMAN_ENQUEUE_FLAG_*** options
+ * @cb: user supplied callback function to invoke before writing commit verb.
+ * @cb_arg: callback function argument
+ *
+ * This is similar to qman_enqueue except that it will invoke a user supplied
+ * callback function just before writng the commit verb. This is useful
+ * when the user want to do something *just before* enqueuing the request and
+ * the enqueue can't fail.
+ */
+int qman_enqueue_precommit(struct qman_fq *fq, const struct qm_fd *fd,
+		u32 flags, qman_cb_precommit cb, void *cb_arg);
+
+/**
+ * qman_enqueue_orp - Enqueue a frame to a frame queue using an ORP
+ * @fq: the frame queue object to enqueue to
+ * @fd: a descriptor of the frame to be enqueued
+ * @flags: bit-mask of QMAN_ENQUEUE_FLAG_*** options
+ * @orp: the frame queue object used as an order restoration point.
+ * @orp_seqnum: the sequence number of this frame in the order restoration path
+ *
+ * Similar to qman_enqueue(), but with the addition of an Order Restoration
+ * Point (@orp) and corresponding sequence number (@orp_seqnum) for this
+ * enqueue operation to employ order restoration. Each frame queue object acts
+ * as an Order Definition Point (ODP) by providing each frame dequeued from it
+ * with an incrementing sequence number, this value is generally ignored unless
+ * that sequence of dequeued frames will need order restoration later. Each
+ * frame queue object also encapsulates an Order Restoration Point (ORP), which
+ * is a re-assembly context for re-ordering frames relative to their sequence
+ * numbers as they are enqueued. The ORP does not have to be within the frame
+ * queue that receives the enqueued frame, in fact it is usually the frame
+ * queue from which the frames were originally dequeued. For the purposes of
+ * order restoration, multiple frames (or "fragments") can be enqueued for a
+ * single sequence number by setting the QMAN_ENQUEUE_FLAG_NLIS flag for all
+ * enqueues except the final fragment of a given sequence number. Ordering
+ * between sequence numbers is guaranteed, even if fragments of different
+ * sequence numbers are interlaced with one another. Fragments of the same
+ * sequence number will retain the order in which they are enqueued. If no
+ * enqueue is to performed, QMAN_ENQUEUE_FLAG_HOLE indicates that the given
+ * sequence number is to be "skipped" by the ORP logic (eg. if a frame has been
+ * dropped from a sequence), or QMAN_ENQUEUE_FLAG_NESN indicates that the given
+ * sequence number should become the ORP's "Next Expected Sequence Number".
+ *
+ * Side note: a frame queue object can be used purely as an ORP, without
+ * carrying any frames at all. Care should be taken not to deallocate a frame
+ * queue object that is being actively used as an ORP, as a future allocation
+ * of the frame queue object may start using the internal ORP before the
+ * previous use has finished.
+ */
+int qman_enqueue_orp(struct qman_fq *fq, const struct qm_fd *fd, u32 flags,
+			struct qman_fq *orp, u16 orp_seqnum);
+
+/**
+ * qman_alloc_fqid_range - Allocate a contiguous range of FQIDs
+ * @result: is set by the API to the base FQID of the allocated range
+ * @count: the number of FQIDs required
+ * @align: required alignment of the allocated range
+ * @partial: non-zero if the API can return fewer than @count FQIDs
+ *
+ * Returns the number of frame queues allocated, or a negative error code. If
+ * @partial is non zero, the allocation request may return a smaller range of
+ * FQs than requested (though alignment will be as requested). If @partial is
+ * zero, the return value will either be 'count' or negative.
+ */
+int qman_alloc_fqid_range(u32 *result, u32 count, u32 align, int partial);
+static inline int qman_alloc_fqid(u32 *result)
+{
+	int ret = qman_alloc_fqid_range(result, 1, 0, 0);
+	return (ret > 0) ? 0 : ret;
+}
+
+/**
+ * qman_release_fqid_range - Release the specified range of frame queue IDs
+ * @fqid: the base FQID of the range to deallocate
+ * @count: the number of FQIDs in the range
+ *
+ * This function can also be used to seed the allocator with ranges of FQIDs
+ * that it can subsequently allocate from.
+ */
+void qman_release_fqid_range(u32 fqid, unsigned int count);
+static inline void qman_release_fqid(u32 fqid)
+{
+	qman_release_fqid_range(fqid, 1);
+}
+
+void qman_seed_fqid_range(u32 fqid, unsigned int count);
+
+
+int qman_shutdown_fq(u32 fqid);
+
+/**
+ * qman_reserve_fqid_range - Reserve the specified range of frame queue IDs
+ * @fqid: the base FQID of the range to deallocate
+ * @count: the number of FQIDs in the range
+ */
+int qman_reserve_fqid_range(u32 fqid, unsigned int count);
+static inline int qman_reserve_fqid(u32 fqid)
+{
+	return qman_reserve_fqid_range(fqid, 1);
+}
+
+	/* Pool-channel management */
+	/* ----------------------- */
+/**
+ * qman_alloc_pool_range - Allocate a contiguous range of pool-channel IDs
+ * @result: is set by the API to the base pool-channel ID of the allocated range
+ * @count: the number of pool-channel IDs required
+ * @align: required alignment of the allocated range
+ * @partial: non-zero if the API can return fewer than @count
+ *
+ * Returns the number of pool-channel IDs allocated, or a negative error code.
+ * If @partial is non zero, the allocation request may return a smaller range of
+ * than requested (though alignment will be as requested). If @partial is zero,
+ * the return value will either be 'count' or negative.
+ */
+int qman_alloc_pool_range(u32 *result, u32 count, u32 align, int partial);
+static inline int qman_alloc_pool(u32 *result)
+{
+	int ret = qman_alloc_pool_range(result, 1, 0, 0);
+	return (ret > 0) ? 0 : ret;
+}
+
+/**
+ * qman_release_pool_range - Release the specified range of pool-channel IDs
+ * @id: the base pool-channel ID of the range to deallocate
+ * @count: the number of pool-channel IDs in the range
+ */
+void qman_release_pool_range(u32 id, unsigned int count);
+static inline void qman_release_pool(u32 id)
+{
+	qman_release_pool_range(id, 1);
+}
+
+/**
+ * qman_reserve_pool_range - Reserve the specified range of pool-channel IDs
+ * @id: the base pool-channel ID of the range to reserve
+ * @count: the number of pool-channel IDs in the range
+ */
+int qman_reserve_pool_range(u32 id, unsigned int count);
+static inline int qman_reserve_pool(u32 id)
+{
+	return qman_reserve_pool_range(id, 1);
+}
+
+void qman_seed_pool_range(u32 id, unsigned int count);
+
+	/* CGR management */
+	/* -------------- */
+/**
+ * qman_create_cgr - Register a congestion group object
+ * @cgr: the 'cgr' object, with fields filled in
+ * @flags: QMAN_CGR_FLAG_* values
+ * @opts: optional state of CGR settings
+ *
+ * Registers this object to receiving congestion entry/exit callbacks on the
+ * portal affine to the cpu portal on which this API is executed. If opts is
+ * NULL then only the callback (cgr->cb) function is registered. If @flags
+ * contains QMAN_CGR_FLAG_USE_INIT, then an init hw command (which will reset
+ * any unspecified parameters) will be used rather than a modify hw hardware
+ * (which only modifies the specified parameters).
+ */
+int qman_create_cgr(struct qman_cgr *cgr, u32 flags,
+			struct qm_mcc_initcgr *opts);
+
+/**
+ * qman_create_cgr_to_dcp - Register a congestion group object to DCP portal
+ * @cgr: the 'cgr' object, with fields filled in
+ * @flags: QMAN_CGR_FLAG_* values
+ * @dcp_portal: the DCP portal to which the cgr object is registered.
+ * @opts: optional state of CGR settings
+ *
+ */
+int qman_create_cgr_to_dcp(struct qman_cgr *cgr, u32 flags, u16 dcp_portal,
+				struct qm_mcc_initcgr *opts);
+
+/**
+ * qman_delete_cgr - Deregisters a congestion group object
+ * @cgr: the 'cgr' object to deregister
+ *
+ * "Unplugs" this CGR object from the portal affine to the cpu on which this API
+ * is executed. This must be excuted on the same affine portal on which it was
+ * created.
+ */
+int qman_delete_cgr(struct qman_cgr *cgr);
+
+/**
+ * qman_delete_cgr_safe - Deregisters a congestion group object from any CPU
+ * @cgr: the 'cgr' object to deregister
+ *
+ * This will select the proper CPU and run there qman_delete_cgr().
+ */
+void qman_delete_cgr_safe(struct qman_cgr *cgr);
+
+/**
+ * qman_modify_cgr - Modify CGR fields
+ * @cgr: the 'cgr' object to modify
+ * @flags: QMAN_CGR_FLAG_* values
+ * @opts: the CGR-modification settings
+ *
+ * The @opts parameter comes from the low-level portal API, and can be NULL.
+ * Note that some fields and options within @opts may be ignored or overwritten
+ * by the driver, in particular the 'cgrid' field is ignored (this operation
+ * only affects the given CGR object). If @flags contains
+ * QMAN_CGR_FLAG_USE_INIT, then an init hw command (which will reset any
+ * unspecified parameters) will be used rather than a modify hw hardware (which
+ * only modifies the specified parameters).
+ */
+int qman_modify_cgr(struct qman_cgr *cgr, u32 flags,
+			struct qm_mcc_initcgr *opts);
+
+/**
+* qman_query_cgr - Queries CGR fields
+* @cgr: the 'cgr' object to query
+* @result: storage for the queried congestion group record
+*/
+int qman_query_cgr(struct qman_cgr *cgr, struct qm_mcr_querycgr *result);
+
+/**
+ * qman_query_congestion - Queries the state of all congestion groups
+ * @congestion: storage for the queried state of all congestion groups
+ */
+int qman_query_congestion(struct qm_mcr_querycongestion *congestion);
+
+/**
+ * qman_alloc_cgrid_range - Allocate a contiguous range of CGR IDs
+ * @result: is set by the API to the base CGR ID of the allocated range
+ * @count: the number of CGR IDs required
+ * @align: required alignment of the allocated range
+ * @partial: non-zero if the API can return fewer than @count
+ *
+ * Returns the number of CGR IDs allocated, or a negative error code.
+ * If @partial is non zero, the allocation request may return a smaller range of
+ * than requested (though alignment will be as requested). If @partial is zero,
+ * the return value will either be 'count' or negative.
+ */
+int qman_alloc_cgrid_range(u32 *result, u32 count, u32 align, int partial);
+static inline int qman_alloc_cgrid(u32 *result)
+{
+	int ret = qman_alloc_cgrid_range(result, 1, 0, 0);
+	return (ret > 0) ? 0 : ret;
+}
+
+/**
+ * qman_release_cgrid_range - Release the specified range of CGR IDs
+ * @id: the base CGR ID of the range to deallocate
+ * @count: the number of CGR IDs in the range
+ */
+void qman_release_cgrid_range(u32 id, unsigned int count);
+static inline void qman_release_cgrid(u32 id)
+{
+	qman_release_cgrid_range(id, 1);
+}
+
+/**
+ * qman_reserve_cgrid_range - Reserve the specified range of CGR ID
+ * @id: the base CGR ID of the range to reserve
+ * @count: the number of CGR IDs in the range
+ */
+int qman_reserve_cgrid_range(u32 id, unsigned int count);
+static inline int qman_reserve_cgrid(u32 id)
+{
+	return qman_reserve_cgrid_range(id, 1);
+}
+
+void qman_seed_cgrid_range(u32 id, unsigned int count);
+
+
+	/* Helpers */
+	/* ------- */
+/**
+ * qman_poll_fq_for_init - Check if an FQ has been initialised from OOS
+ * @fqid: the FQID that will be initialised by other s/w
+ *
+ * In many situations, a FQID is provided for communication between s/w
+ * entities, and whilst the consumer is responsible for initialising and
+ * scheduling the FQ, the producer(s) generally create a wrapper FQ object using
+ * and only call qman_enqueue() (no FQ initialisation, scheduling, etc). Ie;
+ *     qman_create_fq(..., QMAN_FQ_FLAG_NO_MODIFY, ...);
+ * However, data can not be enqueued to the FQ until it is initialised out of
+ * the OOS state - this function polls for that condition. It is particularly
+ * useful for users of IPC functions - each endpoint's Rx FQ is the other
+ * endpoint's Tx FQ, so each side can initialise and schedule their Rx FQ object
+ * and then use this API on the (NO_MODIFY) Tx FQ object in order to
+ * synchronise. The function returns zero for success, +1 if the FQ is still in
+ * the OOS state, or negative if there was an error.
+ */
+static inline int qman_poll_fq_for_init(struct qman_fq *fq)
+{
+	struct qm_mcr_queryfq_np np;
+	int err;
+	err = qman_query_fq_np(fq, &np);
+	if (err)
+		return err;
+	if ((np.state & QM_MCR_NP_STATE_MASK) == QM_MCR_NP_STATE_OOS)
+		return 1;
+	return 0;
+}
+
+	/* -------------- */
+	/* CEETM :: types */
+	/* -------------- */
+/**
+ * Token Rate Structure
+ * Shaping rates are based on a "credit" system and a pre-configured h/w
+ * internal timer. The following type represents a shaper "rate" parameter as a
+ * fractional number of "tokens". Here's how it works. This (fractional) number
+ * of tokens is added to the shaper's "credit" every time the h/w timer elapses
+ * (up to a limit which is set by another shaper parameter). Every time a frame
+ * is enqueued through a shaper, the shaper deducts as many tokens as there are
+ * bytes of data in the enqueued frame. A shaper will not allow itself to
+ * enqueue any frames if its token count is negative. As such;
+ *
+ *         The rate at which data is enqueued is limited by the
+ *         rate at which tokens are added.
+ *
+ * Therefore if the user knows the period between these h/w timer updates in
+ * seconds, they can calculate the maximum traffic rate of the shaper (in
+ * bytes-per-second) from the token rate. And vice versa, they can calculate
+ * the token rate to use in order to achieve a given traffic rate.
+ */
+struct qm_ceetm_rate {
+	/* The token rate is; whole + (fraction/8192) */
+	u32 whole:11; /* 0..2047 */
+	u32 fraction:13; /* 0..8191 */
+};
+
+struct qm_ceetm_weight_code {
+	/* The weight code is; 5 msbits + 3 lsbits */
+	u8 y:5;
+	u8 x:3;
+};
+
+struct qm_ceetm {
+	unsigned int idx;
+	struct list_head sub_portals;
+	struct list_head lnis;
+	unsigned int sp_range[2];
+	unsigned int lni_range[2];
+};
+
+struct qm_ceetm_sp {
+	struct list_head node;
+	unsigned int idx;
+	unsigned int dcp_idx;
+	int is_claimed;
+	struct qm_ceetm_lni *lni;
+};
+
+/* Logical Network Interface */
+struct qm_ceetm_lni {
+	struct list_head node;
+	unsigned int idx;
+	unsigned int dcp_idx;
+	int is_claimed;
+	struct qm_ceetm_sp *sp;
+	struct list_head channels;
+	int shaper_enable;
+	int shaper_couple;
+	int oal;
+	struct qm_ceetm_rate cr_token_rate;
+	struct qm_ceetm_rate er_token_rate;
+	u16 cr_token_bucket_limit;
+	u16 er_token_bucket_limit;
+};
+
+/* Class Queue Channel */
+struct qm_ceetm_channel {
+	struct list_head node;
+	unsigned int idx;
+	unsigned int lni_idx;
+	unsigned int dcp_idx;
+	struct list_head class_queues;
+	struct list_head ccgs;
+	u8 shaper_enable;
+	u8 shaper_couple;
+	struct qm_ceetm_rate cr_token_rate;
+	struct qm_ceetm_rate er_token_rate;
+	u16 cr_token_bucket_limit;
+	u16 er_token_bucket_limit;
+};
+
+struct qm_ceetm_ccg;
+
+/* This callback type is used when handling congestion entry/exit. The
+ * 'cb_ctx' value is the opaque value associated with ccg object.
+ * 'congested' is non-zero on congestion-entry, and zero on congestion-exit.
+ */
+typedef void (*qman_cb_ccgr)(struct qm_ceetm_ccg *ccg, void *cb_ctx,
+							int congested);
+
+/* Class Congestion Group */
+struct qm_ceetm_ccg {
+	struct qm_ceetm_channel *parent;
+	struct list_head node;
+	struct list_head cb_node;
+	qman_cb_ccgr cb;
+	void *cb_ctx;
+	unsigned int idx;
+};
+
+/* Class Queue */
+struct qm_ceetm_cq {
+	struct qm_ceetm_channel *parent;
+	struct qm_ceetm_ccg *ccg;
+	struct list_head node;
+	unsigned int idx;
+	int is_claimed;
+	struct list_head bound_lfqids;
+	struct list_head binding_node;
+};
+
+/* Logical Frame Queue */
+struct qm_ceetm_lfq {
+	struct qm_ceetm_channel *parent;
+	struct list_head node;
+	unsigned int idx;
+	unsigned int dctidx;
+	u64 context_a;
+	u32 context_b;
+	qman_cb_mr ern;
+};
+
+/**
+ * qman_ceetm_bps2tokenrate - Given a desired rate 'bps' measured in bps
+ * (ie. bits-per-second), compute the 'token_rate' fraction that best
+ * approximates that rate.
+ * @bps: the desired shaper rate in bps.
+ * @token_rate: the output token rate computed with the given kbps.
+ * @rounding: dictates how to round if an exact conversion is not possible; if
+ * it is negative then 'token_rate' will round down to the highest value that
+ * does not exceed the desired rate, if it is positive then 'token_rate' will
+ * round up to the lowest value that is greater than or equal to the desired
+ * rate, and if it is zero then it will round to the nearest approximation,
+ * whether that be up or down.
+ *
+ * Return 0 for success, or -EINVAL if prescaler or qman clock is not available.
+  */
+int qman_ceetm_bps2tokenrate(u64 bps,
+				struct qm_ceetm_rate *token_rate,
+				int rounding);
+
+/**
+ * qman_ceetm_tokenrate2bps - Given a 'token_rate', compute the
+ * corresponding number of 'bps'.
+ * @token_rate: the input desired token_rate fraction.
+ * @bps: the output shaper rate in bps computed with the give token rate.
+ * @rounding: has the same semantics as the previous function.
+ *
+ * Return 0 for success, or -EINVAL if prescaler or qman clock is not available.
+ */
+int qman_ceetm_tokenrate2bps(const struct qm_ceetm_rate *token_rate,
+			      u64 *bps,
+			      int rounding);
+
+int qman_alloc_ceetm0_channel_range(u32 *result, u32 count, u32 align,
+								int partial);
+static inline int qman_alloc_ceetm0_channel(u32 *result)
+{
+	int ret = qman_alloc_ceetm0_channel_range(result, 1, 0, 0);
+	return (ret > 0) ? 0 : ret;
+}
+void qman_release_ceetm0_channel_range(u32 channelid, u32 count);
+static inline void qman_release_ceetm0_channelid(u32 channelid)
+{
+	qman_release_ceetm0_channel_range(channelid, 1);
+}
+
+int qman_reserve_ceetm0_channel_range(u32 channelid, u32 count);
+static inline int qman_reserve_ceetm0_channelid(u32 channelid)
+{
+	return qman_reserve_ceetm0_channel_range(channelid, 1);
+}
+
+void qman_seed_ceetm0_channel_range(u32 channelid, u32 count);
+
+
+int qman_alloc_ceetm1_channel_range(u32 *result, u32 count, u32 align,
+								int partial);
+static inline int qman_alloc_ceetm1_channel(u32 *result)
+{
+	int ret = qman_alloc_ceetm1_channel_range(result, 1, 0, 0);
+	return (ret > 0) ? 0 : ret;
+}
+void qman_release_ceetm1_channel_range(u32 channelid, u32 count);
+static inline void qman_release_ceetm1_channelid(u32 channelid)
+{
+	qman_release_ceetm1_channel_range(channelid, 1);
+}
+int qman_reserve_ceetm1_channel_range(u32 channelid, u32 count);
+static inline int qman_reserve_ceetm1_channelid(u32 channelid)
+{
+	return qman_reserve_ceetm1_channel_range(channelid, 1);
+}
+
+void qman_seed_ceetm1_channel_range(u32 channelid, u32 count);
+
+
+int qman_alloc_ceetm0_lfqid_range(u32 *result, u32 count, u32 align,
+								int partial);
+static inline int qman_alloc_ceetm0_lfqid(u32 *result)
+{
+	int ret = qman_alloc_ceetm0_lfqid_range(result, 1, 0, 0);
+	return (ret > 0) ? 0 : ret;
+}
+void qman_release_ceetm0_lfqid_range(u32 lfqid, u32 count);
+static inline void qman_release_ceetm0_lfqid(u32 lfqid)
+{
+	qman_release_ceetm0_lfqid_range(lfqid, 1);
+}
+int qman_reserve_ceetm0_lfqid_range(u32 lfqid, u32 count);
+static inline int qman_reserve_ceetm0_lfqid(u32 lfqid)
+{
+	return qman_reserve_ceetm0_lfqid_range(lfqid, 1);
+}
+
+void qman_seed_ceetm0_lfqid_range(u32 lfqid, u32 count);
+
+
+int qman_alloc_ceetm1_lfqid_range(u32 *result, u32 count, u32 align,
+								int partial);
+static inline int qman_alloc_ceetm1_lfqid(u32 *result)
+{
+	int ret = qman_alloc_ceetm1_lfqid_range(result, 1, 0, 0);
+	return (ret > 0) ? 0 : ret;
+}
+void qman_release_ceetm1_lfqid_range(u32 lfqid, u32 count);
+static inline void qman_release_ceetm1_lfqid(u32 lfqid)
+{
+	qman_release_ceetm1_lfqid_range(lfqid, 1);
+}
+int qman_reserve_ceetm1_lfqid_range(u32 lfqid, u32 count);
+static inline int qman_reserve_ceetm1_lfqid(u32 lfqid)
+{
+	return qman_reserve_ceetm1_lfqid_range(lfqid, 1);
+}
+
+void qman_seed_ceetm1_lfqid_range(u32 lfqid, u32 count);
+
+
+	/* ----------------------------- */
+	/* CEETM :: sub-portals          */
+	/* ----------------------------- */
+
+/**
+ * qman_ceetm_sp_claim - Claims the given sub-portal, provided it is available
+ * to us and configured for traffic-management.
+ * @sp: the returned sub-portal object, if successful.
+ * @dcp_id: specifies the desired Fman block (and thus the relevant CEETM
+ * instance),
+ * @sp_idx" is the desired sub-portal index from 0 to 15.
+ *
+ * Returns zero for success, or -ENODEV if the sub-portal is in use,  or -EINVAL
+ * if the sp_idx is out of range.
+ *
+ * Note that if there are multiple driver domains (eg. a linux kernel versus
+ * user-space drivers in USDPAA, or multiple guests running under a hypervisor)
+ * then a sub-portal may be accessible by more than one instance of a qman
+ * driver and so it may be claimed multiple times. If this is the case, it is
+ * up to the system architect to prevent conflicting configuration actions
+ * coming from the different driver domains. The qman drivers do not have any
+ * behind-the-scenes coordination to prevent this from happening.
+ */
+int qman_ceetm_sp_claim(struct qm_ceetm_sp **sp,
+			enum qm_dc_portal dcp_idx,
+			unsigned int sp_idx);
+
+/**
+ * qman_ceetm_sp_release - Releases a previously claimed sub-portal.
+ * @sp: the sub-portal to be released.
+ *
+ * Returns 0 for success, or -EBUSY for failure if the dependencies are not
+ * released.
+ */
+int qman_ceetm_sp_release(struct qm_ceetm_sp *sp);
+
+	/* ----------------------------------- */
+	/* CEETM :: logical network interfaces */
+	/* ----------------------------------- */
+
+/**
+ * qman_ceetm_lni_claim - Claims an unclaimed LNI.
+ * @lni: the returned LNI object, if successful.
+ * @dcp_id: specifies the desired Fman block (and thus the relevant CEETM
+ * instance)
+ * @lni_idx: is the desired LNI index.
+ *
+ * Returns zero for success, or -EINVAL on failure, which will happen if the LNI
+ * is not available or has already been claimed (and not yet successfully
+ * released), or lni_dix is out of range.
+ *
+ * Note that there may be multiple driver domains (or instances) that need to
+ * transmit out the same LNI, so this claim is only guaranteeing exclusivity
+ * within the domain of the driver being called. See qman_ceetm_sp_claim() and
+ * qman_ceetm_sp_get_lni() for more information.
+ */
+int qman_ceetm_lni_claim(struct qm_ceetm_lni **lni,
+			 enum qm_dc_portal dcp_id,
+			 unsigned int lni_idx);
+
+/**
+ * qman_ceetm_lni_releaes - Releases a previously claimed LNI.
+ * @lni: the lni needs to be released.
+ *
+ * This will only succeed if all dependent objects have been released.
+ * Returns zero for success, or -EBUSY if the dependencies are not released.
+ */
+int qman_ceetm_lni_release(struct qm_ceetm_lni *lni);
+
+/**
+ * qman_ceetm_sp_set_lni
+ * qman_ceetm_sp_get_lni - Set/get the LNI that the sub-portal is currently
+ * mapped to.
+ * @sp: the given sub-portal.
+ * @lni(in "set"function): the LNI object which the sp will be mappaed to.
+ * @lni_idx(in "get" function): the LNI index which the sp is mapped to.
+ *
+ * Returns zero for success, or -EINVAL for the "set" function when this sp-lni
+ * mapping has been set, or configure mapping command returns error, and
+ * -EINVAL for "get" function when this sp-lni mapping is not set or the query
+ * mapping command returns error.
+ *
+ * This may be useful in situations where multiple driver domains have access
+ * to the same sub-portals in order to all be able to transmit out the same
+ * physical interface (perhaps they're on different IP addresses or VPNs, so
+ * Fman is splitting Rx traffic and here we need to converge Tx traffic). In
+ * that case, a control-plane is likely to use qman_ceetm_lni_claim() followed
+ * by qman_ceetm_sp_set_lni() to configure the sub-portal, and other domains
+ * are likely to use qman_ceetm_sp_get_lni() followed by qman_ceetm_lni_claim()
+ * in order to determine the LNI that the control-plane had assigned. This is
+ * why the "get" returns an index, whereas the "set" takes an (already claimed)
+ * LNI object.
+ */
+int qman_ceetm_sp_set_lni(struct qm_ceetm_sp *sp,
+			  struct qm_ceetm_lni *lni);
+int qman_ceetm_sp_get_lni(struct qm_ceetm_sp *sp,
+			  unsigned int *lni_idx);
+
+/**
+ * qman_ceetm_lni_enable_shaper
+ * qman_ceetm_lni_disable_shaper - Enables/disables shaping on the LNI.
+ * @lni: the given LNI.
+ * @coupled: indicates whether CR and ER are coupled.
+ * @oal: the overhead accounting length which is added to the actual length of
+ * each frame when performing shaper calculations.
+ *
+ * When the number of (unused) committed-rate tokens reach the committed-rate
+ * token limit, 'coupled' indicates whether surplus tokens should be added to
+ * the excess-rate token count (up to the excess-rate token limit).
+ * When LNI is claimed, the shaper is disabled by default. The enable function
+ * will turn on this shaper for this lni.
+ * Whenever a claimed LNI is first enabled for shaping, its committed and
+ * excess token rates and limits are zero, so will need to be changed to do
+ * anything useful. The shaper can subsequently be enabled/disabled without
+ * resetting the shaping parameters, but the shaping parameters will be reset
+ * when the LNI is released.
+ *
+ * Returns zero for success, or  errno for "enable" function in the cases as:
+ * a) -EINVAL if the shaper is already enabled,
+ * b) -EIO if the configure shaper command returns error.
+ * For "disable" function, returns:
+ * a) -EINVAL if the shaper is has already disabled.
+ * b) -EIO if calling configure shaper command returns error.
+ */
+int qman_ceetm_lni_enable_shaper(struct qm_ceetm_lni *lni, int coupled,
+								int oal);
+int qman_ceetm_lni_disable_shaper(struct qm_ceetm_lni *lni);
+
+/**
+ * qman_ceetm_lni_is_shaper_enabled - Check LNI shaper status
+ * @lni: the give LNI
+ */
+int qman_ceetm_lni_is_shaper_enabled(struct qm_ceetm_lni *lni);
+
+/**
+ * qman_ceetm_lni_set_commit_rate
+ * qman_ceetm_lni_get_commit_rate
+ * qman_ceetm_lni_set_excess_rate
+ * qman_ceetm_lni_get_excess_rate - Set/get the shaper CR/ER token rate and
+ * token limit for the given LNI.
+ * @lni: the given LNI.
+ * @token_rate: the desired token rate for "set" fuction, or the token rate of
+ * the LNI queried by "get" function.
+ * @token_limit: the desired token bucket limit for "set" function, or the token
+ * limit of the given LNI queried by "get" function.
+ *
+ * Returns zero for success. The "set" function returns -EINVAL if the given
+ * LNI is unshapped or -EIO if the configure shaper command returns error.
+ * The "get" function returns -EINVAL if the token rate or the token limit is
+ * not set or the query command returns error.
+ */
+int qman_ceetm_lni_set_commit_rate(struct qm_ceetm_lni *lni,
+				   const struct qm_ceetm_rate *token_rate,
+				   u16 token_limit);
+int qman_ceetm_lni_get_commit_rate(struct qm_ceetm_lni *lni,
+				   struct qm_ceetm_rate *token_rate,
+				   u16 *token_limit);
+int qman_ceetm_lni_set_excess_rate(struct qm_ceetm_lni *lni,
+				   const struct qm_ceetm_rate *token_rate,
+				   u16 token_limit);
+int qman_ceetm_lni_get_excess_rate(struct qm_ceetm_lni *lni,
+				   struct qm_ceetm_rate *token_rate,
+				   u16 *token_limit);
+/**
+ * qman_ceetm_lni_set_commit_rate_bps
+ * qman_ceetm_lni_get_commit_rate_bps
+ * qman_ceetm_lni_set_excess_rate_bps
+ * qman_ceetm_lni_get_excess_rate_bps - Set/get the shaper CR/ER rate
+ * and token limit for the given LNI.
+ * @lni: the given LNI.
+ * @bps: the desired shaping rate in bps for "set" fuction, or the shaping rate
+ * of the LNI queried by "get" function.
+ * @token_limit: the desired token bucket limit for "set" function, or the token
+ * limit of the given LNI queried by "get" function.
+ *
+ * Returns zero for success. The "set" function returns -EINVAL if the given
+ * LNI is unshapped or -EIO if the configure shaper command returns error.
+ * The "get" function returns -EINVAL if the token rate or the token limit is
+ * not set or the query command returns error.
+ */
+int qman_ceetm_lni_set_commit_rate_bps(struct qm_ceetm_lni *lni,
+				       u64 bps,
+				       u16 token_limit);
+int qman_ceetm_lni_get_commit_rate_bps(struct qm_ceetm_lni *lni,
+				       u64 *bps, u16 *token_limit);
+int qman_ceetm_lni_set_excess_rate_bps(struct qm_ceetm_lni *lni,
+				       u64 bps,
+				       u16 token_limit);
+int qman_ceetm_lni_get_excess_rate_bps(struct qm_ceetm_lni *lni,
+				       u64 *bps, u16 *token_limit);
+
+/**
+ * qman_ceetm_lni_set_tcfcc
+ * qman_ceetm_lni_get_tcfcc - Configure/query "Traffic Class Flow Control".
+ * @lni: the given LNI.
+ * @cq_level: is between 0 and 15, representing individual class queue levels
+ * (CQ0 to CQ7 for every channel) and grouped class queue levels (CQ8 to CQ15
+ * for every channel).
+ * @traffic_class: is between 0 and 7 when associating a given class queue level
+ * to a traffic class, or -1 when disabling traffic class flow control for this
+ * class queue level.
+ *
+ * Return zero for success, or -EINVAL if the cq_level or traffic_class is out
+ * of range as indicated above, or -EIO if the configure/query tcfcc command
+ * returns error.
+ *
+ * Refer to the section of QMan CEETM traffic class flow control in the
+ * Reference Manual.
+ */
+int qman_ceetm_lni_set_tcfcc(struct qm_ceetm_lni *lni,
+			     unsigned int cq_level,
+			     int traffic_class);
+int qman_ceetm_lni_get_tcfcc(struct qm_ceetm_lni *lni,
+			     unsigned int cq_level,
+			     int *traffic_class);
+
+	/* ----------------------------- */
+	/* CEETM :: class queue channels */
+	/* ----------------------------- */
+
+/**
+ * qman_ceetm_channel_claim - Claims an unclaimed CQ channel that is mapped to
+ * the given LNI.
+ * @channel: the returned class queue channel object, if successful.
+ * @lni: the LNI that the channel belongs to.
+ *
+ * Channels are always initially "unshaped".
+ *
+ * Return zero for success, or -ENODEV if there is no channel available(all 32
+ * channels are claimed) or -EINVAL if the channel mapping command returns
+ * error.
+ */
+int qman_ceetm_channel_claim(struct qm_ceetm_channel **channel,
+			     struct qm_ceetm_lni *lni);
+
+/**
+ * qman_ceetm_channel_release - Releases a previously claimed CQ channel.
+ * @channel: the channel needs to be released.
+ *
+ * Returns zero for success, or -EBUSY if the dependencies are still in use.
+ *
+ * Note any shaping of the channel will be cleared to leave it in an unshaped
+ * state.
+ */
+int qman_ceetm_channel_release(struct qm_ceetm_channel *channel);
+
+/**
+ * qman_ceetm_channel_enable_shaper
+ * qman_ceetm_channel_disable_shaper - Enables/disables shaping on the channel.
+ * @channel: the given channel.
+ * @coupled: indicates whether surplus CR tokens should be added to the
+ * excess-rate token count (up to the excess-rate token limit) when the number
+ * of (unused) committed-rate tokens reach the committed_rate token limit.
+ *
+ * Whenever a claimed channel is first enabled for shaping, its committed and
+ * excess token rates and limits are zero, so will need to be changed to do
+ * anything useful. The shaper can subsequently be enabled/disabled without
+ * resetting the shaping parameters, but the shaping parameters will be reset
+ * when the channel is released.
+ *
+ * Return 0 for success, or -EINVAL for failure, in the case that the channel
+ * shaper has been enabled/disabled or the management command returns error.
+ */
+int qman_ceetm_channel_enable_shaper(struct qm_ceetm_channel *channel,
+							 int coupled);
+int qman_ceetm_channel_disable_shaper(struct qm_ceetm_channel *channel);
+
+/**
+ * qman_ceetm_channel_is_shaper_enabled - Check channel shaper status.
+ * @channel: the give channel.
+ */
+int qman_ceetm_channel_is_shaper_enabled(struct qm_ceetm_channel *channel);
+
+/**
+ * qman_ceetm_channel_set_commit_rate
+ * qman_ceetm_channel_get_commit_rate
+ * qman_ceetm_channel_set_excess_rate
+ * qman_ceetm_channel_get_excess_rate - Set/get channel CR/ER shaper parameters.
+ * @channel: the given channel.
+ * @token_rate: the desired token rate for "set" function, or the queried token
+ * rate for "get" function.
+ * @token_limit: the desired token limit for "set" function, or the queried
+ * token limit for "get" function.
+ *
+ * Return zero for success. The "set" function returns -EINVAL if the channel
+ * is unshaped, or -EIO if the configure shapper command returns error. The
+ * "get" function returns -EINVAL if token rate of token limit is not set, or
+ * the query shaper command returns error.
+ */
+int qman_ceetm_channel_set_commit_rate(struct qm_ceetm_channel *channel,
+				   const struct qm_ceetm_rate *token_rate,
+				   u16 token_limit);
+int qman_ceetm_channel_get_commit_rate(struct qm_ceetm_channel *channel,
+				   struct qm_ceetm_rate *token_rate,
+				   u16 *token_limit);
+int qman_ceetm_channel_set_excess_rate(struct qm_ceetm_channel *channel,
+				   const struct qm_ceetm_rate *token_rate,
+				   u16 token_limit);
+int qman_ceetm_channel_get_excess_rate(struct qm_ceetm_channel *channel,
+				   struct qm_ceetm_rate *token_rate,
+				   u16 *token_limit);
+/**
+ * qman_ceetm_channel_set_commit_rate_bps
+ * qman_ceetm_channel_get_commit_rate_bps
+ * qman_ceetm_channel_set_excess_rate_bps
+ * qman_ceetm_channel_get_excess_rate_bps - Set/get channel CR/ER shaper
+ * parameters.
+ * @channel: the given channel.
+ * @token_rate: the desired shaper rate in bps for "set" function, or the
+ * shaper rate in bps for "get" function.
+ * @token_limit: the desired token limit for "set" function, or the queried
+ * token limit for "get" function.
+ *
+ * Return zero for success. The "set" function returns -EINVAL if the channel
+ * is unshaped, or -EIO if the configure shapper command returns error. The
+ * "get" function returns -EINVAL if token rate of token limit is not set, or
+ * the query shaper command returns error.
+ */
+int qman_ceetm_channel_set_commit_rate_bps(struct qm_ceetm_channel *channel,
+					   u64 bps, u16 token_limit);
+int qman_ceetm_channel_get_commit_rate_bps(struct qm_ceetm_channel *channel,
+					   u64 *bps, u16 *token_limit);
+int qman_ceetm_channel_set_excess_rate_bps(struct qm_ceetm_channel *channel,
+					   u64 bps, u16 token_limit);
+int qman_ceetm_channel_get_excess_rate_bps(struct qm_ceetm_channel *channel,
+					   u64 *bps, u16 *token_limit);
+
+/**
+ * qman_ceetm_channel_set_weight
+ * qman_ceetm_channel_get_weight - Set/get the weight for unshaped channel
+ * @channel: the given channel.
+ * @token_limit: the desired token limit as the weight of the unshaped channel
+ * for "set" function, or the queried token limit for "get" function.
+ *
+ * The algorithm of unshaped fair queuing (uFQ) is used for unshaped channel.
+ * It allows the unshaped channels to be included in the CR time eligible list,
+ * and thus use the configured CR token limit value as their fair queuing
+ * weight.
+ *
+ * Return zero for success, or -EINVAL if the channel is a shaped channel or
+ * the management command returns error.
+ */
+int qman_ceetm_channel_set_weight(struct qm_ceetm_channel *channel,
+				  u16 token_limit);
+int qman_ceetm_channel_get_weight(struct qm_ceetm_channel *channel,
+				  u16 *token_limit);
+
+/**
+ * qman_ceetm_channel_set_group
+ * qman_ceetm_channel_get_group - Set/get the grouping of the class scheduler.
+ * @channel: the given channel.
+ * @group_b: indicates whether there is group B in this channel.
+ * @prio_a: the priority of group A.
+ * @prio_b: the priority of group B.
+ *
+ * There are 8 individual class queues (CQ0-CQ7), and 8 grouped class queues
+ * (CQ8-CQ15). If 'group_b' is zero, then all the grouped class queues are in
+ * group A, otherwise they are split into group A (CQ8-11) and group B
+ * (CQ12-C15). The individual class queues and the group(s) are in strict
+ * priority order relative to each other. Within the group(s), the scheduling
+ * is not strict priority order, but the result of scheduling within a group
+ * is in strict priority order relative to the other class queues in the
+ * channel. 'prio_a' and 'prio_b' control the priority order of the groups
+ * relative to the individual class queues, and take values from 0-7. Eg. if
+ * 'group_b' is non-zero, 'prio_a' is 2 and 'prio_b' is 6, then the strict
+ * priority order would be;
+ *      CQ0, CQ1, CQ2, GROUPA, CQ3, CQ4, CQ5, CQ6, GROUPB, CQ7
+ *
+ * Return 0 for success. For "set" function, returns -EINVAL if prio_a or
+ * prio_b are out of the range 0 - 7 (priority of group A or group B can not
+ * be 0, CQ0 is always the highest class queue in this channel.), or -EIO if
+ * the configure scheduler command returns error. For "get" function, return
+ * -EINVAL if the query scheduler command returns error.
+ */
+int qman_ceetm_channel_set_group(struct qm_ceetm_channel *channel,
+			     int group_b,
+			     unsigned int prio_a,
+			     unsigned int prio_b);
+int qman_ceetm_channel_get_group(struct qm_ceetm_channel *channel,
+			     int *group_b,
+			     unsigned int *prio_a,
+			     unsigned int *prio_b);
+
+/**
+ * qman_ceetm_channel_set_group_cr_eligibility
+ * qman_ceetm_channel_set_group_er_eligibility - Set channel group eligibility
+ * @channel: the given channel object
+ * @group_b: indicates whether there is group B in this channel.
+ * @cre: the commit rate eligibility, 1 for enable, 0 for disable.
+ *
+ * Return zero for success, or -EINVAL if eligibility setting fails.
+*/
+int qman_ceetm_channel_set_group_cr_eligibility(struct qm_ceetm_channel
+				*channel, int group_b, int cre);
+int qman_ceetm_channel_set_group_er_eligibility(struct qm_ceetm_channel
+				*channel, int group_b, int ere);
+
+/**
+ * qman_ceetm_channel_set_cq_cr_eligibility
+ * qman_ceetm_channel_set_cq_er_eligibility - Set channel cq eligibility
+ * @channel: the given channel object
+ * @idx: is from 0 to 7 (representing CQ0 to CQ7).
+ * @cre: the commit rate eligibility, 1 for enable, 0 for disable.
+ *
+ * Return zero for success, or -EINVAL if eligibility setting fails.
+*/
+int qman_ceetm_channel_set_cq_cr_eligibility(struct qm_ceetm_channel *channel,
+					unsigned int idx, int cre);
+int qman_ceetm_channel_set_cq_er_eligibility(struct qm_ceetm_channel *channel,
+					unsigned int idx, int ere);
+
+	/* --------------------- */
+	/* CEETM :: class queues */
+	/* --------------------- */
+
+/**
+ * qman_ceetm_cq_claim - Claims an individual class queue.
+ * @cq: the returned class queue object, if successful.
+ * @channel: the class queue channel.
+ * @idx: is from 0 to 7 (representing CQ0 to CQ7).
+ * @ccg: represents the class congestion group that this class queue should be
+ * subscribed to, or NULL if no congestion group membership is desired.
+ *
+ * Returns zero for success, or -EINVAL if @idx is out of range 0 - 7 or
+ * if this class queue has been claimed, or configure class queue command
+ * returns error, or returns -ENOMEM if allocating CQ memory fails.
+ */
+int qman_ceetm_cq_claim(struct qm_ceetm_cq **cq,
+			struct qm_ceetm_channel *channel,
+			unsigned int idx,
+			struct qm_ceetm_ccg *ccg);
+
+/**
+ * qman_ceetm_cq_claim_A - Claims a class queue group A.
+ * @cq: the returned class queue object, if successful.
+ * @channel: the class queue channel.
+ * @idx: is from 8 to 15 if only group A exits, otherwise, it is from 8 to 11.
+ * @ccg: represents the class congestion group that this class queue should be
+ * subscribed to, or NULL if no congestion group membership is desired.
+ *
+ * Return zero for success, or -EINVAL if @idx is out the range or if
+ * this class queue has been claimed or configure class queue command returns
+ * error, or returns -ENOMEM if allocating CQ memory fails.
+ */
+int qman_ceetm_cq_claim_A(struct qm_ceetm_cq **cq,
+				struct qm_ceetm_channel *channel,
+				unsigned int idx,
+				struct qm_ceetm_ccg *ccg);
+
+/**
+ * qman_ceetm_cq_claim_B - Claims a class queue group B.
+ * @cq: the returned class queue object, if successful.
+ * @channel: the class queue channel.
+ * @idx: is from 0 to 3 (CQ12 to CQ15).
+ * @ccg: represents the class congestion group that this class queue should be
+ * subscribed to, or NULL if no congestion group membership is desired.
+ *
+ * Return zero for success, or -EINVAL if @idx is out the range or if
+ * this class queue has been claimed or configure class queue command returns
+ * error, or returns -ENOMEM if allocating CQ memory fails.
+ */
+int qman_ceetm_cq_claim_B(struct qm_ceetm_cq **cq,
+				struct qm_ceetm_channel *channel,
+				unsigned int idx,
+				struct qm_ceetm_ccg *ccg);
+
+/**
+ * qman_ceetm_cq_release - Releases a previously claimed class queue.
+ * @cq: The class queue to be released.
+ *
+ * Return zero for success, or -EBUSY if the dependent objects (eg. logical
+ * FQIDs) have not been released.
+ */
+int qman_ceetm_cq_release(struct qm_ceetm_cq *cq);
+
+/**
+ * qman_ceetm_set_queue_weight
+ * qman_ceetm_get_queue_weight - Configure/query the weight of a grouped class
+ * queue.
+ * @cq: the given class queue.
+ * @weight_code: the desired weight code to set for the given class queue for
+ * "set" function or the queired weight code for "get" function.
+ *
+ * Grouped class queues have a default weight code of zero, which corresponds to
+ * a scheduler weighting of 1. This function can be used to modify a grouped
+ * class queue to another weight, (Use the helpers qman_ceetm_wbfs2ratio()
+ * and qman_ceetm_ratio2wbfs() to convert between these 'weight_code' values
+ * and the corresponding sharing weight.)
+ *
+ * Returns zero for success, or -EIO if the configure weight command returns
+ * error for "set" function, or -EINVAL if the query command returns
+ * error for "get" function.
+ * See section "CEETM Weighted Scheduling among Grouped Classes" in Reference
+ * Manual for weight and weight code.
+ */
+int qman_ceetm_set_queue_weight(struct qm_ceetm_cq *cq,
+				struct qm_ceetm_weight_code *weight_code);
+int qman_ceetm_get_queue_weight(struct qm_ceetm_cq *cq,
+				struct qm_ceetm_weight_code *weight_code);
+
+/**
+ * qman_ceetm_set_queue_weight_in_ratio
+ * qman_ceetm_get_queue_weight_in_ratio - Configure/query the weight of a
+ * grouped class queue.
+ * @cq: the given class queue.
+ * @ratio: the weight in ratio. It should be the real ratio number multiplied
+ * by 100 to get rid of fraction.
+ *
+ * Returns zero for success, or -EIO if the configure weight command returns
+ * error for "set" function, or -EINVAL if the query command returns
+ * error for "get" function.
+ */
+int qman_ceetm_set_queue_weight_in_ratio(struct qm_ceetm_cq *cq, u32 ratio);
+int qman_ceetm_get_queue_weight_in_ratio(struct qm_ceetm_cq *cq, u32 *ratio);
+
+/* Weights are encoded using a pseudo-exponential scheme. The weight codes 0,
+ * 32, 64, [...] correspond to weights of 1, 2, 4, [...]. The weights
+ * corresponding to intermediate weight codes are calculated using linear
+ * interpolation on the inverted values. Or put another way, the inverse weights
+ * for each 32nd weight code are 1, 1/2, 1/4, [...], and so the intervals
+ * between these are divided linearly into 32 intermediate values, the inverses
+ * of which form the remaining weight codes.
+ *
+ * The Weighted Bandwidth Fair Scheduling (WBFS) algorithm provides a form of
+ * scheduling within a group of class queues (group A or B). Weights are used to
+ * normalise the class queues to an underlying BFS algorithm where all class
+ * queues are assumed to require "equal bandwidth". So the weights referred to
+ * by the weight codes act as divisors on the size of frames being enqueued. Ie.
+ * one class queue in a group is assigned a weight of 2 whilst the other class
+ * queues in the group keep the default weight of 1, then the WBFS scheduler
+ * will effectively treat all frames enqueued on the weight-2 class queue as
+ * having half the number of bytes they really have. Ie. if all other things are
+ * equal, that class queue would get twice as much bytes-per-second bandwidth as
+ * the others. So weights should be chosen to provide bandwidth ratios between
+ * members of the same class queue group. These weights have no bearing on
+ * behaviour outside that group's WBFS mechanism though.
+ */
+
+/**
+ * qman_ceetm_wbfs2ratio - Given a weight code ('wbfs'), an accurate fractional
+ * representation of the corresponding weight is given (in order to not lose
+ * any precision).
+ * @weight_code: The given weight code in WBFS.
+ * @numerator: the numerator part of the weight computed by the weight code.
+ * @denominator: the denominator part of the weight computed by the weight code
+ *
+ * Returns zero for success or -EINVAL if the given weight code is illegal.
+ */
+int qman_ceetm_wbfs2ratio(struct qm_ceetm_weight_code *weight_code,
+			   u32 *numerator,
+			   u32 *denominator);
+/**
+ * qman_ceetm_ratio2wbfs - Given a weight, find the nearest possible weight code
+ * If the user needs to know how close this is, convert the resulting weight
+ * code back to a weight and compare.
+ * @numerator: numerator part of the given weight.
+ * @denominator: denominator part of the given weight.
+ * @weight_code: the weight code computed from the given weight.
+ *
+ * Returns zero for success, or -ERANGE if "numerator/denominator" is outside
+ * the range of weights.
+ */
+int qman_ceetm_ratio2wbfs(u32 numerator,
+			   u32 denominator,
+			   struct qm_ceetm_weight_code *weight_code,
+			   int rounding);
+
+#define QMAN_CEETM_FLAG_CLEAR_STATISTICS_COUNTER	0x1
+/**
+ * qman_ceetm_cq_get_dequeue_statistics - Get the statistics provided by CEETM
+ * CQ counters.
+ * @cq: the given CQ object.
+ * @flags: indicates whether the statistics counter will be cleared after query.
+ * @frame_count: The number of the frames that have been counted since the
+ * counter was cleared last time.
+ * @byte_count: the number of bytes in all frames that have been counted.
+ *
+ * Return zero for success or -EINVAL if query statistics command returns error.
+ *
+ */
+int qman_ceetm_cq_get_dequeue_statistics(struct qm_ceetm_cq *cq, u32 flags,
+					u64 *frame_count, u64 *byte_count);
+
+/**
+ * qman_ceetm_drain_cq - drain the CQ till it is empty.
+ * @cq: the give CQ object.
+ * Return 0 for success or -EINVAL for unsuccessful command to empty CQ.
+ */
+int qman_ceetm_drain_cq(struct qm_ceetm_cq *cq);
+
+	/* ---------------------- */
+	/* CEETM :: logical FQIDs */
+	/* ---------------------- */
+/**
+ * qman_ceetm_lfq_claim - Claims an unused logical FQID, associates it with
+ * the given class queue.
+ * @lfq: the returned lfq object, if successful.
+ * @cq: the class queue which needs to claim a LFQID.
+ *
+ * Return zero for success, or -ENODEV if no LFQID is available or -ENOMEM if
+ * allocating memory for lfq fails, or -EINVAL if configuring LFQMT fails.
+ */
+int qman_ceetm_lfq_claim(struct qm_ceetm_lfq **lfq,
+				struct qm_ceetm_cq *cq);
+
+/**
+ * qman_ceetm_lfq_release - Releases a previously claimed logical FQID.
+ * @lfq: the lfq to be released.
+ *
+ * Return zero for success.
+ */
+int qman_ceetm_lfq_release(struct qm_ceetm_lfq *lfq);
+
+/**
+ * qman_ceetm_lfq_set_context
+ * qman_ceetm_lfq_get_context - Set/get the context_a/context_b pair to the
+ * "dequeue context table" associated with the logical FQID.
+ * @lfq: the given logical FQ object.
+ * @context_a: contextA of the dequeue context.
+ * @context_b: contextB of the dequeue context.
+ *
+ * Returns zero for success, or -EINVAL if there is error to set/get the
+ * context pair.
+ */
+int qman_ceetm_lfq_set_context(struct qm_ceetm_lfq *lfq,
+				u64 context_a,
+				u32 context_b);
+int qman_ceetm_lfq_get_context(struct qm_ceetm_lfq *lfq,
+				u64 *context_a,
+				u32 *context_b);
+
+/**
+ * qman_ceetm_create_fq - Initialise a FQ object for the LFQ.
+ * @lfq: the given logic fq.
+ * @fq: the fq object created for the given logic fq.
+ *
+ * The FQ object can be used in qman_enqueue() and qman_enqueue_orp() APIs to
+ * target a logical FQID (and the class queue it is associated with).
+ * Note that this FQ object can only be used for enqueues, and
+ * in the case of qman_enqueue_orp() it can not be used as the 'orp' parameter,
+ * only as 'fq'. This FQ object can not (and shouldn't) be destroyed, it is only
+ * valid as long as the underlying 'lfq' remains claimed. It is the user's
+ * responsibility to ensure that the underlying 'lfq' is not released until any
+ * enqueues to this FQ object have completed. The only field the user needs to
+ * fill in is fq->cb.ern, as that enqueue rejection handler is the callback that
+ * could conceivably be called on this FQ object. This API can be called
+ * multiple times to create multiple FQ objects referring to the same logical
+ * FQID, and any enqueue rejections will respect the callback of the object that
+ * issued the enqueue (and will identify the object via the parameter passed to
+ * the callback too). There is no 'flags' parameter to this API as there is for
+ * qman_create_fq() - the created FQ object behaves as though qman_create_fq()
+ * had been called with the single flag QMAN_FQ_FLAG_NO_MODIFY.
+ *
+ * Returns 0 for success.
+ */
+int qman_ceetm_create_fq(struct qm_ceetm_lfq *lfq, struct qman_fq *fq);
+
+	/* -------------------------------- */
+	/* CEETM :: class congestion groups */
+	/* -------------------------------- */
+
+/**
+ * qman_ceetm_ccg_claim - Claims an unused CCG.
+ * @ccg: the returned CCG object, if successful.
+ * @channel: the given class queue channel
+ * @cscn: the callback function of this CCG.
+ * @cb_ctx: the corresponding context to be used used if state change
+ * notifications are later enabled for this CCG.
+ *
+ * The congestion group is local to the given class queue channel, so only
+ * class queues within the channel can be associated with that congestion group.
+ * The association of class queues to congestion groups occurs  when the class
+ * queues are claimed, see qman_ceetm_cq_claim() and related functions.
+ * Congestion groups are in a "zero" state when initially claimed, and they are
+ * returned to that state when released.
+ *
+ * Return zero for success, or -EINVAL if no CCG in the channel is available.
+ */
+int qman_ceetm_ccg_claim(struct qm_ceetm_ccg **ccg,
+			 struct qm_ceetm_channel *channel,
+			 unsigned int idx,
+			 void (*cscn)(struct qm_ceetm_ccg *,
+				       void *cb_ctx,
+				       int congested),
+			 void *cb_ctx);
+
+/**
+ * qman_ceetm_ccg_release - Releases a previously claimed CCG.
+ * @ccg: the given ccg.
+ *
+ * Returns zero for success, or -EBUSY if the given ccg's dependent objects
+ * (class queues that are associated with the CCG) have not been released.
+ */
+int qman_ceetm_ccg_release(struct qm_ceetm_ccg *ccg);
+
+/* This struct is used to specify attributes for a CCG. The 'we_mask' field
+ * controls which CCG attributes are to be updated, and the remainder specify
+ * the values for those attributes. A CCG counts either frames or the bytes
+ * within those frames, but not both ('mode'). A CCG can optionally cause
+ * enqueues to be rejected, due to tail-drop or WRED, or both (they are
+ * independent options, 'td_en' and 'wr_en_g,wr_en_y,wr_en_r'). Tail-drop can be
+ * level-triggered due to a single threshold ('td_thres') or edge-triggered due
+ * to a "congestion state", but not both ('td_mode'). Congestion state has
+ * distinct entry and exit thresholds ('cs_thres_in' and 'cs_thres_out'), and
+ * notifications can be sent to software the CCG goes in to and out of this
+ * congested state ('cscn_en'). */
+struct qm_ceetm_ccg_params {
+	/* Boolean fields together in a single bitfield struct */
+	struct {
+		/* Whether to count bytes or frames. 1==frames */
+		u8 mode:1;
+		/* En/disable tail-drop. 1==enable */
+		u8 td_en:1;
+		/* Tail-drop on congestion-state or threshold. 1=threshold */
+		u8 td_mode:1;
+		/* Generate congestion state change notifications. 1==enable */
+		u8 cscn_en:1;
+		/* Enable WRED rejections (per colour). 1==enable */
+		u8 wr_en_g:1;
+		u8 wr_en_y:1;
+		u8 wr_en_r:1;
+	} __packed;
+	/* Tail-drop threshold. See qm_cgr_thres_[gs]et64(). */
+	struct qm_cgr_cs_thres td_thres;
+	/* Congestion state thresholds, for entry and exit. */
+	struct qm_cgr_cs_thres cs_thres_in;
+	struct qm_cgr_cs_thres cs_thres_out;
+	/* Overhead accounting length. Per-packet "tax", from -128 to +127 */
+	signed char oal;
+	/* Congestion state change notification for DCP portal, virtual CCGID*/
+	/* WRED parameters. */
+	struct qm_cgr_wr_parm wr_parm_g;
+	struct qm_cgr_wr_parm wr_parm_y;
+	struct qm_cgr_wr_parm wr_parm_r;
+};
+/* Bits used in 'we_mask' to qman_ceetm_ccg_set(), controls which attributes of
+ * the CCGR are to be updated. */
+#define QM_CCGR_WE_MODE         0x0001 /* mode (bytes/frames) */
+#define QM_CCGR_WE_CS_THRES_IN  0x0002 /* congestion state entry threshold */
+#define QM_CCGR_WE_TD_EN        0x0004 /* congestion state tail-drop enable */
+#define QM_CCGR_WE_CSCN_TUPD	0x0008 /* CSCN target update */
+#define QM_CCGR_WE_CSCN_EN      0x0010 /* congestion notification enable */
+#define QM_CCGR_WE_WR_EN_R      0x0020 /* WRED enable - red */
+#define QM_CCGR_WE_WR_EN_Y      0x0040 /* WRED enable - yellow */
+#define QM_CCGR_WE_WR_EN_G      0x0080 /* WRED enable - green */
+#define QM_CCGR_WE_WR_PARM_R    0x0100 /* WRED parameters - red */
+#define QM_CCGR_WE_WR_PARM_Y    0x0200 /* WRED parameters - yellow */
+#define QM_CCGR_WE_WR_PARM_G    0x0400 /* WRED parameters - green */
+#define QM_CCGR_WE_OAL          0x0800 /* overhead accounting length */
+#define QM_CCGR_WE_CS_THRES_OUT 0x1000 /* congestion state exit threshold */
+#define QM_CCGR_WE_TD_THRES     0x2000 /* tail-drop threshold */
+#define QM_CCGR_WE_TD_MODE      0x4000 /* tail-drop mode (state/threshold) */
+#define QM_CCGR_WE_CDV		0x8000 /* cdv */
+
+/**
+ * qman_ceetm_ccg_set
+ * qman_ceetm_ccg_get - Configure/query a subset of CCG attributes.
+ * @ccg: the given CCG object.
+ * @we_mask: the write enable mask.
+ * @params: the parameters setting for this ccg
+ *
+ * Return 0 for success, or -EIO if configure ccg command returns error for
+ * "set" function, or -EINVAL if query ccg command returns error for "get"
+ * function.
+ */
+int qman_ceetm_ccg_set(struct qm_ceetm_ccg *ccg,
+			u16 we_mask,
+			const struct qm_ceetm_ccg_params *params);
+int qman_ceetm_ccg_get(struct qm_ceetm_ccg *ccg,
+			struct qm_ceetm_ccg_params *params);
+
+/** qman_ceetm_cscn_swp_set - Add or remove a software portal from the target
+ * mask.
+ * qman_ceetm_cscn_swp_get - Query whether a given software portal index is
+ * in the cscn target mask.
+ * @ccg: the give CCG object.
+ * @swp_idx: the index of the software portal.
+ * @cscn_enabled: 1: Set the swp to be cscn target. 0: remove the swp from
+ * the target mask.
+ * @we_mask: the write enable mask.
+ * @params: the parameters setting for this ccg
+ *
+ * Return 0 for success, or -EINVAL if command in set/get function fails.
+ */
+int qman_ceetm_cscn_swp_set(struct qm_ceetm_ccg *ccg,
+				u16 swp_idx,
+				unsigned int cscn_enabled,
+				u16 we_mask,
+				const struct qm_ceetm_ccg_params *params);
+int qman_ceetm_cscn_swp_get(struct qm_ceetm_ccg *ccg,
+				u16 swp_idx,
+				unsigned int *cscn_enabled);
+
+/** qman_ceetm_cscn_dcp_set - Add or remove a direct connect portal from the\
+ * target mask.
+ * qman_ceetm_cscn_dcp_get - Query whether a given direct connect portal index
+ * is in the cscn target mask.
+ * @ccg: the give CCG object.
+ * @dcp_idx: the index of the direct connect portal.
+ * @vcgid: congestion state change notification for dcp portal, virtual CGID.
+ * @cscn_enabled: 1: Set the dcp to be cscn target. 0: remove the dcp from
+ * the target mask.
+ * @we_mask: the write enable mask.
+ * @params: the parameters setting for this ccg
+ *
+ * Return 0 for success, or -EINVAL if command in set/get function fails.
+  */
+int qman_ceetm_cscn_dcp_set(struct qm_ceetm_ccg *ccg,
+				u16 dcp_idx,
+				u8 vcgid,
+				unsigned int cscn_enabled,
+				u16 we_mask,
+				const struct qm_ceetm_ccg_params *params);
+int qman_ceetm_cscn_dcp_get(struct qm_ceetm_ccg *ccg,
+				u16 dcp_idx,
+				u8 *vcgid,
+				unsigned int *cscn_enabled);
+
+/**
+ * qman_ceetm_ccg_get_reject_statistics - Get the statistics provided by
+ * CEETM CCG counters.
+ * @ccg: the given CCG object.
+ * @flags: indicates whether the statistics counter will be cleared after query.
+ * @frame_count: The number of the frames that have been counted since the
+ * counter was cleared last time.
+ * @byte_count: the number of bytes in all frames that have been counted.
+ *
+ * Return zero for success or -EINVAL if query statistics command returns error.
+ *
+ */
+int qman_ceetm_ccg_get_reject_statistics(struct qm_ceetm_ccg *ccg, u32 flags,
+					u64 *frame_count, u64 *byte_count);
+
+/**
+ * qman_ceetm_query_lfqmt - Query the logical frame queue mapping table
+ * @lfqid: Logical Frame Queue ID
+ * @lfqmt_query: Results of the query command
+ *
+ * Returns zero for success or -EIO if the query command returns error.
+ *
+ */
+int qman_ceetm_query_lfqmt(int lfqid,
+			   struct qm_mcr_ceetm_lfqmt_query *lfqmt_query);
+
+/**
+ * qman_ceetm_query_cq - Queries a CEETM CQ
+ * @cqid: the channel ID (first byte) followed by the CQ idx
+ * @dcpid: CEETM portal ID
+ * @cq_query: storage for the queried CQ fields
+ *
+ * Returns zero for success or -EIO if the query command returns error.
+ *
+*/
+int qman_ceetm_query_cq(unsigned int cqid, unsigned int dcpid,
+			struct qm_mcr_ceetm_cq_query *cq_query);
+
+/**
+ * qman_ceetm_query_write_statistics - Query (and optionally write) statistics
+ * @cid: Target ID (CQID or CCGRID)
+ * @dcp_idx: CEETM portal ID
+ * @command_type: One of the following:
+ *   0 = Query dequeue statistics. CID carries the CQID to be queried.
+ *   1 = Query and clear dequeue statistics. CID carries the CQID to be queried
+ *   2 = Write dequeue statistics. CID carries the CQID to be written.
+ *   3 = Query reject statistics. CID carries the CCGRID to be queried.
+ *   4 = Query and clear reject statistics. CID carries the CCGRID to be queried
+ *   5 = Write reject statistics. CID carries the CCGRID to be written
+ * @frame_count: Frame count value to be written if this is a write command
+ * @byte_count: Bytes count value to be written if this is a write command
+ *
+ * Returns zero for success or -EIO if the query command returns error.
+ */
+int qman_ceetm_query_write_statistics(u16 cid, enum qm_dc_portal dcp_idx,
+				      u16 command_type, u64 frame_count,
+				      u64 byte_count);
+
+/**
+ * qman_set_wpm - Set waterfall power management
+ *
+ * @wpm_enable: boolean, 1 = enable wpm, 0 = disable wpm.
+ *
+ * Return 0 for success, return -ENODEV if QMan misc_cfg register is not
+ * accessible.
+ */
+int qman_set_wpm(int wpm_enable);
+
+/**
+ * qman_get_wpm - Query the waterfall power management setting
+ *
+ * @wpm_enable: boolean, 1 = enable wpm, 0 = disable wpm.
+ *
+ * Return 0 for success, return -ENODEV if QMan misc_cfg register is not
+ * accessible.
+ */
+int qman_get_wpm(int *wpm_enable);
+
+/* The below qman_p_***() variants might be called in a migration situation
+ * (e.g. cpu hotplug). They are used to continue accessing the portal that
+ * execution was affine to prior to migration.
+ * @qman_portal specifies which portal the APIs will use.
+*/
+const struct qman_portal_config *qman_p_get_portal_config(struct qman_portal
+									 *p);
+int qman_p_irqsource_add(struct qman_portal *p, u32 bits);
+int qman_p_irqsource_remove(struct qman_portal *p, u32 bits);
+int qman_p_poll_dqrr(struct qman_portal *p, unsigned int limit);
+u32 qman_p_poll_slow(struct qman_portal *p);
+void qman_p_poll(struct qman_portal *p);
+void qman_p_stop_dequeues(struct qman_portal *p);
+void qman_p_start_dequeues(struct qman_portal *p);
+void qman_p_static_dequeue_add(struct qman_portal *p, u32 pools);
+void qman_p_static_dequeue_del(struct qman_portal *p, u32 pools);
+u32 qman_p_static_dequeue_get(struct qman_portal *p);
+void qman_p_dca(struct qman_portal *p, struct qm_dqrr_entry *dq,
+						int park_request);
+int qman_p_volatile_dequeue(struct qman_portal *p, struct qman_fq *fq,
+				u32 flags __maybe_unused, u32 vdqcr);
+int qman_p_enqueue(struct qman_portal *p, struct qman_fq *fq,
+					const struct qm_fd *fd, u32 flags);
+int qman_p_enqueue_orp(struct qman_portal *p, struct qman_fq *fq,
+				const struct qm_fd *fd, u32 flags,
+				struct qman_fq *orp, u16 orp_seqnum);
+int qman_p_enqueue_precommit(struct qman_portal *p, struct qman_fq *fq,
+				const struct qm_fd *fd, u32 flags,
+				qman_cb_precommit cb, void *cb_arg);
+
+static inline int qman_is_probed(void) {
+	return 1;
+}
+
+
+static inline int qman_portals_probed(void) {
+	return 1;
+}
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* FSL_QMAN_H */
diff --git a/include/linux/fsl_usdpaa.h b/include/linux/fsl_usdpaa.h
new file mode 100644
index 000000000..2bc8fe393
--- /dev/null
+++ b/include/linux/fsl_usdpaa.h
@@ -0,0 +1,434 @@
+/* Copyright 2011-2012 Freescale Semiconductor, Inc.
+ * Copyright 2020 NXP
+ * This file is licensed under the terms of the GNU General Public License
+ * version 2.  This program is licensed "as is" without any warranty of any
+ * kind, whether express or implied.
+ */
+
+#ifndef FSL_USDPAA_H
+#define FSL_USDPAA_H
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#include <linux/uaccess.h>
+#include <linux/ioctl.h>
+#include <linux/fsl_qman.h> /* For "enum qm_channel" */
+#include <linux/compat.h>
+
+#ifdef CONFIG_FSL_USDPAA
+
+/******************************/
+/* Allocation of resource IDs */
+/******************************/
+
+/* This enum is used to distinguish between the type of underlying object being
+ * manipulated. */
+enum usdpaa_id_type {
+	usdpaa_id_fqid,
+	usdpaa_id_bpid,
+	usdpaa_id_qpool,
+	usdpaa_id_cgrid,
+	usdpaa_id_ceetm0_lfqid,
+	usdpaa_id_ceetm0_channelid,
+	usdpaa_id_ceetm1_lfqid,
+	usdpaa_id_ceetm1_channelid,
+	usdpaa_id_max /* <-- not a valid type, represents the number of types */
+};
+#define USDPAA_IOCTL_MAGIC 'u'
+struct usdpaa_ioctl_id_alloc {
+	uint32_t base; /* Return value, the start of the allocated range */
+	enum usdpaa_id_type id_type; /* what kind of resource(s) to allocate */
+	uint32_t num; /* how many IDs to allocate (and return value) */
+	uint32_t align; /* must be a power of 2, 0 is treated like 1 */
+	int partial; /* whether to allow less than 'num' */
+};
+struct usdpaa_ioctl_id_release {
+	/* Input; */
+	enum usdpaa_id_type id_type;
+	uint32_t base;
+	uint32_t num;
+};
+struct usdpaa_ioctl_id_reserve {
+	enum usdpaa_id_type id_type;
+	uint32_t base;
+	uint32_t num;
+};
+
+
+/* ioctl() commands */
+#define USDPAA_IOCTL_ID_ALLOC \
+	_IOWR(USDPAA_IOCTL_MAGIC, 0x01, struct usdpaa_ioctl_id_alloc)
+#define USDPAA_IOCTL_ID_RELEASE \
+	_IOW(USDPAA_IOCTL_MAGIC, 0x02, struct usdpaa_ioctl_id_release)
+#define USDPAA_IOCTL_ID_RESERVE \
+	_IOW(USDPAA_IOCTL_MAGIC, 0x0A, struct usdpaa_ioctl_id_reserve)
+
+/**********************/
+/* Mapping DMA memory */
+/**********************/
+
+/* Maximum length for a map name, including NULL-terminator */
+#define USDPAA_DMA_NAME_MAX 16
+/* Flags for requesting DMA maps. Maps are private+unnamed or sharable+named.
+ * For a sharable and named map, specify _SHARED (whether creating one or
+ * binding to an existing one). If _SHARED is specified and _CREATE is not, then
+ * the mapping must already exist. If _SHARED and _CREATE are specified and the
+ * mapping doesn't already exist, it will be created. If _SHARED and _CREATE are
+ * specified and the mapping already exists, the mapping will fail unless _LAZY
+ * is specified. When mapping to a pre-existing sharable map, the length must be
+ * an exact match. Lengths must be a power-of-4 multiple of page size.
+ *
+ * Note that this does not actually map the memory to user-space, that is done
+ * by a subsequent mmap() using the page offset returned from this ioctl(). The
+ * ioctl() is what gives the process permission to do this, and a page-offset
+ * with which to do so.
+ */
+#define USDPAA_DMA_FLAG_SHARE    0x01
+#define USDPAA_DMA_FLAG_CREATE   0x02
+#define USDPAA_DMA_FLAG_LAZY     0x04
+#define USDPAA_DMA_FLAG_RDONLY   0x08
+struct usdpaa_ioctl_dma_map {
+	/* Output parameters - virtual and physical addresses */
+	void *ptr;
+	uint64_t phys_addr;
+	/* Input parameter, the length of the region to be created (or if
+	 * mapping an existing region, this must match it). Must be a power-of-4
+	 * multiple of page size. */
+	uint64_t len;
+	/* Input parameter, the USDPAA_DMA_FLAG_* settings. */
+	uint32_t flags;
+	/* If _FLAG_SHARE is specified, the name of the region to be created (or
+	 * of the existing mapping to use). */
+	char name[USDPAA_DMA_NAME_MAX];
+	/* If this ioctl() creates the mapping, this is an input parameter
+	 * stating whether the region supports locking. If mapping an existing
+	 * region, this is a return value indicating the same thing. */
+	int has_locking;
+	/* In the case of a successful map with _CREATE and _LAZY, this return
+	 * value indicates whether we created the mapped region or whether it
+	 * already existed. */
+	int did_create;
+};
+
+#ifdef CONFIG_COMPAT
+struct usdpaa_ioctl_dma_map_compat {
+	/* Output parameters - virtual and physical addresses */
+	compat_uptr_t ptr;
+	uint64_t phys_addr;
+	/* Input parameter, the length of the region to be created (or if
+	 * mapping an existing region, this must match it). Must be a power-of-4
+	 * multiple of page size. */
+	uint64_t len;
+	/* Input parameter, the USDPAA_DMA_FLAG_* settings. */
+	uint32_t flags;
+	/* If _FLAG_SHARE is specified, the name of the region to be created (or
+	 * of the existing mapping to use). */
+	char name[USDPAA_DMA_NAME_MAX];
+	/* If this ioctl() creates the mapping, this is an input parameter
+	 * stating whether the region supports locking. If mapping an existing
+	 * region, this is a return value indicating the same thing. */
+	int has_locking;
+	/* In the case of a successful map with _CREATE and _LAZY, this return
+	 * value indicates whether we created the mapped region or whether it
+	 * already existed. */
+	int did_create;
+};
+
+#define USDPAA_IOCTL_DMA_MAP_COMPAT \
+	_IOWR(USDPAA_IOCTL_MAGIC, 0x03, struct usdpaa_ioctl_dma_map_compat)
+#endif
+
+
+#define USDPAA_IOCTL_DMA_MAP \
+	_IOWR(USDPAA_IOCTL_MAGIC, 0x03, struct usdpaa_ioctl_dma_map)
+/* munmap() does not remove the DMA map, just the user-space mapping to it.
+ * This ioctl will do both (though you can munmap() before calling the ioctl
+ * too). */
+#define USDPAA_IOCTL_DMA_UNMAP \
+	_IOW(USDPAA_IOCTL_MAGIC, 0x04, unsigned char)
+/* We implement a cross-process locking scheme per DMA map. Call this ioctl()
+ * with a mmap()'d address, and the process will (interruptible) sleep if the
+ * lock is already held by another process. Process destruction will
+ * automatically clean up any held locks. */
+#define USDPAA_IOCTL_DMA_LOCK \
+	_IOW(USDPAA_IOCTL_MAGIC, 0x05, unsigned char)
+#define USDPAA_IOCTL_DMA_UNLOCK \
+	_IOW(USDPAA_IOCTL_MAGIC, 0x06, unsigned char)
+
+/***************************************/
+/* Mapping and using QMan/BMan portals */
+/***************************************/
+enum usdpaa_portal_type {
+	 usdpaa_portal_qman,
+	 usdpaa_portal_bman,
+};
+
+#define QBMAN_ANY_PORTAL_IDX 0xffffffff
+
+struct usdpaa_ioctl_portal_map {
+	/* Input parameter, is a qman or bman portal required. */
+
+	enum usdpaa_portal_type type;
+	/* Specifes a specific portal index to map or QBMAN_ANY_PORTAL_IDX
+	   for don't care.  The portal index will be populated by the
+	   driver when the ioctl() successfully completes */
+	uint32_t index;
+
+	/* Return value if the map succeeds, this gives the mapped
+	 * cache-inhibited (cinh) and cache-enabled (cena) addresses. */
+	struct usdpaa_portal_map {
+		void *cinh;
+		void *cena;
+	} addr;
+	/* Qman-specific return values */
+	uint16_t channel;
+	uint32_t pools;
+};
+
+#ifdef CONFIG_COMPAT
+struct compat_usdpaa_ioctl_portal_map {
+	/* Input parameter, is a qman or bman portal required. */
+	enum usdpaa_portal_type type;
+	/* Specifes a specific portal index to map or QBMAN_ANY_PORTAL_IDX
+	   for don't care.  The portal index will be populated by the
+	   driver when the ioctl() successfully completes */
+	uint32_t index;
+	/* Return value if the map succeeds, this gives the mapped
+	 * cache-inhibited (cinh) and cache-enabled (cena) addresses. */
+	struct usdpaa_portal_map_compat {
+		compat_uptr_t cinh;
+		compat_uptr_t cena;
+	} addr;
+	/* Qman-specific return values */
+	uint16_t channel;
+	uint32_t pools;
+};
+#define USDPAA_IOCTL_PORTAL_MAP_COMPAT \
+	_IOWR(USDPAA_IOCTL_MAGIC, 0x07, struct compat_usdpaa_ioctl_portal_map)
+#define USDPAA_IOCTL_PORTAL_UNMAP_COMPAT \
+	_IOW(USDPAA_IOCTL_MAGIC, 0x08, struct usdpaa_portal_map_compat)
+#endif
+
+#define USDPAA_IOCTL_PORTAL_MAP \
+	_IOWR(USDPAA_IOCTL_MAGIC, 0x07, struct usdpaa_ioctl_portal_map)
+#define USDPAA_IOCTL_PORTAL_UNMAP \
+	_IOW(USDPAA_IOCTL_MAGIC, 0x08, struct usdpaa_portal_map)
+
+struct usdpaa_ioctl_irq_map {
+	enum usdpaa_portal_type type; /* Type of portal to map */
+	int fd; /* File descriptor that contains the portal */
+	void *portal_cinh; /* Cache inhibited area to identify the portal */
+};
+
+#define USDPAA_IOCTL_PORTAL_IRQ_MAP \
+	_IOW(USDPAA_IOCTL_MAGIC, 0x09, struct usdpaa_ioctl_irq_map)
+
+#ifdef CONFIG_COMPAT
+
+struct compat_ioctl_irq_map {
+	enum usdpaa_portal_type type; /* Type of portal to map */
+	compat_int_t fd; /* File descriptor that contains the portal */
+	compat_uptr_t portal_cinh; /* Used identify the portal */};
+
+#define USDPAA_IOCTL_PORTAL_IRQ_MAP_COMPAT \
+	_IOW(USDPAA_IOCTL_MAGIC, 0x09, struct compat_ioctl_irq_map)
+#endif
+
+/* ioctl to query the amount of DMA memory used in the system */
+struct usdpaa_ioctl_dma_used {
+	uint64_t free_bytes;
+	uint64_t total_bytes;
+};
+#define USDPAA_IOCTL_DMA_USED \
+	_IOR(USDPAA_IOCTL_MAGIC, 0x0B, struct usdpaa_ioctl_dma_used)
+
+/* ioctl to allocate a raw portal */
+struct usdpaa_ioctl_raw_portal {
+	/* inputs */
+	enum usdpaa_portal_type type; /* Type of portal to allocate */
+
+	 /* set to non zero to turn on stashing */
+	uint8_t enable_stash;
+	/* Stashing attributes for the portal */
+	uint32_t cpu;
+	uint32_t cache;
+	uint32_t window;
+
+	/* Specifies the stash request queue this portal should use */
+	uint8_t sdest;
+
+	/* Specifes a specific portal index to map or QBMAN_ANY_PORTAL_IDX
+	 * for don't care.  The portal index will be populated by the
+	 * driver when the ioctl() successfully completes */
+	uint32_t index;
+
+	/* outputs */
+	uint64_t cinh;
+	uint64_t cena;
+};
+
+#define USDPAA_IOCTL_ALLOC_RAW_PORTAL \
+	_IOWR(USDPAA_IOCTL_MAGIC, 0x0C, struct usdpaa_ioctl_raw_portal)
+
+#define USDPAA_IOCTL_FREE_RAW_PORTAL \
+	_IOR(USDPAA_IOCTL_MAGIC, 0x0D, struct usdpaa_ioctl_raw_portal)
+
+#ifdef CONFIG_COMPAT
+
+struct compat_ioctl_raw_portal {
+	/* inputs */
+	enum usdpaa_portal_type type; /* Type of portal to allocate */
+
+	 /* set to non zero to turn on stashing */
+	uint8_t enable_stash;
+	/* Stashing attributes for the portal */
+	uint32_t cpu;
+	uint32_t cache;
+	uint32_t window;
+	/* Specifies the stash request queue this portal should use */
+	uint8_t sdest;
+
+	/* Specifes a specific portal index to map or QBMAN_ANY_PORTAL_IDX
+	 * for don't care.  The portal index will be populated by the
+	 * driver when the ioctl() successfully completes */
+	uint32_t index;
+
+	/* outputs */
+	uint64_t cinh;
+	uint64_t cena;
+};
+
+#define USDPAA_IOCTL_ALLOC_RAW_PORTAL_COMPAT \
+	_IOWR(USDPAA_IOCTL_MAGIC, 0x0C, struct compat_ioctl_raw_portal)
+
+#define USDPAA_IOCTL_FREE_RAW_PORTAL_COMPAT \
+	_IOR(USDPAA_IOCTL_MAGIC, 0x0D, struct compat_ioctl_raw_portal)
+
+#endif
+
+#ifdef __KERNEL__
+
+/* Early-boot hook */
+int __init fsl_usdpaa_init_early(void);
+
+/* Fault-handling in arch/powerpc/mm/mem.c gives USDPAA an opportunity to detect
+ * faults within its ranges via this hook. */
+int usdpaa_test_fault(unsigned long pfn, u64 *phys_addr, u64 *size);
+
+#endif /* __KERNEL__ */
+
+#endif /* CONFIG_FSL_USDPAA */
+
+#ifdef __KERNEL__
+/* This interface is needed in a few places and though it's not specific to
+ * USDPAA as such, creating a new header for it doesn't make any sense. The
+ * qbman kernel driver implements this interface and uses it as the backend for
+ * both the FQID and BPID allocators. The fsl_usdpaa driver also uses this
+ * interface for tracking per-process allocations handed out to user-space. */
+struct dpa_alloc {
+	struct list_head free;
+	spinlock_t lock;
+	struct list_head used;
+};
+#define DECLARE_DPA_ALLOC(name) \
+	struct dpa_alloc name = { \
+		.free = { \
+			.prev = &name.free, \
+			.next = &name.free \
+		}, \
+		.lock = __SPIN_LOCK_UNLOCKED(name.lock), \
+		.used = { \
+			 .prev = &name.used, \
+			 .next = &name.used \
+		 } \
+	}
+static inline void dpa_alloc_init(struct dpa_alloc *alloc)
+{
+	INIT_LIST_HEAD(&alloc->free);
+	INIT_LIST_HEAD(&alloc->used);
+	spin_lock_init(&alloc->lock);
+}
+int dpa_alloc_new(struct dpa_alloc *alloc, u32 *result, u32 count, u32 align,
+		  int partial);
+void dpa_alloc_free(struct dpa_alloc *alloc, u32 base_id, u32 count);
+void dpa_alloc_seed(struct dpa_alloc *alloc, u32 fqid, u32 count);
+
+/* Like 'new' but specifies the desired range, returns -ENOMEM if the entire
+ * desired range is not available, or 0 for success. */
+int dpa_alloc_reserve(struct dpa_alloc *alloc, u32 base_id, u32 count);
+/* Pops and returns contiguous ranges from the allocator. Returns -ENOMEM when
+ * 'alloc' is empty. */
+int dpa_alloc_pop(struct dpa_alloc *alloc, u32 *result, u32 *count);
+/* Returns 1 if the specified id is alloced, 0 otherwise */
+int dpa_alloc_check(struct dpa_alloc *list, u32 id);
+#endif /* __KERNEL__ */
+
+
+/************************************
+ * Link Status support for user space
+ * interface
+ ************************************/
+#define IF_NAME_MAX_LEN 16
+#define NODE_NAME_LEN	32
+#define ETH_LINK_DOWN 0
+#define ETH_LINK_UP 1
+
+struct usdpaa_ioctl_link_status {
+	/* network device node name */
+	char		if_name[IF_NAME_MAX_LEN];
+	/* Eventfd value */
+	uint32_t	efd;
+};
+
+#define USDPAA_IOCTL_ENABLE_LINK_STATUS_INTERRUPT \
+	_IOW(USDPAA_IOCTL_MAGIC, 0x0E, struct usdpaa_ioctl_link_status)
+
+#define USDPAA_IOCTL_DISABLE_LINK_STATUS_INTERRUPT \
+	_IOW(USDPAA_IOCTL_MAGIC, 0x0F, char *)
+
+struct usdpaa_ioctl_link_status_args {
+	/* network device node name */
+	char    if_name[IF_NAME_MAX_LEN];
+	/* link status(UP/DOWN) */
+	int     link_status;
+	int	link_speed;
+	int	link_duplex;
+	int	link_autoneg;
+};
+
+struct usdpaa_ioctl_update_link_status {
+	/* network device node name */
+	char    if_name[IF_NAME_MAX_LEN];
+	/* link status(ETH_LINK_UP/DOWN) */
+	int     set_link_status;
+};
+
+struct usdpaa_ioctl_update_link_speed {
+	/* network device node name*/
+	char    if_name[IF_NAME_MAX_LEN];
+	int	link_speed;
+	int	link_duplex;
+};
+
+#define USDPAA_IOCTL_GET_LINK_STATUS \
+	_IOWR(USDPAA_IOCTL_MAGIC, 0x10, struct usdpaa_ioctl_link_status_args)
+
+#define USDPAA_IOCTL_UPDATE_LINK_STATUS \
+	_IOW(USDPAA_IOCTL_MAGIC, 0x11, struct usdpaa_ioctl_update_link_status)
+
+#define USDPAA_IOCTL_UPDATE_LINK_SPEED \
+	_IOW(USDPAA_IOCTL_MAGIC, 0x12, struct usdpaa_ioctl_update_link_speed)
+
+#define USDPAA_IOCTL_GET_IOCTL_VERSION \
+	_IOR(USDPAA_IOCTL_MAGIC, 0x14, int)
+
+#define USDPAA_IOCTL_RESTART_LINK_AUTONEG \
+	_IOW(USDPAA_IOCTL_MAGIC, 0x13, char *)
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* FSL_USDPAA_H */
diff --git a/include/linux/fwnode_mdio.h b/include/linux/fwnode_mdio.h
new file mode 100644
index 000000000..faf603c48
--- /dev/null
+++ b/include/linux/fwnode_mdio.h
@@ -0,0 +1,35 @@
+/* SPDX-License-Identifier: GPL-2.0-only */
+/*
+ * FWNODE helper for the MDIO (Ethernet PHY) API
+ */
+
+#ifndef __LINUX_FWNODE_MDIO_H
+#define __LINUX_FWNODE_MDIO_H
+
+#include <linux/phy.h>
+
+#if IS_ENABLED(CONFIG_FWNODE_MDIO)
+int fwnode_mdiobus_phy_device_register(struct mii_bus *mdio,
+				       struct phy_device *phy,
+				       struct fwnode_handle *child, u32 addr);
+
+int fwnode_mdiobus_register_phy(struct mii_bus *bus,
+				struct fwnode_handle *child, u32 addr);
+
+#else /* CONFIG_FWNODE_MDIO */
+int fwnode_mdiobus_phy_device_register(struct mii_bus *mdio,
+				       struct phy_device *phy,
+				       struct fwnode_handle *child, u32 addr)
+{
+	return -EINVAL;
+}
+
+static inline int fwnode_mdiobus_register_phy(struct mii_bus *bus,
+					      struct fwnode_handle *child,
+					      u32 addr)
+{
+	return -EINVAL;
+}
+#endif
+
+#endif /* __LINUX_FWNODE_MDIO_H */
diff --git a/include/linux/hantrodec.h b/include/linux/hantrodec.h
new file mode 100644
index 000000000..f423ea82a
--- /dev/null
+++ b/include/linux/hantrodec.h
@@ -0,0 +1,29 @@
+/*****************************************************************************
+*
+*    The GPL License (GPL)
+*
+*    Copyright (c) 2015-2017, VeriSilicon Inc.
+*    Copyright (c) 2011-2014, Google Inc.
+*
+*    This program is free software; you can redistribute it and/or
+*    modify it under the terms of the GNU General Public License
+*    as published by the Free Software Foundation; either version 2
+*    of the License, or (at your option) any later version.
+*
+*    This program is distributed in the hope that it will be useful,
+*    but WITHOUT ANY WARRANTY; without even the implied warranty of
+*    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+*    GNU General Public License for more details.
+*
+*    You should have received a copy of the GNU General Public License
+*    along with this program; if not, write to the Free Software Foundation,
+*    Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
+*
+*****************************************************************************/
+
+#ifndef _HANTRODEC_H_
+#define _HANTRODEC_H_
+
+#include <uapi/linux/hantrodec.h>
+
+#endif /* !_HANTRODEC_H_ */
diff --git a/include/linux/hx280enc.h b/include/linux/hx280enc.h
new file mode 100755
index 000000000..186a00e34
--- /dev/null
+++ b/include/linux/hx280enc.h
@@ -0,0 +1,31 @@
+/*****************************************************************************
+ * Encoder device driver (kernel module header)
+ *
+ * Copyright (C) 2012 Google Finland Oy.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+ *
+--------------------------------------------------------------------------------
+--
+--  Abstract : 6280/7280/8270/8290/H1 Encoder device driver (kernel module)
+--
+*****************************************************************************/
+
+#ifndef _HX280ENC_H_
+#define _HX280ENC_H_
+
+#include <uapi/linux/hx280enc.h>
+
+#endif /* !_HX280ENC_H_ */
diff --git a/include/linux/imx_rpmsg.h b/include/linux/imx_rpmsg.h
new file mode 100644
index 000000000..e0d5e979a
--- /dev/null
+++ b/include/linux/imx_rpmsg.h
@@ -0,0 +1,43 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * Copyright (C) 2019 NXP.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+/*
+ * @file linux/imx_rpmsg.h
+ *
+ * @brief Global header file for iMX RPMSG
+ *
+ * @ingroup RPMSG
+ */
+#ifndef __LINUX_IMX_RPMSG_H__
+#define __LINUX_IMX_RPMSG_H__
+
+/* Category define */
+#define IMX_RMPSG_LIFECYCLE	1
+#define IMX_RPMSG_PMIC		2
+#define IMX_RPMSG_AUDIO		3
+#define IMX_RPMSG_KEY		4
+#define IMX_RPMSG_GPIO		5
+#define IMX_RPMSG_RTC		6
+#define IMX_RPMSG_SENSOR	7
+/* rpmsg version */
+#define IMX_RMPSG_MAJOR		1
+#define IMX_RMPSG_MINOR		0
+
+#define CIRC_ADD(idx, size, value)	(((idx) + (value)) & ((size) - 1))
+
+struct imx_rpmsg_head {
+	u8 cate;
+	u8 major;
+	u8 minor;
+	u8 type;
+	u8 cmd;
+	u8 reserved[5];
+} __packed;
+
+#endif /* __LINUX_IMX_RPMSG_H__ */
diff --git a/include/linux/imx_sema4.h b/include/linux/imx_sema4.h
new file mode 100644
index 000000000..19850ae77
--- /dev/null
+++ b/include/linux/imx_sema4.h
@@ -0,0 +1,83 @@
+/*
+ * Copyright (C) 2014-2015 Freescale Semiconductor, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#ifndef __LINUX_IMX_SEMA4_H__
+#define __LINUX_IMX_SEMA4_H__
+
+#define SEMA4_NUM_DEVICES	1
+#define SEMA4_NUM_GATES		16
+
+#define SEMA4_UNLOCK	0x00
+#define SEMA4_A9_LOCK	0x01
+#define SEMA4_GATE_MASK	0x03
+
+#define CORE_MUTEX_VALID	(('c'<<24)|('m'<<24)|('t'<<24)|'x')
+
+/*
+ * The enumerates
+ */
+enum {
+	/* sema4 registers offset */
+	SEMA4_CP0INE	= 0x40,
+	SEMA4_CP1INE	= 0x48,
+	SEMA4_CP0NTF	= 0x80,
+	SEMA4_CP1NTF	= 0x88,
+};
+
+static const unsigned int idx_sema4[SEMA4_NUM_GATES] = {
+	1 << 7, 1 << 6, 1 << 5, 1 << 4,
+	1 << 3, 1 << 2, 1 << 1, 1 << 0,
+	1 << 15, 1 << 14, 1 << 13, 1 << 12,
+	1 << 11, 1 << 10, 1 << 9, 1 << 8,
+};
+
+struct imx_sema4_mutex {
+	u32			valid;
+	u32			gate_num;
+	unsigned char		gate_val;
+	wait_queue_head_t       wait_q;
+};
+
+struct imx_sema4_mutex_device {
+	struct device		*dev;
+	u16			cpntf_val;
+	u16			cpine_val;
+	void __iomem		*ioaddr;	/* Mapped address */
+	spinlock_t		lock;		/* Mutex */
+	int			irq;
+
+	u16			alloced;
+	struct imx_sema4_mutex	*mutex_ptr[SEMA4_NUM_GATES];
+};
+
+struct imx_sema4_mutex *
+	imx_sema4_mutex_create(u32 dev_num, u32 mutex_num);
+#ifdef CONFIG_IMX_SEMA4
+int imx_sema4_mutex_destroy(struct imx_sema4_mutex *mutex_ptr);
+int imx_sema4_mutex_trylock(struct imx_sema4_mutex *mutex_ptr);
+int imx_sema4_mutex_lock(struct imx_sema4_mutex *mutex_ptr);
+int imx_sema4_mutex_unlock(struct imx_sema4_mutex *mutex_ptr);
+#else
+static inline int imx_sema4_mutex_destroy(struct imx_sema4_mutex *mutex_ptr)
+{
+	return 0;
+}
+static inline int imx_sema4_mutex_trylock(struct imx_sema4_mutex *mutex_ptr)
+{
+	return 0;
+}
+static inline int imx_sema4_mutex_lock(struct imx_sema4_mutex *mutex_ptr)
+{
+	return 0;
+}
+static inline int imx_sema4_mutex_unlock(struct imx_sema4_mutex *mutex_ptr)
+{
+	return 0;
+}
+#endif
+#endif /* __LINUX_IMX_SEMA4_H__ */
diff --git a/include/linux/imx_vpu.h b/include/linux/imx_vpu.h
new file mode 100644
index 000000000..55fc1b20a
--- /dev/null
+++ b/include/linux/imx_vpu.h
@@ -0,0 +1,19 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * Copyright 2018-2020 NXP
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+#ifndef __LINUX_IMX_VPU_H
+#define __LINUX_IMX_VPU_H
+
+#include <uapi/linux/imx_vpu.h>
+
+#endif
diff --git a/include/linux/ipu-v3-pre.h b/include/linux/ipu-v3-pre.h
new file mode 100644
index 000000000..f5a26e5ea
--- /dev/null
+++ b/include/linux/ipu-v3-pre.h
@@ -0,0 +1,155 @@
+/*
+ * Copyright (C) 2014-2015 Freescale Semiconductor, Inc.
+ *
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+#ifndef __LINUX_IPU_V3_PRE_H_
+#define __LINUX_IPU_V3_PRE_H_
+
+#define IPU_PRE_MAX_WIDTH	1920
+#define IPU_PRE_MAX_BPP		4
+#define IPU_PRE_SMALL_LINE	9	/* to workaround errata ERR009624*/
+
+struct ipu_rect {
+	int left;
+	int top;
+	int width;
+	int height;
+};
+
+struct ipu_pre_context {
+	bool repeat;
+	bool vflip;
+	bool handshake_en;
+	bool hsk_abort_en;
+	unsigned int hsk_line_num;
+	bool sdw_update;
+	unsigned int block_size;
+	unsigned int interlaced;
+	unsigned int prefetch_mode;
+
+	unsigned long cur_buf;
+	unsigned long next_buf;
+
+	unsigned int tile_fmt;
+
+	unsigned int read_burst;
+	unsigned int prefetch_input_bpp;
+	unsigned int prefetch_input_pixel_fmt;
+	unsigned int prefetch_shift_offset;
+	unsigned int prefetch_shift_width;
+	bool shift_bypass;
+	bool field_inverse;
+	bool tpr_coor_offset_en;
+	/* the output of prefetch is
+	 * also the input of store
+	 */
+	struct ipu_rect prefetch_output_size;
+	unsigned int prefetch_input_active_width;
+	unsigned int prefetch_input_width;
+	unsigned int prefetch_input_height;
+	unsigned int store_pitch;
+	int interlace_offset;
+
+	bool store_en;
+	unsigned int write_burst;
+	unsigned int store_output_bpp;
+
+	unsigned int sec_buf_off;
+	unsigned int trd_buf_off;
+
+	/* return for IPU fb caller */
+	unsigned long store_addr;
+};
+
+/*
+ * In order to workaround the PRE SoC bug recorded by errata ERR009624,
+ * the software cannot write the PRE_CTRL register when the PRE writes
+ * the PRE_CTRL register automatically to set the ENABLE bit(bit0) to 1
+ * in the PRE repeat mode.
+ * The software mechanism to set the PRE_CTRL register is different for
+ * PRE Y resolution higher than 9 lines and lower or equal to 9 lines.
+ * Use this helper to check the Y resolution.
+ */
+static inline bool ipu_pre_yres_is_small(unsigned int yres)
+{
+	return yres <= IPU_PRE_SMALL_LINE;
+}
+
+#ifdef CONFIG_MXC_IPU_V3_PRE
+int ipu_pre_alloc(int ipu_id, ipu_channel_t ipu_ch);
+void ipu_pre_free(unsigned int *id);
+unsigned long ipu_pre_alloc_double_buffer(unsigned int id, unsigned int size);
+void ipu_pre_free_double_buffer(unsigned int id);
+int ipu_pre_config(int id, struct ipu_pre_context *config);
+int ipu_pre_set_ctrl(unsigned int id, struct ipu_pre_context *config);
+int ipu_pre_enable(int id);
+void ipu_pre_disable(int id);
+int ipu_pre_set_fb_buffer(int id, bool resolve,
+			  unsigned long fb_paddr,
+			  unsigned int y_res,
+			  unsigned int x_crop,
+			  unsigned int y_crop,
+			  unsigned int sec_buf_off,
+			  unsigned int trd_buf_off);
+int ipu_pre_sdw_update(int id);
+#else
+int ipu_pre_alloc(int ipu_id, ipu_channel_t channel)
+{
+	return -ENODEV;
+}
+
+void ipu_pre_free(unsigned int *id)
+{
+}
+
+unsigned long ipu_pre_alloc_double_buffer(unsigned int id, unsigned int size)
+{
+	return -ENODEV;
+}
+
+void ipu_pre_free_double_buffer(unsigned int id)
+{
+}
+
+int ipu_pre_config(int id, struct ipu_pre_context *config)
+{
+	return -ENODEV;
+}
+
+int ipu_pre_set_ctrl(unsigned int id, struct ipu_pre_context *config)
+{
+	return -ENODEV;
+}
+
+int ipu_pre_enable(int id)
+{
+	return -ENODEV;
+}
+
+void ipu_pre_disable(int id)
+{
+	return;
+}
+
+int ipu_pre_set_fb_buffer(int id, bool resolve,
+			  unsigned long fb_paddr,
+			  unsigned int y_res,
+			  unsigned int x_crop,
+			  unsigned int y_crop,
+			  unsigned int sec_buf_off,
+			  unsigned int trd_buf_off)
+{
+	return -ENODEV;
+}
+int ipu_pre_sdw_update(int id)
+{
+	return -ENODEV;
+}
+#endif
+#endif /* __LINUX_IPU_V3_PRE_H_ */
diff --git a/include/linux/ipu-v3-prg.h b/include/linux/ipu-v3-prg.h
new file mode 100644
index 000000000..2ab803a66
--- /dev/null
+++ b/include/linux/ipu-v3-prg.h
@@ -0,0 +1,61 @@
+/*
+ * Copyright (C) 2014-2015 Freescale Semiconductor, Inc.
+ *
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+#ifndef __LINUX_IPU_V3_PRG_H_
+#define __LINUX_IPU_V3_PRG_H_
+
+#include <linux/ipu-v3.h>
+
+#define PRG_SO_INTERLACE	1
+#define PRG_SO_PROGRESSIVE	0
+#define PRG_BLOCK_MODE		1
+#define PRG_SCAN_MODE		0
+
+struct ipu_prg_config {
+	unsigned int id;
+	unsigned int pre_num;
+	ipu_channel_t ipu_ch;
+	unsigned int stride;
+	unsigned int height;
+	unsigned int ipu_height;
+	unsigned int crop_line;
+	unsigned int so;
+	unsigned int ilo;
+	unsigned int block_mode;
+	bool vflip;
+	u32 baddr;
+	u32 offset;
+};
+
+#ifdef CONFIG_MXC_IPU_V3_PRG
+int ipu_prg_config(struct ipu_prg_config *config);
+int ipu_prg_disable(unsigned int ipu_id, unsigned int pre_num);
+int ipu_prg_wait_buf_ready(unsigned int ipu_id, unsigned int pre_num,
+			   unsigned int hsk_line_num,
+			   int pre_store_out_height);
+#else
+int ipu_prg_config(struct ipu_prg_config *config)
+{
+	return -ENODEV;
+}
+
+int ipu_prg_disable(unsigned int ipu_id, unsigned int pre_num)
+{
+	return -ENODEV;
+}
+
+int ipu_prg_wait_buf_ready(unsigned int ipu_id, unsigned int pre_num,
+			   unsigned int hsk_line_num,
+			   int pre_store_out_height)
+{
+	return -ENODEV;
+}
+#endif
+#endif /* __LINUX_IPU_V3_PRG_H_ */
diff --git a/include/linux/ipu-v3.h b/include/linux/ipu-v3.h
new file mode 100644
index 000000000..ae09614a2
--- /dev/null
+++ b/include/linux/ipu-v3.h
@@ -0,0 +1,770 @@
+/*
+ * Copyright (c) 2010 Sascha Hauer <s.hauer@pengutronix.de>
+ * Copyright (C) 2011-2015 Freescale Semiconductor, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the
+ * Free Software Foundation; either version 2 of the License, or (at your
+ * option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+ * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * for more details.
+ */
+
+#ifndef __LINUX_IPU_V3_H_
+#define __LINUX_IPU_V3_H_
+
+#include <linux/ipu.h>
+
+/* IPU Driver channels definitions.	*/
+/* Note these are different from IDMA channels */
+#define IPU_MAX_CH	32
+#define _MAKE_CHAN(num, v_in, g_in, a_in, out) \
+	((num << 24) | (v_in << 18) | (g_in << 12) | (a_in << 6) | out)
+#define _MAKE_ALT_CHAN(ch)		(ch | (IPU_MAX_CH << 24))
+#define IPU_CHAN_ID(ch)			(ch >> 24)
+#define IPU_CHAN_ALT(ch)		(ch & 0x02000000)
+#define IPU_CHAN_ALPHA_IN_DMA(ch)	((uint32_t) (ch >> 6) & 0x3F)
+#define IPU_CHAN_GRAPH_IN_DMA(ch)	((uint32_t) (ch >> 12) & 0x3F)
+#define IPU_CHAN_VIDEO_IN_DMA(ch)	((uint32_t) (ch >> 18) & 0x3F)
+#define IPU_CHAN_OUT_DMA(ch)		((uint32_t) (ch & 0x3F))
+#define NO_DMA 0x3F
+#define ALT	1
+/*!
+ * Enumeration of IPU logical channels. An IPU logical channel is defined as a
+ * combination of an input (memory to IPU), output (IPU to memory), and/or
+ * secondary input IDMA channels and in some cases an Image Converter task.
+ * Some channels consist of only an input or output.
+ */
+typedef enum {
+	CHAN_NONE = -1,
+	MEM_ROT_ENC_MEM = _MAKE_CHAN(1, 45, NO_DMA, NO_DMA, 48),
+	MEM_ROT_VF_MEM = _MAKE_CHAN(2, 46, NO_DMA, NO_DMA, 49),
+	MEM_ROT_PP_MEM = _MAKE_CHAN(3, 47, NO_DMA, NO_DMA, 50),
+
+	MEM_PRP_ENC_MEM = _MAKE_CHAN(4, 12, 14, 17, 20),
+	MEM_PRP_VF_MEM = _MAKE_CHAN(5, 12, 14, 17, 21),
+	MEM_PP_MEM = _MAKE_CHAN(6, 11, 15, 18, 22),
+
+	MEM_DC_SYNC = _MAKE_CHAN(7, 28, NO_DMA, NO_DMA, NO_DMA),
+	MEM_DC_ASYNC = _MAKE_CHAN(8, 41, NO_DMA, NO_DMA, NO_DMA),
+	MEM_BG_SYNC = _MAKE_CHAN(9, 23, NO_DMA, 51, NO_DMA),
+	MEM_FG_SYNC = _MAKE_CHAN(10, 27, NO_DMA, 31, NO_DMA),
+
+	MEM_BG_ASYNC0 = _MAKE_CHAN(11, 24, NO_DMA, 52, NO_DMA),
+	MEM_FG_ASYNC0 = _MAKE_CHAN(12, 29, NO_DMA, 33, NO_DMA),
+	MEM_BG_ASYNC1 = _MAKE_ALT_CHAN(MEM_BG_ASYNC0),
+	MEM_FG_ASYNC1 = _MAKE_ALT_CHAN(MEM_FG_ASYNC0),
+
+	DIRECT_ASYNC0 = _MAKE_CHAN(13, NO_DMA, NO_DMA, NO_DMA, NO_DMA),
+	DIRECT_ASYNC1 = _MAKE_CHAN(14, NO_DMA, NO_DMA, NO_DMA, NO_DMA),
+
+	CSI_MEM0 = _MAKE_CHAN(15, NO_DMA, NO_DMA, NO_DMA, 0),
+	CSI_MEM1 = _MAKE_CHAN(16, NO_DMA, NO_DMA, NO_DMA, 1),
+	CSI_MEM2 = _MAKE_CHAN(17, NO_DMA, NO_DMA, NO_DMA, 2),
+	CSI_MEM3 = _MAKE_CHAN(18, NO_DMA, NO_DMA, NO_DMA, 3),
+
+	CSI_MEM = CSI_MEM0,
+
+	CSI_PRP_ENC_MEM = _MAKE_CHAN(19, NO_DMA, NO_DMA, NO_DMA, 20),
+	CSI_PRP_VF_MEM = _MAKE_CHAN(20, NO_DMA, NO_DMA, NO_DMA, 21),
+
+	/* for vdi mem->vdi->ic->mem , add graphics plane and alpha*/
+	MEM_VDI_PRP_VF_MEM_P = _MAKE_CHAN(21, 8, 14, 17, 21),
+	MEM_VDI_PRP_VF_MEM = _MAKE_CHAN(22, 9, 14, 17, 21),
+	MEM_VDI_PRP_VF_MEM_N = _MAKE_CHAN(23, 10, 14, 17, 21),
+
+	/* for vdi mem->vdi->mem */
+	MEM_VDI_MEM_P = _MAKE_CHAN(24, 8, NO_DMA, NO_DMA, 5),
+	MEM_VDI_MEM = _MAKE_CHAN(25, 9, NO_DMA, NO_DMA, 5),
+	MEM_VDI_MEM_N = _MAKE_CHAN(26, 10, NO_DMA, NO_DMA, 5),
+
+	/* fake channel for vdoa to link with IPU */
+	MEM_VDOA_MEM =  _MAKE_CHAN(27, NO_DMA, NO_DMA, NO_DMA, NO_DMA),
+
+	MEM_PP_ADC = CHAN_NONE,
+	ADC_SYS2 = CHAN_NONE,
+
+} ipu_channel_t;
+
+/*!
+ * Enumeration of types of buffers for a logical channel.
+ */
+typedef enum {
+	IPU_OUTPUT_BUFFER = 0,	/*!< Buffer for output from IPU */
+	IPU_ALPHA_IN_BUFFER = 1,	/*!< Buffer for input to IPU */
+	IPU_GRAPH_IN_BUFFER = 2,	/*!< Buffer for input to IPU */
+	IPU_VIDEO_IN_BUFFER = 3,	/*!< Buffer for input to IPU */
+	IPU_INPUT_BUFFER = IPU_VIDEO_IN_BUFFER,
+	IPU_SEC_INPUT_BUFFER = IPU_GRAPH_IN_BUFFER,
+} ipu_buffer_t;
+
+#define IPU_PANEL_SERIAL		1
+#define IPU_PANEL_PARALLEL		2
+
+/*!
+ * Enumeration of ADC channel operation mode.
+ */
+typedef enum {
+	Disable,
+	WriteTemplateNonSeq,
+	ReadTemplateNonSeq,
+	WriteTemplateUnCon,
+	ReadTemplateUnCon,
+	WriteDataWithRS,
+	WriteDataWoRS,
+	WriteCmd
+} mcu_mode_t;
+
+/*!
+ * Enumeration of ADC channel addressing mode.
+ */
+typedef enum {
+	FullWoBE,
+	FullWithBE,
+	XY
+} display_addressing_t;
+
+/*!
+ * Union of initialization parameters for a logical channel.
+ */
+typedef union {
+	struct {
+		uint32_t csi;
+		uint32_t mipi_id;
+		uint32_t mipi_vc;
+		bool mipi_en;
+		bool interlaced;
+	} csi_mem;
+	struct {
+		uint32_t in_width;
+		uint32_t in_height;
+		uint32_t in_pixel_fmt;
+		uint32_t out_width;
+		uint32_t out_height;
+		uint32_t out_pixel_fmt;
+		uint32_t outh_resize_ratio;
+		uint32_t outv_resize_ratio;
+		uint32_t csi;
+		uint32_t mipi_id;
+		uint32_t mipi_vc;
+		bool mipi_en;
+	} csi_prp_enc_mem;
+	struct {
+		uint32_t in_width;
+		uint32_t in_height;
+		uint32_t in_pixel_fmt;
+		uint32_t out_width;
+		uint32_t out_height;
+		uint32_t out_pixel_fmt;
+		uint32_t outh_resize_ratio;
+		uint32_t outv_resize_ratio;
+	} mem_prp_enc_mem;
+	struct {
+		uint32_t in_width;
+		uint32_t in_height;
+		uint32_t in_pixel_fmt;
+		uint32_t out_width;
+		uint32_t out_height;
+		uint32_t out_pixel_fmt;
+	} mem_rot_enc_mem;
+	struct {
+		uint32_t in_width;
+		uint32_t in_height;
+		uint32_t in_pixel_fmt;
+		uint32_t out_width;
+		uint32_t out_height;
+		uint32_t out_pixel_fmt;
+		uint32_t outh_resize_ratio;
+		uint32_t outv_resize_ratio;
+		bool graphics_combine_en;
+		bool global_alpha_en;
+		bool key_color_en;
+		uint32_t in_g_pixel_fmt;
+		uint8_t alpha;
+		uint32_t key_color;
+		bool alpha_chan_en;
+		ipu_motion_sel motion_sel;
+		enum v4l2_field field_fmt;
+		uint32_t csi;
+		uint32_t mipi_id;
+		uint32_t mipi_vc;
+		bool mipi_en;
+	} csi_prp_vf_mem;
+	struct {
+		uint32_t in_width;
+		uint32_t in_height;
+		uint32_t in_pixel_fmt;
+		uint32_t out_width;
+		uint32_t out_height;
+		uint32_t out_pixel_fmt;
+		bool graphics_combine_en;
+		bool global_alpha_en;
+		bool key_color_en;
+		display_port_t disp;
+		uint32_t out_left;
+		uint32_t out_top;
+	} csi_prp_vf_adc;
+	struct {
+		uint32_t in_width;
+		uint32_t in_height;
+		uint32_t in_pixel_fmt;
+		uint32_t out_width;
+		uint32_t out_height;
+		uint32_t out_pixel_fmt;
+		uint32_t outh_resize_ratio;
+		uint32_t outv_resize_ratio;
+		bool graphics_combine_en;
+		bool global_alpha_en;
+		bool key_color_en;
+		uint32_t in_g_pixel_fmt;
+		uint8_t alpha;
+		uint32_t key_color;
+		bool alpha_chan_en;
+		ipu_motion_sel motion_sel;
+		enum v4l2_field field_fmt;
+	} mem_prp_vf_mem;
+	struct {
+		uint32_t temp;
+	} mem_prp_vf_adc;
+	struct {
+		uint32_t temp;
+	} mem_rot_vf_mem;
+	struct {
+		uint32_t in_width;
+		uint32_t in_height;
+		uint32_t in_pixel_fmt;
+		uint32_t out_width;
+		uint32_t out_height;
+		uint32_t out_pixel_fmt;
+		uint32_t outh_resize_ratio;
+		uint32_t outv_resize_ratio;
+		bool graphics_combine_en;
+		bool global_alpha_en;
+		bool key_color_en;
+		uint32_t in_g_pixel_fmt;
+		uint8_t alpha;
+		uint32_t key_color;
+		bool alpha_chan_en;
+	} mem_pp_mem;
+	struct {
+		uint32_t temp;
+	} mem_rot_mem;
+	struct {
+		uint32_t in_width;
+		uint32_t in_height;
+		uint32_t in_pixel_fmt;
+		uint32_t out_width;
+		uint32_t out_height;
+		uint32_t out_pixel_fmt;
+		bool graphics_combine_en;
+		bool global_alpha_en;
+		bool key_color_en;
+		display_port_t disp;
+		uint32_t out_left;
+		uint32_t out_top;
+	} mem_pp_adc;
+	struct {
+		uint32_t di;
+		bool interlaced;
+		uint32_t in_pixel_fmt;
+		uint32_t out_pixel_fmt;
+	} mem_dc_sync;
+	struct {
+		uint32_t temp;
+	} mem_sdc_fg;
+	struct {
+		uint32_t di;
+		bool interlaced;
+		uint32_t in_pixel_fmt;
+		uint32_t out_pixel_fmt;
+		bool alpha_chan_en;
+	} mem_dp_bg_sync;
+	struct {
+		uint32_t temp;
+	} mem_sdc_bg;
+	struct {
+		uint32_t di;
+		bool interlaced;
+		uint32_t in_pixel_fmt;
+		uint32_t out_pixel_fmt;
+		bool alpha_chan_en;
+	} mem_dp_fg_sync;
+	struct {
+		uint32_t di;
+	} direct_async;
+	struct {
+		display_port_t disp;
+		mcu_mode_t ch_mode;
+		uint32_t out_left;
+		uint32_t out_top;
+	} adc_sys1;
+	struct {
+		display_port_t disp;
+		mcu_mode_t ch_mode;
+		uint32_t out_left;
+		uint32_t out_top;
+	} adc_sys2;
+} ipu_channel_params_t;
+
+/*
+ * IPU_IRQF_ONESHOT - Interrupt is not reenabled after the irq handler finished.
+ */
+#define IPU_IRQF_NONE		0x00000000
+#define IPU_IRQF_ONESHOT	0x00000001
+
+/*!
+ * Enumeration of IPU interrupt sources.
+ */
+enum ipu_irq_line {
+	IPU_IRQ_CSI0_OUT_EOF = 0,
+	IPU_IRQ_CSI1_OUT_EOF = 1,
+	IPU_IRQ_CSI2_OUT_EOF = 2,
+	IPU_IRQ_CSI3_OUT_EOF = 3,
+	IPU_IRQ_VDIC_OUT_EOF = 5,
+	IPU_IRQ_VDI_P_IN_EOF = 8,
+	IPU_IRQ_VDI_C_IN_EOF = 9,
+	IPU_IRQ_VDI_N_IN_EOF = 10,
+	IPU_IRQ_PP_IN_EOF = 11,
+	IPU_IRQ_PRP_IN_EOF = 12,
+	IPU_IRQ_PRP_GRAPH_IN_EOF = 14,
+	IPU_IRQ_PP_GRAPH_IN_EOF = 15,
+	IPU_IRQ_PRP_ALPHA_IN_EOF = 17,
+	IPU_IRQ_PP_ALPHA_IN_EOF = 18,
+	IPU_IRQ_PRP_ENC_OUT_EOF = 20,
+	IPU_IRQ_PRP_VF_OUT_EOF = 21,
+	IPU_IRQ_PP_OUT_EOF = 22,
+	IPU_IRQ_BG_SYNC_EOF = 23,
+	IPU_IRQ_BG_ASYNC_EOF = 24,
+	IPU_IRQ_FG_SYNC_EOF = 27,
+	IPU_IRQ_DC_SYNC_EOF = 28,
+	IPU_IRQ_FG_ASYNC_EOF = 29,
+	IPU_IRQ_FG_ALPHA_SYNC_EOF = 31,
+
+	IPU_IRQ_FG_ALPHA_ASYNC_EOF = 33,
+	IPU_IRQ_DC_READ_EOF = 40,
+	IPU_IRQ_DC_ASYNC_EOF = 41,
+	IPU_IRQ_DC_CMD1_EOF = 42,
+	IPU_IRQ_DC_CMD2_EOF = 43,
+	IPU_IRQ_DC_MASK_EOF = 44,
+	IPU_IRQ_PRP_ENC_ROT_IN_EOF = 45,
+	IPU_IRQ_PRP_VF_ROT_IN_EOF = 46,
+	IPU_IRQ_PP_ROT_IN_EOF = 47,
+	IPU_IRQ_PRP_ENC_ROT_OUT_EOF = 48,
+	IPU_IRQ_PRP_VF_ROT_OUT_EOF = 49,
+	IPU_IRQ_PP_ROT_OUT_EOF = 50,
+	IPU_IRQ_BG_ALPHA_SYNC_EOF = 51,
+	IPU_IRQ_BG_ALPHA_ASYNC_EOF = 52,
+
+	IPU_IRQ_BG_SYNC_NFACK = 64 + 23,
+	IPU_IRQ_FG_SYNC_NFACK = 64 + 27,
+	IPU_IRQ_DC_SYNC_NFACK = 64 + 28,
+
+	IPU_IRQ_DP_SF_START = 448 + 2,
+	IPU_IRQ_DP_SF_END = 448 + 3,
+	IPU_IRQ_BG_SF_END = IPU_IRQ_DP_SF_END,
+	IPU_IRQ_DC_FC_0 = 448 + 8,
+	IPU_IRQ_DC_FC_1 = 448 + 9,
+	IPU_IRQ_DC_FC_2 = 448 + 10,
+	IPU_IRQ_DC_FC_3 = 448 + 11,
+	IPU_IRQ_DC_FC_4 = 448 + 12,
+	IPU_IRQ_DC_FC_6 = 448 + 13,
+	IPU_IRQ_VSYNC_PRE_0 = 448 + 14,
+	IPU_IRQ_VSYNC_PRE_1 = 448 + 15,
+
+	IPU_IRQ_COUNT
+};
+
+/*!
+ * Bitfield of Display Interface signal polarities.
+ */
+typedef struct {
+	unsigned datamask_en:1;
+	unsigned int_clk:1;
+	unsigned interlaced:1;
+	unsigned odd_field_first:1;
+	unsigned clksel_en:1;
+	unsigned clkidle_en:1;
+	unsigned data_pol:1;	/* true = inverted */
+	unsigned clk_pol:1;	/* true = rising edge */
+	unsigned enable_pol:1;
+	unsigned Hsync_pol:1;	/* true = active high */
+	unsigned Vsync_pol:1;
+} ipu_di_signal_cfg_t;
+
+/*!
+ * Bitfield of CSI signal polarities and modes.
+ */
+
+typedef struct {
+	unsigned data_width:4;
+	unsigned clk_mode:3;
+	unsigned ext_vsync:1;
+	unsigned Vsync_pol:1;
+	unsigned Hsync_pol:1;
+	unsigned pixclk_pol:1;
+	unsigned data_pol:1;
+	unsigned sens_clksrc:1;
+	unsigned pack_tight:1;
+	unsigned force_eof:1;
+	unsigned data_en_pol:1;
+	unsigned data_fmt;
+	unsigned csi;
+	unsigned mclk;
+} ipu_csi_signal_cfg_t;
+
+/*!
+ * Enumeration of CSI data bus widths.
+ */
+enum {
+	IPU_CSI_DATA_WIDTH_4 = 0,
+	IPU_CSI_DATA_WIDTH_8 = 1,
+	IPU_CSI_DATA_WIDTH_10 = 3,
+	IPU_CSI_DATA_WIDTH_16 = 9,
+};
+
+/*!
+ * Enumeration of CSI clock modes.
+ */
+enum {
+	IPU_CSI_CLK_MODE_GATED_CLK,
+	IPU_CSI_CLK_MODE_NONGATED_CLK,
+	IPU_CSI_CLK_MODE_CCIR656_PROGRESSIVE,
+	IPU_CSI_CLK_MODE_CCIR656_INTERLACED,
+	IPU_CSI_CLK_MODE_CCIR1120_PROGRESSIVE_DDR,
+	IPU_CSI_CLK_MODE_CCIR1120_PROGRESSIVE_SDR,
+	IPU_CSI_CLK_MODE_CCIR1120_INTERLACED_DDR,
+	IPU_CSI_CLK_MODE_CCIR1120_INTERLACED_SDR,
+};
+
+enum {
+	IPU_CSI_MIPI_DI0,
+	IPU_CSI_MIPI_DI1,
+	IPU_CSI_MIPI_DI2,
+	IPU_CSI_MIPI_DI3,
+};
+
+typedef enum {
+	RGB,
+	YCbCr,
+	YUV
+} ipu_color_space_t;
+
+/*!
+ * Enumeration of ADC vertical sync mode.
+ */
+typedef enum {
+	VsyncNone,
+	VsyncInternal,
+	VsyncCSI,
+	VsyncExternal
+} vsync_t;
+
+typedef enum {
+	DAT,
+	CMD
+} cmddata_t;
+
+/*!
+ * Enumeration of ADC display update mode.
+ */
+typedef enum {
+	IPU_ADC_REFRESH_NONE,
+	IPU_ADC_AUTO_REFRESH,
+	IPU_ADC_AUTO_REFRESH_SNOOP,
+	IPU_ADC_SNOOPING,
+} ipu_adc_update_mode_t;
+
+/*!
+ * Enumeration of ADC display interface types (serial or parallel).
+ */
+enum {
+	IPU_ADC_IFC_MODE_SYS80_TYPE1,
+	IPU_ADC_IFC_MODE_SYS80_TYPE2,
+	IPU_ADC_IFC_MODE_SYS68K_TYPE1,
+	IPU_ADC_IFC_MODE_SYS68K_TYPE2,
+	IPU_ADC_IFC_MODE_3WIRE_SERIAL,
+	IPU_ADC_IFC_MODE_4WIRE_SERIAL,
+	IPU_ADC_IFC_MODE_5WIRE_SERIAL_CLK,
+	IPU_ADC_IFC_MODE_5WIRE_SERIAL_CS,
+};
+
+enum {
+	IPU_ADC_IFC_WIDTH_8,
+	IPU_ADC_IFC_WIDTH_16,
+};
+
+/*!
+ * Enumeration of ADC display interface burst mode.
+ */
+enum {
+	IPU_ADC_BURST_WCS,
+	IPU_ADC_BURST_WBLCK,
+	IPU_ADC_BURST_NONE,
+	IPU_ADC_BURST_SERIAL,
+};
+
+/*!
+ * Enumeration of ADC display interface RW signal timing modes.
+ */
+enum {
+	IPU_ADC_SER_NO_RW,
+	IPU_ADC_SER_RW_BEFORE_RS,
+	IPU_ADC_SER_RW_AFTER_RS,
+};
+
+/*!
+ * Bitfield of ADC signal polarities and modes.
+ */
+typedef struct {
+	unsigned data_pol:1;
+	unsigned clk_pol:1;
+	unsigned cs_pol:1;
+	unsigned rs_pol:1;
+	unsigned addr_pol:1;
+	unsigned read_pol:1;
+	unsigned write_pol:1;
+	unsigned Vsync_pol:1;
+	unsigned burst_pol:1;
+	unsigned burst_mode:2;
+	unsigned ifc_mode:3;
+	unsigned ifc_width:5;
+	unsigned ser_preamble_len:4;
+	unsigned ser_preamble:8;
+	unsigned ser_rw_mode:2;
+} ipu_adc_sig_cfg_t;
+
+/*!
+ * Enumeration of ADC template commands.
+ */
+enum {
+	RD_DATA,
+	RD_ACK,
+	RD_WAIT,
+	WR_XADDR,
+	WR_YADDR,
+	WR_ADDR,
+	WR_CMND,
+	WR_DATA,
+};
+
+/*!
+ * Enumeration of ADC template command flow control.
+ */
+enum {
+	SINGLE_STEP,
+	PAUSE,
+	STOP,
+};
+
+
+/*Define template constants*/
+#define     ATM_ADDR_RANGE      0x20	/*offset address of DISP */
+#define     TEMPLATE_BUF_SIZE   0x20	/*size of template */
+
+/*!
+ * Define to create ADC template command entry.
+ */
+#define ipu_adc_template_gen(oc, rs, fc, dat) (((rs) << 29) | ((fc) << 27) | \
+			((oc) << 24) | (dat))
+
+typedef struct {
+	u32 reg;
+	u32 value;
+} ipu_lpmc_reg_t;
+
+#define IPU_LPMC_REG_READ       0x80000000L
+
+#define CSI_MCLK_VF  1
+#define CSI_MCLK_ENC 2
+#define CSI_MCLK_RAW 4
+#define CSI_MCLK_I2C 8
+
+struct ipu_soc;
+/* Common IPU API */
+struct ipu_soc *ipu_get_soc(int id);
+int32_t ipu_init_channel(struct ipu_soc *ipu, ipu_channel_t channel, ipu_channel_params_t *params);
+void ipu_uninit_channel(struct ipu_soc *ipu, ipu_channel_t channel);
+void ipu_disable_hsp_clk(struct ipu_soc *ipu);
+
+static inline bool ipu_can_rotate_in_place(ipu_rotate_mode_t rot)
+{
+#ifdef CONFIG_MXC_IPU_V3D
+	return (rot < IPU_ROTATE_HORIZ_FLIP);
+#else
+	return (rot < IPU_ROTATE_90_RIGHT);
+#endif
+}
+
+int32_t ipu_init_channel_buffer(struct ipu_soc *ipu, ipu_channel_t channel, ipu_buffer_t type,
+				uint32_t pixel_fmt,
+				uint16_t width, uint16_t height,
+				uint32_t stride,
+				ipu_rotate_mode_t rot_mode,
+				dma_addr_t phyaddr_0, dma_addr_t phyaddr_1,
+				dma_addr_t phyaddr_2,
+				uint32_t u_offset, uint32_t v_offset);
+
+int32_t ipu_update_channel_buffer(struct ipu_soc *ipu, ipu_channel_t channel, ipu_buffer_t type,
+				  uint32_t bufNum, dma_addr_t phyaddr);
+
+int32_t ipu_update_channel_offset(struct ipu_soc *ipu, ipu_channel_t channel, ipu_buffer_t type,
+				uint32_t pixel_fmt,
+				uint16_t width, uint16_t height,
+				uint32_t stride,
+				uint32_t u, uint32_t v,
+				uint32_t vertical_offset, uint32_t horizontal_offset);
+
+int32_t ipu_get_channel_offset(uint32_t pixel_fmt,
+			       uint16_t width, uint16_t height,
+			       uint32_t stride,
+			       uint32_t u, uint32_t v,
+			       uint32_t vertical_offset, uint32_t horizontal_offset,
+			       uint32_t *u_offset, uint32_t *v_offset);
+
+int32_t ipu_select_buffer(struct ipu_soc *ipu, ipu_channel_t channel,
+			  ipu_buffer_t type, uint32_t bufNum);
+int32_t ipu_select_multi_vdi_buffer(struct ipu_soc *ipu, uint32_t bufNum);
+
+int32_t ipu_link_channels(struct ipu_soc *ipu, ipu_channel_t src_ch, ipu_channel_t dest_ch);
+int32_t ipu_unlink_channels(struct ipu_soc *ipu, ipu_channel_t src_ch, ipu_channel_t dest_ch);
+
+int32_t ipu_is_channel_busy(struct ipu_soc *ipu, ipu_channel_t channel);
+int32_t ipu_check_buffer_ready(struct ipu_soc *ipu, ipu_channel_t channel, ipu_buffer_t type,
+		uint32_t bufNum);
+void ipu_clear_buffer_ready(struct ipu_soc *ipu, ipu_channel_t channel, ipu_buffer_t type,
+		uint32_t bufNum);
+uint32_t ipu_get_cur_buffer_idx(struct ipu_soc *ipu, ipu_channel_t channel, ipu_buffer_t type);
+int32_t ipu_enable_channel(struct ipu_soc *ipu, ipu_channel_t channel);
+int32_t ipu_disable_channel(struct ipu_soc *ipu, ipu_channel_t channel, bool wait_for_stop);
+int32_t ipu_swap_channel(struct ipu_soc *ipu, ipu_channel_t from_ch, ipu_channel_t to_ch);
+uint32_t ipu_channel_status(struct ipu_soc *ipu, ipu_channel_t channel);
+
+int32_t ipu_enable_csi(struct ipu_soc *ipu, uint32_t csi);
+int32_t ipu_disable_csi(struct ipu_soc *ipu, uint32_t csi);
+
+int ipu_lowpwr_display_enable(void);
+int ipu_lowpwr_display_disable(void);
+
+int ipu_enable_irq(struct ipu_soc *ipu, uint32_t irq);
+void ipu_disable_irq(struct ipu_soc *ipu, uint32_t irq);
+void ipu_clear_irq(struct ipu_soc *ipu, uint32_t irq);
+int ipu_request_irq(struct ipu_soc *ipu, uint32_t irq,
+		    irqreturn_t(*handler) (int, void *),
+		    uint32_t irq_flags, const char *devname, void *dev_id);
+void ipu_free_irq(struct ipu_soc *ipu, uint32_t irq, void *dev_id);
+bool ipu_get_irq_status(struct ipu_soc *ipu, uint32_t irq);
+void ipu_set_csc_coefficients(struct ipu_soc *ipu, ipu_channel_t channel, int32_t param[][3]);
+int32_t ipu_set_channel_bandmode(struct ipu_soc *ipu, ipu_channel_t channel,
+				 ipu_buffer_t type, uint32_t band_height);
+
+/* two stripe calculations */
+struct stripe_param{
+	unsigned int input_width; /* width of the input stripe */
+	unsigned int output_width; /* width of the output stripe */
+	unsigned int input_column; /* the first column on the input stripe */
+	unsigned int output_column; /* the first column on the output stripe */
+	unsigned int idr;
+	/* inverse downisizing ratio parameter; expressed as a power of 2 */
+	unsigned int irr;
+	/* inverse resizing ratio parameter; expressed as a multiple of 2^-13 */
+};
+int ipu_calc_stripes_sizes(const unsigned int input_frame_width,
+				unsigned int output_frame_width,
+				const unsigned int maximal_stripe_width,
+				const unsigned long long cirr,
+				const unsigned int equal_stripes,
+				u32 input_pixelformat,
+				u32 output_pixelformat,
+				struct stripe_param *left,
+				struct stripe_param *right);
+
+/* SDC API */
+int32_t ipu_init_sync_panel(struct ipu_soc *ipu, int disp,
+			    uint32_t pixel_clk,
+			    uint16_t width, uint16_t height,
+			    uint32_t pixel_fmt,
+			    uint16_t h_start_width, uint16_t h_sync_width,
+			    uint16_t h_end_width, uint16_t v_start_width,
+			    uint16_t v_sync_width, uint16_t v_end_width,
+			    uint32_t v_to_h_sync, ipu_di_signal_cfg_t sig);
+
+void ipu_uninit_sync_panel(struct ipu_soc *ipu, int disp);
+
+int32_t ipu_disp_set_window_pos(struct ipu_soc *ipu, ipu_channel_t channel, int16_t x_pos,
+				int16_t y_pos);
+int32_t ipu_disp_get_window_pos(struct ipu_soc *ipu, ipu_channel_t channel, int16_t *x_pos,
+				int16_t *y_pos);
+int32_t ipu_disp_set_global_alpha(struct ipu_soc *ipu, ipu_channel_t channel, bool enable,
+				  uint8_t alpha);
+int32_t ipu_disp_set_color_key(struct ipu_soc *ipu, ipu_channel_t channel, bool enable,
+			       uint32_t colorKey);
+int32_t ipu_disp_set_gamma_correction(struct ipu_soc *ipu, ipu_channel_t channel, bool enable,
+				int constk[], int slopek[]);
+
+int ipu_init_async_panel(struct ipu_soc *ipu, int disp, int type, uint32_t cycle_time,
+			 uint32_t pixel_fmt, ipu_adc_sig_cfg_t sig);
+void ipu_reset_disp_panel(struct ipu_soc *ipu);
+
+/* CMOS Sensor Interface API */
+int32_t ipu_csi_init_interface(struct ipu_soc *ipu, uint16_t width, uint16_t height,
+			       uint32_t pixel_fmt, ipu_csi_signal_cfg_t sig);
+
+int32_t ipu_csi_get_sensor_protocol(struct ipu_soc *ipu, uint32_t csi);
+
+int32_t ipu_csi_enable_mclk(struct ipu_soc *ipu, int src, bool flag, bool wait);
+
+static inline int32_t ipu_csi_enable_mclk_if(struct ipu_soc *ipu, int src, uint32_t csi,
+		bool flag, bool wait)
+{
+	return ipu_csi_enable_mclk(ipu, csi, flag, wait);
+}
+
+int ipu_csi_read_mclk_flag(void);
+
+void ipu_csi_flash_strobe(bool flag);
+
+void ipu_csi_get_window_size(struct ipu_soc *ipu, uint32_t *width, uint32_t *height, uint32_t csi);
+
+void ipu_csi_set_window_size(struct ipu_soc *ipu, uint32_t width, uint32_t height, uint32_t csi);
+
+void ipu_csi_set_window_pos(struct ipu_soc *ipu, uint32_t left, uint32_t top, uint32_t csi);
+
+uint32_t bytes_per_pixel(uint32_t fmt);
+
+bool ipu_ch_param_bad_alpha_pos(uint32_t fmt);
+int ipu_ch_param_get_axi_id(struct ipu_soc *ipu, ipu_channel_t channel, ipu_buffer_t type);
+ipu_color_space_t format_to_colorspace(uint32_t fmt);
+bool ipu_pixel_format_is_gpu_tile(uint32_t fmt);
+bool ipu_pixel_format_is_split_gpu_tile(uint32_t fmt);
+bool ipu_pixel_format_is_pre_yuv(uint32_t fmt);
+bool ipu_pixel_format_is_multiplanar_yuv(uint32_t fmt);
+
+struct ipuv3_fb_platform_data {
+	char				disp_dev[32];
+	u32				interface_pix_fmt;
+	char				*mode_str;
+	int				default_bpp;
+	bool				int_clk;
+
+	/* reserved mem */
+	resource_size_t 		res_base[2];
+	resource_size_t 		res_size[2];
+
+	/*
+	 * Late init to avoid display channel being
+	 * re-initialized as we've probably setup the
+	 * channel in bootloader.
+	 */
+	bool                            late_init;
+
+	/* Enable prefetch engine or not? */
+	bool				prefetch;
+
+	/* Enable the PRE resolve engine or not? */
+	bool				resolve;
+};
+
+#endif /* __LINUX_IPU_V3_H_ */
diff --git a/include/linux/ipu.h b/include/linux/ipu.h
new file mode 100644
index 000000000..1090ac65f
--- /dev/null
+++ b/include/linux/ipu.h
@@ -0,0 +1,38 @@
+/*
+ * Copyright 2005-2015 Freescale Semiconductor, Inc.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU Lesser General
+ * Public License.  You may obtain a copy of the GNU Lesser General
+ * Public License Version 2.1 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/lgpl-license.html
+ * http://www.gnu.org/copyleft/lgpl.html
+ */
+
+/*!
+ * @defgroup IPU MXC Image Processing Unit (IPU) Driver
+ */
+/*!
+ * @file linux/ipu.h
+ *
+ * @brief This file contains the IPU driver API declarations.
+ *
+ * @ingroup IPU
+ */
+
+#ifndef __LINUX_IPU_H__
+#define __LINUX_IPU_H__
+
+#include <linux/interrupt.h>
+#include <uapi/linux/ipu.h>
+
+unsigned int fmt_to_bpp(unsigned int pixelformat);
+cs_t colorspaceofpixel(int fmt);
+int need_csc(int ifmt, int ofmt);
+
+int ipu_queue_task(struct ipu_task *task);
+int ipu_check_task(struct ipu_task *task);
+
+#endif
diff --git a/include/linux/ivshmem.h b/include/linux/ivshmem.h
new file mode 100644
index 000000000..bad8547f0
--- /dev/null
+++ b/include/linux/ivshmem.h
@@ -0,0 +1,30 @@
+/* SPDX-License-Identifier: GPL-2.0-only */
+#ifndef _LINUX_IVSHMEM_H
+#define _LINUX_IVSHMEM_H
+
+#include <linux/types.h>
+
+#define IVSHM_PROTO_UNDEFINED		0x0000
+#define IVSHM_PROTO_NET			0x0001
+#define IVSHM_PROTO_VIRTIO_FRONT	0x8000
+#define IVSHM_PROTO_VIRTIO_BACK		0xc000
+#define IVSHM_PROTO_VIRTIO_DEVID_MASK	0x7fff
+
+#define IVSHM_CFG_PRIV_CNTL		0x03
+# define IVSHM_PRIV_CNTL_ONESHOT_INT	BIT(0)
+#define IVSHM_CFG_STATE_TAB_SZ		0x04
+#define IVSHM_CFG_RW_SECTION_SZ		0x08
+#define IVSHM_CFG_OUTPUT_SECTION_SZ	0x10
+#define IVSHM_CFG_ADDRESS		0x18
+
+struct ivshm_regs {
+	u32 id;
+	u32 max_peers;
+	u32 int_control;
+	u32 doorbell;
+	u32 state;
+};
+
+#define IVSHM_INT_ENABLE		BIT(0)
+
+#endif /* _LINUX_IVSHMEM_H */
diff --git a/include/linux/linux_logo.h b/include/linux/linux_logo.h
index d4d5b93ef..83a70ab10 100644
--- a/include/linux/linux_logo.h
+++ b/include/linux/linux_logo.h
@@ -45,6 +45,7 @@ extern const struct linux_logo logo_superh_mono;
 extern const struct linux_logo logo_superh_vga16;
 extern const struct linux_logo logo_superh_clut224;
 extern const struct linux_logo logo_spe_clut224;
+extern const struct linux_logo customer_logo_linux_clut224;
 
 extern const struct linux_logo *fb_find_logo(int depth);
 #ifdef CONFIG_FB_LOGO_EXTRA
diff --git a/include/linux/mfd/fp9931.h b/include/linux/mfd/fp9931.h
new file mode 100644
index 000000000..36907e583
--- /dev/null
+++ b/include/linux/mfd/fp9931.h
@@ -0,0 +1,74 @@
+/* SPDX-License-Identifier: GPL-2.0-or-later */
+/*
+ * Copyright 2021 NXP
+ */
+
+#ifndef __FP9931_H_
+#define __FP9931_H_
+
+/* Reigster Addresses */
+
+#define FP9931_TMST_VALUE		0x00
+#define FP9931_VCOM_SETTING		0x01
+#define FP9931_VPOS_VNEG_SETTING	0x02
+#define FP9931_PWRON_DELAY		0x03
+#define FP9931_CONTROL_REG1		0x0B
+#define FP9931_CONTROL_REG2		0x0C
+
+#define VPOS_VNEG_SETTING		GENMASK(5, 0)
+#define PWRON_DELAY_tDLY1		GENMASK(1, 0)
+#define PWRON_DELAY_tDLY2		GENMASK(3, 2)
+#define PWRON_DELAY_tDLY3		GENMASK(5, 4)
+#define PWRON_DELAY_tDLY4		GENMASK(7, 6)
+#define CONTROL_REG1_V3P3_EN		BIT(1)
+#define CONTROL_REG1_SS_TIME		GENMASK(7, 6)
+#define CONTROL_REG2_VN_CL		GENMASK(1, 0)
+#define CONTROL_REG2_VP_CL		GENMASK(3, 2)
+#define CONTROL_REG2_FIX_RD_PTR		BIT(7)
+
+enum {
+	FP9931_DISPLAY,
+	FP9931_VPOS,
+	FP9931_VNEG,
+	FP9931_VGH,
+	FP9931_VGL,
+	FP9931_VCOM,
+	FP9931_V3P3,
+};
+
+struct fp9931 {
+	struct device *dev;
+	struct fp9931_platform_data *pdata;
+
+	struct i2c_client *client;
+
+	/* power up delay time: 0ms, 1ms, 2ms, 4ms */
+	unsigned int vgl_pwrup;
+	unsigned int vneg_pwrup;
+	unsigned int vgh_pwrup;
+	unsigned int vpos_pwrup;
+
+	/* soft start time for all regulator
+	 * voltages power on: 3ms ~ 6ms
+	 */
+	unsigned int ss_time;
+
+	int gpio_pmic_wakeup;
+	int gpio_pmic_pwrgood;
+};
+
+struct fp9931_platform_data {
+	/* PMIC */
+	struct fp9931_regulator_data *regulators;
+	int num_regulators;
+};
+
+struct fp9931_regulator_data {
+	int id;
+	struct regulator_init_data *initdata;
+	struct device_node *reg_node;
+};
+
+int fp9931_reg_read(struct i2c_client *client, int reg_num, u8 *reg_val);
+int fp9931_reg_write(struct i2c_client *client, int reg_num, u8 reg_val);
+#endif
diff --git a/include/linux/mfd/max17135.h b/include/linux/mfd/max17135.h
new file mode 100644
index 000000000..f41ba1245
--- /dev/null
+++ b/include/linux/mfd/max17135.h
@@ -0,0 +1,207 @@
+/* SPDX-License-Identifier: GPL-2.0-or-later */
+/*
+ * Copyright (C) 2010-2015 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright 2019 NXP
+ */
+#ifndef __LINUX_REGULATOR_MAX17135_H_
+#define __LINUX_REGULATOR_MAX17135_H_
+
+/*
+ * PMIC Register Addresses
+ */
+enum {
+    REG_MAX17135_EXT_TEMP = 0x0,
+    REG_MAX17135_CONFIG,
+    REG_MAX17135_INT_TEMP = 0x4,
+    REG_MAX17135_STATUS,
+    REG_MAX17135_PRODUCT_REV,
+    REG_MAX17135_PRODUCT_ID,
+    REG_MAX17135_DVR,
+    REG_MAX17135_ENABLE,
+    REG_MAX17135_FAULT,  /*0x0A*/
+    REG_MAX17135_HVINP,
+    REG_MAX17135_PRGM_CTRL,
+    REG_MAX17135_TIMING1 = 0x10,    /* Timing regs base address is 0x10 */
+    REG_MAX17135_TIMING2,
+    REG_MAX17135_TIMING3,
+    REG_MAX17135_TIMING4,
+    REG_MAX17135_TIMING5,
+    REG_MAX17135_TIMING6,
+    REG_MAX17135_TIMING7,
+    REG_MAX17135_TIMING8,
+};
+#define MAX17135_REG_NUM        21
+#define MAX17135_MAX_REGISTER   0xFF
+
+/*
+ * Bitfield macros that use rely on bitfield width/shift information.
+ */
+#define BITFMASK(field) (((1U << (field ## _WID)) - 1) << (field ## _LSH))
+#define BITFVAL(field, val) ((val) << (field ## _LSH))
+#define BITFEXT(var, bit) ((var & BITFMASK(bit)) >> (bit ## _LSH))
+
+/*
+ * Shift and width values for each register bitfield
+ */
+#define EXT_TEMP_LSH    7
+#define EXT_TEMP_WID    9
+
+#define THERMAL_SHUTDOWN_LSH    0
+#define THERMAL_SHUTDOWN_WID    1
+
+#define INT_TEMP_LSH    7
+#define INT_TEMP_WID    9
+
+#define STAT_BUSY_LSH   0
+#define STAT_BUSY_WID   1
+#define STAT_OPEN_LSH   1
+#define STAT_OPEN_WID   1
+#define STAT_SHRT_LSH   2
+#define STAT_SHRT_WID   1
+
+#define PROD_REV_LSH    0
+#define PROD_REV_WID    8
+
+#define PROD_ID_LSH     0
+#define PROD_ID_WID     8
+
+#define DVR_LSH         0
+#define DVR_WID         8
+
+#define ENABLE_LSH      0
+#define ENABLE_WID      1
+#define VCOM_ENABLE_LSH 1
+#define VCOM_ENABLE_WID 1
+
+#define FAULT_FBPG_LSH      0
+#define FAULT_FBPG_WID      1
+#define FAULT_HVINP_LSH     1
+#define FAULT_HVINP_WID     1
+#define FAULT_HVINN_LSH     2
+#define FAULT_HVINN_WID     1
+#define FAULT_FBNG_LSH      3
+#define FAULT_FBNG_WID      1
+#define FAULT_HVINPSC_LSH   4
+#define FAULT_HVINPSC_WID   1
+#define FAULT_HVINNSC_LSH   5
+#define FAULT_HVINNSC_WID   1
+#define FAULT_OT_LSH        6
+#define FAULT_OT_WID        1
+#define FAULT_POK_LSH       7
+#define FAULT_POK_WID       1
+
+#define HVINP_LSH           0
+#define HVINP_WID           4
+
+#define CTRL_DVR_LSH        0
+#define CTRL_DVR_WID        1
+#define CTRL_TIMING_LSH     1
+#define CTRL_TIMING_WID     1
+
+#define TIMING1_LSH         0
+#define TIMING1_WID         8
+#define TIMING2_LSH         0
+#define TIMING2_WID         8
+#define TIMING3_LSH         0
+#define TIMING3_WID         8
+#define TIMING4_LSH         0
+#define TIMING4_WID         8
+#define TIMING5_LSH         0
+#define TIMING5_WID         8
+#define TIMING6_LSH         0
+#define TIMING6_WID         8
+#define TIMING7_LSH         0
+#define TIMING7_WID         8
+#define TIMING8_LSH         0
+#define TIMING8_WID         8
+
+struct max17135 {
+	/* chip revision */
+	int rev;
+
+	struct device *dev;
+	struct max17135_platform_data *pdata;
+
+	/* Platform connection */
+	struct i2c_client *i2c_client;
+
+	/* Timings */
+	unsigned int gvee_pwrup;
+	unsigned int vneg_pwrup;
+	unsigned int vpos_pwrup;
+	unsigned int gvdd_pwrup;
+	unsigned int gvdd_pwrdn;
+	unsigned int vpos_pwrdn;
+	unsigned int vneg_pwrdn;
+	unsigned int gvee_pwrdn;
+
+	/* GPIOs */
+	int gpio_pmic_pwrgood;
+	int gpio_pmic_vcom_ctrl;
+	int gpio_pmic_wakeup;
+	int gpio_pmic_v3p3;
+	int gpio_pmic_intr;
+
+	/* MAX17135 part variables */
+	int pass_num;
+	int vcom_uV;
+
+	/* One-time VCOM setup marker */
+	bool vcom_setup;
+
+	/* powerup/powerdown wait time */
+	int max_wait;
+};
+
+enum {
+    /* In alphabetical order */
+    MAX17135_DISPLAY, /* virtual master enable */
+    MAX17135_GVDD,
+    MAX17135_GVEE,
+    MAX17135_HVINN,
+    MAX17135_HVINP,
+    MAX17135_VCOM,
+    MAX17135_VNEG,
+    MAX17135_VPOS,
+    MAX17135_V3P3,
+    MAX17135_NUM_REGULATORS,
+};
+
+/*
+ * Declarations
+ */
+struct regulator_init_data;
+struct max17135_regulator_data;
+
+struct max17135_platform_data {
+	unsigned int gvee_pwrup;
+	unsigned int vneg_pwrup;
+	unsigned int vpos_pwrup;
+	unsigned int gvdd_pwrup;
+	unsigned int gvdd_pwrdn;
+	unsigned int vpos_pwrdn;
+	unsigned int vneg_pwrdn;
+	unsigned int gvee_pwrdn;
+	int gpio_pmic_pwrgood;
+	int gpio_pmic_vcom_ctrl;
+	int gpio_pmic_wakeup;
+	int gpio_pmic_v3p3;
+	int gpio_pmic_intr;
+	int pass_num;
+	int vcom_uV;
+
+	/* PMIC */
+	struct max17135_regulator_data *regulators;
+	int num_regulators;
+};
+
+struct max17135_regulator_data {
+	int id;
+	struct regulator_init_data *initdata;
+	struct device_node *reg_node;
+};
+
+int max17135_reg_read(int reg_num, unsigned int *reg_val);
+int max17135_reg_write(int reg_num, const unsigned int reg_val);
+
+#endif
diff --git a/include/linux/mfd/mxc-hdmi-core.h b/include/linux/mfd/mxc-hdmi-core.h
new file mode 100644
index 000000000..b2696b951
--- /dev/null
+++ b/include/linux/mfd/mxc-hdmi-core.h
@@ -0,0 +1,56 @@
+/*
+ * Copyright (C) 2011-2015 Freescale Semiconductor, Inc. All Rights Reserved.
+ *
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+#ifndef __LINUX_MXC_HDMI_CORE_H_
+#define __LINUX_MXC_HDMI_CORE_H_
+
+#include <video/mxc_edid.h>
+
+#include <sound/core.h>
+#include <sound/pcm.h>
+#include <sound/pcm_params.h>
+#include <sound/soc.h>
+
+#define IRQ_DISABLE_SUCCEED	0
+#define IRQ_DISABLE_FAIL	1
+
+bool hdmi_check_overflow(void);
+
+u8 hdmi_readb(unsigned int reg);
+void hdmi_writeb(u8 value, unsigned int reg);
+void hdmi_mask_writeb(u8 data, unsigned int addr, u8 shift, u8 mask);
+unsigned int hdmi_read4(unsigned int reg);
+void hdmi_write4(unsigned int value, unsigned int reg);
+
+void hdmi_irq_init(void);
+void hdmi_irq_enable(int irq);
+unsigned int hdmi_irq_disable(int irq);
+
+void hdmi_set_sample_rate(unsigned int rate);
+void hdmi_set_dma_mode(unsigned int dma_running);
+void hdmi_init_clk_regenerator(void);
+void hdmi_clk_regenerator_update_pixel_clock(u32 pixclock);
+
+void hdmi_set_edid_cfg(struct mxc_edid_cfg *cfg);
+void hdmi_get_edid_cfg(struct mxc_edid_cfg *cfg);
+
+extern int mxc_hdmi_ipu_id;
+extern int mxc_hdmi_disp_id;
+
+void hdmi_set_registered(int registered);
+int hdmi_get_registered(void);
+int mxc_hdmi_abort_stream(void);
+int mxc_hdmi_register_audio(struct snd_pcm_substream *substream);
+void mxc_hdmi_unregister_audio(struct snd_pcm_substream *substream);
+unsigned int hdmi_set_cable_state(unsigned int state);
+unsigned int hdmi_set_blank_state(unsigned int state);
+int check_hdmi_state(void);
+
+#endif
diff --git a/include/linux/mfd/tmio.h b/include/linux/mfd/tmio.h
index 8ba042430..739b7bf37 100644
--- a/include/linux/mfd/tmio.h
+++ b/include/linux/mfd/tmio.h
@@ -79,6 +79,9 @@
 /* Some controllers have a CBSY bit */
 #define TMIO_MMC_HAVE_CBSY		BIT(11)
 
+/* Some controllers that support HS400 use 4 taps while others use 8. */
+#define TMIO_MMC_HAVE_4TAP_HS400	BIT(13)
+
 int tmio_core_mmc_enable(void __iomem *cnf, int shift, unsigned long base);
 int tmio_core_mmc_resume(void __iomem *cnf, int shift, unsigned long base);
 void tmio_core_mmc_pwr(void __iomem *cnf, int shift, int state);
diff --git a/include/linux/mipi_csi2.h b/include/linux/mipi_csi2.h
new file mode 100644
index 000000000..d750ed9b0
--- /dev/null
+++ b/include/linux/mipi_csi2.h
@@ -0,0 +1,81 @@
+/* SPDX-License-Identifier: GPL-2.0-or-later */
+/*
+ * Copyright (C) 2011-2013 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright 2019 NXP
+ */
+
+#ifndef __INCLUDE_MIPI_CSI2_H
+#define __INCLUDE_MIPI_CSI2_H
+
+/* MIPI CSI2 registers */
+#define MIPI_CSI2_REG(offset)		(offset)
+
+#define	MIPI_CSI2_VERSION		MIPI_CSI2_REG(0x000)
+#define	MIPI_CSI2_N_LANES		MIPI_CSI2_REG(0x004)
+#define	MIPI_CSI2_PHY_SHUTDOWNZ		MIPI_CSI2_REG(0x008)
+#define	MIPI_CSI2_DPHY_RSTZ		MIPI_CSI2_REG(0x00c)
+#define	MIPI_CSI2_CSI2_RESETN		MIPI_CSI2_REG(0x010)
+#define	MIPI_CSI2_PHY_STATE		MIPI_CSI2_REG(0x014)
+#define	MIPI_CSI2_DATA_IDS_1		MIPI_CSI2_REG(0x018)
+#define	MIPI_CSI2_DATA_IDS_2		MIPI_CSI2_REG(0x01c)
+#define	MIPI_CSI2_ERR1			MIPI_CSI2_REG(0x020)
+#define	MIPI_CSI2_ERR2			MIPI_CSI2_REG(0x024)
+#define	MIPI_CSI2_MASK1			MIPI_CSI2_REG(0x028)
+#define	MIPI_CSI2_MASK2			MIPI_CSI2_REG(0x02c)
+#define	MIPI_CSI2_PHY_TST_CTRL0		MIPI_CSI2_REG(0x030)
+#define	MIPI_CSI2_PHY_TST_CTRL1		MIPI_CSI2_REG(0x034)
+#define	MIPI_CSI2_SFT_RESET		MIPI_CSI2_REG(0xf00)
+
+/* mipi data type */
+#define MIPI_DT_YUV420		0x18 /* YYY.../UYVY.... */
+#define MIPI_DT_YUV420_LEGACY	0x1a /* UYY.../VYY...   */
+#define MIPI_DT_YUV422		0x1e /* UYVY...		*/
+#define MIPI_DT_RGB444		0x20
+#define MIPI_DT_RGB555		0x21
+#define MIPI_DT_RGB565		0x22
+#define MIPI_DT_RGB666		0x23
+#define MIPI_DT_RGB888		0x24
+#define MIPI_DT_RAW6		0x28
+#define MIPI_DT_RAW7		0x29
+#define MIPI_DT_RAW8		0x2a
+#define MIPI_DT_RAW10		0x2b
+#define MIPI_DT_RAW12		0x2c
+#define MIPI_DT_RAW14		0x2d
+
+
+struct mipi_csi2_info;
+/* mipi csi2 API */
+struct mipi_csi2_info *mipi_csi2_get_info(void);
+
+bool mipi_csi2_enable(struct mipi_csi2_info *info);
+
+bool mipi_csi2_disable(struct mipi_csi2_info *info);
+
+bool mipi_csi2_get_status(struct mipi_csi2_info *info);
+
+int mipi_csi2_get_bind_ipu(struct mipi_csi2_info *info);
+
+unsigned int mipi_csi2_get_bind_csi(struct mipi_csi2_info *info);
+
+unsigned int mipi_csi2_get_virtual_channel(struct mipi_csi2_info *info);
+
+unsigned int mipi_csi2_set_lanes(struct mipi_csi2_info *info);
+
+unsigned int mipi_csi2_set_datatype(struct mipi_csi2_info *info,
+					unsigned int datatype);
+
+unsigned int mipi_csi2_get_datatype(struct mipi_csi2_info *info);
+
+unsigned int mipi_csi2_dphy_status(struct mipi_csi2_info *info);
+
+unsigned int mipi_csi2_get_error1(struct mipi_csi2_info *info);
+
+unsigned int mipi_csi2_get_error2(struct mipi_csi2_info *info);
+
+int mipi_csi2_pixelclk_enable(struct mipi_csi2_info *info);
+
+void mipi_csi2_pixelclk_disable(struct mipi_csi2_info *info);
+
+int mipi_csi2_reset(struct mipi_csi2_info *info);
+
+#endif
diff --git a/include/linux/mipi_dsi.h b/include/linux/mipi_dsi.h
new file mode 100644
index 000000000..dbc249a38
--- /dev/null
+++ b/include/linux/mipi_dsi.h
@@ -0,0 +1,165 @@
+/*
+ * Copyright (C) 2011-2015 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+#ifndef __INCLUDE_MIPI_DSI_H
+#define __INCLUDE_MIPI_DSI_H
+
+#define     MIPI_DSI_VERSION		(0x000)
+#define     MIPI_DSI_PWR_UP		(0x004)
+#define     MIPI_DSI_CLKMGR_CFG		(0x008)
+#define     MIPI_DSI_DPI_CFG		(0x00c)
+#define     MIPI_DSI_DBI_CFG		(0x010)
+#define     MIPI_DSI_DBIS_CMDSIZE	(0x014)
+#define     MIPI_DSI_PCKHDL_CFG		(0x018)
+#define     MIPI_DSI_VID_MODE_CFG	(0x01c)
+#define     MIPI_DSI_VID_PKT_CFG	(0x020)
+#define     MIPI_DSI_CMD_MODE_CFG	(0x024)
+#define     MIPI_DSI_TMR_LINE_CFG	(0x028)
+#define     MIPI_DSI_VTIMING_CFG	(0x02c)
+#define     MIPI_DSI_PHY_TMR_CFG	(0x030)
+#define     MIPI_DSI_GEN_HDR		(0x034)
+#define     MIPI_DSI_GEN_PLD_DATA	(0x038)
+#define     MIPI_DSI_CMD_PKT_STATUS	(0x03c)
+#define     MIPI_DSI_TO_CNT_CFG		(0x040)
+#define     MIPI_DSI_ERROR_ST0		(0x044)
+#define     MIPI_DSI_ERROR_ST1		(0x048)
+#define     MIPI_DSI_ERROR_MSK0		(0x04c)
+#define     MIPI_DSI_ERROR_MSK1		(0x050)
+#define     MIPI_DSI_PHY_RSTZ		(0x054)
+#define     MIPI_DSI_PHY_IF_CFG		(0x058)
+#define     MIPI_DSI_PHY_IF_CTRL	(0x05c)
+#define     MIPI_DSI_PHY_STATUS		(0x060)
+#define     MIPI_DSI_PHY_TST_CTRL0	(0x064)
+#define     MIPI_DSI_PHY_TST_CTRL1	(0x068)
+
+#define		DSI_PWRUP_RESET					(0x0 << 0)
+#define		DSI_PWRUP_POWERUP				(0x1 << 0)
+
+#define		DSI_DPI_CFG_VID_SHIFT				(0)
+#define		DSI_DPI_CFG_VID_MASK				(0x3)
+#define		DSI_DPI_CFG_COLORCODE_SHIFT			(2)
+#define		DSI_DPI_CFG_COLORCODE_MASK			(0x7)
+#define		DSI_DPI_CFG_DATAEN_ACT_LOW			(0x1 << 5)
+#define		DSI_DPI_CFG_DATAEN_ACT_HIGH			(0x0 << 5)
+#define		DSI_DPI_CFG_VSYNC_ACT_LOW			(0x1 << 6)
+#define		DSI_DPI_CFG_VSYNC_ACT_HIGH			(0x0 << 6)
+#define		DSI_DPI_CFG_HSYNC_ACT_LOW			(0x1 << 7)
+#define		DSI_DPI_CFG_HSYNC_ACT_HIGH			(0x0 << 7)
+#define		DSI_DPI_CFG_SHUTD_ACT_LOW			(0x1 << 8)
+#define		DSI_DPI_CFG_SHUTD_ACT_HIGH			(0x0 << 8)
+#define		DSI_DPI_CFG_COLORMODE_ACT_LOW			(0x1 << 9)
+#define		DSI_DPI_CFG_COLORMODE_ACT_HIGH			(0x0 << 9)
+#define		DSI_DPI_CFG_EN18LOOSELY				(0x1 << 10)
+
+#define		DSI_PCKHDL_CFG_EN_EOTP_TX			(0x1 << 0)
+#define		DSI_PCKHDL_CFG_EN_EOTP_RX			(0x1 << 1)
+#define		DSI_PCKHDL_CFG_EN_BTA				(0x1 << 2)
+#define		DSI_PCKHDL_CFG_EN_ECC_RX			(0x1 << 3)
+#define		DSI_PCKHDL_CFG_EN_CRC_RX			(0x1 << 4)
+#define		DSI_PCKHDL_CFG_GEN_VID_RX_MASK			(0x3)
+#define		DSI_PCKHDL_CFG_GEN_VID_RX_SHIFT			(5)
+
+#define		DSI_VID_MODE_CFG_EN				(0x1 << 0)
+#define		DSI_VID_MODE_CFG_EN_BURSTMODE			(0x3 << 1)
+#define		DSI_VID_MODE_CFG_TYPE_MASK			(0x3)
+#define		DSI_VID_MODE_CFG_TYPE_SHIFT			(1)
+#define		DSI_VID_MODE_CFG_EN_LP_VSA			(0x1 << 3)
+#define		DSI_VID_MODE_CFG_EN_LP_VBP			(0x1 << 4)
+#define		DSI_VID_MODE_CFG_EN_LP_VFP			(0x1 << 5)
+#define		DSI_VID_MODE_CFG_EN_LP_VACT			(0x1 << 6)
+#define		DSI_VID_MODE_CFG_EN_LP_HBP			(0x1 << 7)
+#define		DSI_VID_MODE_CFG_EN_LP_HFP			(0x1 << 8)
+#define		DSI_VID_MODE_CFG_EN_MULTI_PKT			(0x1 << 9)
+#define		DSI_VID_MODE_CFG_EN_NULL_PKT			(0x1 << 10)
+#define		DSI_VID_MODE_CFG_EN_FRAME_ACK			(0x1 << 11)
+#define		DSI_VID_MODE_CFG_EN_LP_MODE (DSI_VID_MODE_CFG_EN_LP_VSA | \
+						 DSI_VID_MODE_CFG_EN_LP_VBP | \
+						 DSI_VID_MODE_CFG_EN_LP_VFP | \
+						 DSI_VID_MODE_CFG_EN_LP_HFP | \
+						 DSI_VID_MODE_CFG_EN_LP_HBP | \
+						 DSI_VID_MODE_CFG_EN_LP_VACT)
+
+
+
+#define		DSI_VID_PKT_CFG_VID_PKT_SZ_MASK			(0x7ff)
+#define		DSI_VID_PKT_CFG_VID_PKT_SZ_SHIFT		(0)
+#define		DSI_VID_PKT_CFG_NUM_CHUNKS_MASK			(0x3ff)
+#define		DSI_VID_PKT_CFG_NUM_CHUNKS_SHIFT		(11)
+#define		DSI_VID_PKT_CFG_NULL_PKT_SZ_MASK		(0x3ff)
+#define		DSI_VID_PKT_CFG_NULL_PKT_SZ_SHIFT		(21)
+
+#define		MIPI_DSI_CMD_MODE_CFG_EN_LOWPOWER		(0x1FFF)
+#define		MIPI_DSI_CMD_MODE_CFG_EN_CMD_MODE		(0x1 << 0)
+
+#define		DSI_TME_LINE_CFG_HSA_TIME_MASK			(0x1ff)
+#define		DSI_TME_LINE_CFG_HSA_TIME_SHIFT			(0)
+#define		DSI_TME_LINE_CFG_HBP_TIME_MASK			(0x1ff)
+#define		DSI_TME_LINE_CFG_HBP_TIME_SHIFT			(9)
+#define		DSI_TME_LINE_CFG_HLINE_TIME_MASK		(0x3fff)
+#define		DSI_TME_LINE_CFG_HLINE_TIME_SHIFT		(18)
+
+#define		DSI_VTIMING_CFG_VSA_LINES_MASK			(0xf)
+#define		DSI_VTIMING_CFG_VSA_LINES_SHIFT			(0)
+#define		DSI_VTIMING_CFG_VBP_LINES_MASK			(0x3f)
+#define		DSI_VTIMING_CFG_VBP_LINES_SHIFT			(4)
+#define		DSI_VTIMING_CFG_VFP_LINES_MASK			(0x3f)
+#define		DSI_VTIMING_CFG_VFP_LINES_SHIFT			(10)
+#define		DSI_VTIMING_CFG_V_ACT_LINES_MASK		(0x7ff)
+#define		DSI_VTIMING_CFG_V_ACT_LINES_SHIFT		(16)
+
+#define		DSI_PHY_TMR_CFG_BTA_TIME_MASK			(0xfff)
+#define		DSI_PHY_TMR_CFG_BTA_TIME_SHIFT			(0)
+#define		DSI_PHY_TMR_CFG_LP2HS_TIME_MASK			(0xff)
+#define		DSI_PHY_TMR_CFG_LP2HS_TIME_SHIFT		(12)
+#define		DSI_PHY_TMR_CFG_HS2LP_TIME_MASK			(0xff)
+#define		DSI_PHY_TMR_CFG_HS2LP_TIME_SHIFT		(20)
+
+#define		DSI_PHY_IF_CFG_N_LANES_MASK			(0x3)
+#define		DSI_PHY_IF_CFG_N_LANES_SHIFT			(0)
+#define		DSI_PHY_IF_CFG_WAIT_TIME_MASK			(0xff)
+#define		DSI_PHY_IF_CFG_WAIT_TIME_SHIFT			(2)
+
+#define		DSI_PHY_RSTZ_EN_CLK				(0x1 << 2)
+#define		DSI_PHY_RSTZ_DISABLE_RST			(0x1 << 1)
+#define		DSI_PHY_RSTZ_DISABLE_SHUTDOWN			(0x1 << 0)
+#define		DSI_PHY_RSTZ_RST				(0x0)
+
+#define		DSI_PHY_STATUS_LOCK				(0x1 << 0)
+#define		DSI_PHY_STATUS_STOPSTATE_CLK_LANE		(0x1 << 2)
+
+#define		DSI_GEN_HDR_TYPE_MASK				(0xff)
+#define		DSI_GEN_HDR_TYPE_SHIFT				(0)
+#define		DSI_GEN_HDR_DATA_MASK				(0xffff)
+#define		DSI_GEN_HDR_DATA_SHIFT				(8)
+
+#define		DSI_CMD_PKT_STATUS_GEN_CMD_EMPTY		(0x1 << 0)
+#define		DSI_CMD_PKT_STATUS_GEN_CMD_FULL			(0x1 << 1)
+#define		DSI_CMD_PKT_STATUS_GEN_PLD_W_EMPTY		(0x1 << 2)
+#define		DSI_CMD_PKT_STATUS_GEN_PLD_W_FULL		(0x1 << 3)
+#define		DSI_CMD_PKT_STATUS_GEN_PLD_R_EMPTY		(0x1 << 4)
+#define		DSI_CMD_PKT_STATUS_GEN_RD_CMD_BUSY		(0x1 << 6)
+
+#define		DSI_ERROR_MSK0_ALL_MASK				(0x1fffff)
+#define		DSI_ERROR_MSK1_ALL_MASK				(0x3ffff)
+
+#define		DSI_PHY_IF_CTRL_RESET				(0x0)
+#define		DSI_PHY_IF_CTRL_TX_REQ_CLK_HS			(0x1 << 0)
+#define		DSI_PHY_IF_CTRL_TX_REQ_CLK_ULPS			(0x1 << 1)
+#define		DSI_PHY_IF_CTRL_TX_EXIT_CLK_ULPS		(0x1 << 2)
+#define		DSI_PHY_IF_CTRL_TX_REQ_DATA_ULPS		(0x1 << 3)
+#define		DSI_PHY_IF_CTRL_TX_EXIT_DATA_ULPS		(0x1 << 4)
+#define		DSI_PHY_IF_CTRL_TX_TRIG_MASK			(0xF)
+#define		DSI_PHY_IF_CTRL_TX_TRIG_SHIFT			(5)
+
+#define		DSI_PHY_CLK_INIT_COMMAND			(0x44)
+#define		DSI_GEN_PLD_DATA_BUF_SIZE			(0x4)
+#endif
diff --git a/include/linux/mipi_dsi_northwest.h b/include/linux/mipi_dsi_northwest.h
new file mode 100644
index 000000000..8cb379c85
--- /dev/null
+++ b/include/linux/mipi_dsi_northwest.h
@@ -0,0 +1,164 @@
+/*
+ * Copyright (C) 2016 Freescale Semiconductor, Inc. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+
+#ifndef __INCLUDE_MIPI_DSI_NORTHWEST_H
+#define __INCLUDE_MIPI_DSI_NORTHWEST_H
+
+/* ----------------------------	register offsets --------------------------- */
+
+/* sim */
+#define SIM_SOPT1		0x0
+#define MIPI_ISO_DISABLE	0x8
+
+#define SIM_SOPT1CFG		0x4
+#define DSI_RST_DPI_N		0x80000000
+#define DSI_RST_ESC_N		0x40000000
+#define DSI_RST_BYTE_N		0x20000000
+#define DSI_SD			0x200
+#define DSI_CM			0x100
+#define DSI_PLL_EN		0x80
+
+/* SRC */
+#define SRC_MIPIPHY_RCR		0x28
+#define MIPI_DSI_RESET_BYTE_N	0x2
+#define MIPI_DSI_RESET_N	0x4
+#define MIPI_DSI_DPI_RESET_N	0x8
+#define MIPI_DSI_ESC_RESET_N	0x10
+#define MIPI_DSI_PCLK_RESET_N	0x20
+
+/* GPR */
+#define IOMUXC_GPR_GPR13	0x34
+#define GPR_MIPI_MUX_SEL	0x4
+
+/* dphy */
+#define DPHY_PD_DPHY			0x300
+#define DPHY_M_PRG_HS_PREPARE		0x304
+#define DPHY_MC_PRG_HS_PREPARE		0x308
+#define DPHY_M_PRG_HS_ZERO		0x30c
+#define DPHY_MC_PRG_HS_ZERO		0x310
+#define DPHY_M_PRG_HS_TRAIL		0x314
+#define DPHY_MC_PRG_HS_TRAIL		0x318
+#define DPHY_PD_PLL			0x31c
+#define DPHY_TST			0x320
+#define DPHY_CN				0x324
+#define DPHY_CM				0x328
+#define DPHY_CO				0x32c
+#define DPHY_LOCK			0x330
+#define DPHY_LOCK_BYP			0x334
+#define DPHY_RTERM_SEL			0x338
+#define DPHY_AUTO_PD_EN			0x33c
+#define DPHY_RXLPRP			0x340
+#define DPHY_RXCDRP			0x344
+
+/* host */
+#define HOST_CFG_NUM_LANES		0x0
+#define HOST_CFG_NONCONTINUOUS_CLK	0x4
+#define HOST_CFG_T_PRE			0x8
+#define HOST_CFG_T_POST			0xc
+#define HOST_CFG_TX_GAP			0x10
+#define HOST_CFG_AUTOINSERT_EOTP	0x14
+#define HOST_CFG_EXTRA_CMDS_AFTER_EOTP	0x18
+#define HOST_CFG_HTX_TO_COUNT		0x1c
+#define HOST_CFG_LRX_H_TO_COUNT		0x20
+#define HOST_CFG_BTA_H_TO_COUNT		0x24
+#define HOST_CFG_TWAKEUP		0x28
+#define HOST_CFG_STATUS_OUT		0x2c
+#define HOST_RX_ERROR_STATUS		0x30
+
+/* dpi */
+#define DPI_PIXEL_PAYLOAD_SIZE		0x200
+#define DPI_PIXEL_FIFO_SEND_LEVEL	0x204
+#define DPI_INTERFACE_COLOR_CODING	0x208
+#define DPI_PIXEL_FORMAT		0x20c
+#define DPI_VSYNC_POLARITY		0x210
+#define DPI_HSYNC_POLARITY		0x214
+#define DPI_VIDEO_MODE			0x218
+#define DPI_HFP				0x21c
+#define DPI_HBP				0x220
+#define DPI_HSA				0x224
+#define DPI_ENABLE_MULT_PKTS		0x228
+#define DPI_VBP				0x22c
+#define DPI_VFP				0x230
+#define DPI_BLLP_MODE			0x234
+#define DPI_USE_NULL_PKT_BLLP		0x238
+#define DPI_VACTIVE			0x23c
+#define DPI_VC				0x240
+
+/* apb pkt */
+#define HOST_TX_PAYLOAD			0x280
+
+#define HOST_PKT_CONTROL		0x284
+#define HOST_PKT_CONTROL_WC(x)		(((x) & 0xffff) << 0)
+#define HOST_PKT_CONTROL_VC(x)		(((x) & 0x3) << 16)
+#define HOST_PKT_CONTROL_DT(x)		(((x) & 0x3f) << 18)
+#define HOST_PKT_CONTROL_HS_SEL(x)	(((x) & 0x1) << 24)
+#define HOST_PKT_CONTROL_BTA_TX(x)	(((x) & 0x1) << 25)
+#define HOST_PKT_CONTROL_BTA_NO_TX(x)	(((x) & 0x1) << 26)
+
+#define HOST_SEND_PACKET		0x288
+#define HOST_PKT_STATUS			0x28c
+#define HOST_PKT_FIFO_WR_LEVEL		0x290
+#define HOST_PKT_FIFO_RD_LEVEL		0x294
+#define HOST_PKT_RX_PAYLOAD		0x298
+
+#define HOST_PKT_RX_PKT_HEADER		0x29c
+#define HOST_PKT_RX_PKT_HEADER_WC(x)	(((x) & 0xffff) << 0)
+#define HOST_PKT_RX_PKT_HEADER_DT(x)	(((x) & 0x3f) << 16)
+#define HOST_PKT_RX_PKT_HEADER_VC(x)	(((x) & 0x3) << 22)
+
+#define HOST_IRQ_STATUS			0x2a0
+#define HOST_IRQ_STATUS_SM_NOT_IDLE			(1 << 0)
+#define HOST_IRQ_STATUS_TX_PKT_DONE			(1 << 1)
+#define HOST_IRQ_STATUS_DPHY_DIRECTION			(1 << 2)
+#define HOST_IRQ_STATUS_TX_FIFO_OVFLW			(1 << 3)
+#define HOST_IRQ_STATUS_TX_FIFO_UDFLW			(1 << 4)
+#define HOST_IRQ_STATUS_RX_FIFO_OVFLW			(1 << 5)
+#define HOST_IRQ_STATUS_RX_FIFO_UDFLW			(1 << 6)
+#define HOST_IRQ_STATUS_RX_PKT_HDR_RCVD			(1 << 7)
+#define HOST_IRQ_STATUS_RX_PKT_PAYLOAD_DATA_RCVD	(1 << 8)
+#define HOST_IRQ_STATUS_HOST_BTA_TIMEOUT		(1 << 29)
+#define HOST_IRQ_STATUS_LP_RX_TIMEOUT			(1 << 30)
+#define HOST_IRQ_STATUS_HS_TX_TIMEOUT			(1 << 31)
+
+#define HOST_IRQ_STATUS2		0x2a4
+#define HOST_IRQ_STATUS2_SINGLE_BIT_ECC_ERR		(1 << 0)
+#define HOST_IRQ_STATUS2_MULTI_BIT_ECC_ERR		(1 << 1)
+#define HOST_IRQ_STATUS2_CRC_ERR			(1 << 2)
+
+#define HOST_IRQ_MASK			0x2a8
+#define HOST_IRQ_MASK_SM_NOT_IDLE_MASK			(1 << 0)
+#define HOST_IRQ_MASK_TX_PKT_DONE_MASK			(1 << 1)
+#define HOST_IRQ_MASK_DPHY_DIRECTION_MASK		(1 << 2)
+#define HOST_IRQ_MASK_TX_FIFO_OVFLW_MASK		(1 << 3)
+#define HOST_IRQ_MASK_TX_FIFO_UDFLW_MASK		(1 << 4)
+#define HOST_IRQ_MASK_RX_FIFO_OVFLW_MASK		(1 << 5)
+#define HOST_IRQ_MASK_RX_FIFO_UDFLW_MASK		(1 << 6)
+#define HOST_IRQ_MASK_RX_PKT_HDR_RCVD_MASK		(1 << 7)
+#define HOST_IRQ_MASK_RX_PKT_PAYLOAD_DATA_RCVD_MASK	(1 << 8)
+#define HOST_IRQ_MASK_HOST_BTA_TIMEOUT_MASK		(1 << 29)
+#define HOST_IRQ_MASK_LP_RX_TIMEOUT_MASK		(1 << 30)
+#define HOST_IRQ_MASK_HS_TX_TIMEOUT_MASK		(1 << 31)
+
+#define HOST_IRQ_MASK2			0x2ac
+#define HOST_IRQ_MASK2_SINGLE_BIT_ECC_ERR_MASK		(1 << 0)
+#define HOST_IRQ_MASK2_MULTI_BIT_ECC_ERR_MASK		(1 << 1)
+#define HOST_IRQ_MASK2_CRC_ERR_MASK			(1 << 2)
+
+/* ------------------------------------- end -------------------------------- */
+
+#endif
diff --git a/include/linux/mipi_dsi_samsung.h b/include/linux/mipi_dsi_samsung.h
new file mode 100644
index 000000000..e58da9541
--- /dev/null
+++ b/include/linux/mipi_dsi_samsung.h
@@ -0,0 +1,131 @@
+/*
+ * Copyright (C) 2015 Freescale Semiconductor, Inc. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+
+#ifndef __INCLUDE_MIPI_DSI_SAMSUNG_H
+#define __INCLUDE_MIPI_DSI_SAMSUNG_H
+
+#define MIPI_DSI_VERSION		(0x000)
+#define MIPI_DSI_STATUS			(0x004)
+#define MIPI_DSI_RGB_STATUS		(0x008)
+#define MIPI_DSI_SWRST			(0x00c)
+#define MIPI_DSI_CLKCTRL		(0x010)
+#define MIPI_DSI_TIMEOUT		(0x014)
+#define MIPI_DSI_CONFIG			(0x018)
+#define MIPI_DSI_ESCMODE		(0x01c)
+#define MIPI_DSI_MDRESOL		(0x020)
+#define MIPI_DSI_MVPORCH		(0x024)
+#define MIPI_DSI_MHPORCH		(0x028)
+#define MIPI_DSI_MSYNC			(0x02c)
+#define MIPI_DSI_SDRESOL		(0x030)
+#define MIPI_DSI_INTSRC			(0x034)
+#define MIPI_DSI_INTMSK			(0x038)
+#define MIPI_DSI_PKTHDR			(0x03c)
+#define MIPI_DSI_PAYLOAD		(0x040)
+#define MIPI_DSI_RXFIFO			(0x044)
+#define MIPI_DSI_FIFOTHLD		(0x048)
+#define MIPI_DSI_FIFOCTRL		(0x04c)
+#define MIPI_DSI_MEMACCHR		(0x050)
+#define MIPI_DSI_MULTI_PKT		(0x078)
+#define MIPI_DSI_PLLCTRL_1G		(0x090)
+#define MIPI_DSI_PLLCTRL		(0x094)
+#define MIPI_DSI_PLLCTRL1		(0x098)
+#define MIPI_DSI_PLLCTRL2		(0x09c)
+#define MIPI_DSI_PLLTMR			(0x0a0)
+#define MIPI_DSI_PHYCTRL_B1		(0x0a4)
+#define MIPI_DSI_PHYCTRL_B2		(0x0a8)
+#define MIPI_DSI_PHYCTRL_M1		(0x0a8)
+#define MIPI_DSI_PHYCTRL_M2		(0x0ac)
+#define MIPI_DSI_PHYTIMING		(0x0b4)
+#define MIPI_DSI_PHYTIMING1		(0x0b8)
+#define MIPI_DSI_PHYTIMING2		(0x0bc)
+
+#define MIPI_DSI_SWRST_SWRST		(0x1 << 0)
+#define MIPI_DSI_SWRST_FUNCRST		(0x1 << 16)
+#define MIPI_DSI_MAIN_HRESOL(x)		(((x) & 0x7ff) << 0)
+#define MIPI_DSI_MAIN_VRESOL(x)		(((x) & 0x7ff) << 16)
+#define MIPI_DSI_MAIN_STANDBY(x)	(((x) & 0x1) << 31)
+#define MIPI_DSI_MAIN_VBP(x)		(((x) & 0x7ff) << 0)
+#define MIPI_DSI_STABLE_VFP(x)		(((x) & 0x7ff) << 16)
+#define MIPI_DSI_CMDALLOW(x)		(((x) & 0xf) << 28)
+#define MIPI_DSI_MAIN_HBP(x)		(((x) & 0xffff) << 0)
+#define MIPI_DSI_MAIN_HFP(x)		(((x) & 0xffff) << 16)
+#define MIPI_DSI_MAIN_VSA(x)		(((x) & 0x3ff) << 22)
+#define MIPI_DSI_MAIN_HSA(x)		(((x) & 0xffff) << 0)
+
+#define MIPI_DSI_LANE_EN(x)		(((x) & 0x1f) << 0)
+#define MIPI_DSI_NUM_OF_DATALANE(x)	(((x) & 0x3) << 5)
+#define MIPI_DSI_SUB_PIX_FORMAT(x)	(((x) & 0x7) << 8)
+#define MIPI_DSI_MAIN_PIX_FORMAT(x)	(((x) & 0x7) << 12)
+#define MIPI_DSI_SUB_VC(x)		(((x) & 0x3) << 16)
+#define MIPI_DSI_MAIN_VC(x)		(((x) & 0x3) << 18)
+#define MIPI_DSI_HSA_DISABLE_MODE(x)	(((x) & 0x1) << 20)
+#define MIPI_DSI_HBP_DISABLE_MODE(x)	(((x) & 0x1) << 21)
+#define MIPI_DSI_HFP_DISABLE_MODE(x)	(((x) & 0x1) << 22)
+#define MIPI_DSI_HSE_DISABLE_MODE(x)	(((x) & 0x1) << 23)
+#define MIPI_DSI_AUTO_MODE(x)		(((x) & 0x1) << 24)
+#define MIPI_DSI_VIDEO_MODE(x)		(((x) & 0x1) << 25)
+#define MIPI_DSI_BURST_MODE(x)		(((x) & 0x1) << 26)
+#define MIPI_DSI_SYNC_IN_FORM(x)	(((x) & 0x1) << 27)
+#define MIPI_DSI_EOT_R03(x)		(((x) & 0x1) << 28)
+#define MIPI_DSI_MFLUSH_VS(x)		(((x) & 0x1) << 29)
+
+#define MIPI_DSI_DP_DN_SWAP_DATA	(0x1 << 24)
+#define MIPI_DSI_PLL_EN(x)		(((x) & 0x1) << 23)
+#define MIPI_DSI_PMS(x)			(((x) & 0x7ffff) << 1)
+
+#define MIPI_DSI_TX_REQUEST_HSCLK(x)	(((x) & 0x1) << 31)
+#define MIPI_DSI_DPHY_SEL(x)		(((x) & 0x1) << 29)
+#define MIPI_DSI_ESC_CLK_EN(x)		(((x) & 0x1) << 28)
+#define MIPI_DSI_PLL_BYPASS(x)		(((x) & 0x1) << 27)
+#define MIPI_DSI_BYTE_CLK_SRC(x)	(((x) & 0x3) << 25)
+#define MIPI_DSI_BYTE_CLK_EN(x)		(((x) & 0x1) << 24)
+#define MIPI_DSI_LANE_ESC_CLK_EN(x)	(((x) & 0x1f) << 19)
+
+#define MIPI_DSI_FORCE_STOP_STATE(x)	(((x) & 0x1) << 20)
+
+#define MIPI_DSI_M_TLPXCTL(x)		(((x) & 0xff) << 8)
+#define MIPI_DSI_M_THSEXITCTL(x)	(((x) & 0xff) << 0)
+
+#define MIPI_DSI_M_TCLKPRPRCTL(x)	(((x) & 0xff) << 24)
+#define MIPI_DSI_M_TCLKZEROCTL(x)	(((x) & 0xff) << 16)
+#define MIPI_DSI_M_TCLKPOSTCTL(x)	(((x) & 0xff) << 8)
+#define MIPI_DSI_M_TCLKTRAILCTL(x)	(((x) & 0xff) << 0)
+
+#define MIPI_DSI_M_THSPRPRCTL(x)	(((x) & 0xff) << 16)
+#define MIPI_DSI_M_THSZEROCTL(x)	(((x) & 0xff) << 8)
+#define MIPI_DSI_M_THSTRAILCTL(x)	(((x) & 0xff) << 0)
+
+#define MIPI_DSI_PLL_STABLE(x)		(((x) & 0x1) << 31)
+#define MIPI_DSI_TX_READY_HS_CLK(x)	(((x) & 0x1) << 10)
+#define MIPI_DSI_ULPS_CLK(x)		(((x) & 0x1) << 9)
+#define MIPI_DSI_STOP_STATE_CLK(x)	(((x) & 0x1) << 8)
+#define MIPI_DSI_ULPS_DAT(x)		(((x) & 0xf) << 4)
+#define MIPI_DSI_STOP_STATE_DAT(x)	(((x) & 0xf) << 0)
+
+#define INTSRC_SFR_PL_FIFO_EMPTY	(0x1 << 29)
+#define INTSRC_SFR_PH_FIFO_EMPTY	(0x1 << 28)
+#define INTSRC_RX_DATA_DONE		(0x1 << 18)
+#define INTMSK_SFR_PL_FIFO_EMPTY	(0x1 << 29)
+#define INTMSK_SFR_PH_FIFO_EMPTY	(0x1 << 28)
+#define INTMSK_RX_DATA_DONE		(0x1 << 18)
+
+#define MIPI_DSI_STOP_STATE_CNT(x)	(((x) & 0x7ff) << 21)
+#define MIPI_DSI_CMD_LPDT		(0x1 << 7)
+#define MIPI_DSI_TX_LPDT		(0x1 << 6)
+
+#endif
diff --git a/include/linux/mm_types.h b/include/linux/mm_types.h
index d86bc1d2d..78a204497 100644
--- a/include/linux/mm_types.h
+++ b/include/linux/mm_types.h
@@ -833,4 +833,52 @@ typedef struct {
 	unsigned long val;
 } swp_entry_t;
 
+#ifdef CONFIG_ANON_VMA_NAME
+/*
+ * mmap_lock should be read-locked when calling vma_anon_name() and while using
+ * the returned pointer.
+ */
+extern const char *vma_anon_name(struct vm_area_struct *vma);
+
+/*
+ * mmap_lock should be read-locked for orig_vma->vm_mm.
+ * mmap_lock should be write-locked for new_vma->vm_mm or new_vma should be
+ * isolated.
+ */
+extern void dup_vma_anon_name(struct vm_area_struct *orig_vma,
+			      struct vm_area_struct *new_vma);
+
+/*
+ * mmap_lock should be write-locked or vma should have been isolated under
+ * write-locked mmap_lock protection.
+ */
+extern void free_vma_anon_name(struct vm_area_struct *vma);
+
+/* mmap_lock should be read-locked */
+static inline bool is_same_vma_anon_name(struct vm_area_struct *vma,
+					 const char *name)
+{
+	const char *vma_name = vma_anon_name(vma);
+
+	/* either both NULL, or pointers to same string */
+	if (vma_name == name)
+		return true;
+
+	return name && vma_name && !strcmp(name, vma_name);
+}
+#else /* CONFIG_ANON_VMA_NAME */
+static inline const char *vma_anon_name(struct vm_area_struct *vma)
+{
+	return NULL;
+}
+static inline void dup_vma_anon_name(struct vm_area_struct *orig_vma,
+			      struct vm_area_struct *new_vma) {}
+static inline void free_vma_anon_name(struct vm_area_struct *vma) {}
+static inline bool is_same_vma_anon_name(struct vm_area_struct *vma,
+					 const char *name)
+{
+	return true;
+}
+#endif  /* CONFIG_ANON_VMA_NAME */
+
 #endif /* _LINUX_MM_TYPES_H */
diff --git a/include/linux/mmc/core.h b/include/linux/mmc/core.h
index 29aa50711..b7ba8810a 100644
--- a/include/linux/mmc/core.h
+++ b/include/linux/mmc/core.h
@@ -107,6 +107,9 @@ struct mmc_command {
  */
 
 	unsigned int		busy_timeout;	/* busy detect timeout in ms */
+	/* Set this flag only for blocking sanitize request */
+	bool			sanitize_busy;
+
 	struct mmc_data		*data;		/* data segment associated with cmd */
 	struct mmc_request	*mrq;		/* associated request */
 };
diff --git a/include/linux/mmc/host.h b/include/linux/mmc/host.h
index 40d7e98fc..9b1fed7b8 100644
--- a/include/linux/mmc/host.h
+++ b/include/linux/mmc/host.h
@@ -286,6 +286,9 @@ struct mmc_host {
 	u32			ocr_avail_sd;	/* SD-specific OCR */
 	u32			ocr_avail_mmc;	/* MMC-specific OCR */
 	struct wakeup_source	*ws;		/* Enable consume of uevents */
+#ifdef CONFIG_PM_SLEEP
+	struct notifier_block	pm_notify;
+#endif
 	u32			max_current_330;
 	u32			max_current_300;
 	u32			max_current_180;
@@ -320,6 +323,7 @@ struct mmc_host {
 #define MMC_CAP_AGGRESSIVE_PM	(1 << 7)	/* Suspend (e)MMC/SD at idle  */
 #define MMC_CAP_NONREMOVABLE	(1 << 8)	/* Nonremovable e.g. eMMC */
 #define MMC_CAP_WAIT_WHILE_BUSY	(1 << 9)	/* Waits while card is busy */
+#define MMC_CAP_ERASE		(1 << 10)	/* Allow erase/trim commands */
 #define MMC_CAP_3_3V_DDR	(1 << 11)	/* Host supports eMMC DDR 3.3V */
 #define MMC_CAP_1_8V_DDR	(1 << 12)	/* Host supports eMMC DDR 1.8V */
 #define MMC_CAP_1_2V_DDR	(1 << 13)	/* Host supports eMMC DDR 1.2V */
diff --git a/include/linux/mmc/pm.h b/include/linux/mmc/pm.h
index 3549f8045..1d554b858 100644
--- a/include/linux/mmc/pm.h
+++ b/include/linux/mmc/pm.h
@@ -23,5 +23,6 @@ typedef unsigned int mmc_pm_flag_t;
 
 #define MMC_PM_KEEP_POWER	(1 << 0)	/* preserve card power during suspend */
 #define MMC_PM_WAKE_SDIO_IRQ	(1 << 1)	/* wake up host system on SDIO IRQ assertion */
+#define MMC_PM_IGNORE_PM_NOTIFY	(1 << 2)	/* ignore mmc pm notify */
 
 #endif /* LINUX_MMC_PM_H */
diff --git a/include/linux/mmc/sdio.h b/include/linux/mmc/sdio.h
index e28769991..0e4e6cd2e 100644
--- a/include/linux/mmc/sdio.h
+++ b/include/linux/mmc/sdio.h
@@ -186,4 +186,7 @@
 
 #define SDIO_FBR_BLKSIZE	0x10	/* block size (2 bytes) */
 
+void mmc_sdio_force_remove(struct mmc_host *host);
+
+
 #endif /* LINUX_MMC_SDIO_H */
diff --git a/include/linux/mmc/sdio_ids.h b/include/linux/mmc/sdio_ids.h
index 120366193..171e7ca05 100644
--- a/include/linux/mmc/sdio_ids.h
+++ b/include/linux/mmc/sdio_ids.h
@@ -24,108 +24,56 @@
 /*
  * Vendors and devices.  Sort key: vendor first, device next.
  */
-
-#define SDIO_VENDOR_ID_STE			0x0020
-#define SDIO_DEVICE_ID_STE_CW1200		0x2280
-
-#define SDIO_VENDOR_ID_INTEL			0x0089
-#define SDIO_DEVICE_ID_INTEL_IWMC3200WIMAX	0x1402
-#define SDIO_DEVICE_ID_INTEL_IWMC3200WIFI	0x1403
-#define SDIO_DEVICE_ID_INTEL_IWMC3200TOP	0x1404
-#define SDIO_DEVICE_ID_INTEL_IWMC3200GPS	0x1405
-#define SDIO_DEVICE_ID_INTEL_IWMC3200BT		0x1406
-#define SDIO_DEVICE_ID_INTEL_IWMC3200WIMAX_2G5	0x1407
-
-#define SDIO_VENDOR_ID_CGUYS			0x0092
-#define SDIO_DEVICE_ID_CGUYS_EW_CG1102GC	0x0004
-
-#define SDIO_VENDOR_ID_TI			0x0097
-#define SDIO_DEVICE_ID_TI_WL1271		0x4076
-
-#define SDIO_VENDOR_ID_ATHEROS			0x0271
-#define SDIO_DEVICE_ID_ATHEROS_AR6003_00	0x0300
-#define SDIO_DEVICE_ID_ATHEROS_AR6003_01	0x0301
-#define SDIO_DEVICE_ID_ATHEROS_AR6004_00	0x0400
-#define SDIO_DEVICE_ID_ATHEROS_AR6004_01	0x0401
-#define SDIO_DEVICE_ID_ATHEROS_AR6004_02	0x0402
-#define SDIO_DEVICE_ID_ATHEROS_AR6004_18	0x0418
-#define SDIO_DEVICE_ID_ATHEROS_AR6004_19	0x0419
-#define SDIO_DEVICE_ID_ATHEROS_AR6005		0x050A
-#define SDIO_DEVICE_ID_ATHEROS_QCA9377		0x0701
-
 #define SDIO_VENDOR_ID_BROADCOM			0x02d0
-#define SDIO_DEVICE_ID_BROADCOM_NINTENDO_WII	0x044b
+#define SDIO_DEVICE_ID_BROADCOM_43143		0xa887
 #define SDIO_DEVICE_ID_BROADCOM_43241		0x4324
 #define SDIO_DEVICE_ID_BROADCOM_4329		0x4329
 #define SDIO_DEVICE_ID_BROADCOM_4330		0x4330
 #define SDIO_DEVICE_ID_BROADCOM_4334		0x4334
-#define SDIO_DEVICE_ID_BROADCOM_4335_4339	0x4335
-#define SDIO_DEVICE_ID_BROADCOM_4339		0x4339
-#define SDIO_DEVICE_ID_BROADCOM_4345		0x4345
-#define SDIO_DEVICE_ID_BROADCOM_4354		0x4354
-#define SDIO_DEVICE_ID_BROADCOM_CYPRESS_89359	0x4355
-#define SDIO_DEVICE_ID_BROADCOM_4356		0x4356
-#define SDIO_DEVICE_ID_BROADCOM_4359		0x4359
-#define SDIO_DEVICE_ID_BROADCOM_CYPRESS_4373	0x4373
-#define SDIO_DEVICE_ID_BROADCOM_CYPRESS_43012	0xa804
-#define SDIO_DEVICE_ID_BROADCOM_43143		0xa887
 #define SDIO_DEVICE_ID_BROADCOM_43340		0xa94c
 #define SDIO_DEVICE_ID_BROADCOM_43341		0xa94d
+#define SDIO_DEVICE_ID_BROADCOM_4335_4339	0x4335
+#define SDIO_DEVICE_ID_BROADCOM_4339		0x4339
 #define SDIO_DEVICE_ID_BROADCOM_43362		0xa962
 #define SDIO_DEVICE_ID_BROADCOM_43364		0xa9a4
+#define SDIO_DEVICE_ID_BROADCOM_43428		0xa9a4
 #define SDIO_DEVICE_ID_BROADCOM_43430		0xa9a6
+#define SDIO_DEVICE_ID_BROADCOM_4345		0x4345
 #define SDIO_DEVICE_ID_BROADCOM_43455		0xa9bf
+#define SDIO_DEVICE_ID_BROADCOM_4354		0x4354
+#define SDIO_DEVICE_ID_BROADCOM_4356		0x4356
+#define SDIO_DEVICE_ID_CYPRESS_4373		0x4373
+#define SDIO_DEVICE_ID_CYPRESS_43012		43012
+
+#define SDIO_VENDOR_ID_INTEL			0x0089
+#define SDIO_DEVICE_ID_INTEL_IWMC3200WIMAX	0x1402
+#define SDIO_DEVICE_ID_INTEL_IWMC3200WIFI	0x1403
+#define SDIO_DEVICE_ID_INTEL_IWMC3200TOP	0x1404
+#define SDIO_DEVICE_ID_INTEL_IWMC3200GPS	0x1405
+#define SDIO_DEVICE_ID_INTEL_IWMC3200BT		0x1406
+#define SDIO_DEVICE_ID_INTEL_IWMC3200WIMAX_2G5	0x1407
 
 #define SDIO_VENDOR_ID_MARVELL			0x02df
 #define SDIO_DEVICE_ID_MARVELL_LIBERTAS		0x9103
-#define SDIO_DEVICE_ID_MARVELL_8688_WLAN	0x9104
-#define SDIO_DEVICE_ID_MARVELL_8688_BT		0x9105
-#define SDIO_DEVICE_ID_MARVELL_8786_WLAN	0x9116
-#define SDIO_DEVICE_ID_MARVELL_8787_WLAN	0x9119
-#define SDIO_DEVICE_ID_MARVELL_8787_BT		0x911a
-#define SDIO_DEVICE_ID_MARVELL_8787_BT_AMP	0x911b
+#define SDIO_DEVICE_ID_MARVELL_8688WLAN		0x9104
+#define SDIO_DEVICE_ID_MARVELL_8688BT		0x9105
 #define SDIO_DEVICE_ID_MARVELL_8797_F0		0x9128
-#define SDIO_DEVICE_ID_MARVELL_8797_WLAN	0x9129
-#define SDIO_DEVICE_ID_MARVELL_8797_BT		0x912a
-#define SDIO_DEVICE_ID_MARVELL_8897_WLAN	0x912d
-#define SDIO_DEVICE_ID_MARVELL_8897_BT		0x912e
-#define SDIO_DEVICE_ID_MARVELL_8887_F0		0x9134
-#define SDIO_DEVICE_ID_MARVELL_8887_WLAN	0x9135
-#define SDIO_DEVICE_ID_MARVELL_8887_BT		0x9136
-#define SDIO_DEVICE_ID_MARVELL_8801_WLAN	0x9139
-#define SDIO_DEVICE_ID_MARVELL_8997_F0		0x9140
-#define SDIO_DEVICE_ID_MARVELL_8997_WLAN	0x9141
-#define SDIO_DEVICE_ID_MARVELL_8997_BT		0x9142
-#define SDIO_DEVICE_ID_MARVELL_8977_WLAN	0x9145
-#define SDIO_DEVICE_ID_MARVELL_8977_BT		0x9146
-#define SDIO_DEVICE_ID_MARVELL_8987_WLAN	0x9149
-#define SDIO_DEVICE_ID_MARVELL_8987_BT		0x914a
+#define SDIO_DEVICE_ID_MARVELL_8887WLAN	0x9134
 
 #define SDIO_VENDOR_ID_MEDIATEK			0x037a
-#define SDIO_DEVICE_ID_MEDIATEK_MT7663		0x7663
-#define SDIO_DEVICE_ID_MEDIATEK_MT7668		0x7668
-
-#define SDIO_VENDOR_ID_MICROCHIP_WILC		0x0296
-#define SDIO_DEVICE_ID_MICROCHIP_WILC1000	0x5347
 
 #define SDIO_VENDOR_ID_SIANO			0x039a
 #define SDIO_DEVICE_ID_SIANO_NOVA_B0		0x0201
 #define SDIO_DEVICE_ID_SIANO_NICE		0x0202
 #define SDIO_DEVICE_ID_SIANO_VEGA_A0		0x0300
 #define SDIO_DEVICE_ID_SIANO_VENICE		0x0301
-#define SDIO_DEVICE_ID_SIANO_MING		0x0302
-#define SDIO_DEVICE_ID_SIANO_PELE		0x0500
-#define SDIO_DEVICE_ID_SIANO_RIO		0x0600
-#define SDIO_DEVICE_ID_SIANO_DENVER_2160	0x0700
-#define SDIO_DEVICE_ID_SIANO_DENVER_1530	0x0800
 #define SDIO_DEVICE_ID_SIANO_NOVA_A0		0x1100
 #define SDIO_DEVICE_ID_SIANO_STELLAR 		0x5347
 
-#define SDIO_VENDOR_ID_RSI			0x041b
-#define SDIO_DEVICE_ID_RSI_9113			0x9330
-#define SDIO_DEVICE_ID_RSI_9116			0x9116
+#define SDIO_VENDOR_ID_TI			0x0097
+#define SDIO_DEVICE_ID_TI_WL1271		0x4076
 
-#define SDIO_VENDOR_ID_TI_WL1251		0x104c
-#define SDIO_DEVICE_ID_TI_WL1251		0x9066
+#define SDIO_VENDOR_ID_STE			0x0020
+#define SDIO_DEVICE_ID_STE_CW1200		0x2280
 
 #endif /* LINUX_MMC_SDIO_IDS_H */
diff --git a/include/linux/mmc/slot-gpio.h b/include/linux/mmc/slot-gpio.h
index 4ae2f2908..0de3d7c01 100644
--- a/include/linux/mmc/slot-gpio.h
+++ b/include/linux/mmc/slot-gpio.h
@@ -17,9 +17,10 @@ int mmc_gpio_get_ro(struct mmc_host *host);
 int mmc_gpio_get_cd(struct mmc_host *host);
 int mmc_gpiod_request_cd(struct mmc_host *host, const char *con_id,
 			 unsigned int idx, bool override_active_level,
-			 unsigned int debounce);
+			 unsigned int debounce, bool *gpio_invert);
 int mmc_gpiod_request_ro(struct mmc_host *host, const char *con_id,
-			 unsigned int idx, unsigned int debounce);
+			 unsigned int idx,
+			 unsigned int debounce, bool *gpio_invert);
 void mmc_gpio_set_cd_isr(struct mmc_host *host,
 			 irqreturn_t (*isr)(int irq, void *dev_id));
 int mmc_gpio_set_cd_wake(struct mmc_host *host, bool on);
diff --git a/include/linux/motorcomm_phy.h b/include/linux/motorcomm_phy.h
new file mode 100755
index 000000000..039c69520
--- /dev/null
+++ b/include/linux/motorcomm_phy.h
@@ -0,0 +1,125 @@
+/*
+ * include/linux/motorcomm_phy.h
+ *
+ * Motorcomm PHY IDs
+ *
+ * This program is free software; you can redistribute  it and/or modify it
+ * under  the terms of  the GNU General  Public License as published by the
+ * Free Software Foundation;  either version 2 of the  License, or (at your
+ * option) any later version.
+ *
+ */
+
+#ifndef _MOTORCOMM_PHY_H
+#define _MOTORCOMM_PHY_H
+
+#define MOTORCOMM_PHY_ID_MASK	0x00000fff
+#define MOTORCOMM_MPHY_ID_MASK	0x0000ffff
+
+#define PHY_ID_YT8010		0x00000309
+#define PHY_ID_YT8510		0x00000109
+#define PHY_ID_YT8511		0x0000010a
+#define PHY_ID_YT8512		0x00000118
+#define PHY_ID_YT8512B		0x00000128
+#define PHY_ID_YT8521		0x0000011a
+#define PHY_ID_YT8531S		0x0000091a
+#define PHY_ID_YT8531		0x0000091b
+//#define PHY_ID_YT8614		0x0000e899
+#define PHY_ID_YT8618		0x0000e889
+
+#define REG_PHY_SPEC_STATUS		0x11
+#define REG_DEBUG_ADDR_OFFSET		0x1e
+#define REG_DEBUG_DATA			0x1f
+
+#define YT8512_EXTREG_AFE_PLL		0x50
+#define YT8512_EXTREG_EXTEND_COMBO	0x4000
+#define YT8512_EXTREG_LED0		0x40c0
+#define YT8512_EXTREG_LED1		0x40c3
+
+#define YT8512_EXTREG_SLEEP_CONTROL1	0x2027
+
+#define YT_SOFTWARE_RESET		0x8000
+
+#define YT8512_CONFIG_PLL_REFCLK_SEL_EN	0x0040
+#define YT8512_CONTROL1_RMII_EN		0x0001
+#define YT8512_LED0_ACT_BLK_IND		0x1000
+#define YT8512_LED0_DIS_LED_AN_TRY	0x0001
+#define YT8512_LED0_BT_BLK_EN		0x0002
+#define YT8512_LED0_HT_BLK_EN		0x0004
+#define YT8512_LED0_COL_BLK_EN		0x0008
+#define YT8512_LED0_BT_ON_EN		0x0010
+#define YT8512_LED1_BT_ON_EN		0x0010
+#define YT8512_LED1_TXACT_BLK_EN	0x0100
+#define YT8512_LED1_RXACT_BLK_EN	0x0200
+#define YT8512_SPEED_MODE		0xc000
+#define YT8512_DUPLEX			0x2000
+
+#define YT8512_SPEED_MODE_BIT		14
+#define YT8512_DUPLEX_BIT		13
+#define YT8512_EN_SLEEP_SW_BIT		15
+
+#define YT8521_EXTREG_SLEEP_CONTROL1 0x27
+#define YT8521_EN_SLEEP_SW_BIT 15
+#define YT8521_EXTREG_LED1 0xA00D
+#define YT8521_EXTREG_LED2 0xA00E
+
+#define YT8521_SPEED_MODE 0xc000
+#define YT8521_DUPLEX 0x2000
+#define YT8521_SPEED_MODE_BIT 14
+#define YT8521_DUPLEX_BIT 13
+#define YT8521_LINK_STATUS_BIT 10
+#define YT8521_LED1_ACT_BLK_IND 0x1000
+#define YT8521_LED2_GT_ON_EN 0x0020
+#define YT8521_LED2_HT_ON_EN 0x0010
+#define YT8521_LED2_TXACT_BLK_EN 0x0100
+#define YT8521_LED2_RXACT_BLK_EN 0x0200
+
+
+/* based on yt8521 wol config register */
+#define YTPHY_UTP_INTR_REG             0x12
+/* WOL Event Interrupt Enable */
+#define YTPHY_WOL_INTR            BIT(6)
+
+/* Magic Packet MAC address registers */
+#define YTPHY_MAGIC_PACKET_MAC_ADDR2                 0xa007
+#define YTPHY_MAGIC_PACKET_MAC_ADDR1                 0xa008
+#define YTPHY_MAGIC_PACKET_MAC_ADDR0                 0xa009
+
+#define YTPHY_WOL_CFG_REG		0xa00a
+#define YTPHY_WOL_CFG_TYPE		BIT(0)	/* WOL TYPE */
+#define YTPHY_WOL_CFG_EN		BIT(3)	/* WOL Enable */
+#define YTPHY_WOL_CFG_INTR_SEL	BIT(6)	/* WOL Event Interrupt Enable */
+#define YTPHY_WOL_CFG_WIDTH1	BIT(1)	/* WOL Pulse Width */
+#define YTPHY_WOL_CFG_WIDTH2	BIT(2)
+
+#define YTPHY_REG_SPACE_UTP             0
+#define YTPHY_REG_SPACE_FIBER           2
+
+enum ytphy_wol_type_e
+{
+    YTPHY_WOL_TYPE_LEVEL,
+    YTPHY_WOL_TYPE_PULSE,
+    YTPHY_WOL_TYPE_MAX
+};
+typedef enum ytphy_wol_type_e ytphy_wol_type_t;
+
+enum ytphy_wol_width_e
+{
+    YTPHY_WOL_WIDTH_84MS,
+    YTPHY_WOL_WIDTH_168MS,
+    YTPHY_WOL_WIDTH_336MS,
+    YTPHY_WOL_WIDTH_672MS,
+    YTPHY_WOL_WIDTH_MAX
+};
+typedef enum ytphy_wol_width_e ytphy_wol_width_t;
+
+struct ytphy_wol_cfg_s
+{
+    int enable;
+    int type;
+    int width;
+};
+typedef struct ytphy_wol_cfg_s ytphy_wol_cfg_t;
+
+#endif /* _MOTORCOMM_PHY_H */
+
diff --git a/include/linux/mtd/spi-nor.h b/include/linux/mtd/spi-nor.h
index 60bac2c0e..36aa72a62 100644
--- a/include/linux/mtd/spi-nor.h
+++ b/include/linux/mtd/spi-nor.h
@@ -51,6 +51,8 @@
 #define SPINOR_OP_CLFSR		0x50	/* Clear flag status register */
 #define SPINOR_OP_RDEAR		0xc8	/* Read Extended Address Register */
 #define SPINOR_OP_WREAR		0xc5	/* Write Extended Address Register */
+#define SPINOR_OP_SRSTEN	0x66	/* Software Reset Enable */
+#define SPINOR_OP_SRST		0x99	/* Software Reset */
 
 /* 4-byte address opcodes - used on Spansion and some Macronix flashes. */
 #define SPINOR_OP_READ_4B	0x13	/* Read data bytes (low frequency) */
@@ -182,6 +184,7 @@ enum spi_nor_protocol {
 	SNOR_PROTO_1_2_2_DTR = SNOR_PROTO_DTR(1, 2, 2),
 	SNOR_PROTO_1_4_4_DTR = SNOR_PROTO_DTR(1, 4, 4),
 	SNOR_PROTO_1_8_8_DTR = SNOR_PROTO_DTR(1, 8, 8),
+	SNOR_PROTO_8_8_8_DTR = SNOR_PROTO_DTR(8, 8, 8),
 };
 
 static inline bool spi_nor_protocol_is_dtr(enum spi_nor_protocol proto)
@@ -228,7 +231,7 @@ struct spi_nor_hwcaps {
  * then Quad SPI protocols before Dual SPI protocols, Fast Read and lastly
  * (Slow) Read.
  */
-#define SNOR_HWCAPS_READ_MASK		GENMASK(14, 0)
+#define SNOR_HWCAPS_READ_MASK		GENMASK(15, 0)
 #define SNOR_HWCAPS_READ		BIT(0)
 #define SNOR_HWCAPS_READ_FAST		BIT(1)
 #define SNOR_HWCAPS_READ_1_1_1_DTR	BIT(2)
@@ -245,11 +248,12 @@ struct spi_nor_hwcaps {
 #define SNOR_HWCAPS_READ_4_4_4		BIT(9)
 #define SNOR_HWCAPS_READ_1_4_4_DTR	BIT(10)
 
-#define SNOR_HWCAPS_READ_OCTAL		GENMASK(14, 11)
+#define SNOR_HWCAPS_READ_OCTAL		GENMASK(15, 11)
 #define SNOR_HWCAPS_READ_1_1_8		BIT(11)
 #define SNOR_HWCAPS_READ_1_8_8		BIT(12)
 #define SNOR_HWCAPS_READ_8_8_8		BIT(13)
 #define SNOR_HWCAPS_READ_1_8_8_DTR	BIT(14)
+#define SNOR_HWCAPS_READ_8_8_8_DTR	BIT(15)
 
 /*
  * Page Program capabilities.
@@ -260,18 +264,19 @@ struct spi_nor_hwcaps {
  * JEDEC/SFDP standard to define them. Also at this moment no SPI flash memory
  * implements such commands.
  */
-#define SNOR_HWCAPS_PP_MASK	GENMASK(22, 16)
-#define SNOR_HWCAPS_PP		BIT(16)
+#define SNOR_HWCAPS_PP_MASK		GENMASK(23, 16)
+#define SNOR_HWCAPS_PP			BIT(16)
 
 #define SNOR_HWCAPS_PP_QUAD	GENMASK(19, 17)
 #define SNOR_HWCAPS_PP_1_1_4	BIT(17)
 #define SNOR_HWCAPS_PP_1_4_4	BIT(18)
 #define SNOR_HWCAPS_PP_4_4_4	BIT(19)
 
-#define SNOR_HWCAPS_PP_OCTAL	GENMASK(22, 20)
-#define SNOR_HWCAPS_PP_1_1_8	BIT(20)
-#define SNOR_HWCAPS_PP_1_8_8	BIT(21)
-#define SNOR_HWCAPS_PP_8_8_8	BIT(22)
+#define SNOR_HWCAPS_PP_OCTAL		GENMASK(23, 20)
+#define SNOR_HWCAPS_PP_1_1_8		BIT(20)
+#define SNOR_HWCAPS_PP_1_8_8		BIT(21)
+#define SNOR_HWCAPS_PP_8_8_8		BIT(22)
+#define SNOR_HWCAPS_PP_8_8_8_DTR	BIT(23)
 
 #define SNOR_HWCAPS_X_X_X	(SNOR_HWCAPS_READ_2_2_2 |	\
 				 SNOR_HWCAPS_READ_4_4_4 |	\
@@ -279,10 +284,14 @@ struct spi_nor_hwcaps {
 				 SNOR_HWCAPS_PP_4_4_4 |		\
 				 SNOR_HWCAPS_PP_8_8_8)
 
+#define SNOR_HWCAPS_X_X_X_DTR	(SNOR_HWCAPS_READ_8_8_8_DTR |	\
+				 SNOR_HWCAPS_PP_8_8_8_DTR)
+
 #define SNOR_HWCAPS_DTR		(SNOR_HWCAPS_READ_1_1_1_DTR |	\
 				 SNOR_HWCAPS_READ_1_2_2_DTR |	\
 				 SNOR_HWCAPS_READ_1_4_4_DTR |	\
-				 SNOR_HWCAPS_READ_1_8_8_DTR)
+				 SNOR_HWCAPS_READ_1_8_8_DTR |	\
+				 SNOR_HWCAPS_READ_8_8_8_DTR)
 
 #define SNOR_HWCAPS_ALL		(SNOR_HWCAPS_READ_MASK |	\
 				 SNOR_HWCAPS_PP_MASK)
@@ -318,6 +327,22 @@ struct spi_nor_controller_ops {
 	int (*erase)(struct spi_nor *nor, loff_t offs);
 };
 
+/**
+ * enum spi_nor_cmd_ext - describes the command opcode extension in DTR mode
+ * @SPI_NOR_EXT_NONE: no extension. This is the default, and is used in Legacy
+ *		      SPI mode
+ * @SPI_NOR_EXT_REPEAT: the extension is same as the opcode
+ * @SPI_NOR_EXT_INVERT: the extension is the bitwise inverse of the opcode
+ * @SPI_NOR_EXT_HEX: the extension is any hex value. The command and opcode
+ *		     combine to form a 16-bit opcode.
+ */
+enum spi_nor_cmd_ext {
+	SPI_NOR_EXT_NONE = 0,
+	SPI_NOR_EXT_REPEAT,
+	SPI_NOR_EXT_INVERT,
+	SPI_NOR_EXT_HEX,
+};
+
 /*
  * Forward declarations that are used internally by the core and manufacturer
  * drivers.
@@ -345,6 +370,7 @@ struct spi_nor_flash_parameter;
  * @program_opcode:	the program opcode
  * @sst_write_second:	used by the SST write operation
  * @flags:		flag options for the current SPI NOR (SNOR_F_*)
+ * @cmd_ext_type:	the command opcode extension type for DTR mode.
  * @read_proto:		the SPI protocol for read operations
  * @write_proto:	the SPI protocol for write operations
  * @reg_proto:		the SPI protocol for read_reg/write_reg/erase operations
@@ -376,6 +402,7 @@ struct spi_nor {
 	enum spi_nor_protocol	reg_proto;
 	bool			sst_write_second;
 	u32			flags;
+	enum spi_nor_cmd_ext	cmd_ext_type;
 
 	const struct spi_nor_controller_ops *controller_ops;
 
diff --git a/include/linux/mx8_mu.h b/include/linux/mx8_mu.h
new file mode 100644
index 000000000..b31e52693
--- /dev/null
+++ b/include/linux/mx8_mu.h
@@ -0,0 +1,48 @@
+/*
+ * Copyright (C) 2016 Freescale Semiconductor, Inc.
+ * Copyright 2017 NXP
+ *
+ * SPDX-License-Identifier:     GPL-2.0+
+ */
+
+#define MU_ATR0_OFFSET1		0x0
+#define MU_ARR0_OFFSET1		0x10
+#define MU_ASR_OFFSET1		0x20
+#define MU_ACR_OFFSET1		0x24
+
+/* Registers offsets of the MU Version 1.0 */
+#define MU_V10_VER_OFFSET1	0x0
+#define MU_V10_ATR0_OFFSET1	0x20
+#define MU_V10_ARR0_OFFSET1	0x40
+#define MU_V10_ASR_OFFSET1	0x60
+#define MU_V10_ACR_OFFSET1	0x64
+#define MU_VER_ID_V10		0x0100 /* Version 1.0 */
+
+#define MU_TR_COUNT1		4
+#define MU_RR_COUNT1		4
+
+#define MU_CR_GIEn_MASK1	(0xF << 28)
+#define MU_CR_RIEn_MASK1	(0xF << 24)
+#define MU_CR_TIEn_MASK1	(0xF << 20)
+#define MU_CR_GIRn_MASK1	(0xF << 16)
+#define MU_CR_NMI_MASK1		(1 << 3)
+#define MU_CR_Fn_MASK1		0x7
+
+#define MU_SR_TE0_MASK1		(1 << 23)
+#define MU_SR_RF0_MASK1		(1 << 27)
+#define MU_CR_RIE0_MASK1	(1 << 27)
+#define MU_CR_GIE0_MASK1	(1 << 31)
+
+#define MU_TR_COUNT			4
+#define MU_RR_COUNT			4
+
+
+void MU_Init(void __iomem *base);
+void MU_SendMessage(void __iomem *base, uint32_t regIndex, uint32_t msg);
+void MU_SendMessageTimeout(void __iomem *base, uint32_t regIndex, uint32_t msg, uint32_t t);
+void MU_ReceiveMsg(void __iomem *base, uint32_t regIndex, uint32_t *msg);
+void MU_EnableGeneralInt(void __iomem *base, uint32_t index);
+void MU_EnableRxFullInt(void __iomem *base, uint32_t index);
+uint32_t MU_ReadStatus(void __iomem *base);
+int32_t MU_SetFn(void __iomem *base, uint32_t Fn);
+
diff --git a/include/linux/mxc_dcic.h b/include/linux/mxc_dcic.h
new file mode 100644
index 000000000..8e330bd46
--- /dev/null
+++ b/include/linux/mxc_dcic.h
@@ -0,0 +1,126 @@
+/*
+ * Copyright (C) 2014-2015 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+/*!
+ * @file linux/mxc_dcic.h
+ *
+ * @brief Global header file for the MXC DCIC driver
+ *
+ * @ingroup MXC DCIC
+ */
+
+#ifndef __LINUX_DCIC_H__
+#define __LINUX_DCIC_H__
+
+#include <uapi/linux/mxc_dcic.h>
+
+#define DCICC_IC_ENABLE					0x1
+#define DCICC_IC_DISABLE				0x0
+#define DCICC_IC_MASK					0x1
+#define DCICC_DE_ACTIVE_HIGH			0
+#define DCICC_DE_ACTIVE_LOW				(0x1 << 4)
+#define DCICC_DE_ACTIVE_MASK			(0x1 << 4)
+#define DCICC_HSYNC_POL_ACTIVE_HIGH		0
+#define DCICC_HSYNC_POL_ACTIVE_LOW		(0x1 << 5)
+#define DCICC_HSYNC_POL_ACTIVE_MASK		(0x1 << 5)
+#define DCICC_VSYNC_POL_ACTIVE_HIGH		0
+#define DCICC_VSYNC_POL_ACTIVE_LOW		(0x1 << 6)
+#define DCICC_VSYNC_POL_ACTIVE_MASK		(0x1 << 6)
+#define DCICC_CLK_POL_NO_INVERTED		0
+#define DCICC_CLK_POL_INVERTED			(0x1 << 7)
+#define DCICC_CLK_POL_INVERTED_MASK		(0x1 << 7)
+
+#define DCICIC_ERROR_INT_DISABLE		1
+#define DCICIC_ERROR_INT_ENABLE			0
+#define DCICIC_ERROR_INT_MASK_MASK		1
+#define DCICIC_FUN_INT_DISABLE			(0x1 << 1)
+#define DCICIC_FUN_INT_ENABLE			0
+#define DCICIC_FUN_INT_MASK				(0x1 << 1)
+#define DCICIC_FREEZE_MASK_CHANGED		0
+#define DCICIC_FREEZE_MASK_FORZEN		(0x1 << 3)
+#define DCICIC_FREEZE_MASK_MASK			(0x1 << 3)
+#define DCICIC_EXT_SIG_EX_DISABLE		0
+#define DCICIC_EXT_SIG_EN_ENABLE		(0x1 << 16)
+#define DCICIC_EXT_SIG_EN_MASK			(0x1 << 16)
+
+#define DCICS_ROI_MATCH_STAT_MASK		0xFFFF
+#define DCICS_EI_STAT_PENDING			(0x1 << 16)
+#define DCICS_EI_STAT_NO_PENDING		0
+#define DCICS_FI_STAT_PENDING			(0x1 << 17)
+#define DCICS_FI_STAT_NO_PENDING		0
+
+#define DCICRC_ROI_START_OFFSET_X_MASK	0x1FFF
+#define DCICRC_ROI_START_OFFSET_X_SHIFT	0
+#define DCICRC_ROI_START_OFFSET_Y_MASK	(0xFFF << 16)
+#define DCICRC_ROI_START_OFFSET_Y_SHIFT	16
+#define DCICRC_ROI_CHANGED				0
+#define DCICRC_ROI_FROZEN				(0x1 << 30)
+#define DCICRC_ROI_ENABLE				(0x1 << 31)
+#define DCICRC_ROI_DISABLE				0
+
+#define DCICRS_ROI_END_OFFSET_X_MASK	0x1FFF
+#define DCICRS_ROI_END_OFFSET_X_SHIFT	0
+#define DCICRS_ROI_END_OFFSET_Y_MASK	(0xFFF << 16)
+#define DCICRS_ROI_END_OFFSET_Y_SHIFT	16
+
+struct roi_regs {
+	u32 dcicrc;
+	u32 dcicrs;
+	u32 dcicrrs;
+	u32 dcicrcs;
+};
+
+struct dcic_regs {
+	u32 dcicc;
+	u32 dcicic;
+	u32 dcics;
+	u32 dcic_reserved;
+	struct roi_regs ROI[16];
+};
+
+struct dcic_mux {
+	char dcic[16];
+	u32 val;
+};
+
+struct bus_mux {
+	char name[16];
+	int reg;
+	int shift;
+	int mask;
+	int dcic_mux_num;
+	const struct dcic_mux *dcics;
+};
+
+struct dcic_info {
+	int bus_mux_num;
+	const struct bus_mux *buses;
+};
+
+struct dcic_data {
+	struct regmap *regmap;
+	struct device *dev;
+	struct dcic_regs *regs;
+	const struct bus_mux *buses;
+	u32 bus_n;
+	u32 mux_n;
+	struct clk *disp_axi_clk;
+	struct clk *dcic_clk;
+	struct mutex lock;
+	struct completion roi_crc_comp;
+	struct class *class;
+	int major;
+	struct cdev cdev;	/* Char device structure */
+	dev_t devt;
+	unsigned int result;
+};
+#endif
diff --git a/include/linux/mxc_mlb.h b/include/linux/mxc_mlb.h
new file mode 100644
index 000000000..d7c792a2b
--- /dev/null
+++ b/include/linux/mxc_mlb.h
@@ -0,0 +1,55 @@
+/*
+ * mxc_mlb.h
+ *
+ * Copyright 2008-2013 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+#ifndef _MXC_MLB_H
+#define _MXC_MLB_H
+
+/* define IOCTL command */
+#define MLB_DBG_RUNTIME		_IO('S', 0x09)
+#define MLB_SET_FPS		_IOW('S', 0x10, unsigned int)
+#define MLB_GET_VER		_IOR('S', 0x11, unsigned long)
+#define MLB_SET_DEVADDR		_IOR('S', 0x12, unsigned char)
+
+/*!
+ * set channel address for each logical channel
+ * the MSB 16bits is for tx channel, the left LSB is for rx channel
+ */
+#define MLB_CHAN_SETADDR	_IOW('S', 0x13, unsigned int)
+#define MLB_CHAN_STARTUP	_IO('S', 0x14)
+#define MLB_CHAN_SHUTDOWN	_IO('S', 0x15)
+#define MLB_CHAN_GETEVENT	_IOR('S', 0x16, unsigned long)
+
+#define MLB_SET_ISOC_BLKSIZE_188 _IO('S', 0x17)
+#define MLB_SET_ISOC_BLKSIZE_196 _IO('S', 0x18)
+#define MLB_SET_SYNC_QUAD	_IOW('S', 0x19, unsigned int)
+#define MLB_IRQ_ENABLE		_IO('S', 0x20)
+#define MLB_IRQ_DISABLE		_IO('S', 0x21)
+
+/*!
+ * MLB event define
+ */
+enum {
+	MLB_EVT_TX_PROTO_ERR_CUR = 1 << 0,
+	MLB_EVT_TX_BRK_DETECT_CUR = 1 << 1,
+	MLB_EVT_TX_PROTO_ERR_PREV = 1 << 8,
+	MLB_EVT_TX_BRK_DETECT_PREV = 1 << 9,
+	MLB_EVT_RX_PROTO_ERR_CUR = 1 << 16,
+	MLB_EVT_RX_BRK_DETECT_CUR = 1 << 17,
+	MLB_EVT_RX_PROTO_ERR_PREV = 1 << 24,
+	MLB_EVT_RX_BRK_DETECT_PREV = 1 << 25,
+};
+
+
+#endif				/* _MXC_MLB_H */
diff --git a/include/linux/mxc_sim_interface.h b/include/linux/mxc_sim_interface.h
new file mode 100644
index 000000000..5eae53a59
--- /dev/null
+++ b/include/linux/mxc_sim_interface.h
@@ -0,0 +1,124 @@
+/*
+ * Copyright (C) 2015 Freescale Semiconductor, Inc. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+#ifndef MXC_SIM_INTERFACE_H
+#define MXC_SIM_INTERFACE_H
+
+#define SIM_ATR_LENGTH_MAX 32
+
+/* Raw ATR SIM_IOCTL_GET_ATR */
+typedef struct {
+	unsigned int size;/* length of ATR received */
+	unsigned char *atr_buffer;/* raw ATR string received */
+	int errval;/* The error vale reported to user space after completing ATR*/
+} sim_atr_t;
+
+/* ISO7816-3 protocols */
+#define SIM_PROTOCOL_T0  1
+#define SIM_PROTOCOL_T1  2
+
+/* Transfer types for SIM_IOCTL_XFER */
+#define SIM_XFER_TYPE_TPDU 1
+#define SIM_XFER_TYPE_PTS  2
+
+typedef struct {
+	unsigned int wwt;
+	unsigned int cwt;
+	unsigned int bwt;
+	unsigned int bgt;
+	unsigned int cgt;
+} sim_timing_t;
+
+/* Transfer data for SIM_IOCTL_XFER */
+typedef struct {
+	unsigned char *xmt_buffer;	/* transmit buffer pointer */
+	int xmt_length;/* transmit buffer length */
+	int timeout;/* transfer timeout in milliseconds */
+	int errval;/* The error vale reported to user space after completing transmitting*/
+} sim_xmt_t;
+
+typedef struct {
+	unsigned char *rcv_buffer;	/* receive buffer pointer */
+	int rcv_length;	/* receive buffer length */
+	int timeout;/* transfer timeout in milliseconds */
+	int errval;/* The error vale reported to user space after receiving*/
+} sim_rcv_t;
+
+typedef struct {
+	unsigned char di;
+	unsigned char fi;
+} sim_baud_t;
+
+/* Interface power states */
+#define SIM_POWER_OFF			(0)
+#define SIM_POWER_ON			(1)
+
+/* Return values for SIM_IOCTL_GET_PRESENSE */
+#define SIM_PRESENT_REMOVED		(0)
+#define SIM_PRESENT_DETECTED		(1)
+#define SIM_PRESENT_OPERATIONAL		(2)
+
+/* The error value */
+#define SIM_OK				(0)
+#define SIM_ERROR_CWT			(1 << 0)
+#define SIM_ERROR_BWT			(1 << 1)
+#define SIM_ERROR_PARITY		(1 << 2)
+#define SIM_ERROR_INVALID_TS		(1 << 3)
+#define SIM_ERROR_FRAME			(1 << 4)
+#define SIM_ERROR_ATR_TIMEROUT		(1 << 5)
+#define SIM_ERROR_NACK_THRESHOLD	(1 << 6)
+#define SIM_ERROR_BGT			(1 << 7)
+#define SIM_ERROR_ATR_DELAY		(1 << 8)
+
+/* Return values for SIM_IOCTL_GET_ERROR */
+#define SIM_E_ACCESS			(1)
+#define SIM_E_TPDUSHORT			(2)
+#define SIM_E_PTSEMPTY			(3)
+#define SIM_E_INVALIDXFERTYPE		(4)
+#define SIM_E_INVALIDXMTLENGTH		(5)
+#define SIM_E_INVALIDRCVLENGTH		(6)
+#define SIM_E_NACK			(7)
+#define SIM_E_TIMEOUT			(8)
+#define SIM_E_NOCARD			(9)
+#define SIM_E_PARAM_FI_INVALID		(10)
+#define SIM_E_PARAM_DI_INVALID		(11)
+#define SIM_E_PARAM_FBYD_WITHFRACTION	(12)
+#define SIM_E_PARAM_FBYD_NOTDIVBY8OR12	(13)
+#define SIM_E_PARAM_DIVISOR_RANGE	(14)
+#define SIM_E_MALLOC			(15)
+#define SIM_E_IRQ			(16)
+#define SIM_E_POWERED_ON		(17)
+#define SIM_E_POWERED_OFF		(18)
+
+/* ioctl encodings */
+#define SIM_IOCTL_BASE			(0xc0)
+#define SIM_IOCTL_GET_PRESENSE		_IOR(SIM_IOCTL_BASE, 1, int)
+#define SIM_IOCTL_GET_ATR		_IOR(SIM_IOCTL_BASE, 2, sim_atr_t)
+#define SIM_IOCTL_XMT			_IOR(SIM_IOCTL_BASE, 3, sim_xmt_t)
+#define SIM_IOCTL_RCV			_IOR(SIM_IOCTL_BASE, 4, sim_rcv_t)
+#define SIM_IOCTL_ACTIVATE		_IO(SIM_IOCTL_BASE, 5)
+#define SIM_IOCTL_DEACTIVATE		_IO(SIM_IOCTL_BASE, 6)
+#define SIM_IOCTL_WARM_RESET		_IO(SIM_IOCTL_BASE, 7)
+#define SIM_IOCTL_COLD_RESET		_IO(SIM_IOCTL_BASE, 8)
+#define SIM_IOCTL_CARD_LOCK		_IO(SIM_IOCTL_BASE, 9)
+#define SIM_IOCTL_CARD_EJECT		_IO(SIM_IOCTL_BASE, 10)
+#define SIM_IOCTL_SET_PROTOCOL		_IOR(SIM_IOCTL_BASE, 11, unsigned int)
+#define SIM_IOCTL_SET_TIMING		_IOR(SIM_IOCTL_BASE, 12, sim_timing_t)
+#define SIM_IOCTL_SET_BAUD		_IOR(SIM_IOCTL_BASE, 13, sim_baud_t)
+#define SIM_IOCTL_WAIT			_IOR(SIM_IOCTL_BASE, 14, unsigned int)
+
+#endif
diff --git a/include/linux/mxc_vpu.h b/include/linux/mxc_vpu.h
new file mode 100644
index 000000000..df024698d
--- /dev/null
+++ b/include/linux/mxc_vpu.h
@@ -0,0 +1,118 @@
+/*
+ * Copyright 2004-2013, 2015 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU Lesser General
+ * Public License.  You may obtain a copy of the GNU Lesser General
+ * Public License Version 2.1 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/lgpl-license.html
+ * http://www.gnu.org/copyleft/lgpl.html
+ */
+
+/*!
+ * @defgroup VPU Video Processor Unit Driver
+ */
+
+/*!
+ * @file linux/mxc_vpu.h
+ *
+ * @brief VPU system initialization and file operation definition
+ *
+ * @ingroup VPU
+ */
+
+#ifndef __LINUX_MXC_VPU_H__
+#define __LINUX_MXC_VPU_H__
+
+#include <linux/fs.h>
+
+struct mxc_vpu_platform_data {
+	bool iram_enable;
+	int  iram_size;
+	void (*reset) (void);
+	void (*pg) (int);
+};
+
+struct vpu_mem_desc {
+	u32 size;
+	dma_addr_t phy_addr;
+	u32 cpu_addr;		/* cpu address to free the dma mem */
+	u32 virt_uaddr;		/* virtual user space address */
+};
+
+#define VPU_IOC_MAGIC  'V'
+
+#define VPU_IOC_PHYMEM_ALLOC	_IO(VPU_IOC_MAGIC, 0)
+#define VPU_IOC_PHYMEM_FREE	_IO(VPU_IOC_MAGIC, 1)
+#define VPU_IOC_WAIT4INT	_IO(VPU_IOC_MAGIC, 2)
+#define VPU_IOC_PHYMEM_DUMP	_IO(VPU_IOC_MAGIC, 3)
+#define VPU_IOC_REG_DUMP	_IO(VPU_IOC_MAGIC, 4)
+#define VPU_IOC_IRAM_SETTING	_IO(VPU_IOC_MAGIC, 6)
+#define VPU_IOC_CLKGATE_SETTING	_IO(VPU_IOC_MAGIC, 7)
+#define VPU_IOC_GET_WORK_ADDR   _IO(VPU_IOC_MAGIC, 8)
+#define VPU_IOC_REQ_VSHARE_MEM	_IO(VPU_IOC_MAGIC, 9)
+#define VPU_IOC_SYS_SW_RESET	_IO(VPU_IOC_MAGIC, 11)
+#define VPU_IOC_GET_SHARE_MEM   _IO(VPU_IOC_MAGIC, 12)
+#define VPU_IOC_QUERY_BITWORK_MEM  _IO(VPU_IOC_MAGIC, 13)
+#define VPU_IOC_SET_BITWORK_MEM    _IO(VPU_IOC_MAGIC, 14)
+#define VPU_IOC_PHYMEM_CHECK	_IO(VPU_IOC_MAGIC, 15)
+#define VPU_IOC_LOCK_DEV	_IO(VPU_IOC_MAGIC, 16)
+
+#define BIT_CODE_RUN			0x000
+#define BIT_CODE_DOWN			0x004
+#define BIT_INT_CLEAR			0x00C
+#define BIT_INT_STATUS			0x010
+#define BIT_CUR_PC			0x018
+#define BIT_INT_REASON			0x174
+
+#define MJPEG_PIC_STATUS_REG		0x3004
+#define MBC_SET_SUBBLK_EN		0x4A0
+
+#define BIT_WORK_CTRL_BUF_BASE		0x100
+#define BIT_WORK_CTRL_BUF_REG(i)	(BIT_WORK_CTRL_BUF_BASE + i * 4)
+#define BIT_CODE_BUF_ADDR		BIT_WORK_CTRL_BUF_REG(0)
+#define BIT_WORK_BUF_ADDR		BIT_WORK_CTRL_BUF_REG(1)
+#define BIT_PARA_BUF_ADDR		BIT_WORK_CTRL_BUF_REG(2)
+#define BIT_BIT_STREAM_CTRL		BIT_WORK_CTRL_BUF_REG(3)
+#define BIT_FRAME_MEM_CTRL		BIT_WORK_CTRL_BUF_REG(4)
+#define BIT_BIT_STREAM_PARAM		BIT_WORK_CTRL_BUF_REG(5)
+
+#ifndef CONFIG_SOC_IMX6Q
+#define BIT_RESET_CTRL			0x11C
+#else
+#define BIT_RESET_CTRL			0x128
+#endif
+
+/* i could be 0, 1, 2, 3 */
+#define	BIT_RD_PTR_BASE			0x120
+#define BIT_RD_PTR_REG(i)		(BIT_RD_PTR_BASE + i * 8)
+#define BIT_WR_PTR_REG(i)		(BIT_RD_PTR_BASE + i * 8 + 4)
+
+/* i could be 0, 1, 2, 3 */
+#define BIT_FRM_DIS_FLG_BASE		(cpu_is_mx51() ? 0x150 : 0x140)
+#define	BIT_FRM_DIS_FLG_REG(i)		(BIT_FRM_DIS_FLG_BASE + i * 4)
+
+#define BIT_BUSY_FLAG			0x160
+#define BIT_RUN_COMMAND			0x164
+#define BIT_INT_ENABLE			0x170
+
+#define	BITVAL_PIC_RUN			8
+
+#define	VPU_SLEEP_REG_VALUE		10
+#define	VPU_WAKE_REG_VALUE		11
+
+int vl2cc_init(u32 vl2cc_hw_base);
+void vl2cc_enable(void);
+void vl2cc_flush(void);
+void vl2cc_disable(void);
+void vl2cc_cleanup(void);
+
+int vl2cc_init(u32 vl2cc_hw_base);
+void vl2cc_enable(void);
+void vl2cc_flush(void);
+void vl2cc_disable(void);
+void vl2cc_cleanup(void);
+
+#endif
diff --git a/include/linux/mxcfb_epdc.h b/include/linux/mxcfb_epdc.h
new file mode 100644
index 000000000..84fea89e7
--- /dev/null
+++ b/include/linux/mxcfb_epdc.h
@@ -0,0 +1,32 @@
+/* SPDX-License-Identifier: GPL-2.0-or-later */
+/*
+ * Copyright (C) 2010-2013 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright 2019 NXP
+ */
+#ifndef _MXCFB_EPDC_KERNEL
+#define _MXCFB_EPDC_KERNEL
+
+struct imx_epdc_fb_mode {
+    struct fb_videomode *vmode;
+    int vscan_holdoff;
+    int sdoed_width;
+    int sdoed_delay;
+    int sdoez_width;
+    int sdoez_delay;
+    int gdclk_hp_offs;
+    int gdsp_offs;
+    int gdoe_offs;
+    int gdclk_offs;
+    int num_ce;
+};
+
+struct imx_epdc_fb_platform_data {
+    struct imx_epdc_fb_mode *epdc_mode;
+    int num_modes;
+    int (*get_pins) (void);
+    void (*put_pins) (void);
+    void (*enable_pins) (void);
+    void (*disable_pins) (void);
+};
+
+#endif
diff --git a/include/linux/netdev_features.h b/include/linux/netdev_features.h
index f96b7f8d8..4b338f1eb 100644
--- a/include/linux/netdev_features.h
+++ b/include/linux/netdev_features.h
@@ -75,6 +75,7 @@ enum {
 	NETIF_F_HW_TC_BIT,		/* Offload TC infrastructure */
 	NETIF_F_HW_ESP_BIT,		/* Hardware ESP transformation offload */
 	NETIF_F_HW_ESP_TX_CSUM_BIT,	/* ESP with TX checksum offload */
+	NETIF_F_HW_ACCEL_MQ_BIT,	/* Hardware-accelerated multiqueue */
 	NETIF_F_RX_UDP_TUNNEL_PORT_BIT, /* Offload of RX port for UDP tunnels */
 	NETIF_F_HW_TLS_TX_BIT,		/* Hardware TLS TX offload */
 	NETIF_F_HW_TLS_RX_BIT,		/* Hardware TLS RX offload */
@@ -149,6 +150,7 @@ enum {
 #define NETIF_F_HW_TC		__NETIF_F(HW_TC)
 #define NETIF_F_HW_ESP		__NETIF_F(HW_ESP)
 #define NETIF_F_HW_ESP_TX_CSUM	__NETIF_F(HW_ESP_TX_CSUM)
+#define NETIF_F_HW_ACCEL_MQ	__NETIF_F(HW_ACCEL_MQ)
 #define	NETIF_F_RX_UDP_TUNNEL_PORT  __NETIF_F(RX_UDP_TUNNEL_PORT)
 #define NETIF_F_HW_TLS_RECORD	__NETIF_F(HW_TLS_RECORD)
 #define NETIF_F_GSO_UDP_L4	__NETIF_F(GSO_UDP_L4)
diff --git a/include/linux/pci.h b/include/linux/pci.h
index f72dff6ad..3fc2e524a 100644
--- a/include/linux/pci.h
+++ b/include/linux/pci.h
@@ -2038,6 +2038,7 @@ static inline void pcibios_penalize_isa_irq(int irq, int active) {}
 int pcibios_alloc_irq(struct pci_dev *dev);
 void pcibios_free_irq(struct pci_dev *dev);
 resource_size_t pcibios_default_alignment(void);
+int pcibios_check_service_irqs(struct pci_dev *dev, int *irqs, int mask);
 
 #if defined(CONFIG_PCI_MMCONFIG) || defined(CONFIG_ACPI_MCFG)
 void __init pci_mmcfg_early_init(void);
diff --git a/include/linux/pci_ids.h b/include/linux/pci_ids.h
index 635a9243c..11dd366de 100644
--- a/include/linux/pci_ids.h
+++ b/include/linux/pci_ids.h
@@ -1481,6 +1481,7 @@
 
 #define PCI_VENDOR_ID_SIEMENS           0x110A
 #define PCI_DEVICE_ID_SIEMENS_DSCC4     0x2102
+#define PCI_DEVICE_ID_IVSHMEM		0x4106
 
 #define PCI_VENDOR_ID_VORTEX		0x1119
 #define PCI_DEVICE_ID_VORTEX_GDT60x0	0x0000
diff --git a/include/linux/phy.h b/include/linux/phy.h
index 08725a262..8559a829a 100644
--- a/include/linux/phy.h
+++ b/include/linux/phy.h
@@ -144,6 +144,7 @@ typedef enum {
 	PHY_INTERFACE_MODE_USXGMII,
 	/* 10GBASE-KR - with Clause 73 AN */
 	PHY_INTERFACE_MODE_10GKR,
+	PHY_INTERFACE_MODE_2500SGMII,
 	PHY_INTERFACE_MODE_MAX,
 } phy_interface_t;
 
@@ -217,6 +218,8 @@ static inline const char *phy_modes(phy_interface_t interface)
 		return "usxgmii";
 	case PHY_INTERFACE_MODE_10GKR:
 		return "10gbase-kr";
+	case PHY_INTERFACE_MODE_2500SGMII:
+		return "sgmii-2500";
 	default:
 		return "unknown";
 	}
@@ -739,6 +742,13 @@ struct phy_driver {
 	 */
 	int (*config_aneg)(struct phy_device *phydev);
 
+	/**
+	 * @config_inband_aneg: Enable or disable in-band auto-negotiation for
+	 * the system-side interface if the PHY operates in a mode that
+	 * requires it: (Q)SGMII, USXGMII, 1000Base-X, etc.
+	 */
+	int (*config_inband_aneg)(struct phy_device *phydev, bool enabled);
+
 	/** @aneg_done: Determines the auto negotiation result */
 	int (*aneg_done)(struct phy_device *phydev);
 
@@ -1350,10 +1360,42 @@ struct phy_device *phy_device_create(struct mii_bus *bus, int addr, u32 phy_id,
 				     bool is_c45,
 				     struct phy_c45_device_ids *c45_ids);
 #if IS_ENABLED(CONFIG_PHYLIB)
+int fwnode_get_phy_id(struct fwnode_handle *fwnode, u32 *phy_id);
+struct mdio_device *fwnode_mdio_find_device(struct fwnode_handle *fwnode);
+struct phy_device *fwnode_phy_find_device(struct fwnode_handle *phy_fwnode);
+struct phy_device *device_phy_find_device(struct device *dev);
+struct fwnode_handle *fwnode_get_phy_node(struct fwnode_handle *fwnode);
 struct phy_device *get_phy_device(struct mii_bus *bus, int addr, bool is_c45);
 int phy_device_register(struct phy_device *phy);
 void phy_device_free(struct phy_device *phydev);
 #else
+static inline int fwnode_get_phy_id(struct fwnode_handle *fwnode, u32 *phy_id)
+{
+	return 0;
+}
+static inline
+struct mdio_device *fwnode_mdio_find_device(struct fwnode_handle *fwnode)
+{
+	return 0;
+}
+
+static inline
+struct phy_device *fwnode_phy_find_device(struct fwnode_handle *phy_fwnode)
+{
+	return NULL;
+}
+
+static inline struct phy_device *device_phy_find_device(struct device *dev)
+{
+	return NULL;
+}
+
+static inline
+struct fwnode_handle *fwnode_get_phy_node(struct fwnode_handle *fwnode)
+{
+	return NULL;
+}
+
 static inline
 struct phy_device *get_phy_device(struct mii_bus *bus, int addr, bool is_c45)
 {
@@ -1393,6 +1435,7 @@ void phy_detach(struct phy_device *phydev);
 void phy_start(struct phy_device *phydev);
 void phy_stop(struct phy_device *phydev);
 int phy_start_aneg(struct phy_device *phydev);
+int phy_config_inband_aneg(struct phy_device *phydev, bool enabled);
 int phy_aneg_done(struct phy_device *phydev);
 int phy_speed_down(struct phy_device *phydev, bool sync);
 int phy_speed_up(struct phy_device *phydev);
diff --git a/include/linux/phy/phy-mixel-lvds-combo.h b/include/linux/phy/phy-mixel-lvds-combo.h
new file mode 100644
index 000000000..16a558fb4
--- /dev/null
+++ b/include/linux/phy/phy-mixel-lvds-combo.h
@@ -0,0 +1,40 @@
+/*
+ * Copyright 2017-2019 NXP
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the
+ * Free Software Foundation; either version 2 of the License, or (at your
+ * option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+ * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * for more details.
+ */
+
+#ifndef PHY_MIXEL_LVDS_COMBO_H_
+#define PHY_MIXEL_LVDS_COMBO_H_
+
+#include "phy.h"
+
+#if IS_ENABLED(CONFIG_PHY_MIXEL_LVDS_COMBO)
+void mixel_phy_combo_lvds_set_phy_speed(struct phy *phy,
+					unsigned long phy_clk_rate);
+void mixel_phy_combo_lvds_set_hsync_pol(struct phy *phy, bool active_high);
+void mixel_phy_combo_lvds_set_vsync_pol(struct phy *phy, bool active_high);
+#else
+static inline void
+mixel_phy_combo_lvds_set_phy_speed(struct phy *phy, unsigned long phy_clk_rate)
+{
+}
+static inline void mixel_phy_combo_lvds_set_hsync_pol(struct phy *phy,
+						      bool active_high)
+{
+}
+static inline void mixel_phy_combo_lvds_set_vsync_pol(struct phy *phy,
+						      bool active_high)
+{
+}
+#endif
+
+#endif	/* PHY_MIXEL_LVDS_COMBO_H_ */
diff --git a/include/linux/phy/phy-mixel-lvds.h b/include/linux/phy/phy-mixel-lvds.h
new file mode 100644
index 000000000..2ffa4ee28
--- /dev/null
+++ b/include/linux/phy/phy-mixel-lvds.h
@@ -0,0 +1,39 @@
+/*
+ * Copyright 2017-2019 NXP
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the
+ * Free Software Foundation; either version 2 of the License, or (at your
+ * option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+ * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * for more details.
+ */
+
+#ifndef PHY_MIXEL_LVDS_H_
+#define PHY_MIXEL_LVDS_H_
+
+#include "phy.h"
+
+#if IS_ENABLED(CONFIG_PHY_MIXEL_LVDS)
+void mixel_phy_lvds_set_phy_speed(struct phy *phy, unsigned long phy_clk_rate);
+void mixel_phy_lvds_set_hsync_pol(struct phy *phy, bool active_high);
+void mixel_phy_lvds_set_vsync_pol(struct phy *phy, bool active_high);
+#else
+static inline void mixel_phy_lvds_set_phy_speed(struct phy *phy,
+						unsigned long phy_clk_rate)
+{
+}
+static inline void mixel_phy_lvds_set_hsync_pol(struct phy *phy,
+						bool active_high)
+{
+}
+static inline void mixel_phy_lvds_set_vsync_pol(struct phy *phy,
+						bool active_high)
+{
+}
+#endif
+
+#endif	/* PHY_MIXEL_LVDS_H_ */
diff --git a/include/linux/phy/phy.h b/include/linux/phy/phy.h
index e435bdb0b..95465cd78 100644
--- a/include/linux/phy/phy.h
+++ b/include/linux/phy/phy.h
@@ -201,6 +201,8 @@ static inline void *phy_get_drvdata(struct phy *phy)
 	return dev_get_drvdata(&phy->dev);
 }
 
+extern struct dentry *phy_debugfs_root;
+
 #if IS_ENABLED(CONFIG_GENERIC_PHY)
 int phy_pm_runtime_get(struct phy *phy);
 int phy_pm_runtime_get_sync(struct phy *phy);
diff --git a/include/linux/phylink.h b/include/linux/phylink.h
index d81a714cf..75d4f9909 100644
--- a/include/linux/phylink.h
+++ b/include/linux/phylink.h
@@ -439,6 +439,9 @@ void phylink_destroy(struct phylink *);
 
 int phylink_connect_phy(struct phylink *, struct phy_device *);
 int phylink_of_phy_connect(struct phylink *, struct device_node *, u32 flags);
+int phylink_fwnode_phy_connect(struct phylink *pl,
+			       struct fwnode_handle *fwnode,
+			       u32 flags);
 void phylink_disconnect_phy(struct phylink *);
 
 void phylink_mac_change(struct phylink *, bool up);
diff --git a/include/linux/platform_data/dma-imx-sdma.h b/include/linux/platform_data/dma-imx-sdma.h
index 30e676b36..a9f79665a 100644
--- a/include/linux/platform_data/dma-imx-sdma.h
+++ b/include/linux/platform_data/dma-imx-sdma.h
@@ -20,12 +20,12 @@ struct sdma_script_start_addrs {
 	s32 per_2_firi_addr;
 	s32 mcu_2_firi_addr;
 	s32 uart_2_per_addr;
-	s32 uart_2_mcu_addr;
+	s32 uart_2_mcu_ram_addr;
 	s32 per_2_app_addr;
 	s32 mcu_2_app_addr;
 	s32 per_2_per_addr;
 	s32 uartsh_2_per_addr;
-	s32 uartsh_2_mcu_addr;
+	s32 uartsh_2_mcu_ram_addr;
 	s32 per_2_shp_addr;
 	s32 mcu_2_shp_addr;
 	s32 ata_2_mcu_addr;
@@ -52,6 +52,12 @@ struct sdma_script_start_addrs {
 	s32 zcanfd_2_mcu_addr;
 	s32 zqspi_2_mcu_addr;
 	s32 mcu_2_ecspi_addr;
+	s32 mcu_2_sai_addr;
+	s32 sai_2_mcu_addr;
+	s32 uart_2_mcu_addr;
+	s32 uartsh_2_mcu_addr;
+	s32 i2c_2_mcu_addr;
+	s32 mcu_2_i2c_addr;
 	/* End of v3 array */
 	s32 mcu_2_zqspi_addr;
 	/* End of v4 array */
diff --git a/include/linux/platform_data/dma-imx.h b/include/linux/platform_data/dma-imx.h
index 281adbb26..03b829c56 100644
--- a/include/linux/platform_data/dma-imx.h
+++ b/include/linux/platform_data/dma-imx.h
@@ -39,6 +39,9 @@ enum sdma_peripheral_type {
 	IMX_DMATYPE_SSI_DUAL,	/* SSI Dual FIFO */
 	IMX_DMATYPE_ASRC_SP,	/* Shared ASRC */
 	IMX_DMATYPE_SAI,	/* SAI */
+	IMX_DMATYPE_MULTI_SAI,	/* MULTI FIFOs For Audio */
+	IMX_DMATYPE_HDMI,	/* HDMI Audio */
+	IMX_DMATYPE_I2C,	/* I2C */
 };
 
 enum imx_dma_prio {
@@ -47,6 +50,39 @@ enum imx_dma_prio {
 	DMA_PRIO_LOW = 2
 };
 
+/**
+ * struct sdma_audio_config - special sdma config for audio case
+ * @src_fifo_num: source fifo number for mcu_2_sai/sai_2_mcu script
+ *                For example, if there are 4 fifos, sdma will fetch
+ *                fifos one by one and roll back to the first fifo after
+ *                the 4th fifo fetch.
+ * @dst_fifo_num: similar as src_fifo_num, but dest fifo instead.
+ * @src_fifo_off: source fifo offset, 0 means all fifos are continuous, 1
+ *                means 1 word offset between fifos. All offset between
+ *                fifos should be same.
+ * @dst_fifo_off: dst fifo offset, similar as @src_fifo_off.
+ * @words_per_fifo: numbers of words per fifo fetch/fill, 0 means
+ *                  one channel per fifo, 1 means 2 channels per fifo..
+ *                  If 'src_fifo_num =  4' and 'chans_per_fifo = 1', it
+ *                  means the first two words(channels) fetch from fifo1
+ *                  and then jump to fifo2 for next two words, and so on
+ *                  after the last fifo4 fetched, roll back to fifo1.
+ * @sw_done_sel: software done selector, PDM need enable software done feature
+ *               in mcu_2_sai/sai_2_mcu script.
+ *               Bit31: sw_done eanbled or not
+ *               Bit16~Bit0: selector
+ *               For example: 0x80000000 means sw_done enabled for done0
+ *                            sector which is for PDM on i.mx8mm.
+ */
+struct sdma_audio_config {
+	u8 src_fifo_num;
+	u8 dst_fifo_num;
+	u8 src_fifo_off;
+	u8 dst_fifo_off;
+	u8 words_per_fifo;
+	u32 sw_done_sel;
+};
+
 struct imx_dma_data {
 	int dma_request; /* DMA request line */
 	int dma_request2; /* secondary DMA request line */
@@ -59,6 +95,11 @@ static inline int imx_dma_is_ipu(struct dma_chan *chan)
 	return !strcmp(dev_name(chan->device->dev), "ipu-core");
 }
 
+static inline int imx_dma_is_pxp(struct dma_chan *chan)
+{
+        return strstr(dev_name(chan->device->dev), "pxp") != NULL;
+}
+
 static inline int imx_dma_is_general_purpose(struct dma_chan *chan)
 {
 	return !strcmp(chan->device->dev->driver->name, "imx-sdma") ||
diff --git a/include/linux/platform_data/mmc-esdhc-imx.h b/include/linux/platform_data/mmc-esdhc-imx.h
index cba1184b3..40d64d152 100644
--- a/include/linux/platform_data/mmc-esdhc-imx.h
+++ b/include/linux/platform_data/mmc-esdhc-imx.h
@@ -38,5 +38,6 @@ struct esdhc_platform_data {
 	unsigned int tuning_step;       /* The delay cell steps in tuning procedure */
 	unsigned int tuning_start_tap;	/* The start delay cell point in tuning procedure */
 	unsigned int strobe_dll_delay_target;	/* The delay cell for strobe pad (read clock) */
+	bool sdio_interrupt_enabled;
 };
 #endif /* __ASM_ARCH_IMX_ESDHC_H */
diff --git a/include/linux/pm_domain.h b/include/linux/pm_domain.h
index 1ad0ec481..cfb8bf699 100644
--- a/include/linux/pm_domain.h
+++ b/include/linux/pm_domain.h
@@ -153,6 +153,7 @@ struct generic_pm_domain {
 		};
 	};
 
+	unsigned int state_idx_saved; /* saved power state for recovery after system suspend/resume */
 };
 
 static inline struct generic_pm_domain *pd_to_genpd(struct dev_pm_domain *pd)
diff --git a/include/linux/pm_qos.h b/include/linux/pm_qos.h
index 4a69d4af3..b87a095fe 100644
--- a/include/linux/pm_qos.h
+++ b/include/linux/pm_qos.h
@@ -15,6 +15,15 @@
 #include <linux/plist.h>
 #include <linux/notifier.h>
 #include <linux/device.h>
+#include <linux/workqueue.h>
+
+enum {
+	PM_QOS_RESERVED = 0,
+	PM_QOS_CPU_DMA_LATENCY,
+
+	/* insert new class ID */
+	PM_QOS_NUM_CLASSES,
+};
 
 enum pm_qos_flags_status {
 	PM_QOS_FLAGS_UNDEFINED = -1,
diff --git a/include/linux/pmic_status.h b/include/linux/pmic_status.h
new file mode 100644
index 000000000..cbef24194
--- /dev/null
+++ b/include/linux/pmic_status.h
@@ -0,0 +1,76 @@
+/* SPDX-License-Identifier: GPL-2.0-or-later */
+/*
+ * Copyright 2004-2015 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright 2019 NXP
+ */
+
+#ifndef __ASM_ARCH_MXC_PMIC_STATUS_H__
+#define __ASM_ARCH_MXC_PMIC_STATUS_H__
+#include <asm-generic/errno-base.h>
+#ifdef __KERNEL__
+#include <asm/uaccess.h>	/* copy_{from,to}_user() */
+#endif
+/*!
+ * @file arch-mxc/pmic_status.h
+ * @brief PMIC APIs return code definition.
+ *
+ * @ingroup PMIC_CORE
+ */
+
+/*!
+ * @enum PMIC_STATUS
+ * @brief Define return values for all PMIC APIs.
+ *
+ * These return values are used by all of the PMIC APIs.
+ *
+ * @ingroup PMIC
+ */
+typedef enum {
+	PMIC_SUCCESS = 0,	/*!< The requested operation was successfully
+				   completed.                                     */
+	PMIC_ERROR = -1,	/*!< The requested operation could not be completed
+				   due to an error.                               */
+	PMIC_PARAMETER_ERROR = -2,	/*!< The requested operation failed because
+					   one or more of the parameters was
+					   invalid.                             */
+	PMIC_NOT_SUPPORTED = -3,	/*!< The requested operation could not be
+					   completed because the PMIC hardware
+					   does not support it. */
+	PMIC_SYSTEM_ERROR_EINTR = -EINTR,
+
+	PMIC_MALLOC_ERROR = -5,	/*!< Error in malloc function             */
+	PMIC_UNSUBSCRIBE_ERROR = -6,	/*!< Error in un-subscribe event          */
+	PMIC_EVENT_NOT_SUBSCRIBED = -7,	/*!< Event occur and not subscribed       */
+	PMIC_EVENT_CALL_BACK = -8,	/*!< Error - bad call back                */
+	PMIC_CLIENT_NBOVERFLOW = -9,	/*!< The requested operation could not be
+					   completed because there are too many
+					   PMIC client requests */
+} PMIC_STATUS;
+
+/*
+ * Bitfield macros that use rely on bitfield width/shift information.
+ */
+#define BITFMASK(field) (((1U << (field ## _WID)) - 1) << (field ## _LSH))
+#define BITFVAL(field, val) ((val) << (field ## _LSH))
+#define BITFEXT(var, bit) ((var & BITFMASK(bit)) >> (bit ## _LSH))
+
+/*
+ * Macros implementing error handling
+ */
+#define CHECK_ERROR(a)			\
+do {					\
+		int ret = (a); 			\
+		if (ret != PMIC_SUCCESS)	\
+	return ret; 			\
+} while (0)
+
+#define CHECK_ERROR_KFREE(func, freeptrs) \
+do { \
+	int ret = (func); \
+	if (ret != PMIC_SUCCESS) { \
+		freeptrs;	\
+		return ret;	\
+	}	\
+} while (0);
+
+#endif				/* __ASM_ARCH_MXC_PMIC_STATUS_H__ */
diff --git a/include/linux/power/sabresd_battery.h b/include/linux/power/sabresd_battery.h
new file mode 100644
index 000000000..10bfa4588
--- /dev/null
+++ b/include/linux/power/sabresd_battery.h
@@ -0,0 +1,65 @@
+/*
+ * sabresd_battery.h - Maxim 8903 USB/Adapter Charger Driver
+ *
+ * Copyright (C) 2011 Samsung Electronics
+ * Copyright (C) 2011-2015 Freescale Semiconductor, Inc.
+ * Based on max8903_charger.h
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ */
+
+#ifndef __MAX8903_SABRESD_H__
+#define __MAX8903_SABRESD_H__
+
+struct max8903_pdata {
+	/*
+	 * GPIOs
+	 * cen, chg, flt, and usus are optional.
+	 * dok, dcm, and uok are not optional depending on the status of
+	 * dc_valid and usb_valid.
+	 */
+	int cen;	/* Charger Enable input */
+	int dok;	/* DC(Adapter) Power OK output */
+	int uok;	/* USB Power OK output */
+	int chg;	/* Charger status output */
+	int flt;	/* Fault output */
+	int dcm;	/* Current-Limit Mode input (1: DC, 2: USB) */
+	int usus;	/* USB Suspend Input (1: suspended) */
+	int feature_flag;/* battery capacity feature(0:enable, 1:disable) */
+
+	/*
+	 * DCM wired to Logic High Set this true when DCM pin connect to
+	 * Logic high.
+	 */
+	bool dcm_always_high;
+
+	/*
+	 * DC(Adapter/TA) is wired
+	 * When dc_valid is true,
+	 *	dok and dcm should be valid.
+	 *
+	 * At least one of dc_valid or usb_valid should be true.
+	 */
+	bool dc_valid;
+	/*
+	 * USB is wired
+	 * When usb_valid is true,
+	 *	uok should be valid.
+	 */
+	bool usb_valid;
+};
+
+#endif /* __SABRESD_BATTERY_H__ */
diff --git a/include/linux/pwm_backlight.h b/include/linux/pwm_backlight.h
index 06086cb93..c922b067a 100644
--- a/include/linux/pwm_backlight.h
+++ b/include/linux/pwm_backlight.h
@@ -21,6 +21,7 @@ struct platform_pwm_backlight_data {
 	void (*notify_after)(struct device *dev, int brightness);
 	void (*exit)(struct device *dev);
 	int (*check_fb)(struct device *dev, struct fb_info *info);
+	char fb_id[16];
 };
 
 #endif
diff --git a/include/linux/pxp_device.h b/include/linux/pxp_device.h
new file mode 100644
index 000000000..9946a56ac
--- /dev/null
+++ b/include/linux/pxp_device.h
@@ -0,0 +1,66 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * Copyright (C) 2013-2014 Freescale Semiconductor, Inc. All Rights Reserved.
+ *
+ * Copyright 2019 NXP
+ */
+#ifndef _PXP_DEVICE
+#define _PXP_DEVICE
+
+#include <linux/idr.h>
+#include <linux/hash.h>
+#include <uapi/linux/pxp_device.h>
+
+struct pxp_irq_info {
+	wait_queue_head_t waitq;
+	atomic_t irq_pending;
+	int hist_status;
+};
+
+struct pxp_buffer_hash {
+	struct hlist_head *hash_table;
+	u32 order;
+	spinlock_t hash_lock;
+};
+
+struct pxp_buf_obj {
+	uint32_t handle;
+
+	uint32_t size;
+	uint32_t mem_type;
+
+	unsigned long offset;
+	void *virtual;
+	unsigned long attrs;
+
+	struct hlist_node item;
+
+	struct sg_table *sgt_base;
+	/* DMABUF related */
+	struct dma_buf_attachment *db_attach;
+};
+
+struct pxp_chan_obj {
+	uint32_t handle;
+	struct dma_chan *chan;
+};
+
+/* File private data */
+struct pxp_file {
+	struct file *filp;
+
+	/* record allocated dma buffer */
+	struct idr buffer_idr;
+	spinlock_t buffer_lock;
+
+	/* record allocated dma channel */
+	struct idr channel_idr;
+	spinlock_t channel_lock;
+};
+
+struct pxp_attachment {
+	struct sg_table sgt;
+	enum dma_data_direction dma_dir;
+};
+
+#endif
diff --git a/include/linux/pxp_dma.h b/include/linux/pxp_dma.h
new file mode 100644
index 000000000..f89e36369
--- /dev/null
+++ b/include/linux/pxp_dma.h
@@ -0,0 +1,70 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * Copyright (C) 2010-2015 Freescale Semiconductor, Inc. All Rights Reserved.
+ *
+ * Copyright 2017-2019 NXP
+ */
+#ifndef _PXP_DMA
+#define _PXP_DMA
+
+#include <uapi/linux/pxp_dma.h>
+
+struct pxp_tx_desc {
+	struct dma_async_tx_descriptor txd;
+	struct list_head tx_list;
+	struct list_head list;
+	int len;
+	union {
+		struct pxp_layer_param s0_param;
+		struct pxp_layer_param out_param;
+		struct pxp_layer_param ol_param;
+		struct pxp_layer_param processing_param;
+	} layer_param;
+	struct pxp_proc_data proc_data;
+
+	u32 hist_status;	/* Histogram output status */
+
+	struct pxp_tx_desc *next;
+};
+
+struct pxp_channel {
+	struct dma_chan dma_chan;
+	dma_cookie_t completed;	/* last completed cookie */
+	enum pxp_channel_status status;
+	void *client;		/* Only one client per channel */
+	unsigned int n_tx_desc;
+	struct pxp_tx_desc *desc;	/* allocated tx-descriptors */
+	struct list_head active_list;	/* active tx-descriptors */
+	struct list_head free_list;	/* free tx-descriptors */
+	struct list_head queue;	/* queued tx-descriptors */
+	struct list_head list;	/* track queued channel number */
+	spinlock_t lock;	/* protects sg[0,1], queue */
+	struct mutex chan_mutex;	/* protects status, cookie, free_list */
+	int active_buffer;
+	unsigned int eof_irq;
+	char eof_name[16];	/* EOF IRQ name for request_irq()  */
+};
+
+#define to_tx_desc(tx) container_of(tx, struct pxp_tx_desc, txd)
+#define to_pxp_channel(d) container_of(d, struct pxp_channel, dma_chan)
+
+void pxp_txd_ack(struct dma_async_tx_descriptor *txd,
+		 struct pxp_channel *pxp_chan);
+
+#ifdef CONFIG_MXC_PXP_CLIENT_DEVICE
+int register_pxp_device(void);
+void unregister_pxp_device(void);
+#else
+static int register_pxp_device(void) { return 0; }
+static void unregister_pxp_device(void) {}
+#endif
+void pxp_fill(
+        u32 bpp,
+        u32 value,
+        u32 width,
+        u32 height,
+        u32 output_buffer,
+        u32 output_pitch);
+
+void m4_process(void);
+#endif
diff --git a/include/linux/remoteproc.h b/include/linux/remoteproc.h
index 3fa3ba649..96551a0cb 100644
--- a/include/linux/remoteproc.h
+++ b/include/linux/remoteproc.h
@@ -392,6 +392,8 @@ struct rproc_ops {
 	int (*load)(struct rproc *rproc, const struct firmware *fw);
 	int (*sanity_check)(struct rproc *rproc, const struct firmware *fw);
 	u64 (*get_boot_addr)(struct rproc *rproc, const struct firmware *fw);
+	void (*elf_memcpy)(struct rproc *rproc, void *dest, const void *src, size_t count);
+	void (*elf_memset)(struct rproc *rproc, void *s, int c, size_t count);
 	unsigned long (*panic)(struct rproc *rproc);
 };
 
@@ -551,6 +553,7 @@ struct rproc {
 	u16 elf_machine;
 	struct cdev cdev;
 	bool cdev_put_on_release;
+	bool skip_fw_recovery;
 };
 
 /**
diff --git a/include/linux/rpmsg.h b/include/linux/rpmsg.h
index a68972b09..7fa25aec3 100644
--- a/include/linux/rpmsg.h
+++ b/include/linux/rpmsg.h
@@ -17,8 +17,8 @@
 #include <linux/kref.h>
 #include <linux/mutex.h>
 #include <linux/poll.h>
-
-#define RPMSG_ADDR_ANY		0xFFFFFFFF
+#include <linux/rpmsg/byteorder.h>
+#include <uapi/linux/rpmsg.h>
 
 struct rpmsg_device;
 struct rpmsg_endpoint;
@@ -46,6 +46,7 @@ struct rpmsg_channel_info {
  * @dst: destination address
  * @ept: the rpmsg endpoint of this channel
  * @announce: if set, rpmsg will announce the creation/removal of this channel
+ * @little_endian: True if transport is using little endian byte representation
  */
 struct rpmsg_device {
 	struct device dev;
@@ -55,6 +56,7 @@ struct rpmsg_device {
 	u32 dst;
 	struct rpmsg_endpoint *ept;
 	bool announce;
+	bool little_endian;
 
 	const struct rpmsg_device_ops *ops;
 };
@@ -111,16 +113,68 @@ struct rpmsg_driver {
 	int (*callback)(struct rpmsg_device *, void *, int, void *, u32);
 };
 
+static inline u16 rpmsg16_to_cpu(struct rpmsg_device *rpdev, __rpmsg16 val)
+{
+	if (!rpdev)
+		return __rpmsg16_to_cpu(rpmsg_is_little_endian(), val);
+	else
+		return __rpmsg16_to_cpu(rpdev->little_endian, val);
+}
+
+static inline __rpmsg16 cpu_to_rpmsg16(struct rpmsg_device *rpdev, u16 val)
+{
+	if (!rpdev)
+		return __cpu_to_rpmsg16(rpmsg_is_little_endian(), val);
+	else
+		return __cpu_to_rpmsg16(rpdev->little_endian, val);
+}
+
+static inline u32 rpmsg32_to_cpu(struct rpmsg_device *rpdev, __rpmsg32 val)
+{
+	if (!rpdev)
+		return __rpmsg32_to_cpu(rpmsg_is_little_endian(), val);
+	else
+		return __rpmsg32_to_cpu(rpdev->little_endian, val);
+}
+
+static inline __rpmsg32 cpu_to_rpmsg32(struct rpmsg_device *rpdev, u32 val)
+{
+	if (!rpdev)
+		return __cpu_to_rpmsg32(rpmsg_is_little_endian(), val);
+	else
+		return __cpu_to_rpmsg32(rpdev->little_endian, val);
+}
+
+static inline u64 rpmsg64_to_cpu(struct rpmsg_device *rpdev, __rpmsg64 val)
+{
+	if (!rpdev)
+		return __rpmsg64_to_cpu(rpmsg_is_little_endian(), val);
+	else
+		return __rpmsg64_to_cpu(rpdev->little_endian, val);
+}
+
+static inline __rpmsg64 cpu_to_rpmsg64(struct rpmsg_device *rpdev, u64 val)
+{
+	if (!rpdev)
+		return __cpu_to_rpmsg64(rpmsg_is_little_endian(), val);
+	else
+		return __cpu_to_rpmsg64(rpdev->little_endian, val);
+}
+
 #if IS_ENABLED(CONFIG_RPMSG)
 
-int register_rpmsg_device(struct rpmsg_device *dev);
-void unregister_rpmsg_device(struct rpmsg_device *dev);
+int rpmsg_register_device(struct rpmsg_device *rpdev);
+int rpmsg_unregister_device(struct device *parent,
+			    struct rpmsg_channel_info *chinfo);
 int __register_rpmsg_driver(struct rpmsg_driver *drv, struct module *owner);
 void unregister_rpmsg_driver(struct rpmsg_driver *drv);
 void rpmsg_destroy_ept(struct rpmsg_endpoint *);
 struct rpmsg_endpoint *rpmsg_create_ept(struct rpmsg_device *,
 					rpmsg_rx_cb_t cb, void *priv,
 					struct rpmsg_channel_info chinfo);
+struct rpmsg_endpoint *rpmsg_create_default_ept(struct rpmsg_device *rpdev,
+						rpmsg_rx_cb_t cb, void *priv,
+						struct rpmsg_channel_info chinfo);
 
 int rpmsg_send(struct rpmsg_endpoint *ept, void *data, int len);
 int rpmsg_sendto(struct rpmsg_endpoint *ept, void *data, int len, u32 dst);
@@ -137,15 +191,18 @@ __poll_t rpmsg_poll(struct rpmsg_endpoint *ept, struct file *filp,
 
 #else
 
-static inline int register_rpmsg_device(struct rpmsg_device *dev)
+static inline int rpmsg_register_device(struct rpmsg_device *rpdev)
 {
 	return -ENXIO;
 }
 
-static inline void unregister_rpmsg_device(struct rpmsg_device *dev)
+static inline int rpmsg_unregister_device(struct device *parent,
+					  struct rpmsg_channel_info *chinfo)
 {
 	/* This shouldn't be possible */
 	WARN_ON(1);
+
+	return -ENXIO;
 }
 
 static inline int __register_rpmsg_driver(struct rpmsg_driver *drv,
@@ -180,6 +237,16 @@ static inline struct rpmsg_endpoint *rpmsg_create_ept(struct rpmsg_device *rpdev
 	return NULL;
 }
 
+static inline struct rpmsg_endpoint *rpmsg_create_default_ept(struct rpmsg_device *rpdev,
+							      rpmsg_rx_cb_t cb, void *priv,
+							      struct rpmsg_channel_info chinfo)
+{
+	/* This shouldn't be possible */
+	WARN_ON(1);
+
+	return NULL;
+}
+
 static inline int rpmsg_send(struct rpmsg_endpoint *ept, void *data, int len)
 {
 	/* This shouldn't be possible */
diff --git a/include/linux/rpmsg/byteorder.h b/include/linux/rpmsg/byteorder.h
new file mode 100644
index 000000000..c0f565dba
--- /dev/null
+++ b/include/linux/rpmsg/byteorder.h
@@ -0,0 +1,67 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * Follows implementation found in linux/virtio_byteorder.h
+ */
+#ifndef _LINUX_RPMSG_BYTEORDER_H
+#define _LINUX_RPMSG_BYTEORDER_H
+#include <linux/types.h>
+#include <uapi/linux/rpmsg_types.h>
+
+static inline bool rpmsg_is_little_endian(void)
+{
+#ifdef __LITTLE_ENDIAN
+	return true;
+#else
+	return false;
+#endif
+}
+
+static inline u16 __rpmsg16_to_cpu(bool little_endian, __rpmsg16 val)
+{
+	if (little_endian)
+		return le16_to_cpu((__force __le16)val);
+	else
+		return be16_to_cpu((__force __be16)val);
+}
+
+static inline __rpmsg16 __cpu_to_rpmsg16(bool little_endian, u16 val)
+{
+	if (little_endian)
+		return (__force __rpmsg16)cpu_to_le16(val);
+	else
+		return (__force __rpmsg16)cpu_to_be16(val);
+}
+
+static inline u32 __rpmsg32_to_cpu(bool little_endian, __rpmsg32 val)
+{
+	if (little_endian)
+		return le32_to_cpu((__force __le32)val);
+	else
+		return be32_to_cpu((__force __be32)val);
+}
+
+static inline __rpmsg32 __cpu_to_rpmsg32(bool little_endian, u32 val)
+{
+	if (little_endian)
+		return (__force __rpmsg32)cpu_to_le32(val);
+	else
+		return (__force __rpmsg32)cpu_to_be32(val);
+}
+
+static inline u64 __rpmsg64_to_cpu(bool little_endian, __rpmsg64 val)
+{
+	if (little_endian)
+		return le64_to_cpu((__force __le64)val);
+	else
+		return be64_to_cpu((__force __be64)val);
+}
+
+static inline __rpmsg64 __cpu_to_rpmsg64(bool little_endian, u64 val)
+{
+	if (little_endian)
+		return (__force __rpmsg64)cpu_to_le64(val);
+	else
+		return (__force __rpmsg64)cpu_to_be64(val);
+}
+
+#endif /* _LINUX_RPMSG_BYTEORDER_H */
diff --git a/include/linux/rpmsg/ns.h b/include/linux/rpmsg/ns.h
new file mode 100644
index 000000000..a7804edd6
--- /dev/null
+++ b/include/linux/rpmsg/ns.h
@@ -0,0 +1,45 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+
+#ifndef _LINUX_RPMSG_NS_H
+#define _LINUX_RPMSG_NS_H
+
+#include <linux/mod_devicetable.h>
+#include <linux/rpmsg.h>
+#include <linux/rpmsg/byteorder.h>
+#include <linux/types.h>
+
+/**
+ * struct rpmsg_ns_msg - dynamic name service announcement message
+ * @name: name of remote service that is published
+ * @addr: address of remote service that is published
+ * @flags: indicates whether service is created or destroyed
+ *
+ * This message is sent across to publish a new service, or announce
+ * about its removal. When we receive these messages, an appropriate
+ * rpmsg channel (i.e device) is created/destroyed. In turn, the ->probe()
+ * or ->remove() handler of the appropriate rpmsg driver will be invoked
+ * (if/as-soon-as one is registered).
+ */
+struct rpmsg_ns_msg {
+	char name[RPMSG_NAME_SIZE];
+	__rpmsg32 addr;
+	__rpmsg32 flags;
+} __packed;
+
+/**
+ * enum rpmsg_ns_flags - dynamic name service announcement flags
+ *
+ * @RPMSG_NS_CREATE: a new remote service was just created
+ * @RPMSG_NS_DESTROY: a known remote service was just destroyed
+ */
+enum rpmsg_ns_flags {
+	RPMSG_NS_CREATE		= 0,
+	RPMSG_NS_DESTROY	= 1,
+};
+
+/* Address 53 is reserved for advertising remote services */
+#define RPMSG_NS_ADDR			(53)
+
+int rpmsg_ns_register_device(struct rpmsg_device *rpdev);
+
+#endif
diff --git a/include/linux/rtc.h b/include/linux/rtc.h
index 22d1575e4..0e345ff4e 100644
--- a/include/linux/rtc.h
+++ b/include/linux/rtc.h
@@ -34,6 +34,18 @@ static inline time64_t rtc_tm_sub(struct rtc_time *lhs, struct rtc_time *rhs)
 	return rtc_tm_to_time64(lhs) - rtc_tm_to_time64(rhs);
 }
 
+static inline void rtc_time_to_tm(unsigned long time, struct rtc_time *tm)
+{
+	rtc_time64_to_tm(time, tm);
+}
+
+static inline int rtc_tm_to_time(struct rtc_time *tm, unsigned long *time)
+{
+	*time = rtc_tm_to_time64(tm);
+
+	return 0;
+}
+
 #include <linux/device.h>
 #include <linux/seq_file.h>
 #include <linux/cdev.h>
diff --git a/include/linux/scmi_protocol.h b/include/linux/scmi_protocol.h
index 9cd312a1f..ecb3aad1a 100644
--- a/include/linux/scmi_protocol.h
+++ b/include/linux/scmi_protocol.h
@@ -8,6 +8,7 @@
 #ifndef _LINUX_SCMI_PROTOCOL_H
 #define _LINUX_SCMI_PROTOCOL_H
 
+#include <linux/bitfield.h>
 #include <linux/device.h>
 #include <linux/notifier.h>
 #include <linux/types.h>
@@ -121,6 +122,7 @@ struct scmi_perf_ops {
 			     unsigned long *rate, unsigned long *power);
 	bool (*fast_switch_possible)(const struct scmi_handle *handle,
 				     struct device *dev);
+	bool (*power_scale_mw_get)(const struct scmi_handle *handle);
 };
 
 /**
@@ -148,13 +150,180 @@ struct scmi_power_ops {
 			 u32 *state);
 };
 
+/**
+ * scmi_sensor_reading  - represent a timestamped read
+ *
+ * Used by @reading_get_timestamped method.
+ *
+ * @value: The signed value sensor read.
+ * @timestamp: An unsigned timestamp for the sensor read, as provided by
+ *	       SCMI platform. Set to zero when not available.
+ */
+struct scmi_sensor_reading {
+	long long value;
+	unsigned long long timestamp;
+};
+
+/**
+ * scmi_range_attrs  - specifies a sensor or axis values' range
+ * @min_range: The minimum value which can be represented by the sensor/axis.
+ * @max_range: The maximum value which can be represented by the sensor/axis.
+ */
+struct scmi_range_attrs {
+	long long min_range;
+	long long max_range;
+};
+
+/**
+ * scmi_sensor_axis_info  - describes one sensor axes
+ * @id: The axes ID.
+ * @type: Axes type. Chosen amongst one of @enum scmi_sensor_class.
+ * @scale: Power-of-10 multiplier applied to the axis unit.
+ * @name: NULL-terminated string representing axes name as advertised by
+ *	  SCMI platform.
+ * @extended_attrs: Flag to indicate the presence of additional extended
+ *		    attributes for this axes.
+ * @resolution: Extended attribute representing the resolution of the axes.
+ *		Set to 0 if not reported by this axes.
+ * @exponent: Extended attribute representing the power-of-10 multiplier that
+ *	      is applied to the resolution field. Set to 0 if not reported by
+ *	      this axes.
+ * @attrs: Extended attributes representing minimum and maximum values
+ *	   measurable by this axes. Set to 0 if not reported by this sensor.
+ */
+struct scmi_sensor_axis_info {
+	unsigned int id;
+	unsigned int type;
+	int scale;
+	char name[SCMI_MAX_STR_SIZE];
+	bool extended_attrs;
+	unsigned int resolution;
+	int exponent;
+	struct scmi_range_attrs attrs;
+};
+
+/**
+ * scmi_sensor_intervals_info  - describes number and type of available update
+ * intervals
+ * @segmented: Flag for segmented intervals' representation. When True there
+ *	       will be exactly 3 intervals in @desc, with each entry
+ *	       representing a member of a segment in this order:
+ *	       {lowest update interval, highest update interval, step size}
+ * @count: Number of intervals described in @desc.
+ * @desc: Array of @count interval descriptor bitmask represented as detailed in
+ *	  the SCMI specification: it can be accessed using the accompanying
+ *	  macros.
+ * @prealloc_pool: A minimal preallocated pool of desc entries used to avoid
+ *		   lesser-than-64-bytes dynamic allocation for small @count
+ *		   values.
+ */
+struct scmi_sensor_intervals_info {
+	bool segmented;
+	unsigned int count;
+#define SCMI_SENS_INTVL_SEGMENT_LOW	0
+#define SCMI_SENS_INTVL_SEGMENT_HIGH	1
+#define SCMI_SENS_INTVL_SEGMENT_STEP	2
+	unsigned int *desc;
+#define SCMI_SENS_INTVL_GET_SECS(x)		FIELD_GET(GENMASK(20, 5), (x))
+#define SCMI_SENS_INTVL_GET_EXP(x)					\
+	({								\
+		int __signed_exp = FIELD_GET(GENMASK(4, 0), (x));	\
+									\
+		if (__signed_exp & BIT(4))				\
+			__signed_exp |= GENMASK(31, 5);			\
+		__signed_exp;						\
+	})
+#define SCMI_MAX_PREALLOC_POOL			16
+	unsigned int prealloc_pool[SCMI_MAX_PREALLOC_POOL];
+};
+
+/**
+ * struct scmi_sensor_info - represents information related to one of the
+ * available sensors.
+ * @id: Sensor ID.
+ * @type: Sensor type. Chosen amongst one of @enum scmi_sensor_class.
+ * @scale: Power-of-10 multiplier applied to the sensor unit.
+ * @num_trip_points: Number of maximum configurable trip points.
+ * @async: Flag for asynchronous read support.
+ * @update: Flag for continuouos update notification support.
+ * @timestamped: Flag for timestamped read support.
+ * @tstamp_scale: Power-of-10 multiplier applied to the sensor timestamps to
+ *		  represent it in seconds.
+ * @num_axis: Number of supported axis if any. Reported as 0 for scalar sensors.
+ * @axis: Pointer to an array of @num_axis descriptors.
+ * @intervals: Descriptor of available update intervals.
+ * @sensor_config: A bitmask reporting the current sensor configuration as
+ *		   detailed in the SCMI specification: it can accessed and
+ *		   modified through the accompanying macros.
+ * @name: NULL-terminated string representing sensor name as advertised by
+ *	  SCMI platform.
+ * @extended_scalar_attrs: Flag to indicate the presence of additional extended
+ *			   attributes for this sensor.
+ * @sensor_power: Extended attribute representing the average power
+ *		  consumed by the sensor in microwatts (uW) when it is active.
+ *		  Reported here only for scalar sensors.
+ *		  Set to 0 if not reported by this sensor.
+ * @resolution: Extended attribute representing the resolution of the sensor.
+ *		Reported here only for scalar sensors.
+ *		Set to 0 if not reported by this sensor.
+ * @exponent: Extended attribute representing the power-of-10 multiplier that is
+ *	      applied to the resolution field.
+ *	      Reported here only for scalar sensors.
+ *	      Set to 0 if not reported by this sensor.
+ * @scalar_attrs: Extended attributes representing minimum and maximum
+ *		  measurable values by this sensor.
+ *		  Reported here only for scalar sensors.
+ *		  Set to 0 if not reported by this sensor.
+ */
 struct scmi_sensor_info {
-	u32 id;
-	u8 type;
-	s8 scale;
-	u8 num_trip_points;
+	unsigned int id;
+	unsigned int type;
+	int scale;
+	unsigned int num_trip_points;
 	bool async;
+	bool update;
+	bool timestamped;
+	int tstamp_scale;
+	unsigned int num_axis;
+	struct scmi_sensor_axis_info *axis;
+	struct scmi_sensor_intervals_info intervals;
+	unsigned int sensor_config;
+#define SCMI_SENS_CFG_UPDATE_SECS_MASK		GENMASK(31, 16)
+#define SCMI_SENS_CFG_GET_UPDATE_SECS(x)				\
+	FIELD_GET(SCMI_SENS_CFG_UPDATE_SECS_MASK, (x))
+
+#define SCMI_SENS_CFG_UPDATE_EXP_MASK		GENMASK(15, 11)
+#define SCMI_SENS_CFG_GET_UPDATE_EXP(x)					\
+	({								\
+		int __signed_exp =					\
+			FIELD_GET(SCMI_SENS_CFG_UPDATE_EXP_MASK, (x));	\
+									\
+		if (__signed_exp & BIT(4))				\
+			__signed_exp |= GENMASK(31, 5);			\
+		__signed_exp;						\
+	})
+
+#define SCMI_SENS_CFG_ROUND_MASK		GENMASK(10, 9)
+#define SCMI_SENS_CFG_ROUND_AUTO		2
+#define SCMI_SENS_CFG_ROUND_UP			1
+#define SCMI_SENS_CFG_ROUND_DOWN		0
+
+#define SCMI_SENS_CFG_TSTAMP_ENABLED_MASK	BIT(1)
+#define SCMI_SENS_CFG_TSTAMP_ENABLE		1
+#define SCMI_SENS_CFG_TSTAMP_DISABLE		0
+#define SCMI_SENS_CFG_IS_TSTAMP_ENABLED(x)				\
+	FIELD_GET(SCMI_SENS_CFG_TSTAMP_ENABLED_MASK, (x))
+
+#define SCMI_SENS_CFG_SENSOR_ENABLED_MASK	BIT(0)
+#define SCMI_SENS_CFG_SENSOR_ENABLE		1
+#define SCMI_SENS_CFG_SENSOR_DISABLE		0
 	char name[SCMI_MAX_STR_SIZE];
+#define SCMI_SENS_CFG_IS_ENABLED(x)		FIELD_GET(BIT(0), (x))
+	bool extended_scalar_attrs;
+	unsigned int sensor_power;
+	unsigned int resolution;
+	int exponent;
+	struct scmi_range_attrs scalar_attrs;
 };
 
 /*
@@ -163,11 +332,100 @@ struct scmi_sensor_info {
  */
 enum scmi_sensor_class {
 	NONE = 0x0,
+	UNSPEC = 0x1,
 	TEMPERATURE_C = 0x2,
+	TEMPERATURE_F = 0x3,
+	TEMPERATURE_K = 0x4,
 	VOLTAGE = 0x5,
 	CURRENT = 0x6,
 	POWER = 0x7,
 	ENERGY = 0x8,
+	CHARGE = 0x9,
+	VOLTAMPERE = 0xA,
+	NITS = 0xB,
+	LUMENS = 0xC,
+	LUX = 0xD,
+	CANDELAS = 0xE,
+	KPA = 0xF,
+	PSI = 0x10,
+	NEWTON = 0x11,
+	CFM = 0x12,
+	RPM = 0x13,
+	HERTZ = 0x14,
+	SECS = 0x15,
+	MINS = 0x16,
+	HOURS = 0x17,
+	DAYS = 0x18,
+	WEEKS = 0x19,
+	MILS = 0x1A,
+	INCHES = 0x1B,
+	FEET = 0x1C,
+	CUBIC_INCHES = 0x1D,
+	CUBIC_FEET = 0x1E,
+	METERS = 0x1F,
+	CUBIC_CM = 0x20,
+	CUBIC_METERS = 0x21,
+	LITERS = 0x22,
+	FLUID_OUNCES = 0x23,
+	RADIANS = 0x24,
+	STERADIANS = 0x25,
+	REVOLUTIONS = 0x26,
+	CYCLES = 0x27,
+	GRAVITIES = 0x28,
+	OUNCES = 0x29,
+	POUNDS = 0x2A,
+	FOOT_POUNDS = 0x2B,
+	OUNCE_INCHES = 0x2C,
+	GAUSS = 0x2D,
+	GILBERTS = 0x2E,
+	HENRIES = 0x2F,
+	FARADS = 0x30,
+	OHMS = 0x31,
+	SIEMENS = 0x32,
+	MOLES = 0x33,
+	BECQUERELS = 0x34,
+	PPM = 0x35,
+	DECIBELS = 0x36,
+	DBA = 0x37,
+	DBC = 0x38,
+	GRAYS = 0x39,
+	SIEVERTS = 0x3A,
+	COLOR_TEMP_K = 0x3B,
+	BITS = 0x3C,
+	BYTES = 0x3D,
+	WORDS = 0x3E,
+	DWORDS = 0x3F,
+	QWORDS = 0x40,
+	PERCENTAGE = 0x41,
+	PASCALS = 0x42,
+	COUNTS = 0x43,
+	GRAMS = 0x44,
+	NEWTON_METERS = 0x45,
+	HITS = 0x46,
+	MISSES = 0x47,
+	RETRIES = 0x48,
+	OVERRUNS = 0x49,
+	UNDERRUNS = 0x4A,
+	COLLISIONS = 0x4B,
+	PACKETS = 0x4C,
+	MESSAGES = 0x4D,
+	CHARS = 0x4E,
+	ERRORS = 0x4F,
+	CORRECTED_ERRS = 0x50,
+	UNCORRECTABLE_ERRS = 0x51,
+	SQ_MILS = 0x52,
+	SQ_INCHES = 0x53,
+	SQ_FEET = 0x54,
+	SQ_CM = 0x55,
+	SQ_METERS = 0x56,
+	RADIANS_SEC = 0x57,
+	BPM = 0x58,
+	METERS_SEC_SQUARED = 0x59,
+	METERS_SEC = 0x5A,
+	CUBIC_METERS_SEC = 0x5B,
+	MM_MERCURY = 0x5C,
+	RADIANS_SEC_SQUARED = 0x5D,
+	OEM_UNIT = 0xFF
 };
 
 /**
@@ -178,6 +436,13 @@ enum scmi_sensor_class {
  * @info_get: get the information of the specified sensor
  * @trip_point_config: selects and configures a trip-point of interest
  * @reading_get: gets the current value of the sensor
+ * @reading_get_timestamped: gets the current value and timestamp, when
+ *			     available, of the sensor. (as of v3.0 spec)
+ *			     Supports multi-axis sensors for sensors which
+ *			     supports it and if the @reading array size of
+ *			     @count entry equals the sensor num_axis
+ * @config_get: Get sensor current configuration
+ * @config_set: Set sensor current configuration
  */
 struct scmi_sensor_ops {
 	int (*count_get)(const struct scmi_handle *handle);
@@ -187,6 +452,13 @@ struct scmi_sensor_ops {
 				 u32 sensor_id, u8 trip_id, u64 trip_value);
 	int (*reading_get)(const struct scmi_handle *handle, u32 sensor_id,
 			   u64 *value);
+	int (*reading_get_timestamped)(const struct scmi_handle *handle,
+				       u32 sensor_id, u8 count,
+				       struct scmi_sensor_reading *readings);
+	int (*config_get)(const struct scmi_handle *handle,
+			  u32 sensor_id, u32 *sensor_config);
+	int (*config_set)(const struct scmi_handle *handle,
+			  u32 sensor_id, u32 sensor_config);
 };
 
 /**
@@ -209,6 +481,64 @@ struct scmi_reset_ops {
 	int (*deassert)(const struct scmi_handle *handle, u32 domain);
 };
 
+/**
+ * struct scmi_voltage_info - describe one available SCMI Voltage Domain
+ *
+ * @id: the domain ID as advertised by the platform
+ * @segmented: defines the layout of the entries of array @levels_uv.
+ *	       - when True the entries are to be interpreted as triplets,
+ *	         each defining a segment representing a range of equally
+ *	         space voltages: <lowest_volts>, <highest_volt>, <step_uV>
+ *	       - when False the entries simply represent a single discrete
+ *	         supported voltage level
+ * @negative_volts_allowed: True if any of the entries of @levels_uv represent
+ *			    a negative voltage.
+ * @attributes: represents Voltage Domain advertised attributes
+ * @name: name assigned to the Voltage Domain by platform
+ * @num_levels: number of total entries in @levels_uv.
+ * @levels_uv: array of entries describing the available voltage levels for
+ *	       this domain.
+ */
+struct scmi_voltage_info {
+	unsigned int id;
+	bool segmented;
+	bool negative_volts_allowed;
+	unsigned int attributes;
+	char name[SCMI_MAX_STR_SIZE];
+	unsigned int num_levels;
+#define SCMI_VOLTAGE_SEGMENT_LOW	0
+#define SCMI_VOLTAGE_SEGMENT_HIGH	1
+#define SCMI_VOLTAGE_SEGMENT_STEP	2
+	int *levels_uv;
+};
+
+/**
+ * struct scmi_voltage_ops - represents the various operations provided
+ * by SCMI Voltage Protocol
+ *
+ * @num_domains_get: get the count of voltage domains provided by SCMI
+ * @info_get: get the information of the specified domain
+ * @config_set: set the config for the specified domain
+ * @config_get: get the config of the specified domain
+ * @level_set: set the voltage level for the specified domain
+ * @level_get: get the voltage level of the specified domain
+ */
+struct scmi_voltage_ops {
+	int (*num_domains_get)(const struct scmi_handle *handle);
+	const struct scmi_voltage_info __must_check *(*info_get)
+		(const struct scmi_handle *handle, u32 domain_id);
+	int (*config_set)(const struct scmi_handle *handle, u32 domain_id,
+			  u32 config);
+#define	SCMI_VOLTAGE_ARCH_STATE_OFF		0x0
+#define	SCMI_VOLTAGE_ARCH_STATE_ON		0x7
+	int (*config_get)(const struct scmi_handle *handle, u32 domain_id,
+			  u32 *config);
+	int (*level_set)(const struct scmi_handle *handle, u32 domain_id,
+			 u32 flags, s32 volt_uV);
+	int (*level_get)(const struct scmi_handle *handle, u32 domain_id,
+			 s32 *volt_uV);
+};
+
 /**
  * struct scmi_notify_ops  - represents notifications' operations provided by
  * SCMI core
@@ -262,6 +592,7 @@ struct scmi_notify_ops {
  * @clk_ops: pointer to set of clock protocol operations
  * @sensor_ops: pointer to set of sensor protocol operations
  * @reset_ops: pointer to set of reset protocol operations
+ * @voltage_ops: pointer to set of voltage protocol operations
  * @notify_ops: pointer to set of notifications related operations
  * @perf_priv: pointer to private data structure specific to performance
  *	protocol(for internal use only)
@@ -273,6 +604,8 @@ struct scmi_notify_ops {
  *	protocol(for internal use only)
  * @reset_priv: pointer to private data structure specific to reset
  *	protocol(for internal use only)
+ * @voltage_priv: pointer to private data structure specific to voltage
+ *	protocol(for internal use only)
  * @notify_priv: pointer to private data structure specific to notifications
  *	(for internal use only)
  */
@@ -284,6 +617,7 @@ struct scmi_handle {
 	const struct scmi_power_ops *power_ops;
 	const struct scmi_sensor_ops *sensor_ops;
 	const struct scmi_reset_ops *reset_ops;
+	const struct scmi_voltage_ops *voltage_ops;
 	const struct scmi_notify_ops *notify_ops;
 	/* for protocol internal use */
 	void *perf_priv;
@@ -291,6 +625,7 @@ struct scmi_handle {
 	void *power_priv;
 	void *sensor_priv;
 	void *reset_priv;
+	void *voltage_priv;
 	void *notify_priv;
 	void *system_priv;
 };
@@ -303,6 +638,7 @@ enum scmi_std_protocol {
 	SCMI_PROTOCOL_CLOCK = 0x14,
 	SCMI_PROTOCOL_SENSOR = 0x15,
 	SCMI_PROTOCOL_RESET = 0x16,
+	SCMI_PROTOCOL_VOLTAGE = 0x17,
 };
 
 enum scmi_system_events {
@@ -386,6 +722,7 @@ enum scmi_notification_events {
 	SCMI_EVENT_PERFORMANCE_LIMITS_CHANGED = 0x0,
 	SCMI_EVENT_PERFORMANCE_LEVEL_CHANGED = 0x1,
 	SCMI_EVENT_SENSOR_TRIP_POINT_EVENT = 0x0,
+	SCMI_EVENT_SENSOR_UPDATE = 0x1,
 	SCMI_EVENT_RESET_ISSUED = 0x0,
 	SCMI_EVENT_BASE_ERROR_EVENT = 0x0,
 	SCMI_EVENT_SYSTEM_POWER_STATE_NOTIFIER = 0x0,
@@ -427,6 +764,14 @@ struct scmi_sensor_trip_point_report {
 	unsigned int	trip_point_desc;
 };
 
+struct scmi_sensor_update_report {
+	ktime_t				timestamp;
+	unsigned int			agent_id;
+	unsigned int			sensor_id;
+	unsigned int			readings_count;
+	struct scmi_sensor_reading	readings[];
+};
+
 struct scmi_reset_issued_report {
 	ktime_t		timestamp;
 	unsigned int	agent_id;
diff --git a/include/linux/skbuff.h b/include/linux/skbuff.h
index acbf1875a..8d56b70d9 100644
--- a/include/linux/skbuff.h
+++ b/include/linux/skbuff.h
@@ -1067,6 +1067,7 @@ static inline void consume_skb(struct sk_buff *skb)
 #endif
 
 void __consume_stateless_skb(struct sk_buff *skb);
+void skb_recycle(struct sk_buff *skb);
 void  __kfree_skb(struct sk_buff *skb);
 extern struct kmem_cache *skbuff_head_cache;
 
diff --git a/include/linux/spi/spi-mem.h b/include/linux/spi/spi-mem.h
index 159463cc6..2b65c9edc 100644
--- a/include/linux/spi/spi-mem.h
+++ b/include/linux/spi/spi-mem.h
@@ -311,6 +311,9 @@ void spi_controller_dma_unmap_mem_op_data(struct spi_controller *ctlr,
 bool spi_mem_default_supports_op(struct spi_mem *mem,
 				 const struct spi_mem_op *op);
 
+bool spi_mem_dtr_supports_op(struct spi_mem *mem,
+			     const struct spi_mem_op *op);
+
 #else
 static inline int
 spi_controller_dma_map_mem_op_data(struct spi_controller *ctlr,
@@ -334,6 +337,12 @@ bool spi_mem_default_supports_op(struct spi_mem *mem,
 	return false;
 }
 
+static inline
+bool spi_mem_dtr_supports_op(struct spi_mem *mem,
+			     const struct spi_mem_op *op)
+{
+	return false;
+}
 #endif /* CONFIG_SPI_MEM */
 
 int spi_mem_adjust_op_size(struct spi_mem *mem, struct spi_mem_op *op);
diff --git a/include/linux/timekeeping.h b/include/linux/timekeeping.h
index 7f7e4a3f4..948dfe68e 100644
--- a/include/linux/timekeeping.h
+++ b/include/linux/timekeeping.h
@@ -3,7 +3,7 @@
 #define _LINUX_TIMEKEEPING_H
 
 #include <linux/errno.h>
-
+#include <linux/time.h>
 /* Included from linux/ktime.h */
 
 void timekeeping_init(void);
@@ -16,6 +16,7 @@ extern void xtime_update(unsigned long ticks);
 /*
  * Get and set timeofday
  */
+extern void do_gettimeofday(struct old_timeval32 *tv);
 extern int do_settimeofday64(const struct timespec64 *ts);
 extern int do_sys_settimeofday64(const struct timespec64 *tv,
 				 const struct timezone *tz);
@@ -95,6 +96,14 @@ static inline ktime_t ktime_get_boottime(void)
 	return ktime_get_with_offset(TK_OFFS_BOOT);
 }
 
+/*
+ * Timespec interfaces utilizing the ktime based ones
+ */
+static inline void get_monotonic_boottime(struct timespec64 *ts)
+{
+	*ts = ktime_to_timespec64(ktime_get_boottime());
+}
+
 static inline ktime_t ktime_get_coarse_boottime(void)
 {
 	return ktime_get_coarse_with_offset(TK_OFFS_BOOT);
diff --git a/include/linux/uio_driver.h b/include/linux/uio_driver.h
index 54bf6b118..baa6f1fee 100644
--- a/include/linux/uio_driver.h
+++ b/include/linux/uio_driver.h
@@ -31,6 +31,7 @@ struct uio_map;
  * @offs:               offset of device memory within the page
  * @size:		size of IO (multiple of page size)
  * @memtype:		type of memory addr points to
+ * @readonly:		true of region is read-only
  * @internal_addr:	ioremap-ped version of addr, for driver internal use
  * @map:		for use by the UIO core only.
  */
@@ -40,6 +41,7 @@ struct uio_mem {
 	unsigned long		offs;
 	resource_size_t		size;
 	int			memtype;
+	bool			readonly;
 	void __iomem		*internal_addr;
 	struct uio_map		*map;
 };
diff --git a/include/linux/usb/chipidea.h b/include/linux/usb/chipidea.h
index 025b41687..c19d602a1 100644
--- a/include/linux/usb/chipidea.h
+++ b/include/linux/usb/chipidea.h
@@ -62,6 +62,8 @@ struct ci_hdrc_platform_data {
 #define CI_HDRC_REQUIRES_ALIGNED_DMA	BIT(13)
 #define CI_HDRC_IMX_IS_HSIC		BIT(14)
 #define CI_HDRC_PMQOS			BIT(15)
+/* PHY enter low power mode when bus suspend */
+#define CI_HDRC_HOST_SUSP_PHY_LPM	BIT(16)
 	enum usb_dr_mode	dr_mode;
 #define CI_HDRC_CONTROLLER_RESET_EVENT		0
 #define CI_HDRC_CONTROLLER_STOPPED_EVENT	1
@@ -101,5 +103,6 @@ struct platform_device *ci_hdrc_add_device(struct device *dev,
 void ci_hdrc_remove_device(struct platform_device *pdev);
 /* Get current available role */
 enum usb_dr_mode ci_hdrc_query_available_role(struct platform_device *pdev);
+int hw_controller_reset(struct ci_hdrc *ci);
 
 #endif
diff --git a/include/linux/usb/hcd.h b/include/linux/usb/hcd.h
index 3dbb42c63..beef40765 100644
--- a/include/linux/usb/hcd.h
+++ b/include/linux/usb/hcd.h
@@ -409,7 +409,10 @@ struct hc_driver {
 	int	(*find_raw_port_number)(struct usb_hcd *, int);
 	/* Call for power on/off the port if necessary */
 	int	(*port_power)(struct usb_hcd *hcd, int portnum, bool enable);
-
+	/* Call for SINGLE_STEP_SET_FEATURE Test for USB2 EH certification */
+#define EHSET_TEST_SINGLE_STEP_SET_FEATURE 0x06
+	int	(*submit_single_step_set_feature)(struct usb_hcd *,
+			struct urb *, int);
 };
 
 static inline int hcd_giveback_urb_in_bh(struct usb_hcd *hcd)
@@ -474,6 +477,14 @@ int usb_hcd_setup_local_mem(struct usb_hcd *hcd, phys_addr_t phys_addr,
 
 struct platform_device;
 extern void usb_hcd_platform_shutdown(struct platform_device *dev);
+#ifdef CONFIG_USB_HCD_TEST_MODE
+extern int ehset_single_step_set_feature(struct usb_hcd *hcd, int port);
+#else
+static inline int ehset_single_step_set_feature(struct usb_hcd *hcd, int port)
+{
+	return 0;
+}
+#endif /* CONFIG_USB_HCD_TEST_MODE */
 
 #ifdef CONFIG_USB_PCI
 struct pci_dev;
diff --git a/include/linux/usb/phy.h b/include/linux/usb/phy.h
index e4de6bc1f..086f95f7b 100644
--- a/include/linux/usb/phy.h
+++ b/include/linux/usb/phy.h
@@ -63,6 +63,13 @@ enum usb_otg_state {
 	OTG_STATE_A_VBUS_ERR,
 };
 
+/* The usb role of phy to be working with */
+enum usb_current_mode {
+	CUR_USB_MODE_NONE,
+	CUR_USB_MODE_HOST,
+	CUR_USB_MODE_DEVICE,
+};
+
 struct usb_phy;
 struct usb_otg;
 
@@ -155,6 +162,15 @@ struct usb_phy {
 	 * manually detect the charger type.
 	 */
 	enum usb_charger_type (*charger_detect)(struct usb_phy *x);
+
+	int	(*notify_suspend)(struct usb_phy *x,
+			enum usb_device_speed speed);
+	int	(*notify_resume)(struct usb_phy *x,
+			enum usb_device_speed speed);
+
+	int	(*set_mode)(struct usb_phy *x,
+			enum usb_current_mode mode);
+
 };
 
 /* for board-specific init logic */
@@ -213,6 +229,15 @@ usb_phy_vbus_off(struct usb_phy *x)
 	return x->set_vbus(x, false);
 }
 
+static inline int
+usb_phy_set_mode(struct usb_phy *x, enum usb_current_mode mode)
+{
+	if (!x || !x->set_mode)
+		return 0;
+
+	return x->set_mode(x, mode);
+}
+
 /* for usb host and peripheral controller drivers */
 #if IS_ENABLED(CONFIG_USB_PHY)
 extern struct usb_phy *usb_get_phy(enum usb_phy_type type);
@@ -334,6 +359,24 @@ usb_phy_notify_disconnect(struct usb_phy *x, enum usb_device_speed speed)
 		return 0;
 }
 
+static inline int usb_phy_notify_suspend
+	(struct usb_phy *x, enum usb_device_speed speed)
+{
+	if (x && x->notify_suspend)
+		return x->notify_suspend(x, speed);
+	else
+		return 0;
+}
+
+static inline int usb_phy_notify_resume
+	(struct usb_phy *x, enum usb_device_speed speed)
+{
+	if (x && x->notify_resume)
+		return x->notify_resume(x, speed);
+	else
+		return 0;
+}
+
 /* notifiers */
 static inline int
 usb_register_notifier(struct usb_phy *x, struct notifier_block *nb)
diff --git a/include/linux/usb/typec.h b/include/linux/usb/typec.h
index 6be558045..9593dbce8 100644
--- a/include/linux/usb/typec.h
+++ b/include/linux/usb/typec.h
@@ -270,6 +270,7 @@ void *typec_get_drvdata(struct typec_port *port);
 
 int typec_find_pwr_opmode(const char *name);
 int typec_find_orientation(const char *name);
+int typec_find_port_power_opmode(const char *name);
 int typec_find_port_power_role(const char *name);
 int typec_find_power_role(const char *name);
 int typec_find_port_data_role(const char *name);
diff --git a/include/media/v4l2-chip-ident.h b/include/media/v4l2-chip-ident.h
new file mode 100644
index 000000000..b4c8416c3
--- /dev/null
+++ b/include/media/v4l2-chip-ident.h
@@ -0,0 +1,355 @@
+/*
+    v4l2 chip identifiers header
+
+    This header provides a list of chip identifiers that can be returned
+    through the VIDIOC_DBG_G_CHIP_IDENT ioctl.
+
+    Copyright (C) 2011-2014 Freescale Semiconductor, Inc.
+    Copyright (C) 2007 Hans Verkuil <hverkuil@xs4all.nl>
+
+    This program is free software; you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation; either version 2 of the License, or
+    (at your option) any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with this program; if not, write to the Free Software
+    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#ifndef V4L2_CHIP_IDENT_H_
+#define V4L2_CHIP_IDENT_H_
+
+/* VIDIOC_DBG_G_CHIP_IDENT: identifies the actual chip installed on the board */
+
+/* KEEP THIS LIST ORDERED BY ID!
+   Otherwise it will be hard to see which ranges are already in use when
+   adding support to a new chip family. */
+enum {
+	/* general idents: reserved range 0-49 */
+	V4L2_IDENT_NONE      = 0,       /* No chip matched */
+	V4L2_IDENT_AMBIGUOUS = 1,       /* Match too general, multiple chips matched */
+	V4L2_IDENT_UNKNOWN   = 2,       /* Chip found, but cannot identify */
+
+	/* module tvaudio: reserved range 50-99 */
+	V4L2_IDENT_TVAUDIO = 50,	/* A tvaudio chip, unknown which it is exactly */
+
+	/* Sony IMX074 */
+	V4L2_IDENT_IMX074 = 74,
+
+	/* module saa7110: just ident 100 */
+	V4L2_IDENT_SAA7110 = 100,
+
+	/* module saa7115: reserved range 101-149 */
+	V4L2_IDENT_SAA7111 = 101,
+	V4L2_IDENT_SAA7111A = 102,
+	V4L2_IDENT_SAA7113 = 103,
+	V4L2_IDENT_SAA7114 = 104,
+	V4L2_IDENT_SAA7115 = 105,
+	V4L2_IDENT_SAA7118 = 108,
+
+	V4L2_IDENT_GM7113C = 140,
+
+	/* module saa7127: reserved range 150-199 */
+	V4L2_IDENT_SAA7127 = 157,
+	V4L2_IDENT_SAA7129 = 159,
+
+	/* module cx25840: reserved range 200-249 */
+	V4L2_IDENT_CX25836 = 236,
+	V4L2_IDENT_CX25837 = 237,
+	V4L2_IDENT_CX25840 = 240,
+	V4L2_IDENT_CX25841 = 241,
+	V4L2_IDENT_CX25842 = 242,
+	V4L2_IDENT_CX25843 = 243,
+
+	/* OmniVision sensors: reserved range 250-299 */
+	V4L2_IDENT_OV7670 = 250,
+	V4L2_IDENT_OV7720 = 251,
+	V4L2_IDENT_OV7725 = 252,
+	V4L2_IDENT_OV7660 = 253,
+	V4L2_IDENT_OV9650 = 254,
+	V4L2_IDENT_OV9655 = 255,
+	V4L2_IDENT_SOI968 = 256,
+	V4L2_IDENT_OV9640 = 257,
+	V4L2_IDENT_OV6650 = 258,
+	V4L2_IDENT_OV2640 = 259,
+	V4L2_IDENT_OV9740 = 260,
+	V4L2_IDENT_OV5642 = 261,
+
+	/* module saa7146: reserved range 300-309 */
+	V4L2_IDENT_SAA7146 = 300,
+
+	/* Conexant MPEG encoder/decoders: reserved range 400-420 */
+	V4L2_IDENT_CX23418_843 = 403, /* Integrated A/V Decoder on the '418 */
+	V4L2_IDENT_CX23415 = 415,
+	V4L2_IDENT_CX23416 = 416,
+	V4L2_IDENT_CX23417 = 417,
+	V4L2_IDENT_CX23418 = 418,
+
+	/* module bt819: reserved range 810-819 */
+	V4L2_IDENT_BT815A = 815,
+	V4L2_IDENT_BT817A = 817,
+	V4L2_IDENT_BT819A = 819,
+
+	/* module au0828 */
+	V4L2_IDENT_AU0828 = 828,
+
+	/* module bttv: ident 848 + 849 */
+	V4L2_IDENT_BT848 = 848,
+	V4L2_IDENT_BT849 = 849,
+
+	/* module bt856: just ident 856 */
+	V4L2_IDENT_BT856 = 856,
+
+	/* module bt866: just ident 866 */
+	V4L2_IDENT_BT866 = 866,
+
+	/* module bttv: ident 878 + 879 */
+	V4L2_IDENT_BT878 = 878,
+	V4L2_IDENT_BT879 = 879,
+
+	/* module ks0127: reserved range 1120-1129 */
+	V4L2_IDENT_KS0122S = 1122,
+	V4L2_IDENT_KS0127  = 1127,
+	V4L2_IDENT_KS0127B = 1128,
+
+	/* module indycam: just ident 2000 */
+	V4L2_IDENT_INDYCAM = 2000,
+
+	/* module vp27smpx: just ident 2700 */
+	V4L2_IDENT_VP27SMPX = 2700,
+
+	/* module vpx3220: reserved range: 3210-3229 */
+	V4L2_IDENT_VPX3214C = 3214,
+	V4L2_IDENT_VPX3216B = 3216,
+	V4L2_IDENT_VPX3220A = 3220,
+
+	/* VX855 just ident 3409 */
+	/* Other via devs could use 3314, 3324, 3327, 3336, 3364, 3353 */
+	V4L2_IDENT_VIA_VX855 = 3409,
+
+	/* module tvp5150 */
+	V4L2_IDENT_TVP5150 = 5150,
+
+	/* module saa5246a: just ident 5246 */
+	V4L2_IDENT_SAA5246A = 5246,
+
+	/* module saa5249: just ident 5249 */
+	V4L2_IDENT_SAA5249 = 5249,
+
+	/* module cs5345: just ident 5345 */
+	V4L2_IDENT_CS5345 = 5345,
+
+	/* module tea6415c: just ident 6415 */
+	V4L2_IDENT_TEA6415C = 6415,
+
+	/* module tea6420: just ident 6420 */
+	V4L2_IDENT_TEA6420 = 6420,
+
+	/* module saa6588: just ident 6588 */
+	V4L2_IDENT_SAA6588 = 6588,
+
+	/* module vs6624: just ident 6624 */
+	V4L2_IDENT_VS6624 = 6624,
+
+	/* module saa6752hs: reserved range 6750-6759 */
+	V4L2_IDENT_SAA6752HS = 6752,
+	V4L2_IDENT_SAA6752HS_AC3 = 6753,
+
+	/* modules tef6862: just ident 6862 */
+	V4L2_IDENT_TEF6862 = 6862,
+
+	/* module tvp7002: just ident 7002 */
+	V4L2_IDENT_TVP7002 = 7002,
+
+	/* module adv7170: just ident 7170 */
+	V4L2_IDENT_ADV7170 = 7170,
+
+	/* module adv7175: just ident 7175 */
+	V4L2_IDENT_ADV7175 = 7175,
+
+	/* module adv7180: just ident 7180 */
+	V4L2_IDENT_ADV7180 = 7180,
+
+	/* module adv7183: just ident 7183 */
+	V4L2_IDENT_ADV7183 = 7183,
+
+	/* module saa7185: just ident 7185 */
+	V4L2_IDENT_SAA7185 = 7185,
+
+	/* module saa7191: just ident 7191 */
+	V4L2_IDENT_SAA7191 = 7191,
+
+	/* module ths7303: just ident 7303 */
+	V4L2_IDENT_THS7303 = 7303,
+
+	/* module adv7343: just ident 7343 */
+	V4L2_IDENT_ADV7343 = 7343,
+
+	/* module ths7353: just ident 7353 */
+	V4L2_IDENT_THS7353 = 7353,
+
+	/* module adv7393: just ident 7393 */
+	V4L2_IDENT_ADV7393 = 7393,
+
+	/* module adv7604: just ident 7604 */
+	V4L2_IDENT_ADV7604 = 7604,
+
+	/* module saa7706h: just ident 7706 */
+	V4L2_IDENT_SAA7706H = 7706,
+
+	/* module mt9v011, just ident 8243 */
+	V4L2_IDENT_MT9V011 = 8243,
+
+	/* module wm8739: just ident 8739 */
+	V4L2_IDENT_WM8739 = 8739,
+
+	/* module wm8775: just ident 8775 */
+	V4L2_IDENT_WM8775 = 8775,
+
+	/* Marvell controllers starting at 8801 */
+	V4L2_IDENT_CAFE = 8801,
+	V4L2_IDENT_ARMADA610 = 8802,
+
+	/* AKM AK8813/AK8814 */
+	V4L2_IDENT_AK8813 = 8813,
+	V4L2_IDENT_AK8814 = 8814,
+
+	/* module cx23885 and cx25840 */
+	V4L2_IDENT_CX23885    = 8850,
+	V4L2_IDENT_CX23885_AV = 8851, /* Integrated A/V decoder */
+	V4L2_IDENT_CX23887    = 8870,
+	V4L2_IDENT_CX23887_AV = 8871, /* Integrated A/V decoder */
+	V4L2_IDENT_CX23888    = 8880,
+	V4L2_IDENT_CX23888_AV = 8881, /* Integrated A/V decoder */
+	V4L2_IDENT_CX23888_IR = 8882, /* Integrated infrared controller */
+
+	/* module ad9389b: just ident 9389 */
+	V4L2_IDENT_AD9389B = 9389,
+
+	/* module tda9840: just ident 9840 */
+	V4L2_IDENT_TDA9840 = 9840,
+
+	/* module tw9910: just ident 9910 */
+	V4L2_IDENT_TW9910 = 9910,
+
+	/* module sn9c20x: just ident 10000 */
+	V4L2_IDENT_SN9C20X = 10000,
+
+	/* module cx231xx and cx25840 */
+	V4L2_IDENT_CX2310X_AV = 23099, /* Integrated A/V decoder; not in '100 */
+	V4L2_IDENT_CX23100    = 23100,
+	V4L2_IDENT_CX23101    = 23101,
+	V4L2_IDENT_CX23102    = 23102,
+
+	/* module msp3400: reserved range 34000-34999 for msp34xx */
+	V4L2_IDENT_MSPX4XX  = 34000, /* generic MSPX4XX identifier, only
+					use internally (tveeprom.c). */
+
+	V4L2_IDENT_MSP3400B = 34002,
+	V4L2_IDENT_MSP3400C = 34003,
+	V4L2_IDENT_MSP3400D = 34004,
+	V4L2_IDENT_MSP3400G = 34007,
+	V4L2_IDENT_MSP3401G = 34017,
+	V4L2_IDENT_MSP3402G = 34027,
+	V4L2_IDENT_MSP3405D = 34054,
+	V4L2_IDENT_MSP3405G = 34057,
+	V4L2_IDENT_MSP3407D = 34074,
+	V4L2_IDENT_MSP3407G = 34077,
+
+	V4L2_IDENT_MSP3410B = 34102,
+	V4L2_IDENT_MSP3410C = 34103,
+	V4L2_IDENT_MSP3410D = 34104,
+	V4L2_IDENT_MSP3410G = 34107,
+	V4L2_IDENT_MSP3411G = 34117,
+	V4L2_IDENT_MSP3412G = 34127,
+	V4L2_IDENT_MSP3415D = 34154,
+	V4L2_IDENT_MSP3415G = 34157,
+	V4L2_IDENT_MSP3417D = 34174,
+	V4L2_IDENT_MSP3417G = 34177,
+
+	V4L2_IDENT_MSP3420G = 34207,
+	V4L2_IDENT_MSP3421G = 34217,
+	V4L2_IDENT_MSP3422G = 34227,
+	V4L2_IDENT_MSP3425G = 34257,
+	V4L2_IDENT_MSP3427G = 34277,
+
+	V4L2_IDENT_MSP3430G = 34307,
+	V4L2_IDENT_MSP3431G = 34317,
+	V4L2_IDENT_MSP3435G = 34357,
+	V4L2_IDENT_MSP3437G = 34377,
+
+	V4L2_IDENT_MSP3440G = 34407,
+	V4L2_IDENT_MSP3441G = 34417,
+	V4L2_IDENT_MSP3442G = 34427,
+	V4L2_IDENT_MSP3445G = 34457,
+	V4L2_IDENT_MSP3447G = 34477,
+
+	V4L2_IDENT_MSP3450G = 34507,
+	V4L2_IDENT_MSP3451G = 34517,
+	V4L2_IDENT_MSP3452G = 34527,
+	V4L2_IDENT_MSP3455G = 34557,
+	V4L2_IDENT_MSP3457G = 34577,
+
+	V4L2_IDENT_MSP3460G = 34607,
+	V4L2_IDENT_MSP3461G = 34617,
+	V4L2_IDENT_MSP3465G = 34657,
+	V4L2_IDENT_MSP3467G = 34677,
+
+	/* module msp3400: reserved range 44000-44999 for msp44xx */
+	V4L2_IDENT_MSP4400G = 44007,
+	V4L2_IDENT_MSP4408G = 44087,
+	V4L2_IDENT_MSP4410G = 44107,
+	V4L2_IDENT_MSP4418G = 44187,
+	V4L2_IDENT_MSP4420G = 44207,
+	V4L2_IDENT_MSP4428G = 44287,
+	V4L2_IDENT_MSP4440G = 44407,
+	V4L2_IDENT_MSP4448G = 44487,
+	V4L2_IDENT_MSP4450G = 44507,
+	V4L2_IDENT_MSP4458G = 44587,
+
+	/* Micron CMOS sensor chips: 45000-45099 */
+	V4L2_IDENT_MT9M001C12ST		= 45000,
+	V4L2_IDENT_MT9M001C12STM	= 45005,
+	V4L2_IDENT_MT9M111		= 45007,
+	V4L2_IDENT_MT9M112		= 45008,
+	V4L2_IDENT_MT9V022IX7ATC	= 45010, /* No way to detect "normal" I77ATx */
+	V4L2_IDENT_MT9V022IX7ATM	= 45015, /* and "lead free" IA7ATx chips */
+	V4L2_IDENT_MT9T031		= 45020,
+	V4L2_IDENT_MT9T111		= 45021,
+	V4L2_IDENT_MT9T112		= 45022,
+	V4L2_IDENT_MT9V111		= 45031,
+	V4L2_IDENT_MT9V112		= 45032,
+
+	/* HV7131R CMOS sensor: just ident 46000 */
+	V4L2_IDENT_HV7131R		= 46000,
+
+	/* Sharp RJ54N1CB0C, 0xCB0C = 51980 */
+	V4L2_IDENT_RJ54N1CB0C = 51980,
+
+	/* module m52790: just ident 52790 */
+	V4L2_IDENT_M52790 = 52790,
+
+	/* module cs53132a: just ident 53132 */
+	V4L2_IDENT_CS53l32A = 53132,
+
+	/* modules upd61151 MPEG2 encoder: just ident 54000 */
+	V4L2_IDENT_UPD61161 = 54000,
+	/* modules upd61152 MPEG2 encoder with AC3: just ident 54001 */
+	V4L2_IDENT_UPD61162 = 54001,
+
+	/* module upd64031a: just ident 64031 */
+	V4L2_IDENT_UPD64031A = 64031,
+
+	/* module upd64083: just ident 64083 */
+	V4L2_IDENT_UPD64083 = 64083,
+
+	/* Don't just add new IDs at the end: KEEP THIS LIST ORDERED BY ID! */
+};
+
+#endif
diff --git a/include/media/v4l2-ioctl.h b/include/media/v4l2-ioctl.h
index 86878fba3..69886908b 100644
--- a/include/media/v4l2-ioctl.h
+++ b/include/media/v4l2-ioctl.h
@@ -554,6 +554,8 @@ struct v4l2_ioctl_ops {
 	int (*vidioc_g_chip_info)(struct file *file, void *fh,
 				  struct v4l2_dbg_chip_info *chip);
 #endif
+	int (*vidioc_g_chip_ident)     (struct file *file, void *fh,
+					struct v4l2_dbg_chip_ident *chip);
 
 	int (*vidioc_enum_framesizes)(struct file *file, void *fh,
 				      struct v4l2_frmsizeenum *fsize);
diff --git a/include/media/v4l2-subdev.h b/include/media/v4l2-subdev.h
index 73150520c..b966b7593 100644
--- a/include/media/v4l2-subdev.h
+++ b/include/media/v4l2-subdev.h
@@ -88,6 +88,7 @@ struct v4l2_decode_vbi_line {
 /*
  * Core ops: it is highly recommended to implement at least these ops:
  *
+ * g_chip_ident
  * log_status
  * g_register
  * s_register
@@ -189,6 +190,7 @@ struct v4l2_subdev_io_pin_config {
  * @unsubscribe_event: remove event subscription from the control framework.
  */
 struct v4l2_subdev_core_ops {
+	int (*g_chip_ident)(struct v4l2_subdev *sd, struct v4l2_dbg_chip_ident *chip);
 	int (*log_status)(struct v4l2_subdev *sd);
 	int (*s_io_pin_config)(struct v4l2_subdev *sd, size_t n,
 				      struct v4l2_subdev_io_pin_config *pincfg);
@@ -392,6 +394,10 @@ struct v4l2_mbus_frame_desc {
  *
  * @g_pixelaspect: callback to return the pixelaspect ratio.
  *
+ * @g_parm: callback for VIDIOC_G_PARM() ioctl handler code.
+ *
+ * @s_parm: callback for VIDIOC_S_PARM() ioctl handler code.
+ *
  * @g_frame_interval: callback for VIDIOC_SUBDEV_G_FRAME_INTERVAL()
  *		      ioctl handler code.
  *
@@ -423,6 +429,8 @@ struct v4l2_subdev_video_ops {
 	int (*g_input_status)(struct v4l2_subdev *sd, u32 *status);
 	int (*s_stream)(struct v4l2_subdev *sd, int enable);
 	int (*g_pixelaspect)(struct v4l2_subdev *sd, struct v4l2_fract *aspect);
+	int (*g_parm)(struct v4l2_subdev *sd, struct v4l2_streamparm *param);
+	int (*s_parm)(struct v4l2_subdev *sd, struct v4l2_streamparm *param);
 	int (*g_frame_interval)(struct v4l2_subdev *sd,
 				struct v4l2_subdev_frame_interval *interval);
 	int (*s_frame_interval)(struct v4l2_subdev *sd,
diff --git a/include/net/sch_generic.h b/include/net/sch_generic.h
index 9226a84dc..b3a424a92 100644
--- a/include/net/sch_generic.h
+++ b/include/net/sch_generic.h
@@ -37,8 +37,15 @@ enum qdisc_state_t {
 	__QDISC_STATE_SCHED,
 	__QDISC_STATE_DEACTIVATED,
 	__QDISC_STATE_MISSED,
+	__QDISC_STATE_DRAINING,
 };
 
+#define QDISC_STATE_MISSED	BIT(__QDISC_STATE_MISSED)
+#define QDISC_STATE_DRAINING	BIT(__QDISC_STATE_DRAINING)
+
+#define QDISC_STATE_NON_EMPTY	(QDISC_STATE_MISSED | \
+					QDISC_STATE_DRAINING)
+
 struct qdisc_size_table {
 	struct rcu_head		rcu;
 	struct list_head	list;
@@ -145,6 +152,11 @@ static inline bool qdisc_is_running(struct Qdisc *qdisc)
 	return (raw_read_seqcount(&qdisc->running) & 1) ? true : false;
 }
 
+static inline bool nolock_qdisc_is_empty(const struct Qdisc *qdisc)
+{
+	return !(READ_ONCE(qdisc->state) & QDISC_STATE_NON_EMPTY);
+}
+
 static inline bool qdisc_is_percpu_stats(const struct Qdisc *q)
 {
 	return q->flags & TCQ_F_CPUSTATS;
diff --git a/include/net/tsn.h b/include/net/tsn.h
new file mode 100644
index 000000000..f1c53bae7
--- /dev/null
+++ b/include/net/tsn.h
@@ -0,0 +1,114 @@
+/* SPDX-License-Identifier: (GPL-2.0+ OR BSD-3-Clause) */
+/* Copyright 2017-2019 NXP */
+
+#ifndef __TSN_H__
+#define __TSN_H__
+
+#include <linux/notifier.h>
+#include <uapi/linux/tsn.h>
+
+enum tsn_notifier_type {
+	TSN_QBV_CONFIGCHANGETIME_ARRIVE = 1,
+};
+
+struct tsn_notifier_info {
+	struct net_device *dev;
+	union {
+		struct tsn_qbv_conf qbv_notify;
+		struct tsn_qci_psfp_sgi_conf qci_notify;
+	} ntdata;
+};
+
+static inline struct net_device *
+tsn_notifier_info_to_dev(const struct tsn_notifier_info *info)
+{
+	return info->dev;
+}
+
+struct tsn_ops {
+	void (*device_init)(struct net_device *ndev);
+	void (*device_deinit)(struct net_device *ndev);
+	u32 (*get_capability)(struct net_device *ndev);
+	/* Qbv standard */
+	int (*qbv_set)(struct net_device *ndev, struct tsn_qbv_conf *qbvconf);
+	int (*qbv_get)(struct net_device *ndev, struct tsn_qbv_conf *qbvconf);
+	int (*qbv_get_status)(struct net_device *ndev,
+				struct tsn_qbv_status *qbvstat);
+	int (*cb_streamid_set)(struct net_device *ndev, u32 index,
+				bool enable, struct tsn_cb_streamid *sid);
+	int (*cb_streamid_get)(struct net_device *ndev, u32 index,
+				struct tsn_cb_streamid *sid);
+	int (*cb_streamid_counters_get)(struct net_device *ndev, u32 index,
+				struct tsn_cb_streamid_counters *sidcounter);
+	int (*qci_get_maxcap)(struct net_device *ndev,
+				struct tsn_qci_psfp_stream_param *qcicapa);
+	int (*qci_sfi_set)(struct net_device *ndev, u32 index, bool enable,
+				struct tsn_qci_psfp_sfi_conf *sficonf);
+	/* return: 0 stream filter instance not valid
+	 * 1 stream filter instance valid
+	 * -1 error happened
+	 */
+	int (*qci_sfi_get)(struct net_device *ndev, u32 index,
+				struct tsn_qci_psfp_sfi_conf *sficonf);
+	int (*qci_sfi_counters_get)(struct net_device *ndev, u32 index,
+				struct tsn_qci_psfp_sfi_counters *sficounter);
+	int (*qci_sgi_set)(struct net_device *ndev, u32 index,
+				struct tsn_qci_psfp_sgi_conf *sgiconf);
+	int (*qci_sgi_get)(struct net_device *ndev, u32 index,
+				struct tsn_qci_psfp_sgi_conf *sgiconf);
+	int (*qci_sgi_status_get)(struct net_device *ndev, u16 index,
+				struct tsn_psfp_sgi_status *sgistat);
+	int (*qci_fmi_set)(struct net_device *ndev, u32 index, bool enable,
+				struct tsn_qci_psfp_fmi *fmi);
+	int (*qci_fmi_get)(struct net_device *ndev, u32 index,
+				struct tsn_qci_psfp_fmi *fmi,
+				struct tsn_qci_psfp_fmi_counters *counters);
+	int (*cbs_set)(struct net_device *ndev, u8 tc, u8 bw);
+	int (*cbs_get)(struct net_device *ndev, u8 tc);
+	/* To set a 8 bits vector shows 8 traffic classes
+	 * preemtable(1) or express(0)
+	 */
+	int (*qbu_set)(struct net_device *ndev, u8 ptvector);
+	/* To get port preemtion status */
+	int (*qbu_get)(struct net_device *ndev,
+				struct tsn_preempt_status *preemptstat);
+	int (*tsd_set)(struct net_device *ndev, struct tsn_tsd *tsd);
+	int (*tsd_get)(struct net_device *ndev, struct tsn_tsd_status *stats);
+	int (*ct_set)(struct net_device *ndev, u8 cut_thru);
+	int (*cbgen_set)(struct net_device *ndev, u32 index,
+			 struct tsn_seq_gen_conf *seqgen);
+	int (*cbrec_set)(struct net_device *ndev, u32 index,
+			 struct tsn_seq_rec_conf *seqrec);
+	int (*cb_get)(struct net_device *ndev, u32 index,
+		      struct tsn_cb_status  *c);
+	int (*dscp_set)(struct net_device *ndev, bool enable,
+			const u8 dscp_ix,
+			struct tsn_qos_switch_dscp_conf *c);
+};
+
+enum ethdev_type {
+	TSN_SWITCH,
+	TSN_ENDPOINT,
+};
+
+#define GROUP_OFFSET_SWITCH 256
+
+struct tsn_port {
+	u16 groupid;
+	struct tsn_ops *tsnops;
+	struct net_device *netdev;
+	struct list_head list;
+	enum ethdev_type type;
+	u8 tc_nums;
+	struct tsn_notifier_info nd;
+};
+
+struct tsn_port *tsn_get_port(struct net_device *ndev);
+int register_tsn_notifier(struct notifier_block *nb);
+int unregister_tsn_notifier(struct notifier_block *nb);
+int call_tsn_notifiers(unsigned long val, struct net_device *dev,
+			     struct tsn_notifier_info *info);
+int tsn_port_register(struct net_device *netdev,
+				struct tsn_ops *tsnops, u16 groupid);
+void tsn_port_unregister(struct net_device *netdev);
+#endif
diff --git a/include/soc/fsl/dpaa2-global.h b/include/soc/fsl/dpaa2-global.h
index 2bfc379d3..632b73bd5 100644
--- a/include/soc/fsl/dpaa2-global.h
+++ b/include/soc/fsl/dpaa2-global.h
@@ -189,4 +189,78 @@ static inline bool dpaa2_cscn_state_congested(struct dpaa2_dq *cscn)
 	return !!(cscn->scn.state & DPAA2_CSCN_STATE_CG);
 }
 
+/* Data Path Order Restoration API
+ * Contains initialization APIs and runtime APIs for the Order Restoration
+ */
+
+/** Order Restoration properties */
+
+/**
+ * Create a new Order Point Record option
+ */
+#define OPR_OPT_CREATE 0x1
+/**
+ * Retire an existing Order Point Record option
+ */
+#define OPR_OPT_RETIRE 0x2
+
+/**
+ * struct opr_cfg - Structure representing OPR configuration
+ * @oprrws: Order point record (OPR) restoration window size (0 to 5)
+ *			0 - Window size is 32 frames.
+ *			1 - Window size is 64 frames.
+ *			2 - Window size is 128 frames.
+ *			3 - Window size is 256 frames.
+ *			4 - Window size is 512 frames.
+ *			5 - Window size is 1024 frames.
+ * @oa: OPR auto advance NESN window size (0 disabled, 1 enabled)
+ * @olws: OPR acceptable late arrival window size (0 to 3)
+ *			0 - Disabled. Late arrivals are always rejected.
+ *			1 - Window size is 32 frames.
+ *			2 - Window size is the same as the OPR restoration
+ *				window size configured in the OPRRWS field.
+ *			3 - Window size is 8192 frames. Late arrivals are
+ *				always accepted.
+ * @oeane: Order restoration list (ORL) resource exhaustion
+ *			advance NESN enable (0 disabled, 1 enabled)
+ * @oloe: OPR loose ordering enable (0 disabled, 1 enabled)
+ */
+struct opr_cfg {
+	u8 oprrws;
+	u8 oa;
+	u8 olws;
+	u8 oeane;
+	u8 oloe;
+};
+
+/**
+ * struct opr_qry - Structure representing OPR configuration
+ * @enable: Enabled state
+ * @rip: Retirement In Progress
+ * @ndsn: Next dispensed sequence number
+ * @nesn: Next expected sequence number
+ * @ea_hseq: Early arrival head sequence number
+ * @hseq_nlis: HSEQ not last in sequence
+ * @ea_tseq: Early arrival tail sequence number
+ * @tseq_nlis: TSEQ not last in sequence
+ * @ea_tptr: Early arrival tail pointer
+ * @ea_hptr: Early arrival head pointer
+ * @opr_id: Order Point Record ID
+ * @opr_vid: Order Point Record Virtual ID
+ */
+struct opr_qry {
+	char enable;
+	char rip;
+	u16 ndsn;
+	u16 nesn;
+	u16 ea_hseq;
+	char hseq_nlis;
+	u16 ea_tseq;
+	char tseq_nlis;
+	u16 ea_tptr;
+	u16 ea_hptr;
+	u16 opr_id;
+	u16 opr_vid;
+};
+
 #endif /* __FSL_DPAA2_GLOBAL_H */
diff --git a/include/soc/fsl/dpaa2-io.h b/include/soc/fsl/dpaa2-io.h
index c9d849924..280f889e2 100644
--- a/include/soc/fsl/dpaa2-io.h
+++ b/include/soc/fsl/dpaa2-io.h
@@ -125,6 +125,18 @@ struct dpaa2_io_store *dpaa2_io_store_create(unsigned int max_frames,
 void dpaa2_io_store_destroy(struct dpaa2_io_store *s);
 struct dpaa2_dq *dpaa2_io_store_next(struct dpaa2_io_store *s, int *is_last);
 
+/* Order Restoration Support */
+int dpaa2_io_service_enqueue_orp_fq(struct dpaa2_io *d, u32 fqid,
+				    const struct dpaa2_fd *fd, u16 orpid,
+				    u16 seqnum, int last);
+
+int dpaa2_io_service_enqueue_orp_qd(struct dpaa2_io *d, u32 qdid, u8 prio,
+				    u16 qdbin, const struct dpaa2_fd *fd,
+				    u16 orpid, u16 seqnum, int last);
+
+int dpaa2_io_service_orp_seqnum_drop(struct dpaa2_io *d, u16 orpid,
+				     u16 seqnum);
+
 int dpaa2_io_query_fq_count(struct dpaa2_io *d, u32 fqid,
 			    u32 *fcnt, u32 *bcnt);
 int dpaa2_io_query_bp_count(struct dpaa2_io *d, u16 bpid,
diff --git a/include/soc/imx/gpc.h b/include/soc/imx/gpc.h
new file mode 100644
index 000000000..6a976e6aa
--- /dev/null
+++ b/include/soc/imx/gpc.h
@@ -0,0 +1,7 @@
+#ifndef __SOC_IMX_GPC_H
+#define __SOC_IMX_GPC_H
+
+void imx_gpc_hold_m4_in_sleep(void);
+void imx_gpc_release_m4_in_sleep(void);
+
+#endif /* __SOC_IMX_GPC_H */
diff --git a/include/soc/imx/imx-secvio-sc.h b/include/soc/imx/imx-secvio-sc.h
new file mode 100644
index 000000000..2d5f2a015
--- /dev/null
+++ b/include/soc/imx/imx-secvio-sc.h
@@ -0,0 +1,178 @@
+/* SPDX-License-Identifier: GPL-2.0+ */
+/*
+ * Copyright 2019 NXP
+ */
+
+#ifndef _MISC_IMX_SECVIO_SC_H_
+#define _MISC_IMX_SECVIO_SC_H_
+
+#include <linux/kernel.h>
+#include <linux/notifier.h>
+
+/* Bitmask of the security violation status bit in the HPSVS register */
+#define HPSVS__LP_SEC_VIO__MASK BIT(31)
+#define HPSVS__SW_LPSV__MASK    BIT(15)
+#define HPSVS__SW_FSV__MASK     BIT(14)
+#define HPSVS__SW_SV__MASK      BIT(13)
+#define HPSVS__SV5__MASK        BIT(5)
+#define HPSVS__SV4__MASK        BIT(4)
+#define HPSVS__SV3__MASK        BIT(3)
+#define HPSVS__SV2__MASK        BIT(2)
+#define HPSVS__SV1__MASK        BIT(1)
+#define HPSVS__SV0__MASK        BIT(0)
+
+/* Bitmask of all security violation status bit in the HPSVS register */
+#define HPSVS__ALL_SV__MASK (HPSVS__LP_SEC_VIO__MASK | \
+			     HPSVS__SW_LPSV__MASK | \
+			     HPSVS__SW_FSV__MASK | \
+			     HPSVS__SW_SV__MASK | \
+			     HPSVS__SV5__MASK | \
+			     HPSVS__SV4__MASK | \
+			     HPSVS__SV3__MASK | \
+			     HPSVS__SV2__MASK | \
+			     HPSVS__SV1__MASK | \
+			     HPSVS__SV0__MASK)
+
+/*
+ * Bitmask of the security violation and tampers status bit in the LPS register
+ */
+#define LPS__ESVD__MASK  BIT(16)
+#define LPS__ET2D__MASK  BIT(10)
+#define LPS__ET1D__MASK  BIT(9)
+#define LPS__WMT2D__MASK BIT(8)
+#define LPS__WMT1D__MASK BIT(7)
+#define LPS__VTD__MASK   BIT(6)
+#define LPS__TTD__MASK   BIT(5)
+#define LPS__CTD__MASK   BIT(4)
+#define LPS__PGD__MASK   BIT(3)
+#define LPS__MCR__MASK   BIT(2)
+#define LPS__SRTCR__MASK BIT(1)
+#define LPS__LPTA__MASK  BIT(0)
+
+/*
+ * Bitmask of all security violation and tampers status bit in the LPS register
+ */
+#define LPS__ALL_TP__MASK (LPS__ESVD__MASK | \
+			   LPS__ET2D__MASK | \
+			   LPS__ET1D__MASK | \
+			   LPS__WMT2D__MASK | \
+			   LPS__WMT1D__MASK | \
+			   LPS__VTD__MASK | \
+			   LPS__TTD__MASK | \
+			   LPS__CTD__MASK | \
+			   LPS__PGD__MASK | \
+			   LPS__MCR__MASK | \
+			   LPS__SRTCR__MASK | \
+			   LPS__LPTA__MASK)
+
+/*
+ * Bitmask of the security violation and tampers status bit in the LPTDS
+ * register
+ */
+#define LPTDS__ET10D__MASK  BIT(7)
+#define LPTDS__ET9D__MASK   BIT(6)
+#define LPTDS__ET8D__MASK   BIT(5)
+#define LPTDS__ET7D__MASK   BIT(4)
+#define LPTDS__ET6D__MASK   BIT(3)
+#define LPTDS__ET5D__MASK   BIT(2)
+#define LPTDS__ET4D__MASK   BIT(1)
+#define LPTDS__ET3D__MASK   BIT(0)
+
+/*
+ * Bitmask of all security violation and tampers status bit in the LPTDS
+ * register
+ */
+#define LPTDS__ALL_TP__MASK (LPTDS__ET10D__MASK | \
+			     LPTDS__ET9D__MASK | \
+			     LPTDS__ET8D__MASK | \
+			     LPTDS__ET7D__MASK | \
+			     LPTDS__ET6D__MASK | \
+			     LPTDS__ET5D__MASK | \
+			     LPTDS__ET4D__MASK | \
+			     LPTDS__ET3D__MASK)
+
+/* Struct for notification */
+/**
+ * struct secvio_sc_notifier_info - Information about the status of the SNVS
+ * @hpsvs:   status from register HPSVS
+ * @lps: status from register LPS
+ * @lptds: status from register LPTDS
+ */
+struct secvio_sc_notifier_info {
+	u32 hpsvs;
+	u32 lps;
+	u32 lptds;
+};
+
+/**
+ * register_imx_secvio_sc_notifier() - Register a notifier
+ *
+ * @nb: The notifier block structure
+ *
+ * Register a function to notify to the imx-secvio-sc module. The function
+ * will be notified when a check of the state of the SNVS happens: called by
+ * a user or triggered by an interruption form the SNVS.
+ *
+ * The struct secvio_sc_notifier_info is passed as data to the notifier.
+ *
+ * Return: 0 in case of success
+ */
+int register_imx_secvio_sc_notifier(struct notifier_block *nb);
+
+/**
+ * unregister_imx_secvio_sc_notifier() - Unregister a notifier
+ *
+ * @nb: The notifier block structure
+ *
+ * Return: 0 in case of success
+ */
+int unregister_imx_secvio_sc_notifier(struct notifier_block *nb);
+
+/**
+ * imx_secvio_sc_get_state() - Get the state of the SNVS
+ *
+ * @info: The structure containing the state of the SNVS
+ *
+ * Return: 0 in case of success
+ */
+int imx_secvio_sc_get_state(struct secvio_sc_notifier_info *info);
+
+/**
+ * imx_secvio_sc_check_state() - Check the state of the SNVS
+ *
+ * If a security violation or a tamper is detected, the list of notifier
+ * (registered using register_imx_secvio_sc_notifier() ) will be called
+ *
+ * Return: 0 in case of success
+ */
+int imx_secvio_sc_check_state(void);
+
+/**
+ * imx_secvio_sc_clear_state() - Clear the state of the SNVS
+ *
+ * @hpsvs: Value to write to HPSVS register
+ * @lps:   Value to write to LPS register
+ * @lptds: Value to write to LPTDSregister
+ *
+ * The function will write the value provided to the corresponding register
+ * which will clear the status of the bits set.
+ *
+ * Return: 0 in case of success
+ */
+int imx_secvio_sc_clear_state(u32 hpsvs, u32 lps, u32 lptds);
+
+/* Commands of the ioctl interface */
+enum ioctl_cmd_t {
+	GET_STATE,
+	CHECK_STATE,
+	CLEAR_STATE,
+};
+
+/* Definition for the ioctl interface */
+#define IMX_SECVIO_SC_GET_STATE   _IOR('S', GET_STATE, \
+				struct secvio_sc_notifier_info)
+#define IMX_SECVIO_SC_CHECK_STATE _IO('S', CHECK_STATE)
+#define IMX_SECVIO_SC_CLEAR_STATE _IOW('S', CLEAR_STATE, \
+				struct secvio_sc_notifier_info)
+
+#endif /* _MISC_IMX_SECVIO_SC_H_ */
diff --git a/include/soc/imx/imx_sip.h b/include/soc/imx/imx_sip.h
new file mode 100644
index 000000000..082a16f7e
--- /dev/null
+++ b/include/soc/imx/imx_sip.h
@@ -0,0 +1,17 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * Copyright 2019 NXP
+ */
+
+#ifndef __IMX_SIP_H__
+#define __IMX_SIP_H__
+
+#define IMX_SIP_GPC			0xC2000000
+#define IMX_SIP_CONFIG_GPC_PM_DOMAIN	0x03
+
+#define IMX_SIP_SRC			0xc2000005
+#define IMX_SIP_SRC_M4_START		0x00
+#define IMX_SIP_SRC_M4_STARTED		0x01
+#define IMX_SIP_SRC_M4_STOP		0x02
+
+#endif /* __IMX_SIP_H__ */
diff --git a/include/soc/imx/soc.h b/include/soc/imx/soc.h
new file mode 100644
index 000000000..78e055231
--- /dev/null
+++ b/include/soc/imx/soc.h
@@ -0,0 +1,20 @@
+/*
+ * Copyright 2017 NXP
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#ifndef __SOC_IMX8_SOC_H__
+#define __SOC_IMX8_SOC_H__
+
+int check_m4_enabled(void);
+
+#endif
diff --git a/include/soc/imx/src.h b/include/soc/imx/src.h
new file mode 100644
index 000000000..c55c34cd2
--- /dev/null
+++ b/include/soc/imx/src.h
@@ -0,0 +1,6 @@
+#ifndef __SOC_IMX_SRC_H
+#define __SOC_IMX_SRC_H
+
+bool imx_src_is_m4_enabled(void);
+
+#endif /* __SOC_IMX_SRC_H */
diff --git a/include/soc/mscc/ocelot.h b/include/soc/mscc/ocelot.h
index 4971b4586..34303dcf0 100644
--- a/include/soc/mscc/ocelot.h
+++ b/include/soc/mscc/ocelot.h
@@ -59,7 +59,8 @@
  * PGID_MCIPV4: the flooding destinations for IPv4 multicast traffic.
  * PGID_MCIPV6: the flooding destinations for IPv6 multicast traffic.
  */
-#define PGID_CPU			59
+#define PGID_CPU			58
+#define PGID_FRER			59
 #define PGID_UC				60
 #define PGID_MC				61
 #define PGID_MCIPV4			62
@@ -426,6 +427,9 @@ enum ocelot_reg {
 	DEV_MAC_FC_MAC_LOW_CFG,
 	DEV_MAC_FC_MAC_HIGH_CFG,
 	DEV_MAC_STICKY,
+	DEV_MM_ENABLE_CONFIG,
+	DEV_MM_VERIF_CONFIG,
+	DEV_MM_STATUS,
 	PCS1G_CFG,
 	PCS1G_MODE_CFG,
 	PCS1G_SD_CFG,
diff --git a/include/soc/mscc/ocelot_ana.h b/include/soc/mscc/ocelot_ana.h
index 1669481d9..6381c68bb 100644
--- a/include/soc/mscc/ocelot_ana.h
+++ b/include/soc/mscc/ocelot_ana.h
@@ -138,6 +138,9 @@
 #define MACACCESS_CMD_READ                     6
 #define MACACCESS_CMD_WRITE                    7
 
+#define MACACCESS_ENTRY_TYPE_NORMAL		0
+#define MACACCESS_ENTRY_TYPE_LOCKED		1
+
 #define ANA_TABLES_VLANACCESS_VLAN_PORT_MASK(x)           (((x) << 2) & GENMASK(13, 2))
 #define ANA_TABLES_VLANACCESS_VLAN_PORT_MASK_M            GENMASK(13, 2)
 #define ANA_TABLES_VLANACCESS_VLAN_PORT_MASK_X(x)         (((x) & GENMASK(13, 2)) >> 2)
@@ -227,6 +230,11 @@
 #define ANA_TABLES_SFIDACCESS_SFID_TBL_CMD(x)             ((x) & GENMASK(1, 0))
 #define ANA_TABLES_SFIDACCESS_SFID_TBL_CMD_M              GENMASK(1, 0)
 
+#define SFIDACCESS_CMD_IDLE                             0
+#define SFIDACCESS_CMD_READ                             1
+#define SFIDACCESS_CMD_WRITE                            2
+#define SFIDACCESS_CMD_INIT				3
+
 #define ANA_TABLES_SFIDTIDX_SGID_VALID                    BIT(26)
 #define ANA_TABLES_SFIDTIDX_SGID(x)                       (((x) << 18) & GENMASK(25, 18))
 #define ANA_TABLES_SFIDTIDX_SGID_M                        GENMASK(25, 18)
@@ -255,12 +263,20 @@
 #define ANA_SG_CONFIG_REG_3_INIT_IPS(x)                   (((x) << 21) & GENMASK(24, 21))
 #define ANA_SG_CONFIG_REG_3_INIT_IPS_M                    GENMASK(24, 21)
 #define ANA_SG_CONFIG_REG_3_INIT_IPS_X(x)                 (((x) & GENMASK(24, 21)) >> 21)
+#define ANA_SG_CONFIG_REG_3_IPV_VALID                     BIT(24)
+#define ANA_SG_CONFIG_REG_3_IPV_INVALID(x)		  (((x) << 24) & GENMASK(24, 24))
+#define ANA_SG_CONFIG_REG_3_INIT_IPV(x)                   (((x) << 21) & GENMASK(23, 21))
+#define ANA_SG_CONFIG_REG_3_INIT_IPV_M                    GENMASK(23, 21)
+#define ANA_SG_CONFIG_REG_3_INIT_IPV_X(x)                 (((x) & GENMASK(23, 21)) >> 21)
 #define ANA_SG_CONFIG_REG_3_INIT_GATE_STATE               BIT(25)
 
 #define ANA_SG_GCL_GS_CONFIG_RSZ                          0x4
 
 #define ANA_SG_GCL_GS_CONFIG_IPS(x)                       ((x) & GENMASK(3, 0))
 #define ANA_SG_GCL_GS_CONFIG_IPS_M                        GENMASK(3, 0)
+#define ANA_SG_GCL_GS_CONFIG_IPV_VALID                    BIT(3)
+#define ANA_SG_GCL_GS_CONFIG_IPV(x)                       ((x) & GENMASK(2, 0))
+#define ANA_SG_GCL_GS_CONFIG_IPV_M                        GENMASK(2, 0)
 #define ANA_SG_GCL_GS_CONFIG_GATE_STATE                   BIT(4)
 
 #define ANA_SG_GCL_TI_CONFIG_RSZ                          0x4
@@ -271,6 +287,10 @@
 #define ANA_SG_STATUS_REG_3_IPS(x)                        (((x) << 20) & GENMASK(23, 20))
 #define ANA_SG_STATUS_REG_3_IPS_M                         GENMASK(23, 20)
 #define ANA_SG_STATUS_REG_3_IPS_X(x)                      (((x) & GENMASK(23, 20)) >> 20)
+#define ANA_SG_STATUS_REG_3_IPV_VALID                     BIT(23)
+#define ANA_SG_STATUS_REG_3_IPV(x)                        (((x) << 20) & GENMASK(22, 20))
+#define ANA_SG_STATUS_REG_3_IPV_M                         GENMASK(22, 20)
+#define ANA_SG_STATUS_REG_3_IPV_X(x)                      (((x) & GENMASK(22, 20)) >> 20)
 #define ANA_SG_STATUS_REG_3_CONFIG_PENDING                BIT(24)
 
 #define ANA_PORT_VLAN_CFG_GSZ                             0x100
diff --git a/include/soc/mscc/ocelot_dev.h b/include/soc/mscc/ocelot_dev.h
index 0c6021f02..cb1d8f5a6 100644
--- a/include/soc/mscc/ocelot_dev.h
+++ b/include/soc/mscc/ocelot_dev.h
@@ -93,6 +93,29 @@
 #define DEV_MAC_STICKY_TX_FRM_LEN_OVR_STICKY              BIT(1)
 #define DEV_MAC_STICKY_TX_ABORT_STICKY                    BIT(0)
 
+#define DEV_MM_CONFIG_ENABLE_CONFIG_MM_RX_ENA        BIT(0)
+#define DEV_MM_CONFIG_ENABLE_CONFIG_MM_TX_ENA        BIT(4)
+#define DEV_MM_CONFIG_ENABLE_CONFIG_KEEP_S_AFTER_D   BIT(8)
+
+#define DEV_MM_CONFIG_VERIF_CONFIG_PRM_VERIFY_DIS    BIT(0)
+#define DEV_MM_CONFIG_VERIF_CONFIG_PRM_VERIFY_TIME(x) (((x) << 4) & GENMASK(11, 4))
+#define DEV_MM_CONFIG_VERIF_CONFIG_PRM_VERIFY_TIME_M GENMASK(11, 4)
+#define DEV_MM_CONFIG_VERIF_CONFIG_PRM_VERIFY_TIME_X(x) (((x) & GENMASK(11, 4)) >> 4)
+#define DEV_MM_CONFIG_VERIF_CONFIG_VERIF_TIMER_UNITS(x) (((x) << 12) & GENMASK(13, 12))
+#define DEV_MM_CONFIG_VERIF_CONFIG_VERIF_TIMER_UNITS_M GENMASK(13, 12)
+#define DEV_MM_CONFIG_VERIF_CONFIG_VERIF_TIMER_UNITS_X(x) (((x) & GENMASK(13, 12)) >> 12)
+
+#define DEV_MM_STATISTICS_MM_STATUS_PRMPT_ACTIVE_STATUS BIT(0)
+#define DEV_MM_STATISTICS_MM_STATUS_PRMPT_ACTIVE_STICKY BIT(4)
+#define DEV_MM_STATISTICS_MM_STATUS_PRMPT_VERIFY_STATE(x) (((x) << 8) & GENMASK(10, 8))
+#define DEV_MM_STATISTICS_MM_STATUS_PRMPT_VERIFY_STATE_M GENMASK(10, 8)
+#define DEV_MM_STATISTICS_MM_STATUS_PRMPT_VERIFY_STATE_X(x) (((x) & GENMASK(10, 8)) >> 8)
+#define DEV_MM_STATISTICS_MM_STATUS_UNEXP_RX_PFRM_STICKY BIT(12)
+#define DEV_MM_STATISTICS_MM_STATUS_UNEXP_TX_PFRM_STICKY BIT(16)
+#define DEV_MM_STATISTICS_MM_STATUS_MM_RX_FRAME_STATUS BIT(20)
+#define DEV_MM_STATISTICS_MM_STATUS_MM_TX_FRAME_STATUS BIT(24)
+#define DEV_MM_STATISTICS_MM_STATUS_MM_TX_PRMPT_STATUS BIT(28)
+
 #define PCS1G_CFG_LINK_STATUS_TYPE                        BIT(4)
 #define PCS1G_CFG_AN_LINK_CTRL_ENA                        BIT(1)
 #define PCS1G_CFG_PCS_ENA                                 BIT(0)
diff --git a/include/sound/dmaengine_pcm.h b/include/sound/dmaengine_pcm.h
index 8c5e38180..96666efdd 100644
--- a/include/sound/dmaengine_pcm.h
+++ b/include/sound/dmaengine_pcm.h
@@ -66,6 +66,9 @@ struct dma_chan *snd_dmaengine_pcm_get_chan(struct snd_pcm_substream *substream)
  * @chan_name: Custom channel name to use when requesting DMA channel.
  * @fifo_size: FIFO size of the DAI controller in bytes
  * @flags: PCM_DAI flags, only SND_DMAENGINE_PCM_DAI_FLAG_PACK for now
+ * @peripheral_config: peripheral configuration for programming peripheral
+ * for dmaengine transfer
+ * @peripheral_size: peripheral configuration buffer size
  */
 struct snd_dmaengine_dai_dma_data {
 	dma_addr_t addr;
@@ -76,6 +79,8 @@ struct snd_dmaengine_dai_dma_data {
 	const char *chan_name;
 	unsigned int fifo_size;
 	unsigned int flags;
+	void *peripheral_config;
+	size_t peripheral_size;
 };
 
 void snd_dmaengine_pcm_set_config_from_dai_data(
diff --git a/include/sound/soc-component.h b/include/sound/soc-component.h
index 2c790ce95..7fe8d21af 100644
--- a/include/sound/soc-component.h
+++ b/include/sound/soc-component.h
@@ -146,6 +146,8 @@ struct snd_soc_component_driver {
 	int (*mmap)(struct snd_soc_component *component,
 		    struct snd_pcm_substream *substream,
 		    struct vm_area_struct *vma);
+	int (*ack)(struct snd_soc_component *component,
+		   struct snd_pcm_substream *substream);
 
 	const struct snd_compress_ops *compress_ops;
 
diff --git a/include/sound/sof.h b/include/sound/sof.h
index 9aa055289..51ce66b85 100644
--- a/include/sound/sof.h
+++ b/include/sound/sof.h
@@ -51,6 +51,7 @@ struct snd_sof_pdata {
 	/* machine */
 	struct platform_device *pdev_mach;
 	const struct snd_soc_acpi_mach *machine;
+	const char *machine_drv_name; /* machine driver name, set only for OF case */
 
 	void *hw_pdata;
 };
diff --git a/include/trace/events/sunrpc.h b/include/trace/events/sunrpc.h
index 9fe6cdcf2..23db248a7 100644
--- a/include/trace/events/sunrpc.h
+++ b/include/trace/events/sunrpc.h
@@ -1006,6 +1006,7 @@ DEFINE_RPC_XPRT_LIFETIME_EVENT(connect);
 DEFINE_RPC_XPRT_LIFETIME_EVENT(disconnect_auto);
 DEFINE_RPC_XPRT_LIFETIME_EVENT(disconnect_done);
 DEFINE_RPC_XPRT_LIFETIME_EVENT(disconnect_force);
+DEFINE_RPC_XPRT_LIFETIME_EVENT(disconnect_cleanup);
 DEFINE_RPC_XPRT_LIFETIME_EVENT(destroy);
 
 DECLARE_EVENT_CLASS(rpc_xprt_event,
diff --git a/include/uapi/drm/drm_fourcc.h b/include/uapi/drm/drm_fourcc.h
index 5498d7a65..d59b56513 100644
--- a/include/uapi/drm/drm_fourcc.h
+++ b/include/uapi/drm/drm_fourcc.h
@@ -243,6 +243,14 @@ extern "C" {
  */
 #define DRM_FORMAT_NV15		fourcc_code('N', 'V', '1', '5') /* 2x2 subsampled Cr:Cb plane */
 
+/*
+ * A fully packed  2 plane YCbCr
+ * Y1 0-9, Y2 10-19, Y3 20-29, Y4 20-39
+ * ....
+ * U1V1: 0-19, U2V2: 20-39
+ */
+#define DRM_FORMAT_NV12_10LE40	fourcc_code('R', 'K', '2', '0') /* 2x2 subsampled Cr:Cb plane */
+
 /*
  * 2 plane YCbCr MSB aligned
  * index 0 = Y plane, [15:0] Y:x [10:6] little endian
@@ -332,6 +340,8 @@ extern "C" {
 #define DRM_FORMAT_MOD_VENDOR_ARM     0x08
 #define DRM_FORMAT_MOD_VENDOR_ALLWINNER 0x09
 #define DRM_FORMAT_MOD_VENDOR_AMLOGIC 0x0a
+#define DRM_FORMAT_MOD_VENDOR_AMPHION 0xf0
+#define DRM_FORMAT_MOD_VENDOR_VSI     0xf1
 
 /* add more to the end as needed */
 
@@ -565,6 +575,15 @@ extern "C" {
  */
 #define DRM_FORMAT_MOD_VIVANTE_SPLIT_SUPER_TILED fourcc_mod_code(VIVANTE, 4)
 
+	/*
+ * Vivante 64x64 super-tiling with compression layout
+ *
+ * This is a tiled layout using 64x64 pixel super-tiles, where each super-tile
+ * contains 8x4 groups of 2x4 tiles of 4x4 pixels each, all in row-major layout
+ * with compression.
+ */
+#define DRM_FORMAT_MOD_VIVANTE_SUPER_TILED_FC	fourcc_mod_code(VIVANTE, 5)
+
 /* NVIDIA frame buffer modifiers */
 
 /*
@@ -1056,6 +1075,42 @@ drm_fourcc_canonicalize_nvidia_format_mod(__u64 modifier)
  */
 #define AMLOGIC_FBC_OPTION_MEM_SAVING		(1ULL << 0)
 
+/* Amphion tiled layout */
+
+/*
+ * Amphion 8x128 tiling layout
+ *
+ * This is a tiled layout using 8x128 pixel vertical strips, where each strip
+ * contains 1x16 groups of 8x8 pixels in a row-major layout.
+ */
+#define DRM_FORMAT_MOD_AMPHION_TILED fourcc_mod_code(AMPHION, 1)
+
+/* Verisilicon framebuffer modifiers */
+
+/*
+ * Verisilicon 8x4 tiling layout
+ *
+ * This is G1 VPU tiled layout using tiles of 8x4 pixels in a row-major
+ * layout.
+ */
+#define DRM_FORMAT_MOD_VSI_G1_TILED fourcc_mod_code(VSI, 1)
+
+/*
+ * Verisilicon 4x4 tiling layout
+ *
+ * This is G2 VPU tiled layout using tiles of 4x4 pixels in a row-major
+ * layout.
+ */
+#define DRM_FORMAT_MOD_VSI_G2_TILED fourcc_mod_code(VSI, 2)
+
+/*
+ * Verisilicon 4x4 tiling with compression layout
+ *
+ * This is G2 VPU tiled layout using tiles of 4x4 pixels in a row-major
+ * layout with compression.
+ */
+#define DRM_FORMAT_MOD_VSI_G2_TILED_COMPRESSED fourcc_mod_code(VSI, 3)
+
 #if defined(__cplusplus)
 }
 #endif
diff --git a/include/uapi/drm/imx_drm.h b/include/uapi/drm/imx_drm.h
new file mode 100644
index 000000000..e80cad4be
--- /dev/null
+++ b/include/uapi/drm/imx_drm.h
@@ -0,0 +1,89 @@
+/*
+ * Copyright 2017 NXP
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the
+ * Free Software Foundation; either version 2 of the License, or (at your
+ * option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+ * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#ifndef _UAPI_IMX_DRM_H_
+#define _UAPI_IMX_DRM_H_
+
+#include "drm.h"
+
+#if defined(__cplusplus)
+extern "C" {
+#endif
+
+/**
+ * Dpu frame info.
+ *
+ */
+struct drm_imx_dpu_frame_info {
+	__u32   width;
+	__u32   height;
+	__u32	x_offset;
+	__u32	y_offset;
+	__u32	stride;
+	__u32	format;
+	__u64   modifier;
+	__u64	baddr;
+	__u64	uv_addr;
+};
+
+#define DRM_IMX_DPU_SET_CMDLIST                 0x00
+#define DRM_IMX_DPU_WAIT                        0x01
+#define DRM_IMX_DPU_GET_PARAM                   0x02
+
+#define DRM_IOCTL_IMX_DPU_SET_CMDLIST   DRM_IOWR(DRM_COMMAND_BASE + \
+		DRM_IMX_DPU_SET_CMDLIST, struct drm_imx_dpu_set_cmdlist)
+#define DRM_IOCTL_IMX_DPU_WAIT          DRM_IOWR(DRM_COMMAND_BASE + \
+		DRM_IMX_DPU_WAIT, struct drm_imx_dpu_wait)
+#define DRM_IOCTL_IMX_DPU_GET_PARAM     DRM_IOWR(DRM_COMMAND_BASE + \
+		DRM_IMX_DPU_GET_PARAM, enum drm_imx_dpu_param)
+
+/**
+ * struct drm_imx_dpu_set_cmdlist - ioctl argument for
+ * DRM_IMX_DPU_SET_CMDLIST.
+ */
+struct drm_imx_dpu_set_cmdlist {
+	__u64	cmd;
+	__u32	cmd_nr;
+
+	/* reserved */
+	__u64	user_data;
+};
+
+/**
+ * struct drm_imx_dpu_wait - ioctl argument for
+ * DRM_IMX_DPU_WAIT.
+ *
+ */
+struct drm_imx_dpu_wait {
+	/* reserved */
+	__u64   user_data;
+};
+
+/**
+ * enum drm_imx_dpu_param - ioctl argument for
+ * DRM_IMX_DPU_GET_PARAM.
+ *
+ */
+enum drm_imx_dpu_param {
+	DRM_IMX_MAX_DPUS,
+};
+
+#if defined(__cplusplus)
+}
+#endif
+
+#endif /* _UAPI_IMX_DRM_H_ */
diff --git a/include/uapi/linux/caam_keygen.h b/include/uapi/linux/caam_keygen.h
new file mode 100644
index 000000000..061696e10
--- /dev/null
+++ b/include/uapi/linux/caam_keygen.h
@@ -0,0 +1,68 @@
+/* SPDX-License-Identifier: ((GPL-2.0+ WITH Linux-syscall-note) OR BSD-3-Clause) */
+/*
+ * NXP CAAM key generation ioctl and kernel interface
+ *
+ * Copyright 2020 NXP
+ *
+ * This file is used by the NXP CAAM Crypto driver.
+ * It can be included by applications that need to communicate
+ * with the driver via the ioctl interface.
+ */
+
+#ifndef _UAPI_CAAM_KEYGEN_H
+#define _UAPI_CAAM_KEYGEN_H
+
+#include <linux/types.h>
+
+/**
+ * struct caam_keygen_cmd - Structure that contains all the necessary
+ *                          information to transfer user-space data to
+ *                          kernel space. This data is used to generate
+ *                          a black key and encapsulate it into a blob
+ *
+ * @key_enc_len        : Length of the key_enc field
+ * @key_mode_len       : Length of the key_mode field
+ * @key_value_len      : Length of the key_value field
+ * @black_key_len      : Length of the generated black key
+ * @key_enc            : Encrypted Key Type
+ *                       Can be either ecb or ccm (AES-ECB or AES-CCM)
+ * @key_mode           : The key mode used to generate the black key
+ *                       Can be either -s (for random black key) or
+ *                       -t (for black key generated from a plaintext)
+ * @key_value          : Based on the key_mode field, can be either the
+ *                       plaintext (for black key generated from a plaintext)
+ *                       or size of key in case of black key generated
+ *                       from random
+ * @black_key          : Black key data obtained from CAAM
+ * @blob_len           : Length of the blob that encapsulates the black key
+ * @blob               : Blob data obtained from CAAM
+ */
+struct caam_keygen_cmd {
+	__u8 key_enc_len;
+	__u8 key_mode_len;
+	__u16 key_value_len;
+
+	__u32 black_key_len;
+
+	__u64 key_enc;
+	__u64 key_mode;
+	__u64 key_value;
+
+	__u64 black_key;
+
+	__u32 blob_len;
+	__u64 blob;
+};
+
+/* The ioctl type, documented in ioctl-number.txt */
+#define CAAM_KEYGEN_IOCTL_TYPE		'K'
+
+/* Create a key */
+#define CAAM_KEYGEN_IOCTL_CREATE \
+	_IOWR(CAAM_KEYGEN_IOCTL_TYPE, 0, struct caam_keygen_cmd)
+
+/* Import a key from a blob */
+#define CAAM_KEYGEN_IOCTL_IMPORT \
+	_IOWR(CAAM_KEYGEN_IOCTL_TYPE, 1, struct caam_keygen_cmd)
+
+#endif /* _UAPI_CAAM_KEYGEN_H */
diff --git a/include/uapi/linux/dma-buf.h b/include/uapi/linux/dma-buf.h
index 7f30393b9..275c9c3dd 100644
--- a/include/uapi/linux/dma-buf.h
+++ b/include/uapi/linux/dma-buf.h
@@ -27,6 +27,10 @@ struct dma_buf_sync {
 	__u64 flags;
 };
 
+struct dma_buf_phys {
+	unsigned long phys;
+};
+
 #define DMA_BUF_SYNC_READ      (1 << 0)
 #define DMA_BUF_SYNC_WRITE     (2 << 0)
 #define DMA_BUF_SYNC_RW        (DMA_BUF_SYNC_READ | DMA_BUF_SYNC_WRITE)
@@ -46,5 +50,6 @@ struct dma_buf_sync {
 #define DMA_BUF_SET_NAME	_IOW(DMA_BUF_BASE, 1, const char *)
 #define DMA_BUF_SET_NAME_A	_IOW(DMA_BUF_BASE, 1, u32)
 #define DMA_BUF_SET_NAME_B	_IOW(DMA_BUF_BASE, 1, u64)
+#define DMA_BUF_IOCTL_PHYS	_IOW(DMA_BUF_BASE, 10, struct dma_buf_phys)
 
 #endif
diff --git a/include/uapi/linux/fmd/Kbuild b/include/uapi/linux/fmd/Kbuild
new file mode 100644
index 000000000..56a204011
--- /dev/null
+++ b/include/uapi/linux/fmd/Kbuild
@@ -0,0 +1,5 @@
+header-y += integrations/
+header-y += Peripherals/
+
+header-y += ioctls.h
+header-y += net_ioctls.h
diff --git a/include/uapi/linux/fmd/Peripherals/Kbuild b/include/uapi/linux/fmd/Peripherals/Kbuild
new file mode 100644
index 000000000..43883efeb
--- /dev/null
+++ b/include/uapi/linux/fmd/Peripherals/Kbuild
@@ -0,0 +1,4 @@
+header-y += fm_ioctls.h
+header-y += fm_port_ioctls.h
+header-y += fm_pcd_ioctls.h
+header-y += fm_test_ioctls.h
diff --git a/include/uapi/linux/fmd/Peripherals/fm_ioctls.h b/include/uapi/linux/fmd/Peripherals/fm_ioctls.h
new file mode 100644
index 000000000..ff9e66b6d
--- /dev/null
+++ b/include/uapi/linux/fmd/Peripherals/fm_ioctls.h
@@ -0,0 +1,628 @@
+/* Copyright (c) 2008-2012 Freescale Semiconductor, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/**************************************************************************//**
+ @File          fm_ioctls.h
+
+ @Description   FM Char device ioctls
+*//***************************************************************************/
+#ifndef __FM_IOCTLS_H
+#define __FM_IOCTLS_H
+
+
+/**************************************************************************//**
+ @Group         lnx_ioctl_FM_grp Frame Manager Linux IOCTL API
+
+ @Description   FM Linux ioctls definitions and enums
+
+ @{
+*//***************************************************************************/
+
+/**************************************************************************//**
+ @Collection    FM IOCTL device ('/dev') definitions
+*//***************************************************************************/
+#define DEV_FM_NAME                 "fm" /**< Name of the FM chardev */
+
+#define DEV_FM_MINOR_BASE           0
+#define DEV_FM_PCD_MINOR_BASE       (DEV_FM_MINOR_BASE + 1)                                 /*/dev/fmx-pcd */
+#define DEV_FM_OH_PORTS_MINOR_BASE  (DEV_FM_PCD_MINOR_BASE + 1)                             /*/dev/fmx-port-ohy */
+#define DEV_FM_RX_PORTS_MINOR_BASE  (DEV_FM_OH_PORTS_MINOR_BASE + FM_MAX_NUM_OF_OH_PORTS)   /*/dev/fmx-port-rxy */
+#define DEV_FM_TX_PORTS_MINOR_BASE  (DEV_FM_RX_PORTS_MINOR_BASE + FM_MAX_NUM_OF_RX_PORTS)   /*/dev/fmx-port-txy */
+#define DEV_FM_MAX_MINORS           (DEV_FM_TX_PORTS_MINOR_BASE + FM_MAX_NUM_OF_TX_PORTS)
+
+#define FM_IOC_NUM(n)       (n)
+#define FM_PCD_IOC_NUM(n)   (n+20)
+#define FM_PORT_IOC_NUM(n)  (n+70)
+/* @} */
+
+#define IOC_FM_MAX_NUM_OF_PORTS         64
+
+
+/**************************************************************************//**
+ @Description   Enum for defining port types
+                (must match enum e_FmPortType defined in fm_ext.h)
+*//***************************************************************************/
+typedef enum ioc_fm_port_type {
+    e_IOC_FM_PORT_TYPE_OH_OFFLINE_PARSING = 0,  /**< Offline parsing port */
+    e_IOC_FM_PORT_TYPE_RX,                      /**< 1G Rx port */
+    e_IOC_FM_PORT_TYPE_RX_10G,                  /**< 10G Rx port */
+    e_IOC_FM_PORT_TYPE_TX,                      /**< 1G Tx port */
+    e_IOC_FM_PORT_TYPE_TX_10G,                  /**< 10G Tx port */
+    e_IOC_FM_PORT_TYPE_DUMMY
+} ioc_fm_port_type;
+
+
+/**************************************************************************//**
+ @Group         lnx_ioctl_FM_lib_grp FM library
+
+ @Description   FM API functions, definitions and enums
+                The FM module is the main driver module and is a mandatory module
+                for FM driver users. Before any further module initialization,
+                this module must be initialized.
+                The FM is a "single-tone" module. It is responsible of the common
+                HW modules: FPM, DMA, common QMI, common BMI initializations and
+                run-time control routines. This module must be initialized always
+                when working with any of the FM modules.
+                NOTE - We assumes that the FML will be initialize only by core No. 0!
+
+ @{
+*//***************************************************************************/
+
+/**************************************************************************//**
+ @Description   FM Exceptions
+*//***************************************************************************/
+typedef enum ioc_fm_exceptions {
+    e_IOC_FM_EX_DMA_BUS_ERROR,              /**< DMA bus error. */
+    e_IOC_EX_DMA_READ_ECC,               /**< Read Buffer ECC error (Valid for FM rev < 6)*/
+    e_IOC_EX_DMA_SYSTEM_WRITE_ECC,       /**< Write Buffer ECC error on system side (Valid for FM rev < 6)*/
+    e_IOC_EX_DMA_FM_WRITE_ECC,           /**< Write Buffer ECC error on FM side (Valid for FM rev < 6)*/
+    e_IOC_EX_DMA_SINGLE_PORT_ECC,        /**< Single Port ECC error on FM side (Valid for FM rev > 6)*/
+    e_IOC_EX_FPM_STALL_ON_TASKS,         /**< Stall of tasks on FPM */
+    e_IOC_EX_FPM_SINGLE_ECC,             /**< Single ECC on FPM. */
+    e_IOC_EX_FPM_DOUBLE_ECC,             /**< Double ECC error on FPM ram access */
+    e_IOC_EX_QMI_SINGLE_ECC,             /**< Single ECC on QMI. */
+    e_IOC_EX_QMI_DOUBLE_ECC,             /**< Double bit ECC occurred on QMI */
+    e_IOC_EX_QMI_DEQ_FROM_UNKNOWN_PORTID,/**< Dequeue from unknown port id */
+    e_IOC_EX_BMI_LIST_RAM_ECC,           /**< Linked List RAM ECC error */
+    e_IOC_EX_BMI_STORAGE_PROFILE_ECC,    /**< Storage Profile ECC Error */
+    e_IOC_EX_BMI_STATISTICS_RAM_ECC,     /**< Statistics Count RAM ECC Error Enable */
+    e_IOC_EX_BMI_DISPATCH_RAM_ECC,       /**< Dispatch RAM ECC Error Enable */
+    e_IOC_EX_IRAM_ECC,                   /**< Double bit ECC occurred on IRAM*/
+    e_IOC_EX_MURAM_ECC                   /**< Double bit ECC occurred on MURAM*/
+} ioc_fm_exceptions;
+
+/**************************************************************************//**
+ @Group         lnx_ioctl_FM_runtime_control_grp FM Runtime Control Unit
+
+ @Description   FM Runtime control unit API functions, definitions and enums.
+                The FM driver provides a set of control routines for each module.
+                These routines may only be called after the module was fully
+                initialized (both configuration and initialization routines were
+                called). They are typically used to get information from hardware
+                (status, counters/statistics, revision etc.), to modify a current
+                state or to force/enable a required action. Run-time control may
+                be called whenever necessary and as many times as needed.
+ @{
+*//***************************************************************************/
+
+/**************************************************************************//**
+ @Collection   General FM defines.
+ *//***************************************************************************/
+#define IOC_FM_MAX_NUM_OF_VALID_PORTS  (FM_MAX_NUM_OF_OH_PORTS + \
+                                        FM_MAX_NUM_OF_1G_RX_PORTS +  \
+                                        FM_MAX_NUM_OF_10G_RX_PORTS + \
+                                        FM_MAX_NUM_OF_1G_TX_PORTS +  \
+                                        FM_MAX_NUM_OF_10G_TX_PORTS)
+/* @} */
+
+/**************************************************************************//**
+ @Description   Structure for Port bandwidth requirement. Port is identified
+                by type and relative id.
+                (must be identical to t_FmPortBandwidth defined in fm_ext.h)
+*//***************************************************************************/
+typedef struct ioc_fm_port_bandwidth_t {
+    ioc_fm_port_type    type;           /**< FM port type */
+    uint8_t             relative_port_id; /**< Type relative port id */
+    uint8_t             bandwidth;      /**< bandwidth - (in term of percents) */
+} ioc_fm_port_bandwidth_t;
+
+/**************************************************************************//**
+ @Description   A Structure containing an array of Port bandwidth requirements.
+                The user should state the ports requiring bandwidth in terms of
+                percentage - i.e. all port's bandwidths in the array must add
+                up to 100.
+                (must be identical to t_FmPortsBandwidthParams defined in fm_ext.h)
+*//***************************************************************************/
+typedef struct ioc_fm_port_bandwidth_params {
+    uint8_t                     num_of_ports;
+                                /**< num of ports listed in the array below */
+    ioc_fm_port_bandwidth_t     ports_bandwidths[IOC_FM_MAX_NUM_OF_VALID_PORTS];
+                                /**< for each port, it's bandwidth (all port's
+                                  bandwidths must add up to 100.*/
+} ioc_fm_port_bandwidth_params;
+
+/**************************************************************************//**
+ @Description   enum for defining FM counters
+*//***************************************************************************/
+typedef enum ioc_fm_counters {
+    e_IOC_FM_COUNTERS_ENQ_TOTAL_FRAME,              /**< QMI total enqueued frames counter */
+    e_IOC_FM_COUNTERS_DEQ_TOTAL_FRAME,              /**< QMI total dequeued frames counter */
+    e_IOC_FM_COUNTERS_DEQ_0,                        /**< QMI 0 frames from QMan counter */
+    e_IOC_FM_COUNTERS_DEQ_1,                        /**< QMI 1 frames from QMan counter */
+    e_IOC_FM_COUNTERS_DEQ_2,                        /**< QMI 2 frames from QMan counter */
+    e_IOC_FM_COUNTERS_DEQ_3,                        /**< QMI 3 frames from QMan counter */
+    e_IOC_FM_COUNTERS_DEQ_FROM_DEFAULT,             /**< QMI dequeue from default queue counter */
+    e_IOC_FM_COUNTERS_DEQ_FROM_CONTEXT,             /**< QMI dequeue from FQ context counter */
+    e_IOC_FM_COUNTERS_DEQ_FROM_FD,                  /**< QMI dequeue from FD command field counter */
+    e_IOC_FM_COUNTERS_DEQ_CONFIRM,                  /**< QMI dequeue confirm counter */
+} ioc_fm_counters;
+
+typedef struct ioc_fm_obj_t {
+    void            *obj;
+} ioc_fm_obj_t;
+
+/**************************************************************************//**
+ @Description   A structure for returning revision information
+                (must match struct t_FmRevisionInfo declared in fm_ext.h)
+*//***************************************************************************/
+typedef struct ioc_fm_revision_info_t {
+    uint8_t         major;               /**< Major revision */
+    uint8_t         minor;               /**< Minor revision */
+} ioc_fm_revision_info_t;
+
+/**************************************************************************//**
+ @Description   A structure for FM counters
+*//***************************************************************************/
+typedef struct ioc_fm_counters_params_t {
+    ioc_fm_counters cnt;                /**< The requested counter */
+    uint32_t        val;                /**< The requested value to get/set from/into the counter */
+} ioc_fm_counters_params_t;
+
+typedef union ioc_fm_api_version_t {
+    struct {
+        uint8_t major;
+        uint8_t minor;
+        uint8_t respin;
+        uint8_t reserved;
+    } version;
+    uint32_t ver;
+} ioc_fm_api_version_t;
+
+#if (DPAA_VERSION >= 11)
+/**************************************************************************//**
+ @Description   A structure of information about each of the external
+                buffer pools used by a port or storage-profile.
+                (must be identical to t_FmExtPoolParams defined in fm_ext.h)
+*//***************************************************************************/
+typedef struct ioc_fm_ext_pool_params {
+    uint8_t                 id;     /**< External buffer pool id */
+    uint16_t                size;   /**< External buffer pool buffer size */
+} ioc_fm_ext_pool_params;
+
+/**************************************************************************//**
+ @Description   A structure for informing the driver about the external
+                buffer pools allocated in the BM and used by a port or a
+                storage-profile.
+                (must be identical to t_FmExtPools defined in fm_ext.h)
+*//***************************************************************************/
+typedef struct ioc_fm_ext_pools {
+    uint8_t                 num_of_pools_used;     /**< Number of pools use by this port */
+    ioc_fm_ext_pool_params  ext_buf_pool[FM_PORT_MAX_NUM_OF_EXT_POOLS];
+                                                /**< Parameters for each port */
+} ioc_fm_ext_pools;
+
+typedef struct ioc_fm_vsp_params_t {
+    void                *p_fm;              /**< A handle to the FM object this VSP related to */
+    ioc_fm_ext_pools    ext_buf_pools;        /**< Which external buffer pools are used
+                                                 (up to FM_PORT_MAX_NUM_OF_EXT_POOLS), and their sizes.
+                                                 parameter associated with Rx / OP port */
+    uint16_t            liodn_offset;        /**< VSP's LIODN offset */
+    struct {
+        ioc_fm_port_type port_type;          /**< Port type */
+        uint8_t         port_id;             /**< Port Id - relative to type */
+    } port_params;
+    uint8_t             relative_profile_id;  /**< VSP Id - relative to VSP's range
+                                                 defined in relevant FM object */
+    void                *id;                /**< return value */
+} ioc_fm_vsp_params_t;
+#endif /* (DPAA_VERSION >= 11) */
+
+/**************************************************************************//**
+ @Description   A structure for defining BM pool depletion criteria
+*//***************************************************************************/
+typedef struct ioc_fm_buf_pool_depletion_t {
+    bool        pools_grp_mode_enable;              /**< select mode in which pause frames will be sent after
+                                                         a number of pools (all together!) are depleted */
+    uint8_t     num_of_pools;                       /**< the number of depleted pools that will invoke
+                                                         pause frames transmission. */
+    bool        pools_to_consider[BM_MAX_NUM_OF_POOLS];
+                                                    /**< For each pool, TRUE if it should be considered for
+                                                         depletion (Note - this pool must be used by this port!). */
+    bool        single_pool_mode_enable;            /**< select mode in which pause frames will be sent after
+                                                         a single-pool is depleted; */
+    bool        pools_to_consider_for_single_mode[BM_MAX_NUM_OF_POOLS];
+                                                    /**< For each pool, TRUE if it should be considered for
+                                                         depletion (Note - this pool must be used by this port!) */
+#if (DPAA_VERSION >= 11)
+    bool        pfc_priorities_en[FM_MAX_NUM_OF_PFC_PRIORITIES];
+                                                    /**< This field is used by the MAC as the Priority Enable Vector in the PFC frame
+                                                         which is transmitted */
+#endif /* (DPAA_VERSION >= 11) */
+} ioc_fm_buf_pool_depletion_t;
+
+#if (DPAA_VERSION >= 11)
+typedef struct ioc_fm_buf_pool_depletion_params_t {
+    void        *p_fm_vsp;
+    ioc_fm_buf_pool_depletion_t fm_buf_pool_depletion;
+} ioc_fm_buf_pool_depletion_params_t;
+#endif /* (DPAA_VERSION >= 11) */
+
+typedef struct ioc_fm_buffer_prefix_content_t {
+    uint16_t    priv_data_size;       /**< Number of bytes to be left at the beginning
+                                         of the external buffer; Note that the private-area will
+                                         start from the base of the buffer address. */
+    bool        pass_prs_result;      /**< TRUE to pass the parse result to/from the FM;
+                                         User may use FM_PORT_GetBufferPrsResult() in order to
+                                         get the parser-result from a buffer. */
+    bool        pass_time_stamp;      /**< TRUE to pass the timeStamp to/from the FM
+                                         User may use FM_PORT_GetBufferTimeStamp() in order to
+                                         get the parser-result from a buffer. */
+    bool        pass_hash_result;     /**< TRUE to pass the KG hash result to/from the FM
+                                         User may use FM_PORT_GetBufferHashResult() in order to
+                                         get the parser-result from a buffer. */
+    bool        pass_all_other_pcd_info; /**< Add all other Internal-Context information:
+                                         AD, hash-result, key, etc. */
+    uint16_t    data_align;          /**< 0 to use driver's default alignment [64],
+                                         other value for selecting a data alignment (must be a power of 2);
+                                         if write optimization is used, must be >= 16. */
+    uint8_t     manip_extra_space;    /**< Maximum extra size needed (insertion-size minus removal-size);
+                                         Note that this field impacts the size of the buffer-prefix
+                                         (i.e. it pushes the data offset);
+                                         This field is irrelevant if DPAA_VERSION==10 */
+} ioc_fm_buffer_prefix_content_t;
+
+typedef struct ioc_fm_buffer_prefix_content_params_t {
+    void        *p_fm_vsp;
+    ioc_fm_buffer_prefix_content_t fm_buffer_prefix_content;
+} ioc_fm_buffer_prefix_content_params_t;
+
+#if (DPAA_VERSION >= 11)
+typedef struct ioc_fm_vsp_config_no_sg_params_t {
+    void        *p_fm_vsp;
+    bool        no_sg;
+} ioc_fm_vsp_config_no_sg_params_t;
+
+typedef struct ioc_fm_vsp_prs_result_params_t {
+    void        *p_fm_vsp;
+    void        *p_data;
+} ioc_fm_vsp_prs_result_params_t;
+#endif
+
+typedef struct fm_ctrl_mon_t {
+    uint8_t     percent_cnt[2];
+} fm_ctrl_mon_t;
+
+typedef struct ioc_fm_ctrl_mon_counters_params_t {
+    uint8_t     fm_ctrl_index;
+    fm_ctrl_mon_t *p_mon;
+} ioc_fm_ctrl_mon_counters_params_t;
+
+/**************************************************************************//**
+ @Function      FM_IOC_SET_PORTS_BANDWIDTH
+
+ @Description   Sets relative weights between ports when accessing common resources.
+
+ @Param[in]     ioc_fm_port_bandwidth_params    Port bandwidth percentages,
+ their sum must equal 100.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_Init().
+*//***************************************************************************/
+#define FM_IOC_SET_PORTS_BANDWIDTH                             _IOW(FM_IOC_TYPE_BASE, FM_IOC_NUM(2), ioc_fm_port_bandwidth_params)
+
+/**************************************************************************//**
+ @Function      FM_IOC_GET_REVISION
+
+ @Description   Returns the FM revision
+
+ @Param[out]    ioc_fm_revision_info_t  A structure of revision information parameters.
+
+ @Return        None.
+
+ @Cautions      Allowed only following FM_Init().
+*//***************************************************************************/
+#define FM_IOC_GET_REVISION                                    _IOR(FM_IOC_TYPE_BASE, FM_IOC_NUM(3), ioc_fm_revision_info_t)
+
+/**************************************************************************//**
+ @Function      FM_IOC_GET_COUNTER
+
+ @Description   Reads one of the FM counters.
+
+ @Param[in,out] ioc_fm_counters_params_t The requested counter parameters.
+
+ @Return        Counter's current value.
+
+ @Cautions      Allowed only following FM_Init().
+                Note that it is user's responsibilty to call this routine only
+                for enabled counters, and there will be no indication if a
+                disabled counter is accessed.
+*//***************************************************************************/
+#define FM_IOC_GET_COUNTER                                    _IOWR(FM_IOC_TYPE_BASE, FM_IOC_NUM(4), ioc_fm_counters_params_t)
+
+/**************************************************************************//**
+ @Function      FM_IOC_SET_COUNTER
+
+ @Description   Sets a value to an enabled counter. Use "0" to reset the counter.
+
+ @Param[in]     ioc_fm_counters_params_t The requested counter parameters.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_Init().
+*//***************************************************************************/
+#define FM_IOC_SET_COUNTER                                    _IOW(FM_IOC_TYPE_BASE, FM_IOC_NUM(5), ioc_fm_counters_params_t)
+
+/**************************************************************************//**
+ @Function      FM_IOC_FORCE_INTR
+
+ @Description   Causes an interrupt event on the requested source.
+
+ @Param[in]     ioc_fm_exceptions   An exception to be forced.
+
+ @Return        E_OK on success; Error code if the exception is not enabled,
+                or is not able to create interrupt.
+
+ @Cautions      Allowed only following FM_Init().
+*//***************************************************************************/
+#define FM_IOC_FORCE_INTR                                    _IOW(FM_IOC_TYPE_BASE, FM_IOC_NUM(6), ioc_fm_exceptions)
+
+/**************************************************************************//**
+ @Function      FM_IOC_GET_API_VERSION
+
+ @Description   Reads the FMD IOCTL API version.
+
+ @Param[in,out] ioc_fm_api_version_t The requested counter parameters.
+
+ @Return        Version's value.
+*//***************************************************************************/
+#define FM_IOC_GET_API_VERSION                               _IOR(FM_IOC_TYPE_BASE, FM_IOC_NUM(7), ioc_fm_api_version_t)
+
+#if (DPAA_VERSION >= 11)
+/**************************************************************************//**
+ @Function      FM_VSP_Config
+
+ @Description   Creates descriptor for the FM VSP module.
+
+                The routine returns a handle (descriptor) to the FM VSP object.
+                This descriptor must be passed as first parameter to all other
+                FM VSP function calls.
+
+                No actual initialization or configuration of FM hardware is
+                done by this routine.
+
+@Param[in]      p_FmVspParams   Pointer to data structure of parameters
+
+ @Retval        Handle to FM VSP object, or NULL for Failure.
+*//***************************************************************************/
+#if defined(FM_COMPAT)
+#define FM_IOC_VSP_CONFIG_COMPAT                             _IOWR(FM_IOC_TYPE_BASE, FM_IOC_NUM(8), ioc_compat_fm_vsp_params_t)
+#endif
+#define FM_IOC_VSP_CONFIG                                    _IOWR(FM_IOC_TYPE_BASE, FM_IOC_NUM(8), ioc_fm_vsp_params_t)
+
+/**************************************************************************//**
+ @Function      FM_VSP_Init
+
+ @Description   Initializes the FM VSP module
+
+ @Param[in]     h_FmVsp - FM VSP module descriptor
+
+ @Return        E_OK on success; Error code otherwise.
+*//***************************************************************************/
+#if defined(FM_COMPAT)
+#define FM_IOC_VSP_INIT_COMPAT                               _IOW(FM_IOC_TYPE_BASE, FM_IOC_NUM(9), ioc_compat_fm_obj_t)
+#endif
+#define FM_IOC_VSP_INIT                                      _IOW(FM_IOC_TYPE_BASE, FM_IOC_NUM(9), ioc_fm_obj_t)
+
+/**************************************************************************//**
+ @Function      FM_VSP_Free
+
+ @Description   Frees all resources that were assigned to FM VSP module.
+
+                Calling this routine invalidates the descriptor.
+
+ @Param[in]     h_FmVsp - FM VSP module descriptor
+
+ @Return        E_OK on success; Error code otherwise.
+*//***************************************************************************/
+#if defined(FM_COMPAT)
+#define FM_IOC_VSP_FREE_COMPAT                               _IOW(FM_IOC_TYPE_BASE, FM_IOC_NUM(10), ioc_compat_fm_obj_t)
+#endif
+#define FM_IOC_VSP_FREE                                      _IOW(FM_IOC_TYPE_BASE, FM_IOC_NUM(10), ioc_fm_obj_t)
+
+/**************************************************************************//**
+ @Function      FM_VSP_ConfigPoolDepletion
+
+ @Description   Calling this routine enables pause frame generation depending on the
+                depletion status of BM pools. It also defines the conditions to activate
+                this functionality. By default, this functionality is disabled.
+
+ @Param[in]     ioc_fm_buf_pool_depletion_params_t      A structure holding the required parameters.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_VSP_Config() and before FM_VSP_Init().
+*//***************************************************************************/
+#if defined(FM_COMPAT)
+#define FM_IOC_VSP_CONFIG_POOL_DEPLETION_COMPAT              _IOW(FM_IOC_TYPE_BASE, FM_IOC_NUM(11), ioc_compat_fm_buf_pool_depletion_params_t)
+#endif
+#define FM_IOC_VSP_CONFIG_POOL_DEPLETION                     _IOW(FM_IOC_TYPE_BASE, FM_IOC_NUM(11), ioc_fm_buf_pool_depletion_params_t)
+
+/**************************************************************************//**
+ @Function      FM_VSP_ConfigBufferPrefixContent
+
+ @Description   Defines the structure, size and content of the application buffer.
+
+                The prefix will
+                In VSPs defined for Tx ports, if 'passPrsResult', the application
+                should set a value to their offsets in the prefix of
+                the FM will save the first 'privDataSize', than,
+                depending on 'passPrsResult' and 'passTimeStamp', copy parse result
+                and timeStamp, and the packet itself (in this order), to the
+                application buffer, and to offset.
+
+                Calling this routine changes the buffer margins definitions
+                in the internal driver data base from its default
+                configuration: Data size:  [DEFAULT_FM_SP_bufferPrefixContent_privDataSize]
+                               Pass Parser result: [DEFAULT_FM_SP_bufferPrefixContent_passPrsResult].
+                               Pass timestamp: [DEFAULT_FM_SP_bufferPrefixContent_passTimeStamp].
+
+ @Param[in]     ioc_fm_buffer_prefix_content_params_t   A structure holding the required parameters.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_VSP_Config() and before FM_VSP_Init().
+*//***************************************************************************/
+#if defined(FM_COMPAT)
+#define FM_IOC_VSP_CONFIG_BUFFER_PREFIX_CONTENT_COMPAT       _IOW(FM_IOC_TYPE_BASE, FM_IOC_NUM(12), ioc_compat_fm_buffer_prefix_content_params_t)
+#endif
+#define FM_IOC_VSP_CONFIG_BUFFER_PREFIX_CONTENT              _IOW(FM_IOC_TYPE_BASE, FM_IOC_NUM(12), ioc_fm_buffer_prefix_content_params_t)
+
+/**************************************************************************//**
+ @Function      FM_VSP_ConfigNoScatherGather
+
+ @Description   Calling this routine changes the possibility to receive S/G frame
+                in the internal driver data base
+                from its default configuration: optimize = [DEFAULT_FM_SP_noScatherGather]
+
+ @Param[in]     ioc_fm_vsp_config_no_sg_params_t        A structure holding the required parameters.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_VSP_Config() and before FM_VSP_Init().
+*//***************************************************************************/
+#if defined(FM_COMPAT)
+#define FM_IOC_VSP_CONFIG_NO_SG_COMPAT                     _IOW(FM_IOC_TYPE_BASE, FM_IOC_NUM(13), ioc_compat_fm_vsp_config_no_sg_params_t)
+#endif
+#define FM_IOC_VSP_CONFIG_NO_SG                            _IOW(FM_IOC_TYPE_BASE, FM_IOC_NUM(13), ioc_fm_vsp_config_no_sg_params_t)
+
+/**************************************************************************//**
+ @Function      FM_VSP_GetBufferPrsResult
+
+ @Description   Returns the pointer to the parse result in the data buffer.
+                In Rx ports this is relevant after reception, if parse
+                result is configured to be part of the data passed to the
+                application. For non Rx ports it may be used to get the pointer
+                of the area in the buffer where parse result should be
+                initialized - if so configured.
+                See FM_VSP_ConfigBufferPrefixContent for data buffer prefix
+                configuration.
+
+ @Param[in]     ioc_fm_vsp_prs_result_params_t  A structure holding the required parameters.
+
+ @Return        Parse result pointer on success, NULL if parse result was not
+                configured for this port.
+
+ @Cautions      Allowed only following FM_VSP_Init().
+*//***************************************************************************/
+#if defined(FM_COMPAT)
+#define FM_IOC_VSP_GET_BUFFER_PRS_RESULT_COMPAT            _IOWR(FM_IOC_TYPE_BASE, FM_IOC_NUM(14), ioc_compat_fm_vsp_prs_result_params_t)
+#endif
+#define FM_IOC_VSP_GET_BUFFER_PRS_RESULT                   _IOWR(FM_IOC_TYPE_BASE, FM_IOC_NUM(14), ioc_fm_vsp_prs_result_params_t)
+#endif /* (DPAA_VERSION >= 11) */
+
+/**************************************************************************//**
+ @Function      FM_CtrlMonStart
+
+ @Description   Start monitoring utilization of all available FM controllers.
+
+                In order to obtain FM controllers utilization the following sequence
+                should be used:
+                -# FM_CtrlMonStart()
+                -# FM_CtrlMonStop()
+                -# FM_CtrlMonGetCounters() - issued for each FM controller
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_Init().
+*//***************************************************************************/
+#define FM_IOC_CTRL_MON_START                              _IO(FM_IOC_TYPE_BASE, FM_IOC_NUM(15))
+
+
+/**************************************************************************//**
+ @Function      FM_CtrlMonStop
+
+ @Description   Stop monitoring utilization of all available FM controllers.
+
+                In order to obtain FM controllers utilization the following sequence
+                should be used:
+                -# FM_CtrlMonStart()
+                -# FM_CtrlMonStop()
+                -# FM_CtrlMonGetCounters() - issued for each FM controller
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_Init().
+*//***************************************************************************/
+#define FM_IOC_CTRL_MON_STOP                               _IO(FM_IOC_TYPE_BASE, FM_IOC_NUM(16))
+
+/**************************************************************************//**
+ @Function      FM_CtrlMonGetCounters
+
+ @Description   Obtain FM controller utilization parameters.
+
+                In order to obtain FM controllers utilization the following sequence
+                should be used:
+                -# FM_CtrlMonStart()
+                -# FM_CtrlMonStop()
+                -# FM_CtrlMonGetCounters() - issued for each FM controller
+
+ @Param[in]     ioc_fm_ctrl_mon_counters_params_t       A structure holding the required parameters.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_Init().
+*//***************************************************************************/
+#if defined(FM_COMPAT)
+#define FM_IOC_CTRL_MON_GET_COUNTERS_COMPAT                _IOW(FM_IOC_TYPE_BASE, FM_IOC_NUM(17), ioc_compat_fm_ctrl_mon_counters_params_t)
+#endif
+#define FM_IOC_CTRL_MON_GET_COUNTERS                       _IOW(FM_IOC_TYPE_BASE, FM_IOC_NUM(17), ioc_fm_ctrl_mon_counters_params_t)
+
+/** @} */ /* end of lnx_ioctl_FM_runtime_control_grp group */
+/** @} */ /* end of lnx_ioctl_FM_lib_grp group */
+/** @} */ /* end of lnx_ioctl_FM_grp */
+
+#define FMD_API_VERSION_MAJOR 21
+#define FMD_API_VERSION_MINOR 1 
+#define FMD_API_VERSION_RESPIN 0
+
+#endif /* __FM_IOCTLS_H */
diff --git a/include/uapi/linux/fmd/Peripherals/fm_pcd_ioctls.h b/include/uapi/linux/fmd/Peripherals/fm_pcd_ioctls.h
new file mode 100644
index 000000000..58721a5c5
--- /dev/null
+++ b/include/uapi/linux/fmd/Peripherals/fm_pcd_ioctls.h
@@ -0,0 +1,3098 @@
+/* Copyright (c) 2008-2012 Freescale Semiconductor, Inc.
+ * Copyright 2021 NXP
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+
+/******************************************************************************
+ @File          fm_pcd_ioctls.h
+
+ @Description   FM PCD ...
+*//***************************************************************************/
+#ifndef __FM_PCD_IOCTLS_H
+#define __FM_PCD_IOCTLS_H
+
+#include "net_ioctls.h"
+#include "fm_ioctls.h"
+
+
+/**************************************************************************//**
+
+ @Group         lnx_ioctl_FM_grp Frame Manager Linux IOCTL API
+
+ @Description   Frame Manager Linux ioctls definitions and enums
+
+ @{
+*//***************************************************************************/
+
+/**************************************************************************//**
+ @Group         lnx_ioctl_FM_PCD_grp FM PCD
+
+ @Description   Frame Manager PCD API functions, definitions and enums
+
+                The FM PCD module is responsible for the initialization of all
+                global classifying FM modules. This includes the parser general and
+                common registers, the key generator global and common registers,
+                and the policer global and common registers.
+                In addition, the FM PCD SW module will initialize all required
+                key generator schemes, coarse classification flows, and policer
+                profiles. When an FM module is configured to work with one of these
+                entities, it will register to it using the FM PORT API. The PCD
+                module will manage the PCD resources - i.e. resource management of
+                KeyGen schemes, etc.
+
+ @{
+*//***************************************************************************/
+
+/**************************************************************************//**
+ @Collection    General PCD defines
+*//***************************************************************************/
+#define IOC_FM_PCD_MAX_NUM_OF_PRIVATE_HDRS              2                   /**< Number of units/headers saved for user */
+
+#define IOC_FM_PCD_PRS_NUM_OF_HDRS                      16                  /**< Number of headers supported by HW parser */
+#define IOC_FM_PCD_MAX_NUM_OF_DISTINCTION_UNITS         (32 - IOC_FM_PCD_MAX_NUM_OF_PRIVATE_HDRS)
+                                                                            /**< Number of distinction units is limited by
+                                                                             register size (32 bits) minus reserved bits
+                                                                             for private headers. */
+#define IOC_FM_PCD_MAX_NUM_OF_INTERCHANGEABLE_HDRS      4                   /**< Maximum number of interchangeable headers
+                                                                             in a distinction unit */
+#define IOC_FM_PCD_KG_NUM_OF_GENERIC_REGS               8                   /**< Total number of generic KeyGen registers */
+#define IOC_FM_PCD_KG_MAX_NUM_OF_EXTRACTS_PER_KEY       35                  /**< Max number allowed on any configuration;
+                                                                             For HW implementation reasons, in most
+                                                                             cases less than this will be allowed; The
+                                                                             driver will return an initialization error
+                                                                             if resource is unavailable. */
+#define IOC_FM_PCD_KG_NUM_OF_EXTRACT_MASKS              4                   /**< Total number of masks allowed on KeyGen extractions. */
+#define IOC_FM_PCD_KG_NUM_OF_DEFAULT_GROUPS             16                  /**< Number of default value logical groups */
+
+#define IOC_FM_PCD_PRS_NUM_OF_LABELS                    32                  /**< Maximum number of SW parser labels */
+#define IOC_FM_PCD_SW_PRS_SIZE                          0x00000800          /**< Total size of SW parser area */
+
+#define IOC_FM_PCD_MAX_MANIP_INSRT_TEMPLATE_SIZE        128                 /**< Maximum size of insertion template for
+                                                                             insert manipulation */
+
+#if DPAA_VERSION >= 11
+#define IOC_FM_PCD_FRM_REPLIC_MAX_NUM_OF_ENTRIES        64                  /**< Maximum possible entries for frame replicator group */
+#endif /* DPAA_VERSION >= 11 */
+/* @} */
+
+#ifdef FM_CAPWAP_SUPPORT
+#error "FM_CAPWAP_SUPPORT not implemented!"
+#endif
+
+
+/**************************************************************************//**
+ @Group         lnx_ioctl_FM_PCD_init_grp FM PCD Initialization Unit
+
+ @Description   Frame Manager PCD Initialization Unit API
+
+ @{
+*//***************************************************************************/
+
+/**************************************************************************//**
+ @Description   PCD counters
+                (must match enum e_FmPcdCounters defined in fm_pcd_ext.h)
+*//***************************************************************************/
+typedef enum ioc_fm_pcd_counters {
+    e_IOC_FM_PCD_KG_COUNTERS_TOTAL,                                 /**< KeyGen counter */
+    e_IOC_FM_PCD_PLCR_COUNTERS_RED,                                 /**< Policer counter - counts the total number of RED packets that exit the Policer. */
+    e_IOC_FM_PCD_PLCR_COUNTERS_YELLOW,                              /**< Policer counter - counts the total number of YELLOW packets that exit the Policer. */
+    e_IOC_FM_PCD_PLCR_COUNTERS_RECOLORED_TO_RED,                    /**< Policer counter - counts the number of packets that changed color to RED by the Policer;
+                                                                         This is a subset of e_IOC_FM_PCD_PLCR_COUNTERS_RED packet count, indicating active color changes. */
+    e_IOC_FM_PCD_PLCR_COUNTERS_RECOLORED_TO_YELLOW,                 /**< Policer counter - counts the number of packets that changed color to YELLOW by the Policer;
+                                                                         This is a subset of e_IOC_FM_PCD_PLCR_COUNTERS_YELLOW packet count, indicating active color changes. */
+    e_IOC_FM_PCD_PLCR_COUNTERS_TOTAL,                               /**< Policer counter - counts the total number of packets passed in the Policer. */
+    e_IOC_FM_PCD_PLCR_COUNTERS_LENGTH_MISMATCH,                     /**< Policer counter - counts the number of packets with length mismatch. */
+    e_IOC_FM_PCD_PRS_COUNTERS_PARSE_DISPATCH,                       /**< Parser counter - counts the number of times the parser block is dispatched. */
+    e_IOC_FM_PCD_PRS_COUNTERS_L2_PARSE_RESULT_RETURNED,             /**< Parser counter - counts the number of times L2 parse result is returned (including errors). */
+    e_IOC_FM_PCD_PRS_COUNTERS_L3_PARSE_RESULT_RETURNED,             /**< Parser counter - counts the number of times L3 parse result is returned (including errors). */
+    e_IOC_FM_PCD_PRS_COUNTERS_L4_PARSE_RESULT_RETURNED,             /**< Parser counter - counts the number of times L4 parse result is returned (including errors). */
+    e_IOC_FM_PCD_PRS_COUNTERS_SHIM_PARSE_RESULT_RETURNED,           /**< Parser counter - counts the number of times SHIM parse result is returned (including errors). */
+    e_IOC_FM_PCD_PRS_COUNTERS_L2_PARSE_RESULT_RETURNED_WITH_ERR,    /**< Parser counter - counts the number of times L2 parse result is returned with errors. */
+    e_IOC_FM_PCD_PRS_COUNTERS_L3_PARSE_RESULT_RETURNED_WITH_ERR,    /**< Parser counter - counts the number of times L3 parse result is returned with errors. */
+    e_IOC_FM_PCD_PRS_COUNTERS_L4_PARSE_RESULT_RETURNED_WITH_ERR,    /**< Parser counter - counts the number of times L4 parse result is returned with errors. */
+    e_IOC_FM_PCD_PRS_COUNTERS_SHIM_PARSE_RESULT_RETURNED_WITH_ERR,  /**< Parser counter - counts the number of times SHIM parse result is returned with errors. */
+    e_IOC_FM_PCD_PRS_COUNTERS_SOFT_PRS_CYCLES,                      /**< Parser counter - counts the number of cycles spent executing soft parser instruction (including stall cycles). */
+    e_IOC_FM_PCD_PRS_COUNTERS_SOFT_PRS_STALL_CYCLES,                /**< Parser counter - counts the number of cycles stalled waiting for parser internal memory reads while executing soft parser instruction. */
+    e_IOC_FM_PCD_PRS_COUNTERS_HARD_PRS_CYCLE_INCL_STALL_CYCLES,     /**< Parser counter - counts the number of cycles spent executing hard parser (including stall cycles). */
+    e_IOC_FM_PCD_PRS_COUNTERS_MURAM_READ_CYCLES,                    /**< MURAM counter - counts the number of cycles while performing FMan Memory read. */
+    e_IOC_FM_PCD_PRS_COUNTERS_MURAM_READ_STALL_CYCLES,              /**< MURAM counter - counts the number of cycles stalled while performing FMan Memory read. */
+    e_IOC_FM_PCD_PRS_COUNTERS_MURAM_WRITE_CYCLES,                   /**< MURAM counter - counts the number of cycles while performing FMan Memory write. */
+    e_IOC_FM_PCD_PRS_COUNTERS_MURAM_WRITE_STALL_CYCLES,             /**< MURAM counter - counts the number of cycles stalled while performing FMan Memory write. */
+    e_IOC_FM_PCD_PRS_COUNTERS_FPM_COMMAND_STALL_CYCLES              /**< FPM counter - counts the number of cycles stalled while performing a FPM Command. */
+} ioc_fm_pcd_counters;
+
+/**************************************************************************//**
+ @Description   PCD interrupts
+                (must match enum e_FmPcdExceptions defined in fm_pcd_ext.h)
+*//***************************************************************************/
+typedef enum ioc_fm_pcd_exceptions {
+    e_IOC_FM_PCD_KG_EXCEPTION_DOUBLE_ECC,                   /**< KeyGen double-bit ECC error is detected on internal memory read access. */
+    e_IOC_FM_PCD_KG_EXCEPTION_KEYSIZE_OVERFLOW,             /**< KeyGen scheme configuration error indicating a key size larger than 56 bytes. */
+    e_IOC_FM_PCD_PLCR_EXCEPTION_DOUBLE_ECC,                 /**< Policer double-bit ECC error has been detected on PRAM read access. */
+    e_IOC_FM_PCD_PLCR_EXCEPTION_INIT_ENTRY_ERROR,           /**< Policer access to a non-initialized profile has been detected. */
+    e_IOC_FM_PCD_PLCR_EXCEPTION_PRAM_SELF_INIT_COMPLETE,    /**< Policer RAM self-initialization complete */
+    e_IOC_FM_PCD_PLCR_EXCEPTION_ATOMIC_ACTION_COMPLETE,     /**< Policer atomic action complete */
+    e_IOC_FM_PCD_PRS_EXCEPTION_DOUBLE_ECC,                  /**< Parser double-bit ECC error */
+    e_IOC_FM_PCD_PRS_EXCEPTION_SINGLE_ECC                   /**< Parser single-bit ECC error */
+} ioc_fm_pcd_exceptions;
+
+/** @} */ /* end of lnx_ioctl_FM_PCD_init_grp group */
+
+
+/**************************************************************************//**
+ @Group         lnx_ioctl_FM_PCD_Runtime_grp FM PCD Runtime Unit
+
+ @Description   Frame Manager PCD Runtime Unit
+
+                The runtime control allows creation of PCD infrastructure modules
+                such as Network Environment Characteristics, Classification Plan
+                Groups and Coarse Classification Trees.
+                It also allows on-the-fly initialization, modification and removal
+                of PCD modules such as KeyGen schemes, coarse classification nodes
+                and Policer profiles.
+
+                In order to explain the programming model of the PCD driver interface
+                a few terms should be explained, and will be used below.
+                  - Distinction Header - One of the 16 protocols supported by the FM parser,
+                    or one of the SHIM headers (1 or 2). May be a header with a special
+                    option (see below).
+                  - Interchangeable Headers Group - This is a group of Headers recognized
+                    by either one of them. For example, if in a specific context the user
+                    chooses to treat IPv4 and IPV6 in the same way, they may create an
+                    interchangeable Headers Unit consisting of these 2 headers.
+                  - A Distinction Unit - a Distinction Header or an Interchangeable Headers
+                    Group.
+                  - Header with special option - applies to Ethernet, MPLS, VLAN, IPv4 and
+                    IPv6, includes multicast, broadcast and other protocol specific options.
+                    In terms of hardware it relates to the options available in the classification
+                    plan.
+                  - Network Environment Characteristics - a set of Distinction Units that define
+                    the total recognizable header selection for a certain environment. This is
+                    NOT the list of all headers that will ever appear in a flow, but rather
+                    everything that needs distinction in a flow, where distinction is made by KeyGen
+                    schemes and coarse classification action descriptors.
+
+                The PCD runtime modules initialization is done in stages. The first stage after
+                initializing the PCD module itself is to establish a Network Flows Environment
+                Definition. The application may choose to establish one or more such environments.
+                Later, when needed, the application will have to state, for some of its modules,
+                to which single environment it belongs.
+
+ @{
+*//***************************************************************************/
+
+
+/**************************************************************************//**
+ @Description   structure for FM counters
+*//***************************************************************************/
+typedef struct ioc_fm_pcd_counters_params_t {
+    ioc_fm_pcd_counters cnt;                /**< The requested counter */
+    uint32_t            val;                /**< The requested value to get/set from/into the counter */
+} ioc_fm_pcd_counters_params_t;
+
+/**************************************************************************//**
+ @Description   structure for FM exception definitios
+*//***************************************************************************/
+typedef struct ioc_fm_pcd_exception_params_t {
+    ioc_fm_pcd_exceptions exception;        /**< The requested exception */
+    bool                  enable;           /**< TRUE to enable interrupt, FALSE to mask it. */
+} ioc_fm_pcd_exception_params_t;
+
+/**************************************************************************//**
+ @Description   A structure for SW parser labels
+                (must be identical to struct t_FmPcdPrsLabelParams defined in fm_pcd_ext.h)
+ *//***************************************************************************/
+typedef struct ioc_fm_pcd_prs_label_params_t {
+    uint32_t                instruction_offset;             /**< SW parser label instruction offset (2 bytes
+                                                                 resolution), relative to Parser RAM. */
+    ioc_net_header_type     hdr;                            /**< The existence of this header will invoke
+                                                                 the SW parser code. */
+    uint8_t                 index_per_hdr;                  /**< Normally 0, if more than one SW parser
+                                                                 attachments for the same header, use this
+                                                                 index to distinguish between them. */
+} ioc_fm_pcd_prs_label_params_t;
+
+/**************************************************************************//**
+ @Description   A structure for SW parser
+                (Must match struct t_FmPcdPrsSwParams defined in fm_pcd_ext.h)
+ *//***************************************************************************/
+typedef struct ioc_fm_pcd_prs_sw_params_t {
+    bool                    override;                   /**< FALSE to invoke a check that nothing else
+                                                             was loaded to this address, including
+                                                             internal patches.
+                                                             TRUE to override any existing code.*/
+    uint32_t                size;                       /**< SW parser code size */
+    uint16_t                base;                       /**< SW parser base (in instruction counts!
+                                                             must be larger than 0x20)*/
+    uint8_t                 *p_code;                    /**< SW parser code */
+    uint32_t                sw_prs_data_params[IOC_FM_PCD_PRS_NUM_OF_HDRS];
+                                                        /**< SW parser data (parameters) */
+    uint8_t                 num_of_labels;              /**< Number of labels for SW parser. */
+    ioc_fm_pcd_prs_label_params_t labels_table[IOC_FM_PCD_PRS_NUM_OF_LABELS];
+                                                        /**< SW parser labels table,
+                                                             containing num_of_labels entries */
+} ioc_fm_pcd_prs_sw_params_t;
+
+/**************************************************************************//**
+ @Description   A structure to set the a KeyGen default value
+ *//***************************************************************************/
+typedef struct ioc_fm_pcd_kg_dflt_value_params_t {
+    uint8_t                         valueId;                /**< 0,1 - one of 2 global default values */
+    uint32_t                        value;                  /**< The requested default value */
+} ioc_fm_pcd_kg_dflt_value_params_t;
+
+
+/**************************************************************************//**
+ @Function      FM_PCD_Enable
+
+ @Description   This routine should be called after PCD is initialized for enabling all
+                PCD engines according to their existing configuration.
+
+ @Return        0 on success; Error code otherwise.
+
+ @Cautions      Allowed only when PCD is disabled.
+*//***************************************************************************/
+#define FM_PCD_IOC_ENABLE  _IO(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(1))
+
+/**************************************************************************//**
+ @Function      FM_PCD_Disable
+
+ @Description   This routine may be called when PCD is enabled in order to
+                disable all PCD engines. It may be called
+                only when none of the ports in the system are using the PCD.
+
+ @Return        0 on success; Error code otherwise.
+
+ @Cautions      Allowed only when PCD is enabled.
+*//***************************************************************************/
+#define FM_PCD_IOC_DISABLE  _IO(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(2))
+
+ /**************************************************************************//**
+ @Function      FM_PCD_PrsLoadSw
+
+ @Description   This routine may be called only when all ports in the
+                system are actively using the classification plan scheme.
+                In such cases it is recommended in order to save resources.
+                The driver automatically saves 8 classification plans for
+                ports that do NOT use the classification plan mechanism, to
+                avoid this (in order to save those entries) this routine may
+                be called.
+
+ @Param[in]     ioc_fm_pcd_prs_sw_params_t  A pointer to the image of the software parser code.
+
+ @Return        0 on success; Error code otherwise.
+
+ @Cautions      Allowed only when PCD is disabled.
+*//***************************************************************************/
+#if defined(FM_COMPAT)
+#define FM_PCD_IOC_PRS_LOAD_SW_COMPAT  _IOW(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(3), ioc_compat_fm_pcd_prs_sw_params_t)
+#endif
+#define FM_PCD_IOC_PRS_LOAD_SW  _IOW(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(3), ioc_fm_pcd_prs_sw_params_t)
+
+/**************************************************************************//**
+ @Function      FM_PCD_KgSetDfltValue
+
+ @Description   Calling this routine sets a global default value to be used
+                by the KeyGen when parser does not recognize a required
+                field/header.
+                By default default values are 0.
+
+ @Param[in]     ioc_fm_pcd_kg_dflt_value_params_t   A pointer to a structure with the relevant parameters
+
+ @Return        0 on success; Error code otherwise.
+
+ @Cautions      Allowed only when PCD is disabled.
+*//***************************************************************************/
+#define FM_PCD_IOC_KG_SET_DFLT_VALUE  _IOW(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(6), ioc_fm_pcd_kg_dflt_value_params_t)
+
+/**************************************************************************//**
+ @Function      FM_PCD_KgSetAdditionalDataAfterParsing
+
+ @Description   Calling this routine allows the keygen to access data past
+                the parser finishing point.
+
+ @Param[in]     uint8_t   payload-offset; the number of bytes beyond the parser location.
+
+ @Return        0 on success; Error code otherwise.
+
+ @Cautions      Allowed only when PCD is disabled.
+*//***************************************************************************/
+#define FM_PCD_IOC_KG_SET_ADDITIONAL_DATA_AFTER_PARSING  _IOW(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(7), uint8_t)
+
+/**************************************************************************//**
+ @Function      FM_PCD_SetException
+
+ @Description   Calling this routine enables/disables PCD interrupts.
+
+ @Param[in]     ioc_fm_pcd_exception_params_t     Arguments struct with exception to be enabled/disabled.
+
+ @Return        0 on success; Error code otherwise.
+*//***************************************************************************/
+#define FM_PCD_IOC_SET_EXCEPTION _IOW(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(8), ioc_fm_pcd_exception_params_t)
+
+/**************************************************************************//**
+ @Function      FM_PCD_GetCounter
+
+ @Description   Reads one of the FM PCD counters.
+
+ @Param[in,out] ioc_fm_pcd_counters_params_t The requested counter parameters.
+
+ @Return        0 on success; Error code otherwise.
+
+ @Cautions      Note that it is user's responsibilty to call this routine only
+                for enabled counters, and there will be no indication if a
+                disabled counter is accessed.
+*//***************************************************************************/
+#define FM_PCD_IOC_GET_COUNTER  _IOWR(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(9), ioc_fm_pcd_counters_params_t)
+
+/**************************************************************************//**
+
+ @Function      FM_PCD_KgSchemeGetCounter
+
+ @Description   Reads scheme packet counter.
+
+ @Param[in]     h_Scheme        scheme handle as returned by FM_PCD_KgSchemeSet().
+
+ @Return        Counter's current value.
+
+ @Cautions      Allowed only following FM_PCD_Init() & FM_PCD_KgSchemeSet().
+*//***************************************************************************/
+#if defined(FM_COMPAT)
+#define FM_PCD_IOC_KG_SCHEME_GET_CNTR_COMPAT  _IOR(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(4), ioc_compat_fm_pcd_kg_scheme_spc_t)
+#endif
+#define FM_PCD_IOC_KG_SCHEME_GET_CNTR  _IOR(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(4), ioc_fm_pcd_kg_scheme_spc_t)
+
+#if 0
+TODO: unused IOCTL
+/**************************************************************************//**
+ @Function      FM_PCD_ModifyCounter
+
+ @Description   Writes a value to an enabled counter. Use "0" to reset the counter.
+
+ @Param[in]     ioc_fm_pcd_counters_params_t - The requested counter parameters.
+
+ @Return        0 on success; Error code otherwise.
+*//***************************************************************************/
+#define FM_PCD_IOC_MODIFY_COUNTER   _IOW(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(10), ioc_fm_pcd_counters_params_t)
+#define FM_PCD_IOC_SET_COUNTER      FM_PCD_IOC_MODIFY_COUNTER
+#endif
+
+/**************************************************************************//**
+ @Function      FM_PCD_ForceIntr
+
+ @Description   Causes an interrupt event on the requested source.
+
+ @Param[in]     ioc_fm_pcd_exceptions - An exception to be forced.
+
+ @Return        0 on success; error code if the exception is not enabled,
+                or is not able to create interrupt.
+*//***************************************************************************/
+#define FM_PCD_IOC_FORCE_INTR _IOW(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(11), ioc_fm_pcd_exceptions)
+
+/**************************************************************************//**
+ @Collection    Definitions of coarse classification parameters as required by KeyGen
+                (when coarse classification is the next engine after this scheme).
+*//***************************************************************************/
+#define IOC_FM_PCD_MAX_NUM_OF_CC_TREES              8
+#define IOC_FM_PCD_MAX_NUM_OF_CC_GROUPS             16
+#define IOC_FM_PCD_MAX_NUM_OF_CC_UNITS              4
+#define IOC_FM_PCD_MAX_NUM_OF_KEYS                  256
+#define IOC_FM_PCD_MAX_NUM_OF_FLOWS                 (4*KILOBYTE)
+#define IOC_FM_PCD_MAX_SIZE_OF_KEY                  56
+#define IOC_FM_PCD_MAX_NUM_OF_CC_ENTRIES_IN_GRP     16
+#define IOC_FM_PCD_LAST_KEY_INDEX                   0xffff
+#define IOC_FM_PCD_MANIP_DSCP_VALUES                64
+/* @} */
+
+/**************************************************************************//**
+ @Collection    A set of definitions to allow protocol
+                special option description.
+*//***************************************************************************/
+typedef uint32_t            ioc_protocol_opt_t;      /**< A general type to define a protocol option. */
+
+typedef ioc_protocol_opt_t  ioc_eth_protocol_opt_t;  /**< Ethernet protocol options. */
+#define IOC_ETH_BROADCAST               0x80000000   /**< Ethernet Broadcast. */
+#define IOC_ETH_MULTICAST               0x40000000   /**< Ethernet Multicast. */
+
+typedef ioc_protocol_opt_t  ioc_vlan_protocol_opt_t; /**< Vlan protocol options. */
+#define IOC_VLAN_STACKED                0x20000000   /**< Stacked VLAN. */
+
+typedef ioc_protocol_opt_t  ioc_mpls_protocol_opt_t; /**< MPLS protocol options. */
+#define IOC_MPLS_STACKED                0x10000000   /**< Stacked MPLS. */
+
+typedef ioc_protocol_opt_t  ioc_ipv4_protocol_opt_t; /**< IPv4 protocol options. */
+#define IOC_IPV4_BROADCAST_1            0x08000000   /**< IPv4 Broadcast. */
+#define IOC_IPV4_MULTICAST_1            0x04000000   /**< IPv4 Multicast. */
+#define IOC_IPV4_UNICAST_2              0x02000000   /**< Tunneled IPv4 - Unicast. */
+#define IOC_IPV4_MULTICAST_BROADCAST_2  0x01000000   /**< Tunneled IPv4 - Broadcast/Multicast. */
+
+#define IOC_IPV4_FRAG_1                 0x00000008   /**< IPV4 reassembly option.
+                                                          IPV4 Reassembly manipulation requires network
+                                                          environment with IPV4 header and IPV4_FRAG_1 option  */
+
+typedef ioc_protocol_opt_t  ioc_ipv6_protocol_opt_t; /**< IPv6 protocol options. */
+#define IOC_IPV6_MULTICAST_1            0x00800000   /**< IPv6 Multicast. */
+#define IOC_IPV6_UNICAST_2              0x00400000   /**< Tunneled IPv6 - Unicast. */
+#define IOC_IPV6_MULTICAST_2            0x00200000   /**< Tunneled IPv6 - Multicast. */
+
+#define IOC_IPV6_FRAG_1                 0x00000004   /**< IPV6 reassembly option.
+                                                          IPV6 Reassembly manipulation requires network
+                                                          environment with IPV6 header and IPV6_FRAG_1 option  */
+#if (DPAA_VERSION >= 11)
+typedef ioc_protocol_opt_t   ioc_capwap_protocol_opt_t;      /**< CAPWAP protocol options. */
+#define CAPWAP_FRAG_1               0x00000008  /**< CAPWAP reassembly option.
+                                                     CAPWAP Reassembly manipulation requires network
+                                                     environment with CAPWAP header and CAPWAP_FRAG_1 option;
+                                                     in case where fragment found, the fragment-extension offset
+                                                     may be found at 'shim2' (in parser-result). */
+#endif /* (DPAA_VERSION >= 11) */
+
+/* @} */
+
+#define IOC_FM_PCD_MANIP_MAX_HDR_SIZE               256
+#define IOC_FM_PCD_MANIP_DSCP_TO_VLAN_TRANS         64
+/**************************************************************************//**
+ @Collection    A set of definitions to support Header Manipulation selection.
+*//***************************************************************************/
+typedef uint32_t                        ioc_hdr_manip_flags_t;              /**< A general type to define a HMan update command flags. */
+
+typedef ioc_hdr_manip_flags_t           ioc_ipv4_hdr_manip_update_flags_t;  /**< IPv4 protocol HMan update command flags. */
+
+#define IOC_HDR_MANIP_IPV4_TOS          0x80000000          /**< update TOS with the given value ('tos' field
+                                                                 of ioc_fm_pcd_manip_hdr_field_update_ipv4_t) */
+#define IOC_HDR_MANIP_IPV4_ID           0x40000000          /**< update IP ID with the given value ('id' field
+                                                                 of ioc_fm_pcd_manip_hdr_field_update_ipv4_t) */
+#define IOC_HDR_MANIP_IPV4_TTL          0x20000000          /**< Decrement TTL by 1 */
+#define IOC_HDR_MANIP_IPV4_SRC          0x10000000          /**< update IP source address with the given value
+                                                                 ('src' field of ioc_fm_pcd_manip_hdr_field_update_ipv4_t) */
+#define IOC_HDR_MANIP_IPV4_DST          0x08000000          /**< update IP destination address with the given value
+                                                                 ('dst' field of ioc_fm_pcd_manip_hdr_field_update_ipv4_t) */
+
+typedef ioc_hdr_manip_flags_t           ioc_ipv6_hdr_manip_update_flags_t;  /**< IPv6 protocol HMan update command flags. */
+
+#define IOC_HDR_MANIP_IPV6_TC           0x80000000          /**< update Traffic Class address with the given value
+                                                                 ('traffic_class' field of ioc_fm_pcd_manip_hdr_field_update_ipv6_t) */
+#define IOC_HDR_MANIP_IPV6_HL           0x40000000          /**< Decrement Hop Limit by 1 */
+#define IOC_HDR_MANIP_IPV6_SRC          0x20000000          /**< update IP source address with the given value
+                                                                 ('src' field of ioc_fm_pcd_manip_hdr_field_update_ipv6_t) */
+#define IOC_HDR_MANIP_IPV6_DST          0x10000000          /**< update IP destination address with the given value
+                                                                 ('dst' field of ioc_fm_pcd_manip_hdr_field_update_ipv6_t) */
+
+typedef ioc_hdr_manip_flags_t           ioc_tcp_udp_hdr_manip_update_flags_t;/**< TCP/UDP protocol HMan update command flags. */
+
+#define IOC_HDR_MANIP_TCP_UDP_SRC       0x80000000          /**< update TCP/UDP source address with the given value
+                                                                 ('src' field of ioc_fm_pcd_manip_hdr_field_update_tcp_udp_t) */
+#define IOC_HDR_MANIP_TCP_UDP_DST       0x40000000          /**< update TCP/UDP destination address with the given value
+                                                                 ('dst' field of ioc_fm_pcd_manip_hdr_field_update_tcp_udp_t) */
+#define IOC_HDR_MANIP_TCP_UDP_CHECKSUM  0x20000000          /**< update TCP/UDP checksum */
+
+/* @} */
+
+/**************************************************************************//**
+ @Description   A type used for returning the order of the key extraction.
+                each value in this array represents the index of the extraction
+                command as defined by the user in the initialization extraction array.
+                The valid size of this array is the user define number of extractions
+                required (also marked by the second '0' in this array).
+*//***************************************************************************/
+typedef    uint8_t    ioc_fm_pcd_kg_key_order_t [IOC_FM_PCD_KG_MAX_NUM_OF_EXTRACTS_PER_KEY];
+
+/**************************************************************************//**
+ @Description   All PCD engines
+                (must match enum e_FmPcdEngine defined in fm_pcd_ext.h)
+*//***************************************************************************/
+typedef enum ioc_fm_pcd_engine {
+    e_IOC_FM_PCD_INVALID = 0,   /**< Invalid PCD engine */
+    e_IOC_FM_PCD_DONE,          /**< No PCD Engine indicated */
+    e_IOC_FM_PCD_KG,            /**< KeyGen */
+    e_IOC_FM_PCD_CC,            /**< Coarse Classifier */
+    e_IOC_FM_PCD_PLCR,          /**< Policer */
+    e_IOC_FM_PCD_PRS,           /**< Parser */
+#if DPAA_VERSION >= 11
+    e_IOC_FM_PCD_FR,            /**< Frame Replicator */
+#endif /* DPAA_VERSION >= 11 */
+    e_IOC_FM_PCD_HASH           /**< Hash Table */
+} ioc_fm_pcd_engine;
+
+/**************************************************************************//**
+ @Description   An enum for selecting extraction by header types
+                (Must match enum e_FmPcdExtractByHdrType defined in fm_pcd_ext.h)
+*//***************************************************************************/
+typedef enum ioc_fm_pcd_extract_by_hdr_type {
+    e_IOC_FM_PCD_EXTRACT_FROM_HDR,      /**< Extract bytes from header */
+    e_IOC_FM_PCD_EXTRACT_FROM_FIELD,    /**< Extract bytes from header field */
+    e_IOC_FM_PCD_EXTRACT_FULL_FIELD     /**< Extract a full field */
+} ioc_fm_pcd_extract_by_hdr_type;
+
+/**************************************************************************//**
+ @Description   An enum for selecting extraction source (when it is not the header)
+                (Must match enum e_FmPcdExtractFrom defined in fm_pcd_ext.h)
+*//***************************************************************************/
+typedef enum ioc_fm_pcd_extract_from {
+    e_IOC_FM_PCD_EXTRACT_FROM_FRAME_START,          /**< KG & CC: Extract from beginning of frame */
+    e_IOC_FM_PCD_EXTRACT_FROM_DFLT_VALUE,           /**< KG only: Extract from a default value */
+    e_IOC_FM_PCD_EXTRACT_FROM_CURR_END_OF_PARSE,    /**< KG only: Extract from the point where parsing had finished */
+    e_IOC_FM_PCD_EXTRACT_FROM_KEY,                  /**< CC only: Field where saved KEY */
+    e_IOC_FM_PCD_EXTRACT_FROM_HASH,                 /**< CC only: Field where saved HASH */
+    e_IOC_FM_PCD_EXTRACT_FROM_PARSE_RESULT,         /**< KG & CC: Extract from the parser result */
+    e_IOC_FM_PCD_EXTRACT_FROM_ENQ_FQID,             /**< KG & CC: Extract from enqueue FQID */
+    e_IOC_FM_PCD_EXTRACT_FROM_FLOW_ID               /**< CC only: Field where saved Dequeue FQID */
+} ioc_fm_pcd_extract_from;
+
+/**************************************************************************//**
+ @Description   An enum for selecting extraction type
+*//***************************************************************************/
+typedef enum ioc_fm_pcd_extract_type {
+    e_IOC_FM_PCD_EXTRACT_BY_HDR,                /**< Extract according to header */
+    e_IOC_FM_PCD_EXTRACT_NON_HDR,               /**< Extract from data that is not the header */
+    e_IOC_FM_PCD_KG_EXTRACT_PORT_PRIVATE_INFO   /**< Extract private info as specified by user */
+} ioc_fm_pcd_extract_type;
+
+/**************************************************************************//**
+ @Description   An enum for selecting a default
+*//***************************************************************************/
+typedef enum ioc_fm_pcd_kg_extract_dflt_select {
+    e_IOC_FM_PCD_KG_DFLT_GBL_0,          /**< Default selection is KG register 0 */
+    e_IOC_FM_PCD_KG_DFLT_GBL_1,          /**< Default selection is KG register 1 */
+    e_IOC_FM_PCD_KG_DFLT_PRIVATE_0,      /**< Default selection is a per scheme register 0 */
+    e_IOC_FM_PCD_KG_DFLT_PRIVATE_1,      /**< Default selection is a per scheme register 1 */
+    e_IOC_FM_PCD_KG_DFLT_ILLEGAL         /**< Illegal selection */
+} ioc_fm_pcd_kg_extract_dflt_select;
+
+/**************************************************************************//**
+ @Description   Enumeration type defining all default groups - each group shares
+                a default value, one of four user-initialized values.
+*//***************************************************************************/
+typedef enum ioc_fm_pcd_kg_known_fields_dflt_types {
+    e_IOC_FM_PCD_KG_MAC_ADDR,               /**< MAC Address */
+    e_IOC_FM_PCD_KG_TCI,                    /**< TCI field */
+    e_IOC_FM_PCD_KG_ENET_TYPE,              /**< ENET Type */
+    e_IOC_FM_PCD_KG_PPP_SESSION_ID,         /**< PPP Session id */
+    e_IOC_FM_PCD_KG_PPP_PROTOCOL_ID,        /**< PPP Protocol id */
+    e_IOC_FM_PCD_KG_MPLS_LABEL,             /**< MPLS label */
+    e_IOC_FM_PCD_KG_IP_ADDR,                /**< IP addr */
+    e_IOC_FM_PCD_KG_PROTOCOL_TYPE,          /**< Protocol type */
+    e_IOC_FM_PCD_KG_IP_TOS_TC,              /**< TOS or TC */
+    e_IOC_FM_PCD_KG_IPV6_FLOW_LABEL,        /**< IPV6 flow label */
+    e_IOC_FM_PCD_KG_IPSEC_SPI,              /**< IPSEC SPI */
+    e_IOC_FM_PCD_KG_L4_PORT,                /**< L4 Port */
+    e_IOC_FM_PCD_KG_TCP_FLAG,               /**< TCP Flag */
+    e_IOC_FM_PCD_KG_GENERIC_FROM_DATA,      /**< grouping implemented by SW,
+                                                 any data extraction that is not the full
+                                                 field described above  */
+    e_IOC_FM_PCD_KG_GENERIC_FROM_DATA_NO_V, /**< grouping implemented by SW,
+                                                 any data extraction without validation */
+    e_IOC_FM_PCD_KG_GENERIC_NOT_FROM_DATA   /**< grouping implemented by SW,
+                                                 extraction from parser result or
+                                                 direct use of default value  */
+} ioc_fm_pcd_kg_known_fields_dflt_types;
+
+/**************************************************************************//**
+ @Description   Enumeration type for defining header index for scenarios with
+                multiple (tunneled) headers
+*//***************************************************************************/
+typedef enum ioc_fm_pcd_hdr_index {
+    e_IOC_FM_PCD_HDR_INDEX_NONE     =   0,      /**< used when multiple headers not used, also
+                                                     to specify regular IP (not tunneled). */
+    e_IOC_FM_PCD_HDR_INDEX_1,                   /**< may be used for VLAN, MPLS, tunneled IP */
+    e_IOC_FM_PCD_HDR_INDEX_2,                   /**< may be used for MPLS, tunneled IP */
+    e_IOC_FM_PCD_HDR_INDEX_3,                   /**< may be used for MPLS */
+    e_IOC_FM_PCD_HDR_INDEX_LAST     =   0xFF    /**< may be used for VLAN, MPLS */
+} ioc_fm_pcd_hdr_index;
+
+/**************************************************************************//**
+ @Description   Enumeration type for selecting the policer profile functional type
+*//***************************************************************************/
+typedef enum ioc_fm_pcd_profile_type_selection {
+    e_IOC_FM_PCD_PLCR_PORT_PRIVATE,             /**< Port dedicated profile */
+    e_IOC_FM_PCD_PLCR_SHARED                    /**< Shared profile (shared within partition) */
+} ioc_fm_pcd_profile_type_selection;
+
+/**************************************************************************//**
+ @Description   Enumeration type for selecting the policer profile algorithm
+*//***************************************************************************/
+typedef enum ioc_fm_pcd_plcr_algorithm_selection {
+    e_IOC_FM_PCD_PLCR_PASS_THROUGH, /**< Policer pass through */
+    e_IOC_FM_PCD_PLCR_RFC_2698,     /**< Policer algorithm RFC 2698 */
+    e_IOC_FM_PCD_PLCR_RFC_4115      /**< Policer algorithm RFC 4115 */
+} ioc_fm_pcd_plcr_algorithm_selection;
+
+/**************************************************************************//**
+ @Description   Enumeration type for selecting a policer profile color mode
+*//***************************************************************************/
+typedef enum ioc_fm_pcd_plcr_color_mode {
+    e_IOC_FM_PCD_PLCR_COLOR_BLIND,  /**< Color blind */
+    e_IOC_FM_PCD_PLCR_COLOR_AWARE   /**< Color aware */
+} ioc_fm_pcd_plcr_color_mode;
+
+/**************************************************************************//**
+ @Description   Enumeration type for selecting a policer profile color
+*//***************************************************************************/
+typedef enum ioc_fm_pcd_plcr_color {
+    e_IOC_FM_PCD_PLCR_GREEN,    /**< Green */
+    e_IOC_FM_PCD_PLCR_YELLOW,   /**< Yellow */
+    e_IOC_FM_PCD_PLCR_RED,      /**< Red */
+    e_IOC_FM_PCD_PLCR_OVERRIDE  /**< Color override */
+} ioc_fm_pcd_plcr_color;
+
+/**************************************************************************//**
+ @Description   Enumeration type for selecting the policer profile packet frame length selector
+*//***************************************************************************/
+typedef enum ioc_fm_pcd_plcr_frame_length_select {
+  e_IOC_FM_PCD_PLCR_L2_FRM_LEN,     /**< L2 frame length */
+  e_IOC_FM_PCD_PLCR_L3_FRM_LEN,     /**< L3 frame length */
+  e_IOC_FM_PCD_PLCR_L4_FRM_LEN,     /**< L4 frame length */
+  e_IOC_FM_PCD_PLCR_FULL_FRM_LEN    /**< Full frame length */
+} ioc_fm_pcd_plcr_frame_length_select;
+
+/**************************************************************************//**
+ @Description   Enumeration type for selecting roll-back frame
+*//***************************************************************************/
+typedef enum ioc_fm_pcd_plcr_roll_back_frame_select {
+  e_IOC_FM_PCD_PLCR_ROLLBACK_L2_FRM_LEN,    /**< Rollback L2 frame length */
+  e_IOC_FM_PCD_PLCR_ROLLBACK_FULL_FRM_LEN   /**< Rollback Full frame length */
+} ioc_fm_pcd_plcr_roll_back_frame_select;
+
+/**************************************************************************//**
+ @Description   Enumeration type for selecting the policer profile packet or byte mode
+*//***************************************************************************/
+typedef enum ioc_fm_pcd_plcr_rate_mode {
+    e_IOC_FM_PCD_PLCR_BYTE_MODE,    /**< Byte mode */
+    e_IOC_FM_PCD_PLCR_PACKET_MODE   /**< Packet mode */
+} ioc_fm_pcd_plcr_rate_mode;
+
+/**************************************************************************//**
+ @Description   Enumeration type for defining action of frame
+*//***************************************************************************/
+typedef enum ioc_fm_pcd_done_action {
+    e_IOC_FM_PCD_ENQ_FRAME = 0,     /**< Enqueue frame */
+    e_IOC_FM_PCD_DROP_FRAME         /**< Drop frame */
+} ioc_fm_pcd_done_action;
+
+/**************************************************************************//**
+ @Description   Enumeration type for selecting the policer counter
+*//***************************************************************************/
+typedef enum ioc_fm_pcd_plcr_profile_counters {
+    e_IOC_FM_PCD_PLCR_PROFILE_GREEN_PACKET_TOTAL_COUNTER,               /**< Green packets counter */
+    e_IOC_FM_PCD_PLCR_PROFILE_YELLOW_PACKET_TOTAL_COUNTER,              /**< Yellow packets counter */
+    e_IOC_FM_PCD_PLCR_PROFILE_RED_PACKET_TOTAL_COUNTER,                 /**< Red packets counter */
+    e_IOC_FM_PCD_PLCR_PROFILE_RECOLOURED_YELLOW_PACKET_TOTAL_COUNTER,   /**< Recolored yellow packets counter */
+    e_IOC_FM_PCD_PLCR_PROFILE_RECOLOURED_RED_PACKET_TOTAL_COUNTER       /**< Recolored red packets counter */
+} ioc_fm_pcd_plcr_profile_counters;
+
+/**************************************************************************//**
+ @Description   Enumeration type for selecting the PCD action after extraction
+*//***************************************************************************/
+typedef enum ioc_fm_pcd_action {
+    e_IOC_FM_PCD_ACTION_NONE,                           /**< NONE  */
+    e_IOC_FM_PCD_ACTION_EXACT_MATCH,                    /**< Exact match on the selected extraction*/
+    e_IOC_FM_PCD_ACTION_INDEXED_LOOKUP                  /**< Indexed lookup on the selected extraction*/
+} ioc_fm_pcd_action;
+
+/**************************************************************************//**
+ @Description   Enumeration type for selecting type of insert manipulation
+*//***************************************************************************/
+typedef enum ioc_fm_pcd_manip_hdr_insrt_type {
+    e_IOC_FM_PCD_MANIP_INSRT_GENERIC,                   /**< Insert according to offset & size */
+    e_IOC_FM_PCD_MANIP_INSRT_BY_HDR,                    /**< Insert according to protocol */
+#if (defined(FM_CAPWAP_SUPPORT) && (DPAA_VERSION == 10))
+    e_IOC_FM_PCD_MANIP_INSRT_BY_TEMPLATE                /**< Insert template to start of frame */
+#endif /* FM_CAPWAP_SUPPORT */
+} ioc_fm_pcd_manip_hdr_insrt_type;
+
+/**************************************************************************//**
+ @Description   Enumeration type for selecting type of remove manipulation
+*//***************************************************************************/
+typedef enum ioc_fm_pcd_manip_hdr_rmv_type {
+    e_IOC_FM_PCD_MANIP_RMV_GENERIC,                     /**< Remove according to offset & size */
+    e_IOC_FM_PCD_MANIP_RMV_BY_HDR                       /**< Remove according to offset & size */
+} ioc_fm_pcd_manip_hdr_rmv_type;
+
+/**************************************************************************//**
+ @Description   An enum for selecting specific L2 fields removal
+*//***************************************************************************/
+typedef enum ioc_fm_pcd_manip_hdr_rmv_specific_l2 {
+    e_IOC_FM_PCD_MANIP_HDR_RMV_ETHERNET,                /**< Ethernet/802.3 MAC */
+    e_IOC_FM_PCD_MANIP_HDR_RMV_STACKED_QTAGS,           /**< stacked QTags */
+    e_IOC_FM_PCD_MANIP_HDR_RMV_ETHERNET_AND_MPLS,       /**< MPLS and Ethernet/802.3 MAC header until
+                                                             the header which follows the MPLS header */
+    e_IOC_FM_PCD_MANIP_HDR_RMV_MPLS                     /**< Remove MPLS header (Unlimited MPLS labels) */
+} ioc_fm_pcd_manip_hdr_rmv_specific_l2;
+
+/**************************************************************************//**
+ @Description   Enumeration type for selecting specific fields updates
+*//***************************************************************************/
+typedef enum ioc_fm_pcd_manip_hdr_field_update_type {
+    e_IOC_FM_PCD_MANIP_HDR_FIELD_UPDATE_VLAN,           /**< VLAN updates */
+    e_IOC_FM_PCD_MANIP_HDR_FIELD_UPDATE_IPV4,           /**< IPV4 updates */
+    e_IOC_FM_PCD_MANIP_HDR_FIELD_UPDATE_IPV6,           /**< IPV6 updates */
+    e_IOC_FM_PCD_MANIP_HDR_FIELD_UPDATE_TCP_UDP,        /**< TCP_UDP updates */
+} ioc_fm_pcd_manip_hdr_field_update_type;
+
+/**************************************************************************//**
+ @Description   Enumeration type for selecting VLAN updates
+*//***************************************************************************/
+typedef enum ioc_fm_pcd_manip_hdr_field_update_vlan {
+    e_IOC_FM_PCD_MANIP_HDR_FIELD_UPDATE_VLAN_VPRI,      /**< Replace VPri of outer most VLAN tag. */
+    e_IOC_FM_PCD_MANIP_HDR_FIELD_UPDATE_DSCP_TO_VLAN    /**< DSCP to VLAN priority bits translation */
+} ioc_fm_pcd_manip_hdr_field_update_vlan;
+
+/**************************************************************************//**
+ @Description   Enumeration type for selecting specific L2 fields removal
+*//***************************************************************************/
+typedef enum ioc_fm_pcd_manip_hdr_insrt_specific_l2 {
+    e_IOC_FM_PCD_MANIP_HDR_INSRT_MPLS                   /**< Insert MPLS header (Unlimited MPLS labels) */
+} ioc_fm_pcd_manip_hdr_insrt_specific_l2;
+
+#if (DPAA_VERSION >= 11)
+/**************************************************************************//**
+ @Description   Enumeration type for selecting QoS mapping mode
+
+                Note: In all cases except 'e_FM_PCD_MANIP_HDR_QOS_MAPPING_NONE'
+                User should instruct the port to read the parser-result
+*//***************************************************************************/
+typedef enum ioc_fm_pcd_manip_hdr_qos_mapping_mode {
+    e_IOC_FM_PCD_MANIP_HDR_QOS_MAPPING_NONE = 0, /**< No mapping, QoS field will not be changed */
+    e_IOC_FM_PCD_MANIP_HDR_QOS_MAPPING_AS_IS, /**< QoS field will be overwritten by the last byte in the parser-result. */
+} ioc_fm_pcd_manip_hdr_qos_mapping_mode;
+
+/**************************************************************************//**
+ @Description   Enumeration type for selecting QoS source
+
+                Note: In all cases except 'e_FM_PCD_MANIP_HDR_QOS_SRC_NONE'
+                User should left room for the parser-result on input/output buffer
+                and instruct the port to read/write the parser-result to the buffer (RPD should be set)
+*//***************************************************************************/
+typedef enum ioc_fm_pcd_manip_hdr_qos_src {
+    e_IOC_FM_PCD_MANIP_HDR_QOS_SRC_NONE = 0, /**< TODO */
+    e_IOC_FM_PCD_MANIP_HDR_QOS_SRC_USER_DEFINED, /**< QoS will be taken from the last byte in the parser-result. */
+} ioc_fm_pcd_manip_hdr_qos_src;
+#endif /* (DPAA_VERSION >= 11) */
+
+/**************************************************************************//**
+ @Description   Enumeration type for selecting type of header insertion
+*//***************************************************************************/
+typedef enum ioc_fm_pcd_manip_hdr_insrt_by_hdr_type {
+    e_IOC_FM_PCD_MANIP_INSRT_BY_HDR_SPECIFIC_L2,         /**< Specific L2 fields insertion */
+#if (DPAA_VERSION >= 11)
+    e_IOC_FM_PCD_MANIP_INSRT_BY_HDR_IP,                 /**< IP insertion */
+    e_IOC_FM_PCD_MANIP_INSRT_BY_HDR_UDP,                /**< UDP insertion */
+    e_IOC_FM_PCD_MANIP_INSRT_BY_HDR_UDP_LITE,             /**< UDP lite insertion */
+    e_IOC_FM_PCD_MANIP_INSRT_BY_HDR_CAPWAP                 /**< CAPWAP insertion */
+#endif /* (DPAA_VERSION >= 11) */
+} ioc_fm_pcd_manip_hdr_insrt_by_hdr_type;
+
+/**************************************************************************//**
+ @Description   Enumeration type for selecting specific custom command
+*//***************************************************************************/
+typedef enum ioc_fm_pcd_manip_hdr_custom_type {
+    e_IOC_FM_PCD_MANIP_HDR_CUSTOM_IP_REPLACE,           /**< Replace IPv4/IPv6 */
+} ioc_fm_pcd_manip_hdr_custom_type;
+
+/**************************************************************************//**
+ @Description   Enumeration type for selecting specific custom command
+*//***************************************************************************/
+typedef enum ioc_fm_pcd_manip_hdr_custom_ip_replace {
+    e_IOC_FM_PCD_MANIP_HDR_CUSTOM_REPLACE_IPV4_BY_IPV6, /**< Replace IPv4 by IPv6 */
+    e_IOC_FM_PCD_MANIP_HDR_CUSTOM_REPLACE_IPV6_BY_IPV4  /**< Replace IPv6 by IPv4 */
+} ioc_fm_pcd_manip_hdr_custom_ip_replace;
+
+/**************************************************************************//**
+ @Description   Enumeration type for selecting type of header removal
+*//***************************************************************************/
+typedef enum ioc_fm_pcd_manip_hdr_rmv_by_hdr_type {
+    e_IOC_FM_PCD_MANIP_RMV_BY_HDR_SPECIFIC_L2 = 0,       /**< Specific L2 fields removal */
+#if (DPAA_VERSION >= 11)
+    e_IOC_FM_PCD_MANIP_RMV_BY_HDR_CAPWAP,                  /**< CAPWAP removal */
+#endif /* (DPAA_VERSION >= 11) */
+#if (DPAA_VERSION >= 11) || ((DPAA_VERSION == 10) && defined(FM_CAPWAP_SUPPORT))
+    e_IOC_FM_PCD_MANIP_RMV_BY_HDR_FROM_START,           /**< Locate from data that is not the header */
+#endif /* (DPAA_VERSION >= 11) || ((DPAA_VERSION == 10) && defined(FM_CAPWAP_SUPPORT)) */
+} ioc_fm_pcd_manip_hdr_rmv_by_hdr_type;
+
+/**************************************************************************//**
+ @Description   Enumeration type for selecting type of timeout mode
+*//***************************************************************************/
+typedef enum ioc_fm_pcd_manip_reassem_time_out_mode {
+    e_IOC_FM_PCD_MANIP_TIME_OUT_BETWEEN_FRAMES,         /**< Limits the time of the reassembly process
+                                                             from the first fragment to the last */
+    e_IOC_FM_PCD_MANIP_TIME_OUT_BETWEEN_FRAG            /**< Limits the time of receiving the fragment */
+} ioc_fm_pcd_manip_reassem_time_out_mode;
+
+/**************************************************************************//**
+ @Description   Enumeration type for selecting type of WaysNumber mode
+*//***************************************************************************/
+typedef enum ioc_fm_pcd_manip_reassem_ways_number {
+    e_IOC_FM_PCD_MANIP_ONE_WAY_HASH = 1,    /**< One way hash    */
+    e_IOC_FM_PCD_MANIP_TWO_WAYS_HASH,       /**< Two ways hash   */
+    e_IOC_FM_PCD_MANIP_THREE_WAYS_HASH,     /**< Three ways hash */
+    e_IOC_FM_PCD_MANIP_FOUR_WAYS_HASH,      /**< Four ways hash  */
+    e_IOC_FM_PCD_MANIP_FIVE_WAYS_HASH,      /**< Five ways hash  */
+    e_IOC_FM_PCD_MANIP_SIX_WAYS_HASH,       /**< Six ways hash   */
+    e_IOC_FM_PCD_MANIP_SEVEN_WAYS_HASH,     /**< Seven ways hash */
+    e_IOC_FM_PCD_MANIP_EIGHT_WAYS_HASH      /**< Eight ways hash */
+} ioc_fm_pcd_manip_reassem_ways_number;
+
+#if (defined(FM_CAPWAP_SUPPORT) && (DPAA_VERSION == 10))
+/**************************************************************************//**
+ @Description   Enumeration type for selecting type of statistics mode
+*//***************************************************************************/
+typedef enum ioc_fm_pcd_stats {
+    e_IOC_FM_PCD_STATS_PER_FLOWID = 0       /**< Flow ID is used as index for getting statistics */
+} ioc_fm_pcd_stats;
+#endif
+
+/**************************************************************************//**
+ @Description   Enumeration type for selecting manipulation type
+*//***************************************************************************/
+typedef enum ioc_fm_pcd_manip_type {
+    e_IOC_FM_PCD_MANIP_HDR = 0,             /**< Header manipulation */
+    e_IOC_FM_PCD_MANIP_REASSEM,             /**< Reassembly */
+    e_IOC_FM_PCD_MANIP_FRAG,                /**< Fragmentation */
+    e_IOC_FM_PCD_MANIP_SPECIAL_OFFLOAD      /**< Special Offloading */
+} ioc_fm_pcd_manip_type;
+
+/**************************************************************************//**
+ @Description   Enumeration type for selecting type of statistics mode
+*//***************************************************************************/
+typedef enum ioc_fm_pcd_cc_stats_mode {
+    e_IOC_FM_PCD_CC_STATS_MODE_NONE = 0,        /**< No statistics support */
+    e_IOC_FM_PCD_CC_STATS_MODE_FRAME,           /**< Frame count statistics */
+    e_IOC_FM_PCD_CC_STATS_MODE_BYTE_AND_FRAME,  /**< Byte and frame count statistics */
+#if (DPAA_VERSION >= 11)
+    e_IOC_FM_PCD_CC_STATS_MODE_RMON,            /**< Byte and frame length range count statistics */
+#endif /* (DPAA_VERSION >= 11) */
+} ioc_fm_pcd_cc_stats_mode;
+
+/**************************************************************************//**
+ @Description   Enumeration type for determining the action in case an IP packet
+                is larger than MTU but its DF (Don't Fragment) bit is set.
+*//***************************************************************************/
+typedef enum ioc_fm_pcd_manip_dont_frag_action {
+    e_IOC_FM_PCD_MANIP_DISCARD_PACKET = 0,      /**< Discard packet */
+    e_IOC_FM_PCD_MANIP_ENQ_TO_ERR_Q_OR_DISCARD_PACKET =  e_IOC_FM_PCD_MANIP_DISCARD_PACKET,
+                                                /**< Obsolete, cannot enqueue to error queue;
+                                                     In practice, selects to discard packets;
+                                                     Will be removed in the future */
+    e_IOC_FM_PCD_MANIP_FRAGMENT_PACKECT,        /**< Fragment packet and continue normal processing */
+    e_IOC_FM_PCD_MANIP_CONTINUE_WITHOUT_FRAG    /**< Continue normal processing without fragmenting the packet */
+} ioc_fm_pcd_manip_dont_frag_action;
+
+/**************************************************************************//**
+ @Description   Enumeration type for selecting type of special offload manipulation
+*//***************************************************************************/
+typedef enum ioc_fm_pcd_manip_special_offload_type {
+    e_IOC_FM_PCD_MANIP_SPECIAL_OFFLOAD_IPSEC,    /**< IPSec offload manipulation */
+#if (DPAA_VERSION >= 11)
+    e_IOC_FM_PCD_MANIP_SPECIAL_OFFLOAD_CAPWAP    /**< CAPWAP offload manipulation */
+#endif /* (DPAA_VERSION >= 11) */
+} ioc_fm_pcd_manip_special_offload_type;
+
+/**************************************************************************//**
+ @Description   A union of protocol dependent special options
+                (Must match union u_FmPcdHdrProtocolOpt defined in fm_pcd_ext.h)
+*//***************************************************************************/
+typedef union ioc_fm_pcd_hdr_protocol_opt_u {
+    ioc_eth_protocol_opt_t    eth_opt;     /**< Ethernet options */
+    ioc_vlan_protocol_opt_t   vlan_opt;    /**< Vlan options */
+    ioc_mpls_protocol_opt_t   mpls_opt;    /**< MPLS options */
+    ioc_ipv4_protocol_opt_t   ipv4_opt;    /**< IPv4 options */
+    ioc_ipv6_protocol_opt_t   ipv6_opt;    /**< IPv6 options */
+#if (DPAA_VERSION >= 11)
+    ioc_capwap_protocol_opt_t capwap_opt;  /**< CAPWAP options */
+#endif /* (DPAA_VERSION >= 11) */
+} ioc_fm_pcd_hdr_protocol_opt_u;
+
+/**************************************************************************//**
+ @Description   A union holding all known protocol fields
+*//***************************************************************************/
+typedef union ioc_fm_pcd_fields_u {
+    ioc_header_field_eth_t              eth;            /**< Ethernet               */
+    ioc_header_field_vlan_t             vlan;           /**< VLAN                   */
+    ioc_header_field_llc_snap_t         llc_snap;       /**< LLC SNAP               */
+    ioc_header_field_pppoe_t            pppoe;          /**< PPPoE                  */
+    ioc_header_field_mpls_t             mpls;           /**< MPLS                   */
+    ioc_header_field_ip_t               ip;             /**< IP                     */
+    ioc_header_field_ipv4_t             ipv4;           /**< IPv4                   */
+    ioc_header_field_ipv6_t             ipv6;           /**< IPv6                   */
+    ioc_header_field_udp_t              udp;            /**< UDP                    */
+    ioc_header_field_udp_lite_t         udp_lite;       /**< UDP_Lite               */
+    ioc_header_field_tcp_t              tcp;            /**< TCP                    */
+    ioc_header_field_sctp_t             sctp;           /**< SCTP                   */
+    ioc_header_field_dccp_t             dccp;           /**< DCCP                   */
+    ioc_header_field_gre_t              gre;            /**< GRE                    */
+    ioc_header_field_minencap_t         minencap;       /**< Minimal Encapsulation  */
+    ioc_header_field_ipsec_ah_t         ipsec_ah;       /**< IPSec AH               */
+    ioc_header_field_ipsec_esp_t        ipsec_esp;      /**< IPSec ESP              */
+    ioc_header_field_udp_encap_esp_t    udp_encap_esp;  /**< UDP Encapsulation ESP  */
+} ioc_fm_pcd_fields_u;
+
+/**************************************************************************//**
+ @Description   Parameters for defining header extraction for key generation
+*//***************************************************************************/
+typedef struct ioc_fm_pcd_from_hdr_t {
+    uint8_t             size;           /**< Size in byte */
+    uint8_t             offset;         /**< Byte offset */
+} ioc_fm_pcd_from_hdr_t;
+
+/**************************************************************************//**
+ @Description   Parameters for defining field extraction for key generation
+*//***************************************************************************/
+typedef struct ioc_fm_pcd_from_field_t {
+    ioc_fm_pcd_fields_u field;          /**< Field selection */
+    uint8_t             size;           /**< Size in byte */
+    uint8_t             offset;         /**< Byte offset */
+} ioc_fm_pcd_from_field_t;
+
+/**************************************************************************//**
+ @Description   Parameters for defining a single network environment unit
+                A distinction unit should be defined if it will later be used
+                by one or more PCD engines to distinguish between flows.
+                (Must match struct t_FmPcdDistinctionUnit defined in fm_pcd_ext.h)
+*//***************************************************************************/
+typedef struct ioc_fm_pcd_distinction_unit_t {
+    struct {
+        ioc_net_header_type             hdr;                /**< One of the headers supported by the FM */
+        ioc_fm_pcd_hdr_protocol_opt_u   opt;                /**< Select only one option! */
+    } hdrs[IOC_FM_PCD_MAX_NUM_OF_INTERCHANGEABLE_HDRS];
+} ioc_fm_pcd_distinction_unit_t;
+
+/**************************************************************************//**
+ @Description   Parameters for defining all different distinction units supported
+                by a specific PCD Network Environment Characteristics module.
+
+                Each unit represent a protocol or a group of protocols that may
+                be used later by the different PCD engines to distinguish between flows.
+                (Must match struct t_FmPcdNetEnvParams defined in fm_pcd_ext.h)
+*//***************************************************************************/
+typedef struct ioc_fm_pcd_net_env_params_t {
+    uint8_t                         num_of_distinction_units;/**< Number of different units to be identified */
+    ioc_fm_pcd_distinction_unit_t   units[IOC_FM_PCD_MAX_NUM_OF_DISTINCTION_UNITS];
+                                                            /**< An array of num_of_distinction_units of the
+                                                                     different units to be identified */
+    void                            *id;                    /**< Output parameter; Returns the net-env Id to be used */
+} ioc_fm_pcd_net_env_params_t;
+
+/**************************************************************************//**
+ @Description   Parameters for defining a single extraction action when
+                creating a key
+*//***************************************************************************/
+typedef struct ioc_fm_pcd_extract_entry_t {
+    ioc_fm_pcd_extract_type                 type;           /**< Extraction type select */
+    union {
+        struct {
+            ioc_net_header_type             hdr;            /**< Header selection */
+            bool                            ignore_protocol_validation;
+                                                            /**< Ignore protocol validation */
+            ioc_fm_pcd_hdr_index            hdr_index;      /**< Relevant only for MPLS, VLAN and tunneled
+                                                                 IP. Otherwise should be cleared.*/
+            ioc_fm_pcd_extract_by_hdr_type  type;           /**< Header extraction type select */
+            union {
+                ioc_fm_pcd_from_hdr_t       from_hdr;       /**< Extract bytes from header parameters */
+                ioc_fm_pcd_from_field_t     from_field;     /**< Extract bytes from field parameters */
+                ioc_fm_pcd_fields_u         full_field;     /**< Extract full field parameters */
+            } extract_by_hdr_type;
+        } extract_by_hdr;                                   /**< Used when type = e_IOC_FM_PCD_KG_EXTRACT_BY_HDR */
+        struct {
+            ioc_fm_pcd_extract_from         src;            /**< Non-header extraction source */
+            ioc_fm_pcd_action               action;         /**< Relevant for CC Only */
+            uint16_t                        ic_indx_mask;   /**< Relevant only for CC when
+                                                                 action = e_IOC_FM_PCD_ACTION_INDEXED_LOOKUP;
+                                                                 Note that the number of bits that are set within
+                                                                 this mask must be log2 of the CC-node 'num_of_keys'.
+                                                                 Note that the mask cannot be set on the lower bits. */
+            uint8_t                         offset;         /**< Byte offset */
+            uint8_t                         size;           /**< Size in bytes */
+        } extract_non_hdr;                                  /**< Used when type = e_IOC_FM_PCD_KG_EXTRACT_NON_HDR */
+    } extract_params;
+} ioc_fm_pcd_extract_entry_t;
+
+/**************************************************************************//**
+ @Description   A structure for defining masks for each extracted
+                field in the key.
+*//***************************************************************************/
+typedef struct ioc_fm_pcd_kg_extract_mask_t {
+    uint8_t                extract_array_index;         /**< Index in the extraction array, as initialized by user */
+    uint8_t                offset;                      /**< Byte offset */
+    uint8_t                mask;                        /**< A byte mask (selected bits will be ignored) */
+} ioc_fm_pcd_kg_extract_mask_t;
+
+/**************************************************************************//**
+ @Description   A structure for defining default selection per groups
+                of fields
+*//***************************************************************************/
+typedef struct ioc_fm_pcd_kg_extract_dflt_t {
+    ioc_fm_pcd_kg_known_fields_dflt_types    type;          /**< Default type select*/
+    ioc_fm_pcd_kg_extract_dflt_select        dflt_select;   /**< Default register select */
+} ioc_fm_pcd_kg_extract_dflt_t;
+
+
+/**************************************************************************//**
+ @Description   A structure for defining all parameters needed for
+                generation a key and using a hash function
+*//***************************************************************************/
+typedef struct ioc_fm_pcd_kg_key_extract_and_hash_params_t {
+    uint32_t                            private_dflt0;          /**< Scheme default register 0 */
+    uint32_t                            private_dflt1;          /**< Scheme default register 1 */
+    uint8_t                             num_of_used_extracts;   /**< defines the valid size of the following array */
+    ioc_fm_pcd_extract_entry_t          extract_array [IOC_FM_PCD_KG_MAX_NUM_OF_EXTRACTS_PER_KEY];
+                                                                /**< An array of extraction definitions. */
+    uint8_t                             num_of_used_dflts;      /**< defines the valid size of the following array */
+    ioc_fm_pcd_kg_extract_dflt_t        dflts[IOC_FM_PCD_KG_NUM_OF_DEFAULT_GROUPS];
+                                                                /**< For each extraction used in this scheme, specify the required
+                                                                     default register to be used when header is not found.
+                                                                     types not specified in this array will get undefined value. */
+    uint8_t                             num_of_used_masks;      /**< Defines the valid size of the following array */
+    ioc_fm_pcd_kg_extract_mask_t        masks[IOC_FM_PCD_KG_NUM_OF_EXTRACT_MASKS];
+    uint8_t                             hash_shift;             /**< Hash result right shift.
+                                                                     Selects the 24 bits out of the 64 hash result.
+                                                                     0 means using the 24 LSB's, otherwise use the
+                                                                     24 LSB's after shifting right.*/
+    uint32_t                            hash_distribution_num_of_fqids; /**< must be > 1 and a power of 2. Represents the range
+                                                                             of queues for the key and hash functionality */
+    uint8_t                             hash_distribution_fqids_shift;  /**< selects the FQID bits that will be effected by the hash */
+    bool                                symmetric_hash;         /**< TRUE to generate the same hash for frames with swapped source and
+                                                                     destination fields on all layers; If TRUE, driver will check that for
+                                                                     all layers, if SRC extraction is selected, DST extraction must also be
+                                                                     selected, and vice versa. */
+} ioc_fm_pcd_kg_key_extract_and_hash_params_t;
+
+/**************************************************************************//**
+ @Description   A structure of parameters for defining a single
+                Qid mask (extracted OR).
+*//***************************************************************************/
+typedef struct ioc_fm_pcd_kg_extracted_or_params_t {
+    ioc_fm_pcd_extract_type                 type;               /**< Extraction type select */
+    union {
+        struct {                                                 /**< used when type = e_IOC_FM_PCD_KG_EXTRACT_BY_HDR */
+            ioc_net_header_type             hdr;
+            ioc_fm_pcd_hdr_index            hdr_index;          /**< Relevant only for MPLS, VLAN and tunneled
+                                                                     IP. Otherwise should be cleared.*/
+            bool                            ignore_protocol_validation;
+
+        } extract_by_hdr;
+        ioc_fm_pcd_extract_from             src;                /**< used when type = e_IOC_FM_PCD_KG_EXTRACT_NON_HDR */
+    } extract_params;
+    uint8_t                                 extraction_offset;  /**< Offset for extraction */
+    ioc_fm_pcd_kg_extract_dflt_select       dflt_value;         /**< Select register from which extraction is taken if
+                                                                     field not found */
+    uint8_t                                 mask;               /**< Mask LSB byte of extraction (specified bits are ignored) */
+    uint8_t                         bit_offset_in_fqid;    /**< 0-31, Selects which bits of the 24 FQID bits to effect using
+                                                             the extracted byte; Assume byte is placed as the 8 MSB's in
+                                                             a 32 bit word where the lower bits
+                                                             are the FQID; i.e if bitOffsetInFqid=1 than its LSB
+                                                             will effect the FQID MSB, if bitOffsetInFqid=24 than the
+                                                             extracted byte will effect the 8 LSB's of the FQID,
+                                                             if bitOffsetInFqid=31 than the byte's MSB will effect
+                                                             the FQID's LSB; 0 means - no effect on FQID;
+                                                             Note that one, and only one of
+                                                             bitOffsetInFqid or bitOffsetInPlcrProfile must be set (i.e,
+                                                             extracted byte must effect either FQID or Policer profile).*/
+    uint8_t                         bit_offset_in_plcr_profile;
+                                                        /**< 0-15, Selects which bits of the 8 policer profile id bits to
+                                                             effect using the extracted byte; Assume byte is placed
+                                                             as the 8 MSB's in a 16 bit word where the lower bits
+                                                             are the policer profile id; i.e if bitOffsetInPlcrProfile=1
+                                                             than its LSB will effect the profile MSB, if bitOffsetInFqid=8
+                                                             than the extracted byte will effect the whole policer profile id,
+                                                             if bitOffsetInFqid=15 than the byte's MSB will effect
+                                                             the Policer Profile id's LSB;
+                                                             0 means - no effect on policer profile; Note that one, and only one of
+                                                             bitOffsetInFqid or bitOffsetInPlcrProfile must be set (i.e,
+                                                             extracted byte must effect either FQID or Policer profile).*/
+} ioc_fm_pcd_kg_extracted_or_params_t;
+
+/**************************************************************************//**
+ @Description   A structure for configuring scheme counter
+*//***************************************************************************/
+typedef struct ioc_fm_pcd_kg_scheme_counter_t {
+    bool        update;     /**< FALSE to keep the current counter state
+                                 and continue from that point, TRUE to update/reset
+                                 the counter when the scheme is written. */
+    uint32_t    value;      /**< If update=TRUE, this value will be written into the
+                                 counter; clear this field to reset the counter. */
+} ioc_fm_pcd_kg_scheme_counter_t;
+
+
+/**************************************************************************//**
+ @Description   A structure for retrieving FMKG_SE_SPC
+*//***************************************************************************/
+typedef struct ioc_fm_pcd_kg_scheme_spc_t {
+    uint32_t    val;       /**< return value */
+    void        *id;       /**< scheme handle */
+} ioc_fm_pcd_kg_scheme_spc_t;
+
+/**************************************************************************//**
+ @Description   A structure for defining policer profile parameters as required by keygen
+                (when policer is the next engine after this scheme).
+                (Must match struct t_FmPcdKgPlcrProfile defined in fm_pcd_ext.h)
+*//***************************************************************************/
+typedef struct ioc_fm_pcd_kg_plcr_profile_t {
+    bool                shared_profile;                 /**< TRUE if this profile is shared between ports
+                                                             (i.e. managed by master partition) May not be TRUE
+                                                             if profile is after Coarse Classification*/
+    bool                direct;                         /**< If TRUE, direct_relative_profile_id only selects the profile
+                                                             id, if FALSE fqid_offset_relative_profile_id_base is used
+                                                             together with fqid_offset_shift and num_of_profiles
+                                                             parameters, to define a range of profiles from
+                                                             which the KeyGen result will determine the
+                                                             destination policer profile.  */
+    union {
+        uint16_t        direct_relative_profile_id;     /**< Used if 'direct' is TRUE, to select policer profile.
+                                                             This parameter should indicate the policer profile offset within the port's
+                                                             policer profiles or SHARED window. */
+        struct {
+            uint8_t     fqid_offset_shift;              /**< Shift of KG results without the qid base */
+            uint8_t     fqid_offset_relative_profile_id_base;
+                                                        /**< OR of KG results without the qid base
+                                                             This parameter should indicate the policer profile
+                                                             offset within the port's policer profiles window
+                                                             or SHARED window depends on shared_profile */
+            uint8_t     num_of_profiles;                /**< Range of profiles starting at base */
+        } indirect_profile;                             /**< Indirect profile parameters */
+    } profile_select;                                   /**< Direct/indirect profile selection and parameters */
+} ioc_fm_pcd_kg_plcr_profile_t;
+
+#if DPAA_VERSION >= 11
+/**************************************************************************//**
+ @Description   Parameters for configuring a storage profile for a KeyGen scheme.
+*//***************************************************************************/
+typedef struct ioc_fm_pcd_kg_storage_profile_t {
+    bool                direct;                     /**< If TRUE, directRelativeProfileId only selects the
+                                                         profile id;
+                                                         If FALSE, fqidOffsetRelativeProfileIdBase is used
+                                                         together with fqidOffsetShift and numOfProfiles
+                                                         parameters to define a range of profiles from which
+                                                         the KeyGen result will determine the destination
+                                                         storage profile. */
+    union {
+        uint16_t        direct_relative_profileId;    /**< Used when 'direct' is TRUE, to select a storage profile;
+                                                         should indicate the storage profile offset within the
+                                                         port's storage profiles window. */
+        struct {
+            uint8_t     fqid_offset_shift;            /**< Shift of KeyGen results without the FQID base */
+            uint8_t     fqid_offset_relative_profile_id_base;
+                                                    /**< OR of KeyGen results without the FQID base;
+                                                         should indicate the policer profile offset within the
+                                                         port's storage profiles window. */
+            uint8_t     num_of_profiles;              /**< Range of profiles starting at base. */
+        } indirect_profile;                          /**< Indirect profile parameters. */
+    } profile_select;                                /**< Direct/indirect profile selection and parameters. */
+} ioc_fm_pcd_kg_storage_profile_t;
+#endif /* DPAA_VERSION >= 11 */
+
+/**************************************************************************//**
+ @Description   Parameters for defining CC as the next engine after KeyGen
+                (Must match struct t_FmPcdKgCc defined in fm_pcd_ext.h)
+*//***************************************************************************/
+typedef struct ioc_fm_pcd_kg_cc_t {
+    void                            *tree_id;           /**< CC Tree id */
+    uint8_t                         grp_id;             /**< CC group id within the CC tree */
+    bool                            plcr_next;          /**< TRUE if after CC, in case of data frame,
+                                                             policing is required. */
+    bool                            bypass_plcr_profile_generation;
+                                                        /**< TRUE to bypass KeyGen policer profile generation;
+                                                             selected profile is the one set at port initialization. */
+    ioc_fm_pcd_kg_plcr_profile_t    plcr_profile;       /**< Valid only if plcr_next = TRUE and
+                                                             bypass_plcr_profile_generation = FALSE */
+} ioc_fm_pcd_kg_cc_t;
+
+/**************************************************************************//**
+ @Description   Parameters for defining initializing a KeyGen scheme
+                (Must match struct t_FmPcdKgSchemeParams defined in fm_pcd_ext.h)
+*//***************************************************************************/
+typedef struct ioc_fm_pcd_kg_scheme_params_t {
+    bool                                modify;         /**< TRUE to change an existing scheme */
+    union {
+        uint8_t                         relative_scheme_id;
+                                                        /**< if modify=FALSE: partition-relative scheme id */
+        void                            *scheme_id;     /**< if modify=TRUE: the id of an existing scheme */
+    } scm_id;
+    bool                                always_direct;  /**< This scheme is reached only directly, i.e. no need
+                                                             for match vector; KeyGen will ignore it when matching */
+    struct {                                            /**< HL relevant only if always_direct=FALSE */
+        void                            *net_env_id;    /**< The id of the Network Environment as returned
+                                                             by FM_PCD_NetEnvCharacteristicsSet() */
+        uint8_t                         num_of_distinction_units;
+                                                        /**< Number of NetEnv units listed in unit_ids array */
+        uint8_t                         unit_ids[IOC_FM_PCD_MAX_NUM_OF_DISTINCTION_UNITS];
+                                                        /**< Indexes as passed to SetNetEnvCharacteristics (?) array */
+    } net_env_params;
+    bool                                use_hash;       /**< use the KG Hash functionality */
+    ioc_fm_pcd_kg_key_extract_and_hash_params_t key_extract_and_hash_params;
+                                                        /**< used only if useHash = TRUE */
+    bool                                bypass_fqid_generation;
+                                                        /**< Normally - FALSE, TRUE to avoid FQID update in the IC;
+                                                             In such a case FQID after KG will be the default FQID
+                                                             defined for the relevant port, or the FQID defined by CC
+                                                             in cases where CC was the previous engine. */
+    uint32_t                            base_fqid;      /**< Base FQID; Relevant only if bypass_fqid_generation = FALSE;
+                                                             If hash is used and an even distribution is expected
+                                                             according to hash_distribution_num_of_fqids, base_fqid must be aligned to
+                                                             hash_distribution_num_of_fqids. */
+    uint8_t                             num_of_used_extracted_ors;
+                                                        /**< Number of FQID masks listed in extracted_ors array*/
+    ioc_fm_pcd_kg_extracted_or_params_t extracted_ors[IOC_FM_PCD_KG_NUM_OF_GENERIC_REGS];
+                                                        /**< IOC_FM_PCD_KG_NUM_OF_GENERIC_REGS
+                                                             registers are shared between qid_masks
+                                                             functionality and some of the extraction
+                                                             actions; Normally only some will be used
+                                                             for qid_mask. Driver will return error if
+                                                             resource is full at initialization time. */
+#if DPAA_VERSION >= 11
+    bool                                override_storage_profile;
+                                                        /**< TRUE if KeyGen override previously decided storage profile */
+    ioc_fm_pcd_kg_storage_profile_t     storage_profile;/**< Used when override_storage_profile=TRUE */
+#endif /* DPAA_VERSION >= 11 */
+    ioc_fm_pcd_engine                   next_engine;     /**< may be BMI, PLCR or CC */
+    union {                                              /**< depends on nextEngine */
+        ioc_fm_pcd_done_action          done_action;     /**< Used when next engine is BMI (done) */
+        ioc_fm_pcd_kg_plcr_profile_t    plcr_profile;    /**< Used when next engine is PLCR */
+        ioc_fm_pcd_kg_cc_t              cc;              /**< Used when next engine is CC */
+    } kg_next_engine_params;
+    ioc_fm_pcd_kg_scheme_counter_t      scheme_counter;  /**< A structure of parameters for updating
+                                                              the scheme counter */
+    void                                *id;             /**< Returns the scheme Id to be used */
+} ioc_fm_pcd_kg_scheme_params_t;
+
+/**************************************************************************//**
+ @Collection
+*//***************************************************************************/
+#if DPAA_VERSION >= 11
+#define IOC_FM_PCD_CC_STATS_MAX_NUM_OF_FLR      10  /* Maximal supported number of frame length ranges */
+#define IOC_FM_PCD_CC_STATS_FLR_SIZE            2   /* Size in bytes of a frame length range limit */
+#endif /* DPAA_VERSION >= 11 */
+#define IOC_FM_PCD_CC_STATS_FLR_COUNT_SIZE      4   /* Size in bytes of a frame length range counter */
+/* @} */
+
+/**************************************************************************//**
+ @Description   Parameters for defining CC as the next engine after a CC node.
+                (Must match struct t_FmPcdCcNextCcParams defined in fm_pcd_ext.h)
+*//***************************************************************************/
+typedef struct ioc_fm_pcd_cc_next_cc_params_t {
+    void        *cc_node_id;                             /**< Id of the next CC node */
+} ioc_fm_pcd_cc_next_cc_params_t;
+
+#if DPAA_VERSION >= 11
+/**************************************************************************//**
+ @Description   A structure for defining Frame Replicator as the next engine after a CC node.
+                (Must match struct t_FmPcdCcNextFrParams defined in fm_pcd_ext.h)
+*//***************************************************************************/
+typedef struct ioc_fm_pcd_cc_next_fr_params_t {
+    void*       frm_replic_id;              /**< The id of the next frame replicator group */
+} ioc_fm_pcd_cc_next_fr_params_t;
+#endif /* DPAA_VERSION >= 11 */
+
+/**************************************************************************//**
+ @Description   A structure for defining PLCR params when PLCR is the
+                next engine after a CC node
+                (Must match struct t_FmPcdCcNextPlcrParams defined in fm_pcd_ext.h)
+*//***************************************************************************/
+typedef struct ioc_fm_pcd_cc_next_plcr_params_t {
+    bool        override_params;            /**< TRUE if CC override previously decided parameters*/
+    bool        shared_profile;             /**< Relevant only if overrideParams=TRUE:
+                                                TRUE if this profile is shared between ports */
+    uint16_t    new_relative_profile_id;    /**< Relevant only if overrideParams=TRUE:
+                                                (otherwise profile id is taken from keygen);
+                                                This parameter should indicate the policer
+                                                profile offset within the port's
+                                                policer profiles or from SHARED window.*/
+    uint32_t    new_fqid;                   /**< Relevant only if overrideParams=TRUE:
+                                                FQID for enquing the frame;
+                                                In earlier chips  if policer next engine is KEYGEN,
+                                                this parameter can be 0, because the KEYGEN always decides
+                                                the enqueue FQID.*/
+#if DPAA_VERSION >= 11
+    uint8_t     new_relative_storage_profile_id;
+                                            /**< Indicates the relative storage profile offset within
+                                                 the port's storage profiles window;
+                                                 Relevant only if the port was configured with VSP. */
+#endif /* DPAA_VERSION >= 11 */
+} ioc_fm_pcd_cc_next_plcr_params_t;
+
+/**************************************************************************//**
+ @Description   A structure for defining enqueue params when BMI is the
+                next engine after a CC node
+                (Must match struct t_FmPcdCcNextEnqueueParams defined in fm_pcd_ext.h)
+*//***************************************************************************/
+typedef struct ioc_fm_pcd_cc_next_enqueue_params_t {
+    ioc_fm_pcd_done_action  action;         /**< Action - when next engine is BMI (done) */
+    bool                    override_fqid;  /**< TRUE if CC override previously decided fqid and vspid,
+                                                 relevant if action = e_IOC_FM_PCD_ENQ_FRAME */
+    uint32_t                new_fqid;       /**< Valid if overrideFqid=TRUE, FQID for enqueuing the frame
+                                                 (otherwise FQID is taken from KeyGen),
+                                                 relevant if action = e_IOC_FM_PCD_ENQ_FRAME*/
+#if DPAA_VERSION >= 11
+    uint8_t                 new_relative_storage_profile_id;
+                                            /**< Valid if override_fqid=TRUE, Indicates the relative virtual
+                                                 storage profile offset within the port's storage profiles
+                                                 window; Relevant only if the port was configured with VSP. */
+#endif /* DPAA_VERSION >= 11 */
+
+} ioc_fm_pcd_cc_next_enqueue_params_t;
+
+/**************************************************************************//**
+ @Description   A structure for defining KG params when KG is the next engine after a CC node
+                (Must match struct t_FmPcdCcNextKgParams defined in fm_pcd_ext.h)
+*//***************************************************************************/
+typedef struct ioc_fm_pcd_cc_next_kg_params_t {
+    bool       override_fqid;               /**< TRUE if CC override previously decided fqid and vspid,
+                                                 Note - this parameters are irrelevant for earlier chips */
+    uint32_t   new_fqid;                    /**< Valid if overrideFqid=TRUE, FQID for enqueuing the frame
+                                                 (otherwise FQID is taken from KeyGen),
+                                                 Note - this parameters are irrelevant for earlier chips */
+#if DPAA_VERSION >= 11
+    uint8_t              new_relative_storage_profile_id;
+                                            /**< Valid if override_fqid=TRUE, Indicates the relative virtual
+                                                 storage profile offset within the port's storage profiles
+                                                 window; Relevant only if the port was configured with VSP. */
+#endif /* DPAA_VERSION >= 11 */
+    void       *p_direct_scheme;            /**< Direct scheme id to go to. */
+} ioc_fm_pcd_cc_next_kg_params_t;
+
+/**************************************************************************//**
+ @Description   Parameters for defining the next engine after a CC node.
+                (Must match struct t_FmPcdCcNextEngineParams defined in fm_pcd_ext.h)
+*//***************************************************************************/
+typedef struct ioc_fm_pcd_cc_next_engine_params_t {
+    ioc_fm_pcd_engine                           next_engine;    /**< User has to initialize parameters
+                                                                     according to nextEngine definition */
+    union {
+            ioc_fm_pcd_cc_next_cc_params_t      cc_params;      /**< Parameters in case next engine is CC */
+            ioc_fm_pcd_cc_next_plcr_params_t    plcr_params;    /**< Parameters in case next engine is PLCR */
+            ioc_fm_pcd_cc_next_enqueue_params_t enqueue_params; /**< Parameters in case next engine is BMI */
+            ioc_fm_pcd_cc_next_kg_params_t      kg_params;      /**< Parameters in case next engine is KG */
+#if DPAA_VERSION >= 11
+            ioc_fm_pcd_cc_next_fr_params_t      fr_params;      /**< Parameters in case next engine is FR */
+#endif /* DPAA_VERSION >= 11 */
+    } params;                                                   /**< Union used for all the next-engine parameters options */
+    void                                        *manip_id;      /**< Handle to Manipulation object.
+                                                                     Relevant if next engine is of type result
+                                                                     (e_IOC_FM_PCD_PLCR, e_IOC_FM_PCD_KG, e_IOC_FM_PCD_DONE) */
+    bool                                        statistics_en;  /**< If TRUE, statistics counters are incremented
+                                                                      for each frame passing through this
+                                                                      Coarse Classification entry. */
+} ioc_fm_pcd_cc_next_engine_params_t;
+
+/**************************************************************************//**
+ @Description   Parameters for defining a single CC key
+*//***************************************************************************/
+typedef struct ioc_fm_pcd_cc_key_params_t {
+    uint8_t                 *p_key;         /**< pointer to the key of the size defined in key_size */
+    uint8_t                 *p_mask;        /**< pointer to the Mask per key of the size defined
+                                                 in keySize. p_key and p_mask (if defined) has to be
+                                                 of the same size defined in the key_size */
+    ioc_fm_pcd_cc_next_engine_params_t  cc_next_engine_params;
+                                            /**< parameters for the next for the defined Key in p_key */
+
+} ioc_fm_pcd_cc_key_params_t;
+
+/**************************************************************************//**
+ @Description   Parameters for defining CC keys parameters
+                The driver supports two methods for CC node allocation: dynamic and static.
+                Static mode was created in order to prevent runtime alloc/free
+                of FMan memory (MURAM), which may cause fragmentation; in this mode,
+                the driver automatically allocates the memory according to
+                'max_num_of_keys' parameter. The driver calculates the maximal memory
+                size that may be used for this CC-Node taking into consideration
+                'mask_support' and 'statistics_mode' parameters.
+                When 'action' = e_IOC_FM_PCD_ACTION_INDEXED_LOOKUP in the extraction
+                parameters of this node, 'max_num_of_keys' must be equal to 'num_of_keys'.
+                In dynamic mode, 'max_num_of_keys' must be zero. At initialization,
+                all required structures are allocated according to 'num_of_keys'
+                parameter. During runtime modification, these structures are
+                re-allocated according to the updated number of keys.
+
+                Please note that 'action' and 'ic_indx_mask' mentioned in the
+                specific parameter explanations are passed in the extraction
+                parameters of the node (fields of extractccparams.extractnonhdr).
+*//***************************************************************************/
+typedef struct ioc_keys_params_t {
+    uint16_t                    max_num_of_keys;/**< Maximum number of keys that will (ever) be used in this CC-Node;
+                                                     A value of zero may be used for dynamic memory allocation. */
+    bool                        mask_support;   /**< This parameter is relevant only if a node is initialized with
+                                                     action = e_IOC_FM_PCD_ACTION_EXACT_MATCH and max_num_of_keys > 0;
+                                                     Should be TRUE to reserve table memory for key masks, even if
+                                                     initial keys do not contain masks, or if the node was initialized
+                                                     as 'empty' (without keys); this will allow user to add keys with
+                                                     masks at runtime. */
+    ioc_fm_pcd_cc_stats_mode    statistics_mode;/**< Determines the supported statistics mode for all node's keys.
+                                                     To enable statistics gathering, statistics should be enabled per
+                                                     every key, using 'statistics_en' in next engine parameters structure
+                                                     of that key;
+                                                     If 'max_num_of_keys' is set, all required structures will be
+                                                     preallocated for all keys. */
+#if (DPAA_VERSION >= 11)
+    uint16_t                    frame_length_ranges[IOC_FM_PCD_CC_STATS_MAX_NUM_OF_FLR];
+                                                /**< Relevant only for 'RMON' statistics mode
+                                                     (this feature is supported only on B4860 device);
+                                                     Holds a list of programmable thresholds. For each received frame,
+                                                     its length in bytes is examined against these range thresholds and
+                                                     the appropriate counter is incremented by 1. For example, to belong
+                                                     to range i, the following should hold:
+                                                     range i-1 threshold < frame length <= range i threshold
+                                                     Each range threshold must be larger then its preceding range
+                                                     threshold. Last range threshold must be 0xFFFF. */
+#endif /* (DPAA_VERSION >= 11) */
+    uint16_t                    num_of_keys;    /**< Number of initial keys;
+                                                     Note that in case of 'action' = e_IOC_FM_PCD_ACTION_INDEXED_LOOKUP,
+                                                     this field should be power-of-2 of the number of bits that are
+                                                     set in 'ic_indx_mask'. */
+    uint8_t                     key_size;       /**< Size of key - for extraction of type FULL_FIELD, 'key_size' has
+                                                     to be the standard size of the selected key; For other extraction
+                                                     types, 'key_size' has to be as size of extraction; When 'action' =
+                                                     e_IOC_FM_PCD_ACTION_INDEXED_LOOKUP, 'keySize' must be 2. */
+    ioc_fm_pcd_cc_key_params_t  key_params[IOC_FM_PCD_MAX_NUM_OF_KEYS];
+                                                /**< An array with 'num_of_keys' entries, each entry specifies the
+                                                     corresponding key parameters;
+                                                     When 'action' = e_IOC_FM_PCD_ACTION_EXACT_MATCH, this value must not
+                                                     exceed 255 (IOC_FM_PCD_MAX_NUM_OF_KEYS-1) as the last entry is saved
+                                                     for the 'miss' entry. */
+    ioc_fm_pcd_cc_next_engine_params_t  cc_next_engine_params_for_miss;
+                                                /**< Parameters for defining the next engine when a key is not matched;
+                                                     Not relevant if action = e_IOC_FM_PCD_ACTION_INDEXED_LOOKUP. */
+} ioc_keys_params_t;
+
+/**************************************************************************//**
+ @Description   Parameters for defining a CC node
+*//***************************************************************************/
+typedef struct ioc_fm_pcd_cc_node_params_t {
+    ioc_fm_pcd_extract_entry_t          extract_cc_params;  /**< Extraction parameters */
+    ioc_keys_params_t                   keys_params;        /**< Keys definition matching the selected extraction */
+    void                                *id;                /**< Output parameter; returns the CC node Id to be used */
+} ioc_fm_pcd_cc_node_params_t;
+
+/**************************************************************************//**
+ @Description   Parameters for defining a hash table
+                (Must match struct t_FmPcdHashTableParams defined in fm_pcd_ext.h)
+*//***************************************************************************/
+typedef struct ioc_fm_pcd_hash_table_params_t {
+    uint16_t                    max_num_of_keys;            /**< Maximum Number Of Keys that will (ever) be used in this Hash-table */
+    ioc_fm_pcd_cc_stats_mode    statistics_mode;            /**< If not e_IOC_FM_PCD_CC_STATS_MODE_NONE, the required structures for the
+                                                                 requested statistics mode will be allocated according to max_num_of_keys. */
+    uint8_t                     kg_hash_shift;              /**< KG-Hash-shift as it was configured in the KG-scheme
+                                                                 that leads to this hash-table. */
+    uint16_t                    hash_res_mask;              /**< Mask that will be used on the hash-result;
+                                                                 The number-of-sets for this hash will be calculated
+                                                                 as (2^(number of bits set in 'hash_res_mask'));
+                                                                 The 4 lower bits must be cleared. */
+    uint8_t                     hash_shift;                 /**< Byte offset from the beginning of the KeyGen hash result to the
+                                                                 2-bytes to be used as hash index. */
+    uint8_t                     match_key_size;             /**< Size of the exact match keys held by the hash buckets */
+
+    ioc_fm_pcd_cc_next_engine_params_t   cc_next_engine_params_for_miss;
+                                                            /**< Parameters for defining the next engine when a key is not matched */
+    void                        *id;
+} ioc_fm_pcd_hash_table_params_t;
+
+/**************************************************************************//**
+ @Description   A structure with the arguments for the FM_PCD_HashTableAddKey ioctl() call
+*//***************************************************************************/
+typedef struct ioc_fm_pcd_hash_table_add_key_params_t {
+    void                        *p_hash_tbl;
+    uint8_t                     key_size;
+    ioc_fm_pcd_cc_key_params_t  key_params;
+} ioc_fm_pcd_hash_table_add_key_params_t;
+
+/**************************************************************************//**
+ @Description   Parameters for defining a CC tree group.
+
+                This structure defines a CC group in terms of NetEnv units
+                and the action to be taken in each case. The unit_ids list must
+                be given in order from low to high indices.
+
+                ioc_fm_pcd_cc_next_engine_params_t is a list of 2^num_of_distinction_units
+                structures where each defines the next action to be taken for
+                each units combination. for example:
+                num_of_distinction_units = 2
+                unit_ids = {1,3}
+                next_engine_per_entries_in_grp[0] = ioc_fm_pcd_cc_next_engine_params_t for the case that
+                                                    unit 1 - not found; unit 3 - not found;
+                next_engine_per_entries_in_grp[1] = ioc_fm_pcd_cc_next_engine_params_t for the case that
+                                                    unit 1 - not found; unit 3 - found;
+                next_engine_per_entries_in_grp[2] = ioc_fm_pcd_cc_next_engine_params_t for the case that
+                                                    unit 1 - found; unit 3 - not found;
+                next_engine_per_entries_in_grp[3] = ioc_fm_pcd_cc_next_engine_params_t for the case that
+                                                    unit 1 - found; unit 3 - found;
+*//***************************************************************************/
+typedef struct ioc_fm_pcd_cc_grp_params_t {
+    uint8_t                             num_of_distinction_units;   /**< Up to 4 */
+    uint8_t                             unit_ids [IOC_FM_PCD_MAX_NUM_OF_CC_UNITS];
+                                                                    /**< Indexes of the units as defined in
+                                                                         FM_PCD_NetEnvCharacteristicsSet() */
+    ioc_fm_pcd_cc_next_engine_params_t  next_engine_per_entries_in_grp[IOC_FM_PCD_MAX_NUM_OF_CC_ENTRIES_IN_GRP];
+                                                                    /**< Maximum entries per group is 16 */
+} ioc_fm_pcd_cc_grp_params_t;
+
+/**************************************************************************//**
+ @Description   Parameters for defining the CC tree groups
+                (Must match struct t_FmPcdCcTreeParams defined in fm_pcd_ext.h)
+*//***************************************************************************/
+typedef struct ioc_fm_pcd_cc_tree_params_t {
+        void                            *net_env_id;    /**< Id of the Network Environment as returned
+                                                             by FM_PCD_NetEnvCharacteristicsSet() */
+        uint8_t                         num_of_groups;  /**< Number of CC groups within the CC tree */
+        ioc_fm_pcd_cc_grp_params_t      fm_pcd_cc_group_params [IOC_FM_PCD_MAX_NUM_OF_CC_GROUPS];
+                                                        /**< Parameters for each group. */
+        void                            *id;            /**< Output parameter; Returns the tree Id to be used */
+} ioc_fm_pcd_cc_tree_params_t;
+
+/**************************************************************************//**
+ @Description   Parameters for defining policer byte rate
+*//***************************************************************************/
+typedef struct ioc_fm_pcd_plcr_byte_rate_mode_param_t {
+    ioc_fm_pcd_plcr_frame_length_select     frame_length_selection;     /**< Frame length selection */
+    ioc_fm_pcd_plcr_roll_back_frame_select  roll_back_frame_selection;  /**< relevant option only e_IOC_FM_PCD_PLCR_L2_FRM_LEN,
+                                                                             e_IOC_FM_PCD_PLCR_FULL_FRM_LEN */
+} ioc_fm_pcd_plcr_byte_rate_mode_param_t;
+
+/**************************************************************************//**
+ @Description   Parameters for defining the policer profile (based on
+                RFC-2698 or RFC-4115 attributes).
+*//***************************************************************************/
+typedef struct ioc_fm_pcd_plcr_non_passthrough_alg_param_t {
+    ioc_fm_pcd_plcr_rate_mode               rate_mode;                      /**< Byte / Packet */
+    ioc_fm_pcd_plcr_byte_rate_mode_param_t  byte_mode_param;                /**< Valid for Byte NULL for Packet */
+    uint32_t                                committed_info_rate;            /**< KBits/Sec or Packets/Sec */
+    uint32_t                                committed_burst_size;           /**< KBits or Packets */
+    uint32_t                                peak_or_excess_info_rate;       /**< KBits/Sec or Packets/Sec */
+    uint32_t                                peak_or_excess_burst_size;      /**< KBits or Packets */
+} ioc_fm_pcd_plcr_non_passthrough_alg_param_t;
+
+/**************************************************************************//**
+ @Description   Parameters for defining the next engine after policer
+*//***************************************************************************/
+typedef union ioc_fm_pcd_plcr_next_engine_params_u {
+        ioc_fm_pcd_done_action     action;              /**< Action - when next engine is BMI (done) */
+        void                       *p_profile;          /**< Policer profile handle -  used when next engine
+                                                             is PLCR, must be a SHARED profile */
+        void                       *p_direct_scheme;    /**< Direct scheme select - when next engine is Keygen */
+} ioc_fm_pcd_plcr_next_engine_params_u;
+
+typedef struct ioc_fm_pcd_port_params_t {
+    ioc_fm_port_type                    port_type;          /**< Type of port for this profile */
+    uint8_t                             port_id;            /**< FM-Port id of port for this profile */
+} ioc_fm_pcd_port_params_t;
+
+/**************************************************************************//**
+ @Description   Parameters for defining the policer profile entry
+                (Must match struct t_FmPcdPlcrProfileParams defined in fm_pcd_ext.h)
+*//***************************************************************************/
+typedef struct ioc_fm_pcd_plcr_profile_params_t {
+    bool                                        modify;                     /**< TRUE to change an existing profile */
+    union {
+        struct {
+            ioc_fm_pcd_profile_type_selection   profile_type;               /**< Type of policer profile */
+            ioc_fm_pcd_port_params_t            *p_fm_port;                 /**< Relevant for per-port profiles only */
+            uint16_t                            relative_profile_id;        /**< Profile id - relative to shared group or to port */
+        } new_params;                                                       /**< Use it when modify = FALSE */
+        void                                    *p_profile;                 /**< A handle to a profile - use it when modify=TRUE */
+    } profile_select;
+    ioc_fm_pcd_plcr_algorithm_selection         alg_selection;              /**< Profile Algorithm PASS_THROUGH, RFC_2698, RFC_4115 */
+    ioc_fm_pcd_plcr_color_mode                  color_mode;                 /**< COLOR_BLIND, COLOR_AWARE */
+
+    union {
+        ioc_fm_pcd_plcr_color                   dflt_color;                 /**< For Color-Blind Pass-Through mode; the policer will re-color
+                                                                                 any incoming packet with the default value. */
+        ioc_fm_pcd_plcr_color                   override;                   /**< For Color-Aware modes; the profile response to a
+                                                                                 pre-color value of 2'b11. */
+    } color;
+
+    ioc_fm_pcd_plcr_non_passthrough_alg_param_t non_passthrough_alg_param;  /**< RFC2698 or RFC4115 parameters */
+
+    ioc_fm_pcd_engine                           next_engine_on_green;       /**< Next engine for green-colored frames */
+    ioc_fm_pcd_plcr_next_engine_params_u        params_on_green;            /**< Next engine parameters for green-colored frames  */
+
+    ioc_fm_pcd_engine                           next_engine_on_yellow;      /**< Next engine for yellow-colored frames */
+    ioc_fm_pcd_plcr_next_engine_params_u        params_on_yellow;           /**< Next engine parameters for yellow-colored frames  */
+
+    ioc_fm_pcd_engine                           next_engine_on_red;         /**< Next engine for red-colored frames */
+    ioc_fm_pcd_plcr_next_engine_params_u        params_on_red;              /**< Next engine parameters for red-colored frames  */
+
+    bool                                        trap_profile_on_flow_A;     /**< Obsolete - do not use */
+    bool                                        trap_profile_on_flow_B;     /**< Obsolete - do not use */
+    bool                                        trap_profile_on_flow_C;     /**< Obsolete - do not use */
+
+    void                                        *id;                        /**< output parameter; Returns the profile Id to be used */
+} ioc_fm_pcd_plcr_profile_params_t;
+
+/**************************************************************************//**
+ @Description   A structure for modifying CC tree next engine
+*//***************************************************************************/
+typedef struct ioc_fm_pcd_cc_tree_modify_next_engine_params_t {
+    void                                *id;                /**< CC tree Id to be used */
+    uint8_t                             grp_indx;           /**< A Group index in the tree */
+    uint8_t                             indx;               /**< Entry index in the group defined by grp_index */
+    ioc_fm_pcd_cc_next_engine_params_t  cc_next_engine_params;
+                                                            /**< Parameters for the next for the defined Key in the p_Key */
+} ioc_fm_pcd_cc_tree_modify_next_engine_params_t;
+
+/**************************************************************************//**
+ @Description   A structure for modifying CC node next engine
+*//***************************************************************************/
+typedef struct ioc_fm_pcd_cc_node_modify_next_engine_params_t {
+    void                                *id;                /**< CC node Id to be used */
+    uint16_t                            key_indx;           /**< Key index for Next Engine Params modifications;
+                                                                 NOTE: This parameter is IGNORED for miss-key!  */
+    uint8_t                             key_size;           /**< Key size of added key */
+    ioc_fm_pcd_cc_next_engine_params_t  cc_next_engine_params;
+                                                            /**< parameters for the next for the defined Key in the p_Key */
+} ioc_fm_pcd_cc_node_modify_next_engine_params_t;
+
+/**************************************************************************//**
+ @Description   A structure for remove CC node key
+*//***************************************************************************/
+typedef struct ioc_fm_pcd_cc_node_remove_key_params_t {
+    void                                *id;                /**< CC node Id to be used */
+    uint16_t                            key_indx;           /**< Key index for Next Engine Params modifications;
+                                                                 NOTE: This parameter is IGNORED for miss-key!  */
+} ioc_fm_pcd_cc_node_remove_key_params_t;
+
+/**************************************************************************//**
+ @Description   A structure for modifying CC node key and next engine
+*//***************************************************************************/
+typedef struct ioc_fm_pcd_cc_node_modify_key_and_next_engine_params_t {
+    void                                *id;                /**< CC node Id to be used */
+    uint16_t                            key_indx;           /**< Key index for Next Engine Params modifications;
+                                                                 NOTE: This parameter is IGNORED for miss-key!  */
+    uint8_t                             key_size;           /**< Key size of added key */
+    ioc_fm_pcd_cc_key_params_t          key_params;         /**< it's array with numOfKeys entries each entry in
+                                                                 the array of the type ioc_fm_pcd_cc_key_params_t */
+} ioc_fm_pcd_cc_node_modify_key_and_next_engine_params_t;
+
+/**************************************************************************//**
+ @Description   A structure for modifying CC node key
+*//***************************************************************************/
+typedef struct ioc_fm_pcd_cc_node_modify_key_params_t {
+    void                                *id;                /**< CC node Id to be used */
+    uint16_t                            key_indx;           /**< Key index for Next Engine Params modifications;
+                                                                 NOTE: This parameter is IGNORED for miss-key!  */
+    uint8_t                             key_size;           /**< Key size of added key */
+    uint8_t                             *p_key;             /**< Pointer to the key of the size defined in key_size */
+    uint8_t                             *p_mask;            /**< Pointer to the Mask per key of the size defined
+                                                                 in keySize. p_Key and p_Mask (if defined) have to be
+                                                                 of the same size as defined in the key_size */
+} ioc_fm_pcd_cc_node_modify_key_params_t;
+
+/**************************************************************************//**
+ @Description   A structure with the arguments for the FM_PCD_HashTableRemoveKey ioctl() call
+*//***************************************************************************/
+typedef struct ioc_fm_pcd_hash_table_remove_key_params_t {
+    void       *p_hash_tbl;     /**< The id of the hash table */
+    uint8_t     key_size;       /**< The size of the key to remove */
+    uint8_t    *p_key;          /**< Pointer to the key to remove */
+} ioc_fm_pcd_hash_table_remove_key_params_t;
+
+/**************************************************************************//**
+ @Description   Parameters for selecting a location for requested manipulation
+*//***************************************************************************/
+typedef struct ioc_fm_manip_hdr_info_t {
+    ioc_net_header_type                 hdr;            /**< Header selection */
+    ioc_fm_pcd_hdr_index                hdr_index;      /**< Relevant only for MPLS, VLAN and tunneled IP. Otherwise should be cleared. */
+    bool                                by_field;       /**< TRUE if the location of manipulation is according to some field in the specific header*/
+    ioc_fm_pcd_fields_u                 full_field;     /**< Relevant only when by_field = TRUE: Extract field */
+} ioc_fm_manip_hdr_info_t;
+
+/**************************************************************************//**
+ @Description   Parameters for defining header removal by header type
+*//***************************************************************************/
+typedef struct ioc_fm_pcd_manip_hdr_rmv_by_hdr_params_t {
+    ioc_fm_pcd_manip_hdr_rmv_by_hdr_type        type;  /**< Selection of header removal location */
+    union {
+#if ((DPAA_VERSION == 10) && defined(FM_CAPWAP_SUPPORT))
+        struct {
+            bool                                include;/**< If FALSE, remove until the specified header (not including the header);
+                                                             If TRUE, remove also the specified header. */
+            ioc_fm_manip_hdr_info_t             hdr_info;
+        } from_start_by_hdr;                           /**< Relevant when type = e_IOC_FM_PCD_MANIP_RMV_BY_HDR_FROM_START */
+#endif /* FM_CAPWAP_SUPPORT */
+#if (DPAA_VERSION >= 11)
+        ioc_fm_manip_hdr_info_t                hdr_info;        /**< Relevant when type = e_FM_PCD_MANIP_RMV_BY_HDR_FROM_START */
+#endif /* (DPAA_VERSION >= 11) */
+        ioc_fm_pcd_manip_hdr_rmv_specific_l2    specific_l2;/**< Relevant when type = e_IOC_FM_PCD_MANIP_BY_HDR_SPECIFIC_L2;
+                                                                 Defines which L2 headers to remove. */
+    } u;
+} ioc_fm_pcd_manip_hdr_rmv_by_hdr_params_t;
+
+/**************************************************************************//**
+ @Description   Parameters for configuring IP fragmentation manipulation
+*//***************************************************************************/
+typedef struct ioc_fm_pcd_manip_frag_ip_params_t {
+    uint16_t                    size_for_fragmentation;     /**< If length of the frame is greater than this value,
+                                                                 IP fragmentation will be executed.*/
+#if DPAA_VERSION == 10
+    uint8_t                     scratch_bpid;               /**< Absolute buffer pool id according to BM configuration.*/
+#endif /* DPAA_VERSION == 10 */
+    bool                        sg_bpid_en;                 /**< Enable a dedicated buffer pool id for the Scatter/Gather buffer allocation;
+                                                                 If disabled, the Scatter/Gather buffer will be allocated from the same pool as the
+                                                                 received frame's buffer. */
+    uint8_t                     sg_bpid;                    /**< Scatter/Gather buffer pool id;
+                                                                 This parameter is relevant when 'sg_bpid_en=TRUE';
+                                                                 Same LIODN number is used for these buffers as for the received frames buffers, so buffers
+                                                                 of this pool need to be allocated in the same memory area as the received buffers.
+                                                                 If the received buffers arrive from different sources, the Scatter/Gather BP id should be
+                                                                 mutual to all these sources. */
+    ioc_fm_pcd_manip_dont_frag_action  dont_frag_action;    /**< Dont Fragment Action - If an IP packet is larger
+                                                                 than MTU and its DF bit is set, then this field will
+                                                                 determine the action to be taken.*/
+} ioc_fm_pcd_manip_frag_ip_params_t;
+
+/**************************************************************************//**
+ @Description   Parameters for configuring IP reassembly manipulation.
+
+                This is a common structure for both IPv4 and IPv6 reassembly
+                manipulation. For reassembly of both IPv4 and IPv6, make sure to
+                set the 'hdr' field in ioc_fm_pcd_manip_reassem_params_t to IOC_HEADER_TYPE_IPv6.
+*//***************************************************************************/
+typedef struct ioc_fm_pcd_manip_reassem_ip_params_t {
+    uint8_t                         relative_scheme_id[2];    /**< Partition relative scheme id:
+                                                                 relativeSchemeId[0] -  Relative scheme ID for IPV4 Reassembly manipulation;
+                                                                 relativeSchemeId[1] -  Relative scheme ID for IPV6 Reassembly manipulation;
+                                                                 NOTE: The following comment is relevant only for FMAN v2 devices:
+                                                                 Relative scheme ID for IPv4/IPv6 Reassembly manipulation must be smaller than
+                                                                 the user schemes id to ensure that the reassembly's schemes will be first match.
+                                                                 The remaining schemes, if defined, should have higher relative scheme ID. */
+#if DPAA_VERSION >= 11
+    uint32_t                        non_consistent_sp_fqid; /**< In case that other fragments of the frame corresponds to different storage
+                                                                 profile than the opening fragment (Non-Consistent-SP state)
+                                                                 then one of two possible scenarios occurs:
+                                                                 if 'nonConsistentSpFqid != 0', the reassembled frame will be enqueued to
+                                                                 this fqid, otherwise a 'Non Consistent SP' bit will be set in the FD[status].*/
+#else
+    uint8_t                         sg_bpid;                /**< Buffer pool id for the S/G frame created by the reassembly process */
+#endif /* DPAA_VERSION >= 11 */
+    uint8_t                         data_mem_id;            /**< Memory partition ID for the IPR's external tables structure */
+    uint16_t                        data_liodn_offset;      /**< LIODN offset for access the IPR's external tables structure. */
+    uint16_t                        min_frag_size[2];       /**< Minimum fragment size:
+                                                                 minFragSize[0] - for ipv4, minFragSize[1] - for ipv6 */
+    ioc_fm_pcd_manip_reassem_ways_number   num_of_frames_per_hash_entry[2];
+                                                            /**< Number of frames per hash entry needed for reassembly process:
+                                                                 numOfFramesPerHashEntry[0] - for ipv4 (max value is e_IOC_FM_PCD_MANIP_EIGHT_WAYS_HASH);
+                                                                 numOfFramesPerHashEntry[1] - for ipv6 (max value is e_IOC_FM_PCD_MANIP_SIX_WAYS_HASH). */
+    uint16_t                        max_num_frames_in_process;/**< Number of frames which can be processed by Reassembly in the same time;
+                                                                 Must be power of 2;
+                                                                 In the case numOfFramesPerHashEntry == e_IOC_FM_PCD_MANIP_FOUR_WAYS_HASH,
+                                                                 maxNumFramesInProcess has to be in the range of 4 - 512;
+                                                                 In the case numOfFramesPerHashEntry == e_IOC_FM_PCD_MANIP_EIGHT_WAYS_HASH,
+                                                                 maxNumFramesInProcess has to be in the range of 8 - 2048. */
+    ioc_fm_pcd_manip_reassem_time_out_mode  time_out_mode;  /**< Expiration delay initialized by Reassembly process */
+    uint32_t                        fqid_for_time_out_frames;/**< FQID in which time out frames will enqueue during Time Out Process  */
+    uint32_t                        timeout_threshold_for_reassm_process;
+                                                            /**< Represents the time interval in microseconds which defines
+                                                                 if opened frame (at least one fragment was processed but not all the fragments)is found as too old*/
+} ioc_fm_pcd_manip_reassem_ip_params_t;
+
+/**************************************************************************//**
+ @Description   Parameters for defining IPSEC manipulation
+*//***************************************************************************/
+typedef struct ioc_fm_pcd_manip_special_offload_ipsec_params_t {
+    bool    decryption;                     /**< TRUE if being used in decryption direction;
+                                                 FALSE if being used in encryption direction. */
+    bool    ecn_copy;                       /**< TRUE to copy the ECN bits from inner/outer to outer/inner
+                                                 (direction depends on the 'decryption' field). */
+    bool    dscp_copy;                      /**< TRUE to copy the DSCP bits from inner/outer to outer/inner
+                                                 (direction depends on the 'decryption' field). */
+    bool    variable_ip_hdr_len;            /**< TRUE for supporting variable IP header length in decryption. */
+    bool    variable_ip_version;            /**< TRUE for supporting both IP version on the same SA in encryption */
+    uint8_t outer_ip_hdr_len;               /**< If 'variable_ip_version == TRUE' than this field must be set to non-zero value;
+                                                 It is specifies the length of the outer IP header that was configured in the
+                                                 corresponding SA. */
+    uint16_t    arw_size;                   /**< if <> '0' then will perform ARW check for this SA;
+                                                 The value must be a multiplication of 16 */
+    void    *arw_addr;                      /**< if arwSize <> '0' then this field must be set to non-zero value;
+                                                 MUST be allocated from FMAN's MURAM that the post-sec op-port belong
+                                                 Must be 4B aligned. Required MURAM size is '(NEXT_POWER_OF_2(arwSize+32))/8+4' Bytes */
+} ioc_fm_pcd_manip_special_offload_ipsec_params_t;
+
+#if (DPAA_VERSION >= 11)
+/**************************************************************************//**
+ @Description   Parameters for configuring CAPWAP fragmentation manipulation
+
+ Restrictions:
+     - Maximum number of fragments per frame is 16.
+     - Transmit confirmation is not supported.
+     - Fragmentation nodes must be set as the last PCD action (i.e. the
+       corresponding CC node key must have next engine set to e_FM_PCD_DONE).
+     - Only BMan buffers shall be used for frames to be fragmented.
+     - NOTE: The following comment is relevant only for FMAN v3 devices: IPF
+       does not support VSP. Therefore, on the same port where we have IPF we
+       cannot support VSP.
+*//***************************************************************************/
+typedef struct ioc_fm_pcd_manip_frag_capwap_params_t {
+    uint16_t                    size_for_fragmentation;   /**< If length of the frame is greater than this value,
+                                                             CAPWAP fragmentation will be executed.*/
+    bool                        sg_bpid_en;               /**< Enable a dedicated buffer pool id for the Scatter/Gather buffer allocation;
+                                                             If disabled, the Scatter/Gather buffer will be allocated from the same pool as the
+                                                             received frame's buffer. */
+    uint8_t                     sg_bpid;                 /**< Scatter/Gather buffer pool id;
+                                                             This parameters is relevant when 'sgBpidEn=TRUE';
+                                                             Same LIODN number is used for these buffers as for the received frames buffers, so buffers
+                                                             of this pool need to be allocated in the same memory area as the received buffers.
+                                                             If the received buffers arrive from different sources, the Scatter/Gather BP id should be
+                                                             mutual to all these sources. */
+    bool                        compress_mode_en;         /**< CAPWAP Header Options Compress Enable mode;
+                                                             When this mode is enabled then only the first fragment include the CAPWAP header options
+                                                             field (if user provides it in the input frame) and all other fragments exclude the CAPWAP
+                                                             options field (CAPWAP header is updated accordingly).*/
+} ioc_fm_pcd_manip_frag_capwap_params_t;
+
+/**************************************************************************//**
+ @Description   Parameters for configuring CAPWAP reassembly manipulation.
+
+ Restrictions:
+    - Application must define one scheme to catch the reassembled frames.
+    - Maximum number of fragments per frame is 16.
+
+*//***************************************************************************/
+typedef struct ioc_fm_pcd_manip_reassem_capwap_params_t {
+    uint8_t                         relative_scheme_id;    /**< Partition relative scheme id;
+                                                                 NOTE: this id must be smaller than the user schemes id to ensure that the reassembly scheme will be first match;
+                                                                 Rest schemes, if defined, should have higher relative scheme ID. */
+    uint8_t                         data_mem_id;              /**< Memory partition ID for the IPR's external tables structure */
+    uint16_t                        data_liodn_offset;        /**< LIODN offset for access the IPR's external tables structure. */
+    uint16_t                        max_reassembled_frame_length;/**< The maximum CAPWAP reassembled frame length in bytes;
+                                                                   If maxReassembledFrameLength == 0, any successful reassembled frame length is
+                                                                   considered as a valid length;
+                                                                   if maxReassembledFrameLength > 0, a successful reassembled frame which its length
+                                                                   exceeds this value is considered as an error frame (FD status[CRE] bit is set). */
+    ioc_fm_pcd_manip_reassem_ways_number   num_of_frames_per_hash_entry;
+                                                            /**< Number of frames per hash entry needed for reassembly process */
+    uint16_t                        max_num_frames_in_process;  /**< Number of frames which can be processed by reassembly in the same time;
+                                                                 Must be power of 2;
+                                                                 In the case numOfFramesPerHashEntry == e_FM_PCD_MANIP_FOUR_WAYS_HASH,
+                                                                 maxNumFramesInProcess has to be in the range of 4 - 512;
+                                                                 In the case numOfFramesPerHashEntry == e_FM_PCD_MANIP_EIGHT_WAYS_HASH,
+                                                                 maxNumFramesInProcess has to be in the range of 8 - 2048. */
+    ioc_fm_pcd_manip_reassem_time_out_mode  time_out_mode;            /**< Expiration delay initialized by Reassembly process */
+    uint32_t                        fqid_for_time_out_frames;   /**< FQID in which time out frames will enqueue during Time Out Process;
+                                                                 Recommended value for this field is 0; in this way timed-out frames will be discarded */
+    uint32_t                        timeout_threshold_for_reassm_process;
+                                                            /**< Represents the time interval in microseconds which defines
+                                                                 if opened frame (at least one fragment was processed but not all the fragments)is found as too old*/
+} ioc_fm_pcd_manip_reassem_capwap_params_t;
+
+/**************************************************************************//**
+ @Description   structure for defining CAPWAP manipulation
+*//***************************************************************************/
+typedef struct ioc_fm_pcd_manip_special_offload_capwap_params_t {
+    bool                    dtls;   /**< TRUE if continue to SEC DTLS encryption */
+    ioc_fm_pcd_manip_hdr_qos_src   qos_src; /**< TODO */
+} ioc_fm_pcd_manip_special_offload_capwap_params_t;
+
+#endif /* (DPAA_VERSION >= 11) */
+
+/**************************************************************************//**
+ @Description   Parameters for defining special offload manipulation
+*//***************************************************************************/
+typedef struct ioc_fm_pcd_manip_special_offload_params_t {
+    ioc_fm_pcd_manip_special_offload_type               type;       /**< Type of special offload manipulation */
+    union
+    {
+        ioc_fm_pcd_manip_special_offload_ipsec_params_t ipsec;      /**< Parameters for IPSec; Relevant when
+                                                                         type = e_IOC_FM_PCD_MANIP_SPECIAL_OFFLOAD_IPSEC */
+
+#if (DPAA_VERSION >= 11)
+        ioc_fm_pcd_manip_special_offload_capwap_params_t  capwap;     /**< Parameters for CAPWAP; Relevant when
+                                                                type = e_FM_PCD_MANIP_SPECIAL_OFFLOAD_CAPWAP */
+#endif /* (DPAA_VERSION >= 11) */
+    } u;
+} ioc_fm_pcd_manip_special_offload_params_t;
+
+/**************************************************************************//**
+ @Description   Parameters for defining generic removal manipulation
+*//***************************************************************************/
+typedef struct ioc_fm_pcd_manip_hdr_rmv_generic_params_t {
+    uint8_t                         offset;         /**< Offset from beginning of header to the start
+                                                         location of the removal */
+    uint8_t                         size;           /**< Size of removed section */
+} ioc_fm_pcd_manip_hdr_rmv_generic_params_t;
+
+/**************************************************************************//**
+ @Description   Parameters for defining insertion manipulation
+*//***************************************************************************/
+typedef struct ioc_fm_pcd_manip_hdr_insrt_t {
+    uint8_t size;           /**< size of inserted section */
+    uint8_t *p_data;        /**< data to be inserted */
+} ioc_fm_pcd_manip_hdr_insrt_t;
+
+/**************************************************************************//**
+ @Description   Parameters for defining generic insertion manipulation
+*//***************************************************************************/
+typedef struct ioc_fm_pcd_manip_hdr_insrt_generic_params_t {
+    uint8_t                         offset;         /**< Offset from beginning of header to the start
+                                                         location of the insertion */
+    uint8_t                         size;           /**< Size of inserted section */
+    bool                            replace;        /**< TRUE to override (replace) existing data at
+                                                         'offset', FALSE to insert */
+    uint8_t                         *p_data;        /**< Pointer to data to be inserted */
+} ioc_fm_pcd_manip_hdr_insrt_generic_params_t;
+
+/**************************************************************************//**
+ @Description   Parameters for defining header manipulation VLAN DSCP To Vpri translation
+*//***************************************************************************/
+typedef struct ioc_fm_pcd_manip_hdr_field_update_vlan_dscp_to_vpri_t {
+    uint8_t                         dscp_to_vpri_table[IOC_FM_PCD_MANIP_DSCP_TO_VLAN_TRANS];
+                                                    /**< A table of VPri values for each DSCP value;
+                                                         The index is the D_SCP value (0-0x3F) and the
+                                                         value is the corresponding VPRI (0-15). */
+    uint8_t                         vpri_def_val;   /**< 0-7, Relevant only if if update_type =
+                                                         e_IOC_FM_PCD_MANIP_HDR_FIELD_UPDATE_DSCP_TO_VLAN,
+                                                         this field is the Q Tag default value if the
+                                                         IP header is not found. */
+} ioc_fm_pcd_manip_hdr_field_update_vlan_dscp_to_vpri_t;
+
+/**************************************************************************//**
+ @Description   Parameters for defining header manipulation VLAN fields updates
+*//***************************************************************************/
+typedef struct ioc_fm_pcd_manip_hdr_field_update_vlan_t {
+    ioc_fm_pcd_manip_hdr_field_update_vlan  update_type;    /**< Selects VLAN update type */
+    union {
+        uint8_t                                     vpri;   /**< 0-7, Relevant only if If update_type =
+                                                                 e_IOC_FM_PCD_MANIP_HDR_FIELD_UPDATE_VLAN_PRI, this
+                                                                 is the new VLAN pri. */
+        ioc_fm_pcd_manip_hdr_field_update_vlan_dscp_to_vpri_t    dscp_to_vpri;
+                                                            /**<  Parameters structure, Relevant only if update_type =
+                                                                  e_IOC_FM_PCD_MANIP_HDR_FIELD_UPDATE_DSCP_TO_VLAN. */
+    } u;
+} ioc_fm_pcd_manip_hdr_field_update_vlan_t;
+
+/**************************************************************************//**
+ @Description   Parameters for defining header manipulation IPV4 fields updates
+*//***************************************************************************/
+typedef struct ioc_fm_pcd_manip_hdr_field_update_ipv4_t {
+    ioc_ipv4_hdr_manip_update_flags_t       valid_updates;  /**< ORed flag, selecting the required updates */
+    uint8_t                                 tos;            /**< 8 bit New TOS; Relevant if valid_updates contains
+                                                                 IOC_HDR_MANIP_IPV4_TOS */
+    uint16_t                                id;             /**< 16 bit New IP ID; Relevant only if valid_updates
+                                                                 contains IOC_HDR_MANIP_IPV4_ID */
+    uint32_t                                src;            /**< 32 bit New IP SRC; Relevant only if valid_updates
+                                                                 contains IOC_HDR_MANIP_IPV4_SRC */
+    uint32_t                                dst;            /**< 32 bit New IP DST; Relevant only if valid_updates
+                                                                 contains IOC_HDR_MANIP_IPV4_DST */
+} ioc_fm_pcd_manip_hdr_field_update_ipv4_t;
+
+/**************************************************************************//**
+ @Description   Parameters for defining header manipulation IPV6 fields updates
+*//***************************************************************************/
+typedef struct ioc_fm_pcd_manip_hdr_field_update_ipv6_t {
+    ioc_ipv6_hdr_manip_update_flags_t       valid_updates;  /**< ORed flag, selecting the required updates */
+    uint8_t                                 traffic_class;  /**< 8 bit New Traffic Class; Relevant if valid_updates contains
+                                                                 IOC_HDR_MANIP_IPV6_TC */
+    uint8_t                                 src[IOC_NET_HEADER_FIELD_IPv6_ADDR_SIZE];
+                                                            /**< 16 byte new IP SRC; Relevant only if valid_updates
+                                                                 contains IOC_HDR_MANIP_IPV6_SRC */
+    uint8_t                                 dst[IOC_NET_HEADER_FIELD_IPv6_ADDR_SIZE];
+                                                            /**< 16 byte new IP DST; Relevant only if valid_updates
+                                                                 contains IOC_HDR_MANIP_IPV6_DST */
+} ioc_fm_pcd_manip_hdr_field_update_ipv6_t;
+
+/**************************************************************************//**
+ @Description   Parameters for defining header manipulation TCP/UDP fields updates
+*//***************************************************************************/
+typedef struct ioc_fm_pcd_manip_hdr_field_update_tcp_udp_t {
+    ioc_tcp_udp_hdr_manip_update_flags_t    valid_updates;  /**< ORed flag, selecting the required updates */
+    uint16_t                                src;            /**< 16 bit New TCP/UDP SRC; Relevant only if valid_updates
+                                                                 contains IOC_HDR_MANIP_TCP_UDP_SRC */
+    uint16_t                                dst;            /**< 16 bit New TCP/UDP DST; Relevant only if valid_updates
+                                                                 contains IOC_HDR_MANIP_TCP_UDP_DST */
+} ioc_fm_pcd_manip_hdr_field_update_tcp_udp_t;
+
+/**************************************************************************//**
+ @Description   Parameters for defining header manipulation fields updates
+*//***************************************************************************/
+typedef struct ioc_fm_pcd_manip_hdr_field_update_params_t {
+    ioc_fm_pcd_manip_hdr_field_update_type          type;   /**< Type of header field update manipulation */
+    union {
+        ioc_fm_pcd_manip_hdr_field_update_vlan_t    vlan;   /**< Parameters for VLAN update. Relevant when
+                                                                 type = e_IOC_FM_PCD_MANIP_HDR_FIELD_UPDATE_VLAN */
+        ioc_fm_pcd_manip_hdr_field_update_ipv4_t    ipv4;   /**< Parameters for IPv4 update. Relevant when
+                                                                 type = e_IOC_FM_PCD_MANIP_HDR_FIELD_UPDATE_IPV4 */
+        ioc_fm_pcd_manip_hdr_field_update_ipv6_t    ipv6;   /**< Parameters for IPv6 update. Relevant when
+                                                                 type = e_IOC_FM_PCD_MANIP_HDR_FIELD_UPDATE_IPV6 */
+        ioc_fm_pcd_manip_hdr_field_update_tcp_udp_t tcp_udp;/**< Parameters for TCP/UDP update. Relevant when
+                                                                 type = e_IOC_FM_PCD_MANIP_HDR_FIELD_UPDATE_TCP_UDP */
+    } u;
+} ioc_fm_pcd_manip_hdr_field_update_params_t;
+
+/**************************************************************************//**
+ @Description   Parameters for defining custom header manipulation for IP replacement
+*//***************************************************************************/
+typedef struct ioc_fm_pcd_manip_hdr_custom_ip_hdr_replace_t {
+    ioc_fm_pcd_manip_hdr_custom_ip_replace  replace_type;   /**< Selects replace update type */
+    bool                                    dec_ttl_hl;     /**< Decrement TTL (IPV4) or Hop limit (IPV6) by 1 */
+    bool                                    update_ipv4_id; /**< Relevant when replace_type =
+                                                                 e_IOC_FM_PCD_MANIP_HDR_CUSTOM_REPLACE_IPV6_BY_IPV4 */
+    uint16_t                                id;             /**< 16 bit New IP ID; Relevant only if
+                                                                 update_ipv4_id = TRUE */
+    uint8_t                                 hdr_size;       /**< The size of the new IP header */
+    uint8_t                                 hdr[IOC_FM_PCD_MANIP_MAX_HDR_SIZE];
+                                                            /**< The new IP header */
+} ioc_fm_pcd_manip_hdr_custom_ip_hdr_replace_t;
+
+/**************************************************************************//**
+ @Description   Parameters for defining custom header manipulation
+*//***************************************************************************/
+typedef struct ioc_fm_pcd_manip_hdr_custom_params_t {
+    ioc_fm_pcd_manip_hdr_custom_type                type;   /**< Type of header field update manipulation */
+    union {
+        ioc_fm_pcd_manip_hdr_custom_ip_hdr_replace_t    ip_hdr_replace;
+                                                            /**< Parameters IP header replacement */
+    } u;
+} ioc_fm_pcd_manip_hdr_custom_params_t;
+
+/**************************************************************************//**
+ @Description   Parameters for defining specific L2 insertion manipulation
+*//***************************************************************************/
+typedef struct ioc_fm_pcd_manip_hdr_insrt_specific_l2_params_t {
+    ioc_fm_pcd_manip_hdr_insrt_specific_l2  specific_l2;    /**< Selects which L2 headers to insert */
+    bool                                    update;         /**< TRUE to update MPLS header */
+    uint8_t                                 size;           /**< size of inserted section */
+    uint8_t                                *p_data;         /**< data to be inserted */
+} ioc_fm_pcd_manip_hdr_insrt_specific_l2_params_t;
+
+#if (DPAA_VERSION >= 11)
+/**************************************************************************//**
+ @Description   Parameters for defining IP insertion manipulation
+*//***************************************************************************/
+typedef struct ioc_fm_pcd_manip_hdr_insrt_ip_params_t {
+    bool    calc_l4_checksum; /**< Calculate L4 checksum. */
+    ioc_fm_pcd_manip_hdr_qos_mapping_mode   mapping_mode; /**< TODO */
+    uint8_t last_pid_offset;     /**< the offset of the last Protocol within
+                                 the inserted header */
+    uint16_t  id;           /**< 16 bit New IP ID */
+    bool                            dont_frag_overwrite;
+    /**< IPv4 only. DF is overwritten with the hash-result next-to-last byte.
+     * This byte is configured to be overwritten when RPD is set. */
+    uint8_t                         last_dst_offset;
+    /**< IPv6 only. if routing extension exist, user should set the offset of the destination address
+     * in order to calculate UDP checksum pseudo header;
+     * Otherwise set it to '0'. */
+    ioc_fm_pcd_manip_hdr_insrt_t insrt; /**< size and data to be inserted. */
+} ioc_fm_pcd_manip_hdr_insrt_ip_params_t;
+#endif /* (DPAA_VERSION >= 11) */
+
+/**************************************************************************//**
+ @Description   Parameters for defining header insertion manipulation by header type
+*//***************************************************************************/
+typedef struct ioc_fm_pcd_manip_hdr_insrt_by_hdr_params_t {
+    ioc_fm_pcd_manip_hdr_insrt_by_hdr_type          type;   /**< Selects manipulation type */
+    union {
+       ioc_fm_pcd_manip_hdr_insrt_specific_l2_params_t  specific_l2_params;
+                                                            /**< Used when type = e_IOC_FM_PCD_MANIP_INSRT_BY_HDR_SPECIFIC_L2:
+                                                                 Selects which L2 headers to remove */
+#if (DPAA_VERSION >= 11)
+        ioc_fm_pcd_manip_hdr_insrt_ip_params_t      ip_params;  /**< Used when type = e_FM_PCD_MANIP_INSRT_BY_HDR_IP */
+        ioc_fm_pcd_manip_hdr_insrt_t                insrt;     /**< Used when type is one of e_FM_PCD_MANIP_INSRT_BY_HDR_UDP,
+                                                                e_FM_PCD_MANIP_INSRT_BY_HDR_UDP_LITE, or
+                                                                e_FM_PCD_MANIP_INSRT_BY_HDR_CAPWAP */
+#endif /* (DPAA_VERSION >= 11) */
+    } u;
+} ioc_fm_pcd_manip_hdr_insrt_by_hdr_params_t;
+
+/**************************************************************************//**
+ @Description   Parameters for defining header insertion manipulation
+*//***************************************************************************/
+typedef struct ioc_fm_pcd_manip_hdr_insrt_params_t {
+    ioc_fm_pcd_manip_hdr_insrt_type                     type;   /**< Type of insertion manipulation */
+    union {
+        ioc_fm_pcd_manip_hdr_insrt_by_hdr_params_t      by_hdr; /**< Parameters for defining header insertion manipulation by header type,
+                                                                     relevant if 'type' = e_IOC_FM_PCD_MANIP_INSRT_BY_HDR */
+        ioc_fm_pcd_manip_hdr_insrt_generic_params_t     generic;/**< Parameters for defining generic header insertion manipulation,
+                                                                     relevant if type = e_IOC_FM_PCD_MANIP_INSRT_GENERIC */
+#if (defined(FM_CAPWAP_SUPPORT) && (DPAA_VERSION == 10))
+        ioc_fm_pcd_manip_hdr_insrt_by_template_params_t by_template;
+                                                                /**< Parameters for defining header insertion manipulation by template,
+                                                                     relevant if 'type' = e_IOC_FM_PCD_MANIP_INSRT_BY_TEMPLATE */
+#endif /* FM_CAPWAP_SUPPORT */
+    } u;
+} ioc_fm_pcd_manip_hdr_insrt_params_t;
+
+/**************************************************************************//**
+ @Description   Parameters for defining header removal manipulation
+*//***************************************************************************/
+typedef struct ioc_fm_pcd_manip_hdr_rmv_params_t {
+    ioc_fm_pcd_manip_hdr_rmv_type                  type;       /**< Type of header removal manipulation */
+    union {
+        ioc_fm_pcd_manip_hdr_rmv_by_hdr_params_t   by_hdr;     /**< Parameters for defining header removal manipulation by header type,
+                                                                    relevant if type = e_IOC_FM_PCD_MANIP_RMV_BY_HDR */
+        ioc_fm_pcd_manip_hdr_rmv_generic_params_t  generic;    /**< Parameters for defining generic header removal manipulation,
+                                                                    relevant if type = e_IOC_FM_PCD_MANIP_RMV_GENERIC */
+    } u;
+} ioc_fm_pcd_manip_hdr_rmv_params_t;
+
+/**************************************************************************//**
+ @Description   Parameters for defining header manipulation node
+*//***************************************************************************/
+typedef struct ioc_fm_pcd_manip_hdr_params_t {
+    bool                                        rmv;                  /**< TRUE, to define removal manipulation */
+    ioc_fm_pcd_manip_hdr_rmv_params_t           rmv_params;           /**< Parameters for removal manipulation, relevant if 'rmv' = TRUE */
+
+    bool                                        insrt;                /**< TRUE, to define insertion manipulation */
+    ioc_fm_pcd_manip_hdr_insrt_params_t         insrt_params;         /**< Parameters for insertion manipulation, relevant if 'insrt' = TRUE */
+
+    bool                                        field_update;         /**< TRUE, to define field update manipulation */
+    ioc_fm_pcd_manip_hdr_field_update_params_t  field_update_params;  /**< Parameters for field update manipulation, relevant if 'fieldUpdate' = TRUE */
+
+    bool                                        custom;               /**< TRUE, to define custom manipulation */
+    ioc_fm_pcd_manip_hdr_custom_params_t        custom_params;        /**< Parameters for custom manipulation, relevant if 'custom' = TRUE */
+
+    bool                                        dont_parse_after_manip;/**< FALSE to activate the parser a second time after
+                                                                            completing the manipulation on the frame */
+} ioc_fm_pcd_manip_hdr_params_t;
+
+
+/**************************************************************************//**
+ @Description   structure for defining fragmentation manipulation
+*//***************************************************************************/
+typedef struct ioc_fm_pcd_manip_frag_params_t {
+    ioc_net_header_type                     hdr;            /**< Header selection */
+    union {
+#if (DPAA_VERSION >= 11)
+        ioc_fm_pcd_manip_frag_capwap_params_t    capwap_frag;   /**< Parameters for defining CAPWAP fragmentation,
+                                                           relevant if 'hdr' = HEADER_TYPE_CAPWAP */
+#endif /* (DPAA_VERSION >= 11) */
+        ioc_fm_pcd_manip_frag_ip_params_t   ip_frag;        /**< Parameters for defining IP fragmentation,
+                                                                 relevant if 'hdr' = HEADER_TYPE_Ipv4 or HEADER_TYPE_Ipv6 */
+    } u;
+} ioc_fm_pcd_manip_frag_params_t;
+
+/**************************************************************************//**
+ @Description   structure for defining reassemble manipulation
+*//***************************************************************************/
+typedef struct ioc_fm_pcd_manip_reassem_params_t {
+    ioc_net_header_type                         hdr;        /**< Header selection */
+    union {
+#if (DPAA_VERSION >= 11)
+        ioc_fm_pcd_manip_reassem_capwap_params_t capwap_reassem;  /**< Parameters for defining CAPWAP reassembly,
+                                                           relevant if 'hdr' = HEADER_TYPE_CAPWAP */
+#endif /* (DPAA_VERSION >= 11) */
+        ioc_fm_pcd_manip_reassem_ip_params_t    ip_reassem; /**< Parameters for defining IP reassembly,
+                                                                 relevant if 'hdr' = HEADER_TYPE_Ipv4 or HEADER_TYPE_Ipv6 */
+    } u;
+} ioc_fm_pcd_manip_reassem_params_t;
+
+/**************************************************************************//**
+ @Description   Parameters for defining a manipulation node
+*//***************************************************************************/
+typedef struct ioc_fm_pcd_manip_params_t {
+    ioc_fm_pcd_manip_type                           type;   /**< Selects type of manipulation node */
+    union {
+        ioc_fm_pcd_manip_hdr_params_t               hdr;    /**< Parameters for defining header manipulation node */
+        ioc_fm_pcd_manip_reassem_params_t           reassem;/**< Parameters for defining reassembly manipulation node */
+        ioc_fm_pcd_manip_frag_params_t              frag;   /**< Parameters for defining fragmentation manipulation node */
+        ioc_fm_pcd_manip_special_offload_params_t   special_offload;/**< Parameters for defining special offload manipulation node */
+    } u;
+    void                                            *p_next_manip;/**< Handle to another (previously defined) manipulation node;
+                                                                 Allows concatenation of manipulation actions
+                                                                 This parameter is optional and may be NULL. */
+#if (defined(FM_CAPWAP_SUPPORT) && (DPAA_VERSION == 10))
+    bool                                            frag_or_reasm;/**< TRUE, if defined fragmentation/reassembly manipulation */
+    ioc_fm_pcd_manip_frag_or_reasm_params_t         frag_or_reasm_params;/**< Parameters for fragmentation/reassembly manipulation,
+                                                                            relevant if frag_or_reasm = TRUE */
+#endif /* FM_CAPWAP_SUPPORT */
+    void                                           *id;
+} ioc_fm_pcd_manip_params_t;
+
+/**************************************************************************//**
+ @Description   Structure for retrieving IP reassembly statistics
+*//***************************************************************************/
+typedef struct ioc_fm_pcd_manip_reassem_ip_stats_t {
+    /* common counters for both IPv4 and IPv6 */
+    uint32_t    timeout;                        /**< Counts the number of TimeOut occurrences */
+    uint32_t    rfd_pool_busy;                    /**< Counts the number of failed attempts to allocate
+                                                     a Reassembly Frame Descriptor */
+    uint32_t    internal_buffer_busy;             /**< Counts the number of times an internal buffer busy occurred */
+    uint32_t    external_buffer_busy;             /**< Counts the number of times external buffer busy occurred */
+    uint32_t    sg_fragments;                    /**< Counts the number of Scatter/Gather fragments */
+    uint32_t    dma_semaphore_depletion;          /**< Counts the number of failed attempts to allocate a DMA semaphore */
+#if (DPAA_VERSION >= 11)
+    uint32_t        non_consistent_sp;            /**< Counts the number of Non Consistent Storage Profile events for
+                                                     successfully reassembled frames */
+#endif /* (DPAA_VERSION >= 11) */
+struct {
+        uint32_t    successfully_reassembled;    /**< Counts the number of successfully reassembled frames */
+        uint32_t    valid_fragments;             /**< Counts the total number of valid fragments that
+                                                     have been processed for all frames */
+        uint32_t    processed_fragments;         /**< Counts the number of processed fragments
+                                                     (valid and error fragments) for all frames */
+        uint32_t    malformed_fragments;         /**< Counts the number of malformed fragments processed for all frames */
+        uint32_t    discarded_fragments;         /**< Counts the number of fragments discarded by the reassembly process */
+        uint32_t    auto_learn_busy;              /**< Counts the number of times a busy condition occurs when attempting
+                                                     to access an IP-Reassembly Automatic Learning Hash set */
+        uint32_t    more_than16fragments;        /**< Counts the fragment occurrences in which the number of fragments-per-frame
+                                                     exceeds 16 */
+    } specific_hdr_statistics[2];                 /**< slot '0' is for IPv4, slot '1' is for IPv6 */
+} ioc_fm_pcd_manip_reassem_ip_stats_t;
+
+/**************************************************************************//**
+ @Description   Structure for retrieving IP fragmentation statistics
+*//***************************************************************************/
+typedef struct ioc_fm_pcd_manip_frag_ip_stats_t {
+    uint32_t    total_frames;            /**< Number of frames that passed through the manipulation node */
+    uint32_t    fragmented_frames;       /**< Number of frames that were fragmented */
+    uint32_t    generated_fragments;     /**< Number of fragments that were generated */
+} ioc_fm_pcd_manip_frag_ip_stats_t;
+
+#if (DPAA_VERSION >= 11)
+/**************************************************************************//**
+ @Description   Structure for retrieving CAPWAP reassembly statistics
+*//***************************************************************************/
+typedef struct ioc_fm_pcd_manip_reassem_capwap_stats_t {
+    uint32_t    timeout;                    /**< Counts the number of timeout occurrences */
+    uint32_t    rfd_pool_busy;                /**< Counts the number of failed attempts to allocate
+                                                 a Reassembly Frame Descriptor */
+    uint32_t    internal_buffer_busy;         /**< Counts the number of times an internal buffer busy occurred */
+    uint32_t    external_buffer_busy;         /**< Counts the number of times external buffer busy occurred */
+    uint32_t    sg_fragments;                /**< Counts the number of Scatter/Gather fragments */
+    uint32_t    dma_semaphore_depletion;      /**< Counts the number of failed attempts to allocate a DMA semaphore */
+    uint32_t    successfully_reassembled;    /**< Counts the number of successfully reassembled frames */
+    uint32_t    valid_fragments;             /**< Counts the total number of valid fragments that
+                                                 have been processed for all frames */
+    uint32_t    processed_fragments;         /**< Counts the number of processed fragments
+                                                 (valid and error fragments) for all frames */
+    uint32_t    malformed_fragments;         /**< Counts the number of malformed fragments processed for all frames */
+    uint32_t    autoLearn_busy;              /**< Counts the number of times a busy condition occurs when attempting
+                                                 to access an Reassembly Automatic Learning Hash set */
+    uint32_t    discarded_fragments;         /**< Counts the number of fragments discarded by the reassembly process */
+    uint32_t    more_than16fragments;        /**< Counts the fragment occurrences in which the number of fragments-per-frame
+                                                 exceeds 16 */
+    uint32_t    exceed_max_reassembly_frame_len;/**< ounts the number of times that a successful reassembled frame
+                                                 length exceeds MaxReassembledFrameLength value */
+} ioc_fm_pcd_manip_reassem_capwap_stats_t;
+
+/**************************************************************************//**
+ @Description   Structure for retrieving CAPWAP fragmentation statistics
+*//***************************************************************************/
+typedef struct ioc_fm_pcd_manip_frag_capwap_stats_t {
+    uint32_t    total_frames;            /**< Number of frames that passed through the manipulation node */
+    uint32_t    fragmented_frames;       /**< Number of frames that were fragmented */
+    uint32_t    generated_fragments;     /**< Number of fragments that were generated */
+#if (defined(DEBUG_ERRORS) && (DEBUG_ERRORS > 0))
+    uint8_t     sg_allocation_failure;    /**< Number of allocation failure of s/g buffers */
+#endif /* (defined(DEBUG_ERRORS) && (DEBUG_ERRORS > 0)) */
+} ioc_fm_pcd_manip_frag_capwap_stats_t;
+#endif /* (DPAA_VERSION >= 11) */
+
+/**************************************************************************//**
+ @Description   Structure for retrieving reassembly statistics
+*//***************************************************************************/
+typedef struct ioc_fm_pcd_manip_reassem_stats_t {
+    union {
+        ioc_fm_pcd_manip_reassem_ip_stats_t  ip_reassem;  /**< Structure for IP reassembly statistics */
+#if (DPAA_VERSION >= 11)
+        ioc_fm_pcd_manip_reassem_capwap_stats_t  capwap_reassem;  /**< Structure for CAPWAP reassembly statistics */
+#endif /* (DPAA_VERSION >= 11) */
+    } u;
+} ioc_fm_pcd_manip_reassem_stats_t;
+
+/**************************************************************************//**
+ @Description   structure for retrieving fragmentation statistics
+*//***************************************************************************/
+typedef struct ioc_fm_pcd_manip_frag_stats_t {
+    union {
+        ioc_fm_pcd_manip_frag_ip_stats_t     ip_frag;     /**< Structure for IP fragmentation statistics */
+#if (DPAA_VERSION >= 11)
+        ioc_fm_pcd_manip_frag_capwap_stats_t capwap_frag; /**< Structure for CAPWAP fragmentation statistics */
+#endif /* (DPAA_VERSION >= 11) */
+    } u;
+} ioc_fm_pcd_manip_frag_stats_t;
+
+/**************************************************************************//**
+ @Description   structure for defining manipulation statistics
+*//***************************************************************************/
+typedef struct ioc_fm_pcd_manip_stats_t {
+    union {
+        ioc_fm_pcd_manip_reassem_stats_t  reassem;    /**< Structure for reassembly statistics */
+        ioc_fm_pcd_manip_frag_stats_t     frag;       /**< Structure for fragmentation statistics */
+    } u;
+} ioc_fm_pcd_manip_stats_t;
+
+/**************************************************************************//**
+ @Description   Parameters for acquiring manipulation statistics
+*//***************************************************************************/
+typedef struct ioc_fm_pcd_manip_get_stats_t {
+	void				*id;
+	ioc_fm_pcd_manip_stats_t	stats;
+} ioc_fm_pcd_manip_get_stats_t;
+
+#if DPAA_VERSION >= 11
+/**************************************************************************//**
+ @Description   Parameters for defining frame replicator group and its members
+*//***************************************************************************/
+typedef struct ioc_fm_pcd_frm_replic_group_params_t {
+    uint8_t                     max_num_of_entries;    /**< Maximal number of members in the group  - must be at least two */
+    uint8_t                     num_of_entries;       /**< Number of members in the group - must be at least 1 */
+    ioc_fm_pcd_cc_next_engine_params_t   next_engine_params[IOC_FM_PCD_FRM_REPLIC_MAX_NUM_OF_ENTRIES];
+                                                    /**< Array of members' parameters */
+    void                        *id;
+} ioc_fm_pcd_frm_replic_group_params_t;
+
+typedef struct ioc_fm_pcd_frm_replic_member_t {
+    void *h_replic_group;
+    uint16_t member_index;
+} ioc_fm_pcd_frm_replic_member_t;
+
+typedef struct ioc_fm_pcd_frm_replic_member_params_t {
+    ioc_fm_pcd_frm_replic_member_t member;
+    ioc_fm_pcd_cc_next_engine_params_t next_engine_params;
+} ioc_fm_pcd_frm_replic_member_params_t;
+#endif /* DPAA_VERSION >= 11 */
+
+
+typedef struct ioc_fm_pcd_cc_key_statistics_t {
+    uint32_t    byte_count;      /**< This counter reflects byte count of frames that
+                                     were matched by this key. */
+    uint32_t    frame_count;     /**< This counter reflects count of frames that
+                                     were matched by this key. */
+#if (DPAA_VERSION >= 11)
+    uint32_t    frame_length_range_count[IOC_FM_PCD_CC_STATS_MAX_NUM_OF_FLR];
+                                /**< These counters reflect how many frames matched
+                                     this key in 'RMON' statistics mode:
+                                     Each counter holds the number of frames of a
+                                     specific frames length range, according to the
+                                     ranges provided at initialization. */
+#endif /* (DPAA_VERSION >= 11) */
+} ioc_fm_pcd_cc_key_statistics_t;
+
+
+typedef struct ioc_fm_pcd_cc_tbl_get_stats_t {
+    void                            *id;
+    uint16_t                        key_index;
+    ioc_fm_pcd_cc_key_statistics_t  statistics;
+} ioc_fm_pcd_cc_tbl_get_stats_t;
+
+/**************************************************************************//**
+ @Function      FM_PCD_MatchTableGetKeyStatistics
+
+ @Description   This routine may be used to get statistics counters of specific key
+                in a CC Node.
+
+                If 'e_FM_PCD_CC_STATS_MODE_FRAME' and
+                'e_FM_PCD_CC_STATS_MODE_BYTE_AND_FRAME' were set for this node,
+                these counters reflect how many frames passed that were matched
+                this key; The total frames count will be returned in the counter
+                of the first range (as only one frame length range was defined).
+                If 'e_FM_PCD_CC_STATS_MODE_RMON' was set for this node, the total
+                frame count will be separated to frame length counters, based on
+                provided frame length ranges.
+
+ @Param[in]     h_CcNode        A handle to the node
+ @Param[in]     keyIndex        Key index for adding
+ @Param[out]    p_KeyStatistics Key statistics counters
+
+ @Return        The specific key statistics.
+
+ @Cautions      Allowed only following FM_PCD_MatchTableSet().
+*//***************************************************************************/
+
+#if defined(FM_COMPAT)
+#define FM_PCD_IOC_MATCH_TABLE_GET_KEY_STAT_COMPAT   _IOWR(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(12), ioc_compat_fm_pcd_cc_tbl_get_stats_t)
+#endif
+#define FM_PCD_IOC_MATCH_TABLE_GET_KEY_STAT  _IOWR(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(12), ioc_fm_pcd_cc_tbl_get_stats_t)
+
+/**************************************************************************//**
+ @Function      FM_PCD_MatchTableGetMissStatistics
+
+ @Description   This routine may be used to get statistics counters of miss entry
+                in a CC Node.
+
+                If 'e_FM_PCD_CC_STATS_MODE_FRAME' and
+                'e_FM_PCD_CC_STATS_MODE_BYTE_AND_FRAME' were set for this node,
+                these counters reflect how many frames were not matched to any
+                existing key and therefore passed through the miss entry; The
+                total frames count will be returned in the counter of the
+                first range (as only one frame length range was defined).
+
+ @Param[in]     h_CcNode            A handle to the node
+ @Param[out]    p_MissStatistics    Statistics counters for 'miss'
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PCD_MatchTableSet().
+*//***************************************************************************/
+
+#if defined(FM_COMPAT)
+#define FM_PCD_IOC_MATCH_TABLE_GET_MISS_STAT_COMPAT   _IOWR(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(13), ioc_compat_fm_pcd_cc_tbl_get_stats_t)
+#endif
+#define FM_PCD_IOC_MATCH_TABLE_GET_MISS_STAT  _IOWR(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(13), ioc_fm_pcd_cc_tbl_get_stats_t)
+
+/**************************************************************************//**
+ @Function      FM_PCD_HashTableGetMissStatistics
+
+ @Description   This routine may be used to get statistics counters of 'miss'
+                entry of the a hash table.
+
+                If 'e_FM_PCD_CC_STATS_MODE_FRAME' and
+                'e_FM_PCD_CC_STATS_MODE_BYTE_AND_FRAME' were set for this node,
+                these counters reflect how many frames were not matched to any
+                existing key and therefore passed through the miss entry;
+
+ @Param[in]     h_HashTbl           A handle to a hash table
+ @Param[out]    p_MissStatistics    Statistics counters for 'miss'
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PCD_HashTableSet().
+*//***************************************************************************/
+
+#if defined(FM_COMPAT)
+#define FM_PCD_IOC_HASH_TABLE_GET_MISS_STAT_COMPAT   _IOWR(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(14), ioc_compat_fm_pcd_cc_tbl_get_stats_t)
+#endif
+#define FM_PCD_IOC_HASH_TABLE_GET_MISS_STAT  _IOWR(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(14), ioc_fm_pcd_cc_tbl_get_stats_t)
+
+
+/**************************************************************************//**
+ @Function      FM_PCD_NetEnvCharacteristicsSet
+
+ @Description   Define a set of Network Environment Characteristics.
+
+                When setting an environment it is important to understand its
+                application. It is not meant to describe the flows that will run
+                on the ports using this environment, but what the user means TO DO
+                with the PCD mechanisms in order to parse-classify-distribute those
+                frames.
+                By specifying a distinction unit, the user means it would use that option
+                for distinction between frames at either a KeyGen scheme or a coarse
+                classification action descriptor. Using interchangeable headers to define a
+                unit means that the user is indifferent to which of the interchangeable
+                headers is present in the frame, and wants the distinction to be based
+                on the presence of either one of them.
+
+                Depending on context, there are limitations to the use of environments. A
+                port using the PCD functionality is bound to an environment. Some or even
+                all ports may share an environment but also an environment per port is
+                possible. When initializing a scheme, a classification plan group (see below),
+                or a coarse classification tree, one of the initialized environments must be
+                stated and related to. When a port is bound to a scheme, a classification
+                plan group, or a coarse classification tree, it MUST be bound to the same
+                environment.
+
+                The different PCD modules, may relate (for flows definition) ONLY on
+                distinction units as defined by their environment. When initializing a
+                scheme for example, it may not choose to select IPV4 as a match for
+                recognizing flows unless it was defined in the relating environment. In
+                fact, to guide the user through the configuration of the PCD, each module's
+                characterization in terms of flows is not done using protocol names, but using
+                environment indexes.
+
+                In terms of HW implementation, the list of distinction units sets the LCV vectors
+                and later used for match vector, classification plan vectors and coarse classification
+                indexing.
+
+ @Param[in,out] ioc_fm_pcd_net_env_params_t   A structure defining the distiction units for this configuration.
+
+ @Return        0 on success; Error code otherwise.
+*//***************************************************************************/
+#if defined(FM_COMPAT)
+#define FM_PCD_IOC_NET_ENV_CHARACTERISTICS_SET_COMPAT   _IOWR(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(20), ioc_compat_fm_pcd_net_env_params_t)
+#endif
+#define FM_PCD_IOC_NET_ENV_CHARACTERISTICS_SET  _IOWR(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(20), ioc_fm_pcd_net_env_params_t)
+
+/**************************************************************************//**
+ @Function      FM_PCD_NetEnvCharacteristicsDelete
+
+ @Description   Deletes a set of Network Environment Charecteristics.
+
+ @Param[in]     ioc_fm_obj_t - The id of a Network Environment object.
+
+ @Return        0 on success; Error code otherwise.
+*//***************************************************************************/
+#if defined(FM_COMPAT)
+#define FM_PCD_IOC_NET_ENV_CHARACTERISTICS_DELETE_COMPAT  _IOW(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(21), ioc_compat_fm_obj_t)
+#endif
+#define FM_PCD_IOC_NET_ENV_CHARACTERISTICS_DELETE   _IOW(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(21), ioc_fm_obj_t)
+
+/**************************************************************************//**
+ @Function      FM_PCD_KgSchemeSet
+
+ @Description   Initializing or modifying and enabling a scheme for the KeyGen.
+                This routine should be called for adding or modifying a scheme.
+                When a scheme needs modifying, the API requires that it will be
+                rewritten. In such a case 'modify' should be TRUE. If the
+                routine is called for a valid scheme and 'modify' is FALSE,
+                it will return error.
+
+ @Param[in,out] ioc_fm_pcd_kg_scheme_params_t   A structure of parameters for defining the scheme
+
+ @Return        0 on success; Error code otherwise.
+*//***************************************************************************/
+#if defined(FM_COMPAT)
+#define FM_PCD_IOC_KG_SCHEME_SET_COMPAT     _IOWR(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(24), ioc_compat_fm_pcd_kg_scheme_params_t)
+#endif
+#define FM_PCD_IOC_KG_SCHEME_SET    _IOWR(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(24), ioc_fm_pcd_kg_scheme_params_t)
+
+/**************************************************************************//**
+ @Function      FM_PCD_KgSchemeDelete
+
+ @Description   Deleting an initialized scheme.
+
+ @Param[in]     ioc_fm_obj_t        scheme id as initalized by application at FM_PCD_IOC_KG_SET_SCHEME
+
+ @Return        0 on success; Error code otherwise.
+*//***************************************************************************/
+#if defined(FM_COMPAT)
+#define FM_PCD_IOC_KG_SCHEME_DELETE_COMPAT  _IOW(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(25), ioc_compat_fm_obj_t)
+#endif
+#define FM_PCD_IOC_KG_SCHEME_DELETE     _IOW(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(25), ioc_fm_obj_t)
+
+/**************************************************************************//**
+ @Function      FM_PCD_CcRootBuild
+
+ @Description   This routine must be called to define a complete coarse
+                classification tree. This is the way to define coarse
+                classification to a certain flow - the KeyGen schemes
+                may point only to trees defined in this way.
+
+ @Param[in,out] ioc_fm_pcd_cc_tree_params_t     A structure of parameters to define the tree.
+
+ @Return        0 on success; Error code otherwise.
+*//***************************************************************************/
+#if defined(FM_COMPAT)
+#define FM_PCD_IOC_CC_ROOT_BUILD_COMPAT _IOWR(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(26), compat_uptr_t)
+#endif
+#define FM_PCD_IOC_CC_ROOT_BUILD    _IOWR(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(26), void *) /* workaround ...*/
+
+/**************************************************************************//**
+ @Function      FM_PCD_CcRootDelete
+
+ @Description   Deleting a built tree.
+
+ @Param[in]     ioc_fm_obj_t - The id of a CC tree.
+*//***************************************************************************/
+#if defined(FM_COMPAT)
+#define FM_PCD_IOC_CC_ROOT_DELETE_COMPAT    _IOW(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(27), ioc_compat_fm_obj_t)
+#endif
+#define FM_PCD_IOC_CC_ROOT_DELETE    _IOW(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(27), ioc_fm_obj_t)
+
+/**************************************************************************//**
+ @Function      FM_PCD_MatchTableSet
+
+ @Description   This routine should be called for each CC (coarse classification)
+                node. The whole CC tree should be built bottom up so that each
+                node points to already defined nodes. p_NodeId returns the node
+                Id to be used by other nodes.
+
+ @Param[in,out] ioc_fm_pcd_cc_node_params_t       A structure for defining the CC node params
+
+ @Return        0 on success; Error code otherwise.
+*//***************************************************************************/
+#if defined(FM_COMPAT)
+#define FM_PCD_IOC_MATCH_TABLE_SET_COMPAT    _IOWR(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(28), compat_uptr_t)
+#endif
+#define FM_PCD_IOC_MATCH_TABLE_SET    _IOWR(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(28), void *) /* workaround ...*/
+
+/**************************************************************************//**
+ @Function      FM_PCD_MatchTableDelete
+
+ @Description   Deleting a built node.
+
+ @Param[in]     ioc_fm_obj_t - The id of a CC node.
+
+ @Return        0 on success; Error code otherwise.
+*//***************************************************************************/
+#if defined(FM_COMPAT)
+#define FM_PCD_IOC_MATCH_TABLE_DELETE_COMPAT    _IOW(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(29), ioc_compat_fm_obj_t)
+#endif
+#define FM_PCD_IOC_MATCH_TABLE_DELETE   _IOW(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(29), ioc_fm_obj_t)
+
+/**************************************************************************//**
+ @Function      FM_PCD_CcRootModifyNextEngine
+
+ @Description   Modify the Next Engine Parameters in the entry of the tree.
+
+ @Param[in]     ioc_fm_pcd_cc_tree_modify_next_engine_params_t - Pointer to a structure with the relevant parameters
+
+ @Return        0 on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PCD_CcRootBuild().
+*//***************************************************************************/
+#if defined(FM_COMPAT)
+#define FM_PCD_IOC_CC_ROOT_MODIFY_NEXT_ENGINE_COMPAT   _IOW(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(30), ioc_compat_fm_pcd_cc_tree_modify_next_engine_params_t)
+#endif
+#define FM_PCD_IOC_CC_ROOT_MODIFY_NEXT_ENGINE   _IOW(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(30), ioc_fm_pcd_cc_tree_modify_next_engine_params_t)
+
+/**************************************************************************//**
+ @Function      FM_PCD_MatchTableModifyNextEngine
+
+ @Description   Modify the Next Engine Parameters in the relevant key entry of the node.
+
+ @Param[in]     ioc_fm_pcd_cc_node_modify_next_engine_params_t  A pointer to a structure with the relevant parameters
+
+ @Return        0 on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PCD_MatchTableSet().
+*//***************************************************************************/
+#if defined(FM_COMPAT)
+#define FM_PCD_IOC_MATCH_TABLE_MODIFY_NEXT_ENGINE_COMPAT   _IOW(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(31), ioc_compat_fm_pcd_cc_node_modify_next_engine_params_t)
+#endif
+#define FM_PCD_IOC_MATCH_TABLE_MODIFY_NEXT_ENGINE   _IOW(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(31), ioc_fm_pcd_cc_node_modify_next_engine_params_t)
+
+/**************************************************************************//**
+ @Function      FM_PCD_MatchTableModifyMissNextEngine
+
+ @Description   Modify the Next Engine Parameters of the Miss key case of the node.
+
+ @Param[in]     ioc_fm_pcd_cc_node_modify_next_engine_params_t - Pointer to a structure with the relevant parameters
+
+ @Return        0 on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PCD_MatchTableSet().
+*//***************************************************************************/
+#if defined(FM_COMPAT)
+#define FM_PCD_IOC_MATCH_TABLE_MODIFY_MISS_NEXT_ENGINE_COMPAT   _IOW(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(32), ioc_compat_fm_pcd_cc_node_modify_next_engine_params_t)
+#endif
+#define FM_PCD_IOC_MATCH_TABLE_MODIFY_MISS_NEXT_ENGINE _IOW(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(32), ioc_fm_pcd_cc_node_modify_next_engine_params_t)
+
+/**************************************************************************//**
+ @Function      FM_PCD_MatchTableRemoveKey
+
+ @Description   Remove the key (including next engine parameters of this key)
+                defined by the index of the relevant node.
+
+ @Param[in]     ioc_fm_pcd_cc_node_remove_key_params_t  A pointer to a structure with the relevant parameters
+
+ @Return        0 on success; Error code otherwise.
+
+ @Cautions      Allowed only after FM_PCD_MatchTableSet() has been called for this
+                node and for all of the nodes that lead to it.
+*//***************************************************************************/
+#if defined(FM_COMPAT)
+#define FM_PCD_IOC_MATCH_TABLE_REMOVE_KEY_COMPAT    _IOW(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(33), ioc_compat_fm_pcd_cc_node_remove_key_params_t)
+#endif
+#define FM_PCD_IOC_MATCH_TABLE_REMOVE_KEY   _IOW(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(33), ioc_fm_pcd_cc_node_remove_key_params_t)
+
+/**************************************************************************//**
+ @Function      FM_PCD_MatchTableAddKey
+
+ @Description   Add the key (including next engine parameters of this key in the
+                index defined by the keyIndex. Note that 'FM_PCD_LAST_KEY_INDEX'
+                may be used when the user doesn't care about the position of the
+                key in the table - in that case, the key will be automatically
+                added by the driver in the last available entry.
+
+ @Param[in]     ioc_fm_pcd_cc_node_modify_key_and_next_engine_params_t  A pointer to a structure with the relevant parameters
+
+ @Return        0 on success; Error code otherwise.
+
+ @Cautions      Allowed only after FM_PCD_MatchTableSet() has been called for this
+                node and for all of the nodes that lead to it.
+*//***************************************************************************/
+#if defined(FM_COMPAT)
+#define FM_PCD_IOC_MATCH_TABLE_ADD_KEY_COMPAT   _IOW(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(34), ioc_compat_fm_pcd_cc_node_modify_key_and_next_engine_params_t)
+#endif
+#define FM_PCD_IOC_MATCH_TABLE_ADD_KEY  _IOW(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(34), ioc_fm_pcd_cc_node_modify_key_and_next_engine_params_t)
+
+/**************************************************************************//**
+ @Function      FM_PCD_MatchTableModifyKeyAndNextEngine
+
+ @Description   Modify the key and Next Engine Parameters of this key in the index defined by key_index.
+
+ @Param[in]     ioc_fm_pcd_cc_node_modify_key_and_next_engine_params_t  A pointer to a structure with the relevant parameters
+
+ @Return        0 on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PCD_MatchTableSet() not only of the relevnt node but also
+                the node that points to this node
+*//***************************************************************************/
+#if defined(FM_COMPAT)
+#define FM_PCD_IOC_MATCH_TABLE_MODIFY_KEY_AND_NEXT_ENGINE_COMPAT    _IOW(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(35), ioc_compat_fm_pcd_cc_node_modify_key_and_next_engine_params_t)
+#endif
+#define FM_PCD_IOC_MATCH_TABLE_MODIFY_KEY_AND_NEXT_ENGINE   _IOW(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(35), ioc_fm_pcd_cc_node_modify_key_and_next_engine_params_t)
+
+/**************************************************************************//**
+ @Function      FM_PCD_MatchTableModifyKey
+
+ @Description   Modify the key at the index defined by key_index.
+
+ @Param[in]     ioc_fm_pcd_cc_node_modify_key_params_t - Pointer to a structure with the relevant parameters
+
+ @Return        0 on success; Error code otherwise.
+
+ @Cautions      Allowed only after FM_PCD_MatchTableSet() has been called for this
+                node and for all of the nodes that lead to it.
+*//***************************************************************************/
+#if defined(FM_COMPAT)
+#define FM_PCD_IOC_MATCH_TABLE_MODIFY_KEY_COMPAT    _IOW(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(36), ioc_compat_fm_pcd_cc_node_modify_key_params_t)
+#endif
+#define FM_PCD_IOC_MATCH_TABLE_MODIFY_KEY   _IOW(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(36), ioc_fm_pcd_cc_node_modify_key_params_t)
+
+/**************************************************************************//**
+ @Function      FM_PCD_HashTableSet
+
+ @Description   This routine initializes a hash table structure.
+                KeyGen hash result determines the hash bucket.
+                Next, KeyGen key is compared against all keys of this
+                bucket (exact match).
+                Number of sets (number of buckets) of the hash equals to the
+                number of 1-s in 'hash_res_mask' in the provided parameters.
+                Number of hash table ways is then calculated by dividing
+                'max_num_of_keys' equally between the hash sets. This is the maximal
+                number of keys that a hash bucket may hold.
+                The hash table is initialized empty and keys may be
+                added to it following the initialization. Keys masks are not
+                supported in current hash table implementation.
+                The initialized hash table can be integrated as a node in a
+                CC tree.
+
+ @Param[in,out] ioc_fm_pcd_hash_table_params_t - Pointer to a structure with the relevant parameters
+
+ @Return        0 on success; Error code otherwise.
+*//***************************************************************************/
+#if defined(FM_COMPAT)
+#define FM_PCD_IOC_HASH_TABLE_SET_COMPAT _IOWR(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(37), ioc_compat_fm_pcd_hash_table_params_t)
+#endif
+#define FM_PCD_IOC_HASH_TABLE_SET _IOWR(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(37), ioc_fm_pcd_hash_table_params_t)
+
+
+/**************************************************************************//**
+ @Function      FM_PCD_HashTableDelete
+
+ @Description   This routine deletes the provided hash table and released all
+                its allocated resources.
+
+ @Param[in]     ioc_fm_obj_t - The ID of a hash table.
+
+ @Return        0 on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PCD_HashTableSet().
+*//***************************************************************************/
+#if defined(FM_COMPAT)
+#define FM_PCD_IOC_HASH_TABLE_DELETE_COMPAT _IOW(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(37), ioc_compat_fm_obj_t)
+#endif
+#define FM_PCD_IOC_HASH_TABLE_DELETE _IOW(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(37), ioc_fm_obj_t)
+
+/**************************************************************************//**
+ @Function      FM_PCD_HashTableAddKey
+
+ @Description   This routine adds the provided key (including next engine
+                parameters of this key) to the hash table.
+                The key is added as the last key of the bucket that it is
+                mapped to.
+
+ @Param[in]     ioc_fm_pcd_hash_table_add_key_params_t - Pointer to a structure with the relevant parameters
+
+ @Return        0 on success; error code otherwise.
+
+ @Cautions      Allowed only following FM_PCD_HashTableSet().
+*//***************************************************************************/
+#if defined(FM_COMPAT)
+#define FM_PCD_IOC_HASH_TABLE_ADD_KEY_COMPAT _IOW(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(39), ioc_compat_fm_pcd_hash_table_add_key_params_t)
+#endif
+#define FM_PCD_IOC_HASH_TABLE_ADD_KEY _IOW(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(39), ioc_fm_pcd_hash_table_add_key_params_t)
+
+/**************************************************************************//**
+ @Function      FM_PCD_HashTableRemoveKey
+
+ @Description   This routine removes the requested key (including next engine
+                parameters of this key) from the hash table.
+
+ @Param[in]     ioc_fm_pcd_hash_table_remove_key_params_t - Pointer to a structure with the relevant parameters
+
+ @Return        0 on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PCD_HashTableSet().
+*//***************************************************************************/
+#if defined(FM_COMPAT)
+#define FM_PCD_IOC_HASH_TABLE_REMOVE_KEY_COMPAT _IOW(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(40), ioc_compat_fm_pcd_hash_table_remove_key_params_t)
+#endif
+#define FM_PCD_IOC_HASH_TABLE_REMOVE_KEY _IOW(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(40), ioc_fm_pcd_hash_table_remove_key_params_t)
+
+/**************************************************************************//**
+ @Function      FM_PCD_PlcrProfileSet
+
+ @Description   Sets a profile entry in the policer profile table.
+                The routine overrides any existing value.
+
+ @Param[in,out] ioc_fm_pcd_plcr_profile_params_t    A structure of parameters for defining a
+                                                    policer profile entry.
+
+ @Return        0 on success; Error code otherwise.
+*//***************************************************************************/
+#if defined(FM_COMPAT)
+#define FM_PCD_IOC_PLCR_PROFILE_SET_COMPAT     _IOWR(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(41), ioc_compat_fm_pcd_plcr_profile_params_t)
+#endif
+#define FM_PCD_IOC_PLCR_PROFILE_SET     _IOWR(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(41), ioc_fm_pcd_plcr_profile_params_t)
+
+/**************************************************************************//**
+ @Function      FM_PCD_PlcrProfileDelete
+
+ @Description   Delete a profile entry in the policer profile table.
+                The routine set entry to invalid.
+
+ @Param[in]     ioc_fm_obj_t        The id of a policer profile.
+
+ @Return        0 on success; Error code otherwise.
+*//***************************************************************************/
+#if defined(FM_COMPAT)
+#define FM_PCD_IOC_PLCR_PROFILE_DELETE_COMPAT   _IOW(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(41), ioc_compat_fm_obj_t)
+#endif
+#define FM_PCD_IOC_PLCR_PROFILE_DELETE  _IOW(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(41), ioc_fm_obj_t)
+
+/**************************************************************************//**
+ @Function      FM_PCD_ManipNodeSet
+
+ @Description   This routine should be called for defining a manipulation
+                node. A manipulation node must be defined before the CC node
+                that precedes it.
+
+ @Param[in]     ioc_fm_pcd_manip_params_t - A structure of parameters defining the manipulation
+
+ @Return        A handle to the initialized object on success; NULL code otherwise.
+*//***************************************************************************/
+#if defined(FM_COMPAT)
+#define FM_PCD_IOC_MANIP_NODE_SET_COMPAT    _IOWR(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(43), ioc_compat_fm_pcd_manip_params_t)
+#endif
+#define FM_PCD_IOC_MANIP_NODE_SET   _IOWR(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(43), ioc_fm_pcd_manip_params_t)
+
+/**************************************************************************//**
+ @Function      FM_PCD_ManipNodeReplace
+
+ @Description   Change existing manipulation node to be according to new requirement.
+                (Here, it's implemented as a variant of the same IOCTL as for
+                FM_PCD_ManipNodeSet(), and one that when called, the 'id' member
+                in its 'ioc_fm_pcd_manip_params_t' argument is set to contain
+                the manip node's handle)
+
+ @Param[in]     ioc_fm_pcd_manip_params_t - A structure of parameters defining the manipulation
+
+ @Return        0 on success; error code otherwise.
+
+ @Cautions      Allowed only following FM_PCD_ManipNodeSet().
+*//***************************************************************************/
+#if defined(FM_COMPAT)
+#define FM_PCD_IOC_MANIP_NODE_REPLACE_COMPAT    FM_PCD_IOC_MANIP_NODE_SET_COMPAT
+#endif
+#define FM_PCD_IOC_MANIP_NODE_REPLACE           FM_PCD_IOC_MANIP_NODE_SET
+
+/**************************************************************************//**
+ @Function      FM_PCD_ManipNodeDelete
+
+ @Description   Delete an existing manipulation node.
+
+ @Param[in]     ioc_fm_obj_t       The id of the manipulation node to delete.
+
+ @Return        0 on success; error code otherwise.
+
+ @Cautions      Allowed only following FM_PCD_ManipNodeSet().
+*//***************************************************************************/
+#if defined(FM_COMPAT)
+#define FM_PCD_IOC_MANIP_NODE_DELETE_COMPAT _IOW(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(44), ioc_compat_fm_obj_t)
+#endif
+#define FM_PCD_IOC_MANIP_NODE_DELETE    _IOW(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(44), ioc_fm_obj_t)
+
+/**************************************************************************//**
+ @Function      FM_PCD_ManipGetStatistics
+
+ @Description   Retrieve the manipulation statistics.
+
+ @Param[in]     h_ManipNode         A handle to a manipulation node.
+ @Param[out]    p_FmPcdManipStats   A structure for retrieving the manipulation statistics
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PCD_ManipNodeSet().
+*//***************************************************************************/
+#if defined(FM_COMPAT)
+#define FM_PCD_IOC_MANIP_GET_STATS_COMPAT  _IOWR(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(50), ioc_compat_fm_pcd_manip_get_stats_t)
+#endif
+#define FM_PCD_IOC_MANIP_GET_STATS   _IOWR(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(50), ioc_fm_pcd_manip_get_stats_t)
+
+/**************************************************************************//**
+@Function      FM_PCD_SetAdvancedOffloadSupport
+
+@Description   This routine must be called in order to support the following features:
+               IP-fragmentation, IP-reassembly, IPsec, Header-manipulation, frame-replicator.
+
+@Param[in]     h_FmPcd         FM PCD module descriptor.
+
+@Return        0 on success; error code otherwise.
+
+@Cautions      Allowed only when PCD is disabled.
+*//***************************************************************************/
+#define FM_PCD_IOC_SET_ADVANCED_OFFLOAD_SUPPORT _IO(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(45))
+
+/**************************************************************************//**
+ @Function      FM_PCD_AllowHcUsage
+
+ @Description   This routine must be called to temporary allow/deny HC usage
+                This is the way to avoid crash of certain HC operations
+                performed under heavy traffic.
+
+ @Param[in] 	uint8_t     0 - Deny HC usage HC, 1 - Allow HC usage
+
+ @Return        0 on success; Error code otherwise.
+*//***************************************************************************/
+#define FM_PCD_IOC_ALLOW_HC_USAGE _IOW(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(51), uint8_t)
+
+#if (DPAA_VERSION >= 11)
+/**************************************************************************//**
+ @Function      FM_PCD_FrmReplicSetGroup
+
+ @Description   Initialize a Frame Replicator group.
+
+ @Param[in]     h_FmPcd                FM PCD module descriptor.
+ @Param[in]     p_FrmReplicGroupParam  A structure of parameters for the initialization of
+                                       the frame replicator group.
+
+ @Return        A handle to the initialized object on success; NULL code otherwise.
+
+ @Cautions      Allowed only following FM_PCD_Init().
+*//***************************************************************************/
+#if defined(FM_COMPAT)
+#define FM_PCD_IOC_FRM_REPLIC_GROUP_SET_COMPAT _IOWR(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(46), ioc_compat_fm_pcd_frm_replic_group_params_t)
+#endif
+#define FM_PCD_IOC_FRM_REPLIC_GROUP_SET _IOWR(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(46), ioc_fm_pcd_frm_replic_group_params_t)
+
+/**************************************************************************//**
+ @Function      FM_PCD_FrmReplicDeleteGroup
+
+ @Description   Delete a Frame Replicator group.
+
+ @Param[in]     h_FrmReplicGroup  A handle to the frame replicator group.
+
+ @Return        E_OK on success;  Error code otherwise.
+
+ @Cautions      Allowed only following FM_PCD_FrmReplicSetGroup().
+*//***************************************************************************/
+#if defined(FM_COMPAT)
+#define FM_PCD_IOC_FRM_REPLIC_GROUP_DELETE_COMPAT _IOWR(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(47), ioc_compat_fm_obj_t)
+#endif
+#define FM_PCD_IOC_FRM_REPLIC_GROUP_DELETE _IOWR(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(47), ioc_fm_obj_t)
+
+/**************************************************************************//**
+ @Function      FM_PCD_FrmReplicAddMember
+
+ @Description   Add the member in the index defined by the memberIndex.
+
+ @Param[in]     h_FrmReplicGroup   A handle to the frame replicator group.
+ @Param[in]     memberIndex        member index for adding.
+ @Param[in]     p_MemberParams     A pointer to the new member parameters.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PCD_FrmReplicSetGroup() of this group.
+*//***************************************************************************/
+#if defined(FM_COMPAT)
+#define FM_PCD_IOC_FRM_REPLIC_MEMBER_ADD_COMPAT _IOWR(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(48), ioc_compat_fm_pcd_frm_replic_member_params_t)
+#endif
+#define FM_PCD_IOC_FRM_REPLIC_MEMBER_ADD _IOWR(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(48), ioc_fm_pcd_frm_replic_member_params_t)
+
+/**************************************************************************//**
+ @Function      FM_PCD_FrmReplicRemoveMember
+
+ @Description   Remove the member defined by the index from the relevant group.
+
+ @Param[in]     h_FrmReplicGroup   A handle to the frame replicator group.
+ @Param[in]     memberIndex        member index for removing.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PCD_FrmReplicSetGroup() of this group.
+*//***************************************************************************/
+#if defined(FM_COMPAT)
+#define FM_PCD_IOC_FRM_REPLIC_MEMBER_REMOVE_COMPAT _IOWR(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(49), ioc_compat_fm_pcd_frm_replic_member_t)
+#endif
+#define FM_PCD_IOC_FRM_REPLIC_MEMBER_REMOVE _IOWR(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(49), ioc_fm_pcd_frm_replic_member_t)
+
+#endif
+
+#if (defined(FM_CAPWAP_SUPPORT) && (DPAA_VERSION == 10))
+/**************************************************************************//**
+ @Function      FM_PCD_StatisticsSetNode
+
+ @Description   This routine should be called for defining a statistics node.
+
+ @Param[in,out] ioc_fm_pcd_stats_params_t A structure of parameters defining the statistics
+
+ @Return        0 on success; Error code otherwise.
+*//***************************************************************************/
+#if defined(FM_COMPAT)
+#define FM_PCD_IOC_STATISTICS_SET_NODE_COMPAT _IOWR(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(45), void *)
+#endif
+#define FM_PCD_IOC_STATISTICS_SET_NODE _IOWR(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(45), void *)
+
+#endif /* FM_CAPWAP_SUPPORT */
+
+#ifdef NCSW_BACKWARD_COMPATIBLE_API
+#if defined(FM_COMPAT)
+#define FM_PCD_IOC_SET_NET_ENV_CHARACTERISTICS_COMPAT \
+                                                FM_PCD_IOC_NET_ENV_CHARACTERISTICS_SET_COMPAT
+#define FM_PCD_IOC_DELETE_NET_ENV_CHARACTERISTICS_COMPAT \
+                                                FM_PCD_IOC_NET_ENV_CHARACTERISTICS_DELETE_COMPAT
+#define FM_PCD_IOC_KG_SET_SCHEME_COMPAT         FM_PCD_IOC_KG_SCHEME_SET_COMPAT
+#define FM_PCD_IOC_KG_DEL_SCHEME_COMPAT         FM_PCD_IOC_KG_SCHEME_DELETE_COMPAT
+#define FM_PCD_IOC_CC_BUILD_TREE_COMPAT         FM_PCD_IOC_CC_ROOT_BUILD_COMPAT
+#define FM_PCD_IOC_CC_DELETE_TREE_COMPAT        FM_PCD_IOC_CC_ROOT_DELETE_COMPAT
+#define FM_PCD_IOC_CC_DELETE_NODE_COMPAT        FM_PCD_IOC_MATCH_TABLE_DELETE_COMPAT
+#define FM_PCD_IOC_CC_TREE_MODIFY_NEXT_ENGINE_COMPAT \
+                                                FM_PCD_IOC_CC_ROOT_MODIFY_NEXT_ENGINE_COMPAT
+#define FM_PCD_IOC_CC_NODE_MODIFY_NEXT_ENGINE_COMPAT \
+                                                FM_PCD_IOC_MATCH_TABLE_MODIFY_NEXT_ENGINE_COMPAT
+#define FM_PCD_IOC_CC_NODE_MODIFY_MISS_NEXT_ENGINE_COMPAT \
+                                                FM_PCD_IOC_MATCH_TABLE_MODIFY_MISS_NEXT_ENGINE_COMPAT
+#define FM_PCD_IOC_CC_NODE_REMOVE_KEY_COMPAT    FM_PCD_IOC_MATCH_TABLE_REMOVE_KEY_COMPAT
+#define FM_PCD_IOC_CC_NODE_ADD_KEY_COMPAT       FM_PCD_IOC_MATCH_TABLE_ADD_KEY_COMPAT
+#define FM_PCD_IOC_CC_NODE_MODIFY_KEY_AND_NEXT_ENGINE_COMPAT \
+                                                FM_PCD_IOC_MATCH_TABLE_MODIFY_KEY_AND_NEXT_ENGINE_COMPAT
+#define FM_PCD_IOC_CC_NODE_MODIFY_KEY_COMPAT    FM_PCD_IOC_MATCH_TABLE_MODIFY_KEY_COMPAT
+#define FM_PCD_IOC_PLCR_SET_PROFILE_COMPAT      FM_PCD_IOC_PLCR_PROFILE_SET_COMPAT
+#define FM_PCD_IOC_PLCR_DEL_PROFILE_COMPAT      FM_PCD_IOC_PLCR_PROFILE_DELETE_COMPAT
+#define FM_PCD_IOC_MANIP_SET_NODE_COMPAT        FM_PCD_IOC_MANIP_NODE_SET_COMPAT
+#define FM_PCD_IOC_MANIP_DELETE_NODE_COMPAT     FM_PCD_IOC_MANIP_NODE_DELETE_COMPAT
+#endif
+#define FM_PCD_IOC_SET_NET_ENV_CHARACTERISTICS  FM_PCD_IOC_NET_ENV_CHARACTERISTICS_SET
+#define FM_PCD_IOC_DELETE_NET_ENV_CHARACTERISTICS \
+                                                FM_PCD_IOC_NET_ENV_CHARACTERISTICS_DELETE
+#define FM_PCD_IOC_KG_SET_SCHEME                FM_PCD_IOC_KG_SCHEME_SET
+#define FM_PCD_IOC_KG_DEL_SCHEME                FM_PCD_IOC_KG_SCHEME_DELETE
+#define FM_PCD_IOC_CC_BUILD_TREE                FM_PCD_IOC_CC_ROOT_BUILD
+#define FM_PCD_IOC_CC_DELETE_TREE               FM_PCD_IOC_CC_ROOT_DELETE
+#define FM_PCD_IOC_CC_DELETE_NODE               FM_PCD_IOC_MATCH_TABLE_DELETE
+#define FM_PCD_IOC_CC_TREE_MODIFY_NEXT_ENGINE   FM_PCD_IOC_CC_ROOT_MODIFY_NEXT_ENGINE
+#define FM_PCD_IOC_CC_NODE_MODIFY_NEXT_ENGINE   FM_PCD_IOC_MATCH_TABLE_MODIFY_NEXT_ENGINE
+#define FM_PCD_IOC_CC_NODE_MODIFY_MISS_NEXT_ENGINE \
+                                                FM_PCD_IOC_MATCH_TABLE_MODIFY_MISS_NEXT_ENGINE
+#define FM_PCD_IOC_CC_NODE_REMOVE_KEY           FM_PCD_IOC_MATCH_TABLE_REMOVE_KEY
+#define FM_PCD_IOC_CC_NODE_ADD_KEY              FM_PCD_IOC_MATCH_TABLE_ADD_KEY
+#define FM_PCD_IOC_CC_NODE_MODIFY_KEY_AND_NEXT_ENGINE \
+                                                FM_PCD_IOC_MATCH_TABLE_MODIFY_KEY_AND_NEXT_ENGINE
+#define FM_PCD_IOC_CC_NODE_MODIFY_KEY           FM_PCD_IOC_MATCH_TABLE_MODIFY_KEY
+#define FM_PCD_IOC_PLCR_SET_PROFILE             FM_PCD_IOC_PLCR_PROFILE_SET
+#define FM_PCD_IOC_PLCR_DEL_PROFILE             FM_PCD_IOC_PLCR_PROFILE_DELETE
+#define FM_PCD_IOC_MANIP_SET_NODE               FM_PCD_IOC_MANIP_NODE_SET
+#define FM_PCD_IOC_MANIP_DELETE_NODE            FM_PCD_IOC_MANIP_NODE_DELETE
+#endif /* NCSW_BACKWARD_COMPATIBLE_API */
+
+#endif /* __FM_PCD_IOCTLS_H */
+/** @} */ /* end of lnx_ioctl_FM_PCD_Runtime_grp group */
+/** @} */ /* end of lnx_ioctl_FM_PCD_grp group */
+/** @} */ /* end of lnx_ioctl_FM_grp group */
diff --git a/include/uapi/linux/fmd/Peripherals/fm_port_ioctls.h b/include/uapi/linux/fmd/Peripherals/fm_port_ioctls.h
new file mode 100644
index 000000000..23150e568
--- /dev/null
+++ b/include/uapi/linux/fmd/Peripherals/fm_port_ioctls.h
@@ -0,0 +1,973 @@
+/* Copyright (c) 2008-2012 Freescale Semiconductor, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/******************************************************************************
+ @File          fm_port_ioctls.h
+
+ @Description   FM Port routines
+*//***************************************************************************/
+#ifndef __FM_PORT_IOCTLS_H
+#define __FM_PORT_IOCTLS_H
+
+#include "enet_ext.h"
+#include "net_ioctls.h"
+#include "fm_ioctls.h"
+#include "fm_pcd_ioctls.h"
+
+
+/**************************************************************************//**
+
+ @Group         lnx_ioctl_FM_grp Frame Manager Linux IOCTL API
+
+ @Description   FM Linux ioctls definitions and enums
+
+ @{
+*//***************************************************************************/
+
+/**************************************************************************//**
+ @Group         lnx_ioctl_FM_PORT_grp FM Port
+
+ @Description   FM Port API
+
+                The FM uses a general module called "port" to represent a Tx port
+                (MAC), an Rx port (MAC), offline parsing flow or host command
+                flow. There may be up to 17 (may change) ports in an FM - 5 Tx
+                ports (4 for the 1G MACs, 1 for the 10G MAC), 5 Rx Ports, and 7
+                Host command/Offline parsing ports. The SW driver manages these
+                ports as sub-modules of the FM, i.e. after an FM is initialized,
+                its ports may be initialized and operated upon.
+
+                The port is initialized aware of its type, but other functions on
+                a port may be indifferent to its type. When necessary, the driver
+                verifies coherency and returns error if applicable.
+
+                On initialization, user specifies the port type and it's index
+                (relative to the port's type). Host command and Offline parsing
+                ports share the same id range, I.e user may not initialized host
+                command port 0 and offline parsing port 0.
+
+ @{
+*//***************************************************************************/
+
+/**************************************************************************//**
+ @Description   An enum for defining port PCD modes.
+                (Must match enum e_FmPortPcdSupport defined in fm_port_ext.h)
+
+                This enum defines the superset of PCD engines support - i.e. not
+                all engines have to be used, but all have to be enabled. The real
+                flow of a specific frame depends on the PCD configuration and the
+                frame headers and payload.
+                Note: the first engine and the first engine after the parser (if
+                exists) should be in order, the order is important as it will
+                define the flow of the port. However, as for the rest engines
+                (the ones that follows), the order is not important anymore as
+                it is defined by the PCD graph itself.
+*//***************************************************************************/
+typedef enum ioc_fm_port_pcd_support {
+      e_IOC_FM_PORT_PCD_SUPPORT_NONE = 0                /**< BMI to BMI, PCD is not used */
+    , e_IOC_FM_PORT_PCD_SUPPORT_PRS_ONLY                /**< Use only Parser */
+    , e_IOC_FM_PORT_PCD_SUPPORT_PLCR_ONLY               /**< Use only Policer */
+    , e_IOC_FM_PORT_PCD_SUPPORT_PRS_AND_PLCR            /**< Use Parser and Policer */
+    , e_IOC_FM_PORT_PCD_SUPPORT_PRS_AND_KG              /**< Use Parser and Keygen */
+    , e_IOC_FM_PORT_PCD_SUPPORT_PRS_AND_KG_AND_CC       /**< Use Parser, Keygen and Coarse Classification */
+    , e_IOC_FM_PORT_PCD_SUPPORT_PRS_AND_KG_AND_CC_AND_PLCR
+                                                        /**< Use all PCD engines */
+    , e_IOC_FM_PORT_PCD_SUPPORT_PRS_AND_KG_AND_PLCR     /**< Use Parser, Keygen and Policer */
+    , e_IOC_FM_PORT_PCD_SUPPORT_PRS_AND_CC              /**< Use Parser and Coarse Classification */
+    , e_IOC_FM_PORT_PCD_SUPPORT_PRS_AND_CC_AND_PLCR     /**< Use Parser and Coarse Classification and Policer */
+    , e_IOC_FM_PORT_PCD_SUPPORT_CC_ONLY                 /**< Use only Coarse Classification */
+#if (defined(FM_CAPWAP_SUPPORT) && (DPAA_VERSION == 10))
+    , e_IOC_FM_PORT_PCD_SUPPORT_CC_AND_KG               /**< Use Coarse Classification,and Keygen */
+    , e_IOC_FM_PORT_PCD_SUPPORT_CC_AND_KG_AND_PLCR      /**< Use Coarse Classification, Keygen and Policer */
+#endif /* FM_CAPWAP_SUPPORT */
+} ioc_fm_port_pcd_support;
+
+
+/**************************************************************************//**
+ @Collection   FM Frame error
+*//***************************************************************************/
+typedef uint32_t    ioc_fm_port_frame_err_select_t;     /**< typedef for defining Frame Descriptor errors */
+
+/* @} */
+
+
+/**************************************************************************//**
+ @Description   An enum for defining Dual Tx rate limiting scale.
+                (Must match e_FmPortDualRateLimiterScaleDown defined in fm_port_ext.h)
+*//***************************************************************************/
+typedef enum ioc_fm_port_dual_rate_limiter_scale_down {
+    e_IOC_FM_PORT_DUAL_RATE_LIMITER_NONE = 0,           /**< Use only single rate limiter  */
+    e_IOC_FM_PORT_DUAL_RATE_LIMITER_SCALE_DOWN_BY_2,    /**< Divide high rate limiter by 2 */
+    e_IOC_FM_PORT_DUAL_RATE_LIMITER_SCALE_DOWN_BY_4,    /**< Divide high rate limiter by 4 */
+    e_IOC_FM_PORT_DUAL_RATE_LIMITER_SCALE_DOWN_BY_8     /**< Divide high rate limiter by 8 */
+} ioc_fm_port_dual_rate_limiter_scale_down;
+
+/**************************************************************************//**
+ @Description   A structure for defining Tx rate limiting
+                (Must match struct t_FmPortRateLimit defined in fm_port_ext.h)
+*//***************************************************************************/
+typedef struct ioc_fm_port_rate_limit_t {
+    uint16_t                            max_burst_size;         /**< in KBytes for Tx ports, in frames
+                                                                     for offline parsing ports. (note that
+                                                                     for early chips burst size is
+                                                                     rounded up to a multiply of 1000 frames).*/
+    uint32_t                            rate_limit;             /**< in Kb/sec for Tx ports, in frame/sec for
+                                                                     offline parsing ports. Rate limit refers to
+                                                                     data rate (rather than line rate). */
+    ioc_fm_port_dual_rate_limiter_scale_down rate_limit_divider;    /**< For offline parsing ports only. Not-valid
+                                                                     for some earlier chip revisions */
+} ioc_fm_port_rate_limit_t;
+
+
+
+/**************************************************************************//**
+ @Group         lnx_ioctl_FM_PORT_runtime_control_grp FM Port Runtime Control Unit
+
+ @Description   FM Port Runtime control unit API functions, definitions and enums.
+
+ @{
+*//***************************************************************************/
+
+/**************************************************************************//**
+ @Description   An enum for defining FM Port counters.
+                (Must match enum e_FmPortCounters defined in fm_port_ext.h)
+*//***************************************************************************/
+typedef enum ioc_fm_port_counters {
+    e_IOC_FM_PORT_COUNTERS_CYCLE,                       /**< BMI performance counter */
+    e_IOC_FM_PORT_COUNTERS_TASK_UTIL,                   /**< BMI performance counter */
+    e_IOC_FM_PORT_COUNTERS_QUEUE_UTIL,                  /**< BMI performance counter */
+    e_IOC_FM_PORT_COUNTERS_DMA_UTIL,                    /**< BMI performance counter */
+    e_IOC_FM_PORT_COUNTERS_FIFO_UTIL,                   /**< BMI performance counter */
+    e_IOC_FM_PORT_COUNTERS_RX_PAUSE_ACTIVATION,         /**< BMI Rx only performance counter */
+    e_IOC_FM_PORT_COUNTERS_FRAME,                       /**< BMI statistics counter */
+    e_IOC_FM_PORT_COUNTERS_DISCARD_FRAME,               /**< BMI statistics counter */
+    e_IOC_FM_PORT_COUNTERS_DEALLOC_BUF,                 /**< BMI deallocate buffer statistics counter */
+    e_IOC_FM_PORT_COUNTERS_RX_BAD_FRAME,                /**< BMI Rx only statistics counter */
+    e_IOC_FM_PORT_COUNTERS_RX_LARGE_FRAME,              /**< BMI Rx only statistics counter */
+    e_IOC_FM_PORT_COUNTERS_RX_FILTER_FRAME,             /**< BMI Rx & OP only statistics counter */
+    e_IOC_FM_PORT_COUNTERS_RX_LIST_DMA_ERR,             /**< BMI Rx, OP & HC only statistics counter */
+    e_IOC_FM_PORT_COUNTERS_RX_OUT_OF_BUFFERS_DISCARD,   /**< BMI Rx, OP & HC statistics counter */
+    e_IOC_FM_PORT_COUNTERS_PREPARE_TO_ENQUEUE_COUNTER,  /**< BMI Rx, OP & HC only statistics counter */
+    e_IOC_FM_PORT_COUNTERS_WRED_DISCARD,                /**< BMI OP & HC only statistics counter */
+    e_IOC_FM_PORT_COUNTERS_LENGTH_ERR,                  /**< BMI non-Rx statistics counter */
+    e_IOC_FM_PORT_COUNTERS_UNSUPPRTED_FORMAT,           /**< BMI non-Rx statistics counter */
+    e_IOC_FM_PORT_COUNTERS_DEQ_TOTAL,                   /**< QMI total QM dequeues counter */
+    e_IOC_FM_PORT_COUNTERS_ENQ_TOTAL,                   /**< QMI total QM enqueues counter */
+    e_IOC_FM_PORT_COUNTERS_DEQ_FROM_DEFAULT,            /**< QMI counter */
+    e_IOC_FM_PORT_COUNTERS_DEQ_CONFIRM                  /**< QMI counter */
+} ioc_fm_port_counters;
+
+typedef struct ioc_fm_port_bmi_stats_t {
+    uint32_t cnt_cycle;
+    uint32_t cnt_task_util;
+    uint32_t cnt_queue_util;
+    uint32_t cnt_dma_util;
+    uint32_t cnt_fifo_util;
+    uint32_t cnt_rx_pause_activation;
+    uint32_t cnt_frame;
+    uint32_t cnt_discard_frame;
+    uint32_t cnt_dealloc_buf;
+    uint32_t cnt_rx_bad_frame;
+    uint32_t cnt_rx_large_frame;
+    uint32_t cnt_rx_filter_frame;
+    uint32_t cnt_rx_list_dma_err;
+    uint32_t cnt_rx_out_of_buffers_discard;
+    uint32_t cnt_wred_discard;
+    uint32_t cnt_length_err;
+    uint32_t cnt_unsupported_format;
+} ioc_fm_port_bmi_stats_t;
+
+/**************************************************************************//**
+ @Description   Structure for Port id parameters.
+                (Description may be inaccurate;
+                must match struct t_FmPortCongestionGrps defined in fm_port_ext.h)
+
+                Fields commented 'IN' are passed by the port module to be used
+                by the FM module.
+                Fields commented 'OUT' will be filled by FM before returning to port.
+*//***************************************************************************/
+typedef struct ioc_fm_port_congestion_groups_t {
+    uint16_t    num_of_congestion_grps_to_consider;     /**< The number of required congestion groups
+                                                             to define the size of the following array */
+    uint8_t     congestion_grps_to_consider [FM_PORT_NUM_OF_CONGESTION_GRPS];
+                                                        /**< An array of CG indexes;
+                                                             Note that the size of the array should be
+                                                             'num_of_congestion_grps_to_consider'. */
+#if DPAA_VERSION >= 11
+    bool        pfc_priorities_enable[FM_PORT_NUM_OF_CONGESTION_GRPS][FM_MAX_NUM_OF_PFC_PRIORITIES];
+                                                        /**< A matrix that represents the map between the CG ids
+                                                             defined in 'congestion_grps_to_consider' to the priorities
+                                                             mapping array. */
+#endif /* DPAA_VERSION >= 11 */
+} ioc_fm_port_congestion_groups_t;
+
+
+
+/**************************************************************************//**
+ @Function      FM_PORT_Disable
+
+ @Description   Gracefully disable an FM port. The port will not start new tasks after all
+                tasks associated with the port are terminated.
+
+ @Return        0 on success; error code otherwise.
+
+ @Cautions      This is a blocking routine, it returns after port is
+                gracefully stopped, i.e. the port will not except new frames,
+                but it will finish all frames or tasks which were already began
+*//***************************************************************************/
+#define FM_PORT_IOC_DISABLE   _IO(FM_IOC_TYPE_BASE, FM_PORT_IOC_NUM(1))
+
+/**************************************************************************//**
+ @Function      FM_PORT_Enable
+
+ @Description   A runtime routine provided to allow disable/enable of port.
+
+ @Return        0 on success; error code otherwise.
+*//***************************************************************************/
+#define FM_PORT_IOC_ENABLE   _IO(FM_IOC_TYPE_BASE, FM_PORT_IOC_NUM(2))
+
+/**************************************************************************//**
+ @Function      FM_PORT_SetRateLimit
+
+ @Description   Calling this routine enables rate limit algorithm.
+                By default, this functionality is disabled.
+                Note that rate-limit mechanism uses the FM time stamp.
+                The selected rate limit specified here would be
+                rounded DOWN to the nearest 16M.
+
+                May be used for Tx and offline parsing ports only
+
+ @Param[in]     ioc_fm_port_rate_limit A structure of rate limit parameters
+
+ @Return        0 on success; error code otherwise.
+*//***************************************************************************/
+#define FM_PORT_IOC_SET_RATE_LIMIT _IOW(FM_IOC_TYPE_BASE, FM_PORT_IOC_NUM(3), ioc_fm_port_rate_limit_t)
+
+/**************************************************************************//**
+ @Function      FM_PORT_DeleteRateLimit
+
+ @Description   Calling this routine disables the previously enabled rate limit.
+
+                May be used for Tx and offline parsing ports only
+
+ @Return        0 on success; error code otherwise.
+*//***************************************************************************/
+#define FM_PORT_IOC_DELETE_RATE_LIMIT   _IO(FM_IOC_TYPE_BASE, FM_PORT_IOC_NUM(5))
+#define FM_PORT_IOC_REMOVE_RATE_LIMIT   FM_PORT_IOC_DELETE_RATE_LIMIT
+
+
+/**************************************************************************//**
+ @Function      FM_PORT_AddCongestionGrps
+
+ @Description   This routine effects the corresponding Tx port.
+                It should be called in order to enable pause
+                frame transmission in case of congestion in one or more
+                of the congestion groups relevant to this port.
+                Each call to this routine may add one or more congestion
+                groups to be considered relevant to this port.
+
+                May be used for Rx, or RX+OP ports only (depending on chip)
+
+ @Param[in]     ioc_fm_port_congestion_groups_t - A pointer to an array of
+                                                congestion group ids to consider.
+
+ @Return        0 on success; error code otherwise.
+*//***************************************************************************/
+#define FM_PORT_IOC_ADD_CONGESTION_GRPS    _IOW(FM_IOC_TYPE_BASE, FM_PORT_IOC_NUM(34), ioc_fm_port_congestion_groups_t)
+
+/**************************************************************************//**
+ @Function      FM_PORT_RemoveCongestionGrps
+
+ @Description   This routine effects the corresponding Tx port. It should be
+                called when congestion groups were
+                defined for this port and are no longer relevant, or pause
+                frames transmitting is not required on their behalf.
+                Each call to this routine may remove one or more congestion
+                groups to be considered relevant to this port.
+
+                May be used for Rx, or RX+OP ports only (depending on chip)
+
+ @Param[in]     ioc_fm_port_congestion_groups_t - A pointer to an array of
+                                                congestion group ids to consider.
+
+ @Return        0 on success; error code otherwise.
+*//***************************************************************************/
+#define FM_PORT_IOC_REMOVE_CONGESTION_GRPS    _IOW(FM_IOC_TYPE_BASE, FM_PORT_IOC_NUM(35), ioc_fm_port_congestion_groups_t)
+
+/**************************************************************************//**
+ @Function      FM_PORT_SetErrorsRoute
+
+ @Description   Errors selected for this routine will cause a frame with that error
+                to be enqueued to error queue.
+                Errors not selected for this routine will cause a frame with that error
+                to be enqueued to the one of the other port queues.
+                By default all errors are defined to be enqueued to error queue.
+                Errors that were configured to be discarded (at initialization)
+                may not be selected here.
+
+                May be used for Rx and offline parsing ports only
+
+ @Param[in]     ioc_fm_port_frame_err_select_t  A list of errors to enqueue to error queue
+
+ @Return        0 on success; error code otherwise.
+
+ @Cautions      Allowed only following FM_PORT_Config() and before FM_PORT_Init().
+                (szbs001: How is it possible to have one function that needs to be
+                          called BEFORE FM_PORT_Init() implemented as an ioctl,
+                          which will ALWAYS be called AFTER the FM_PORT_Init()
+                          for that port!?!?!?!???!?!??!?!?)
+*//***************************************************************************/
+#define FM_PORT_IOC_SET_ERRORS_ROUTE   _IOW(FM_IOC_TYPE_BASE, FM_PORT_IOC_NUM(4), ioc_fm_port_frame_err_select_t)
+
+
+/**************************************************************************//**
+ @Group         lnx_ioctl_FM_PORT_pcd_runtime_control_grp FM Port PCD Runtime Control Unit
+
+ @Description   FM Port PCD Runtime control unit API functions, definitions and enums.
+
+ @{
+*//***************************************************************************/
+
+/**************************************************************************//**
+ @Description   A structure defining the KG scheme after the parser.
+                (Must match struct t_FmPcdKgSchemeSelect defined in fm_port_ext.h)
+
+                This is relevant only to change scheme selection mode - from
+                direct to indirect and vice versa, or when the scheme is selected directly,
+                to select the scheme id.
+
+*//***************************************************************************/
+typedef struct ioc_fm_pcd_kg_scheme_select_t {
+    bool        direct;                     /**< TRUE to use 'scheme_id' directly, FALSE to use LCV.*/
+    void       *scheme_id;                  /**< Relevant for 'direct'=TRUE only.
+                                                 'scheme_id' selects the scheme after parser. */
+} ioc_fm_pcd_kg_scheme_select_t;
+
+/**************************************************************************//**
+ @Description   Scheme IDs structure
+                (Must match struct t_FmPcdPortSchemesParams defined in fm_port_ext.h)
+*//***************************************************************************/
+typedef struct ioc_fm_pcd_port_schemes_params_t {
+    uint8_t     num_of_schemes;                         /**< Number of schemes for port to be bound to. */
+    void        *scheme_ids[FM_PCD_KG_NUM_OF_SCHEMES];  /**< Array of 'num_of_schemes' schemes for the
+                                                             port to be bound to */
+} ioc_fm_pcd_port_schemes_params_t;
+
+/**************************************************************************//**
+ @Description   A union for defining port protocol parameters for parser
+                (Must match union u_FmPcdHdrPrsOpts defined in fm_port_ext.h)
+*//***************************************************************************/
+typedef union ioc_fm_pcd_hdr_prs_opts_u {
+    /* MPLS */
+    struct {
+        bool                label_interpretation_enable;/**< When this bit is set, the last MPLS label will be
+                                                             interpreted as described in HW spec table. When the bit
+                                                             is cleared, the parser will advance to MPLS next parse */
+        ioc_net_header_type next_parse;                 /**< must be equal or higher than IPv4 */
+    } mpls_prs_options;
+
+    /* VLAN */
+    struct {
+        uint16_t            tag_protocol_id1;           /**< User defined Tag Protocol Identifier, to be recognized
+                                                             on VLAN TAG on top of 0x8100 and 0x88A8 */
+        uint16_t            tag_protocol_id2;           /**< User defined Tag Protocol Identifier, to be recognized
+                                                             on VLAN TAG on top of 0x8100 and 0x88A8 */
+    } vlan_prs_options;
+
+    /* PPP */
+    struct{
+        bool                enable_mtu_check;           /**< Check validity of MTU according to RFC2516 */
+    } pppoe_prs_options;
+
+    /* IPV6 */
+    struct {
+        bool                routing_hdr_disable;        /**< Disable routing header */
+    } ipv6_prs_options;
+
+    /* UDP */
+    struct {
+        bool                pad_ignore_checksum;        /**< TRUE to ignore pad in checksum */
+    } udp_prs_options;
+
+    /* TCP */
+    struct {
+        bool                pad_ignore_checksum;        /**< TRUE to ignore pad in checksum */
+    } tcp_prs_options;
+} ioc_fm_pcd_hdr_prs_opts_u;
+
+/**************************************************************************//**
+ @Description   A structure for defining each header for the parser
+                (must match struct t_FmPcdPrsAdditionalHdrParams defined in fm_port_ext.h)
+*//***************************************************************************/
+typedef struct ioc_fm_pcd_prs_additional_hdr_params_t {
+    ioc_net_header_type         hdr;                /**< Selected header */
+    bool                        err_disable;        /**< TRUE to disable error indication */
+    bool                        soft_prs_enable;    /**< Enable jump to SW parser when this
+                                                         header is recognized by the HW parser. */
+    uint8_t                     index_per_hdr;      /**< Normally 0, if more than one sw parser
+                                                         attachments exists for the same header,
+                                                         (in the main sw parser code) use this
+                                                         index to distinguish between them. */
+    bool                        use_prs_opts;       /**< TRUE to use parser options. */
+    ioc_fm_pcd_hdr_prs_opts_u   prs_opts;           /**< A unuion according to header type,
+                                                         defining the parser options selected.*/
+} ioc_fm_pcd_prs_additional_hdr_params_t;
+
+/**************************************************************************//**
+ @Description   A structure for defining port PCD parameters
+                (Must match t_FmPortPcdPrsParams defined in fm_port_ext.h)
+*//***************************************************************************/
+typedef struct ioc_fm_port_pcd_prs_params_t {
+    uint8_t                         prs_res_priv_info;      /**< The private info provides a method of inserting
+                                                                 port information into the parser result. This information
+                                                                 may be extracted by KeyGen and be used for frames
+                                                                 distribution when a per-port distinction is required,
+                                                                 it may also be used as a port logical id for analyzing
+                                                                 incoming frames. */
+    uint8_t                         parsing_offset;         /**< Number of bytes from begining of packet to start parsing */
+    ioc_net_header_type             first_prs_hdr;          /**< The type of the first header axpected at 'parsing_offset' */
+    bool                            include_in_prs_statistics; /**< TRUE to include this port in the parser statistics */
+    uint8_t                         num_of_hdrs_with_additional_params;
+                                                            /**< Normally 0, some headers may get special parameters */
+    ioc_fm_pcd_prs_additional_hdr_params_t  additional_params[IOC_FM_PCD_PRS_NUM_OF_HDRS];
+                                                            /**< 'num_of_hdrs_with_additional_params' structures
+                                                                  additional parameters for each header that requires them */
+    bool                            set_vlan_tpid1;         /**< TRUE to configure user selection of Ethertype to
+                                                                 indicate a VLAN tag (in addition to the TPID values
+                                                                 0x8100 and 0x88A8). */
+    uint16_t                        vlan_tpid1;             /**< extra tag to use if set_vlan_tpid1=TRUE. */
+    bool                            set_vlan_tpid2;         /**< TRUE to configure user selection of Ethertype to
+                                                                 indicate a VLAN tag (in addition to the TPID values
+                                                                 0x8100 and 0x88A8). */
+    uint16_t                        vlan_tpid2;             /**< extra tag to use if set_vlan_tpid1=TRUE. */
+} ioc_fm_port_pcd_prs_params_t;
+
+/**************************************************************************//**
+ @Description   A structure for defining coarse alassification parameters
+                (Must match t_FmPortPcdCcParams defined in fm_port_ext.h)
+*//***************************************************************************/
+typedef struct ioc_fm_port_pcd_cc_params_t {
+    void                *cc_tree_id; /**< CC tree id */
+} ioc_fm_port_pcd_cc_params_t;
+
+/**************************************************************************//**
+ @Description   A structure for defining keygen parameters
+                (Must match t_FmPortPcdKgParams defined in fm_port_ext.h)
+*//***************************************************************************/
+typedef struct ioc_fm_port_pcd_kg_params_t {
+    uint8_t             num_of_schemes;                 /**< Number of schemes for port to be bound to. */
+    void               *scheme_ids[FM_PCD_KG_NUM_OF_SCHEMES];
+                                                        /**< Array of 'num_of_schemes' schemes for the
+                                                             port to be bound to */
+    bool                direct_scheme;                  /**< TRUE for going from parser to a specific scheme,
+                                                             regardless of parser result */
+    void               *direct_scheme_id;               /**< Scheme id, as returned by FM_PCD_KgSetScheme;
+                                                             relevant only if direct=TRUE. */
+} ioc_fm_port_pcd_kg_params_t;
+
+/**************************************************************************//**
+ @Description   A structure for defining policer parameters
+                (Must match t_FmPortPcdPlcrParams defined in fm_port_ext.h)
+*//***************************************************************************/
+typedef struct ioc_fm_port_pcd_plcr_params_t {
+    void                *plcr_profile_id;               /**< Selected profile handle;
+                                                             relevant in one of the following cases:
+                                                             e_IOC_FM_PORT_PCD_SUPPORT_PLCR_ONLY or
+                                                             e_IOC_FM_PORT_PCD_SUPPORT_PRS_AND_PLCR were selected,
+                                                             or if any flow uses a KG scheme where policer
+                                                                profile is not generated (bypass_plcr_profile_generation selected) */
+} ioc_fm_port_pcd_plcr_params_t;
+
+/**************************************************************************//**
+ @Description   A structure for defining port PCD parameters
+                (Must match struct t_FmPortPcdParams defined in fm_port_ext.h)
+*//***************************************************************************/
+typedef struct ioc_fm_port_pcd_params_t {
+    ioc_fm_port_pcd_support         pcd_support;    /**< Relevant for Rx and offline ports only.
+                                                         Describes the active PCD engines for this port. */
+    void                            *net_env_id;    /**< HL Unused in PLCR only mode */
+    ioc_fm_port_pcd_prs_params_t    *p_prs_params;  /**< Parser parameters for this port */
+    ioc_fm_port_pcd_cc_params_t     *p_cc_params;   /**< Coarse classification parameters for this port */
+    ioc_fm_port_pcd_kg_params_t     *p_kg_params;   /**< Keygen parameters for this port */
+    ioc_fm_port_pcd_plcr_params_t   *p_plcr_params; /**< Policer parameters for this port */
+    void                            *p_ip_reassembly_manip;/**< IP Reassembly manipulation */
+#if (DPAA_VERSION >= 11)
+    void                            *p_capwap_reassembly_manip;/**< CAPWAP Reassembly manipulation */
+#endif /* (DPAA_VERSION >= 11) */
+} ioc_fm_port_pcd_params_t;
+
+/**************************************************************************//**
+ @Description   A structure for defining the Parser starting point
+                (Must match struct t_FmPcdPrsStart defined in fm_port_ext.h)
+*//***************************************************************************/
+typedef struct ioc_fm_pcd_prs_start_t {
+    uint8_t             parsing_offset; /**< Number of bytes from begining of packet to
+                                             start parsing */
+    ioc_net_header_type first_prs_hdr;  /**< The type of the first header axpected at
+                                             'parsing_offset' */
+} ioc_fm_pcd_prs_start_t;
+
+
+/**************************************************************************//**
+ @Description   FQID parameters structure
+*//***************************************************************************/
+typedef struct ioc_fm_port_pcd_fqids_params_t {
+    uint32_t            num_fqids;  /**< Number of fqids to be allocated for the port */
+    uint8_t             alignment;  /**< Alignment required for this port */
+    uint32_t            base_fqid;  /**< output parameter - the base fqid */
+} ioc_fm_port_pcd_fqids_params_t;
+
+
+/**************************************************************************//**
+ @Function      FM_PORT_IOC_ALLOC_PCD_FQIDS
+
+ @Description   Allocates FQID's
+
+                May be used for Rx and offline parsing ports only
+
+ @Param[in,out] ioc_fm_port_pcd_fqids_params_t  Parameters for allocating FQID's
+
+ @Return        0 on success; error code otherwise.
+*//***************************************************************************/
+#define FM_PORT_IOC_ALLOC_PCD_FQIDS   _IOWR(FM_IOC_TYPE_BASE, FM_PORT_IOC_NUM(19), ioc_fm_port_pcd_fqids_params_t)
+
+/**************************************************************************//**
+ @Function      FM_PORT_IOC_FREE_PCD_FQIDS
+
+ @Description   Frees previously-allocated FQIDs
+
+                May be used for Rx and offline parsing ports only
+
+ @Param[in]		uint32_t	Base FQID of previously allocated range.
+
+ @Return        0 on success; error code otherwise.
+*//***************************************************************************/
+#define FM_PORT_IOC_FREE_PCD_FQIDS   _IOW(FM_IOC_TYPE_BASE, FM_PORT_IOC_NUM(19), uint32_t)
+
+
+/**************************************************************************//**
+ @Function      FM_PORT_SetPCD
+
+ @Description   Calling this routine defines the port's PCD configuration.
+                It changes it from its default configuration which is PCD
+                disabled (BMI to BMI) and configures it according to the passed
+                parameters.
+
+                May be used for Rx and offline parsing ports only
+
+ @Param[in]     ioc_fm_port_pcd_params_t    A Structure of parameters defining the port's PCD
+                                            configuration.
+
+ @Return        0 on success; error code otherwise.
+*//***************************************************************************/
+#if defined(FM_COMPAT)
+#define FM_PORT_IOC_SET_PCD_COMPAT _IOW(FM_IOC_TYPE_BASE, FM_PORT_IOC_NUM(20), ioc_compat_fm_port_pcd_params_t)
+#endif
+#define FM_PORT_IOC_SET_PCD _IOW(FM_IOC_TYPE_BASE, FM_PORT_IOC_NUM(20), ioc_fm_port_pcd_params_t)
+
+/**************************************************************************//**
+ @Function      FM_PORT_DeletePCD
+
+ @Description   Calling this routine releases the port's PCD configuration.
+                The port returns to its default configuration which is PCD
+                disabled (BMI to BMI) and all PCD configuration is removed.
+
+                May be used for Rx and offline parsing ports which are
+                in PCD mode only
+
+ @Return        0 on success; error code otherwise.
+*//***************************************************************************/
+#define FM_PORT_IOC_DELETE_PCD _IO(FM_IOC_TYPE_BASE, FM_PORT_IOC_NUM(21))
+
+/**************************************************************************//**
+ @Function      FM_PORT_AttachPCD
+
+ @Description   This routine may be called after FM_PORT_DetachPCD was called,
+                to return to the originally configured PCD support flow.
+                The couple of routines are used to allow PCD configuration changes
+                that demand that PCD will not be used while changes take place.
+
+                May be used for Rx and offline parsing ports which are
+                in PCD mode only
+
+ @Return        0 on success; error code otherwise.
+*//***************************************************************************/
+#define FM_PORT_IOC_ATTACH_PCD _IO(FM_IOC_TYPE_BASE, FM_PORT_IOC_NUM(23))
+
+/**************************************************************************//**
+ @Function      FM_PORT_DetachPCD
+
+ @Description   Calling this routine detaches the port from its PCD functionality.
+                The port returns to its default flow which is BMI to BMI.
+
+                May be used for Rx and offline parsing ports which are
+                in PCD mode only
+
+ @Return        0 on success; error code otherwise.
+*//***************************************************************************/
+#define FM_PORT_IOC_DETACH_PCD _IO(FM_IOC_TYPE_BASE, FM_PORT_IOC_NUM(22))
+
+/**************************************************************************//**
+ @Function      FM_PORT_PcdPlcrAllocProfiles
+
+ @Description   This routine may be called only for ports that use the Policer in
+                order to allocate private policer profiles.
+
+ @Param[in]     uint16_t       The number of required policer profiles
+
+ @Return        0 on success; error code otherwise.
+
+ @Cautions      Allowed before FM_PORT_SetPCD() only.
+*//***************************************************************************/
+#define FM_PORT_IOC_PCD_PLCR_ALLOC_PROFILES     _IOW(FM_IOC_TYPE_BASE, FM_PORT_IOC_NUM(24), uint16_t)
+
+/**************************************************************************//**
+ @Function      FM_PORT_PcdPlcrFreeProfiles
+
+ @Description   This routine should be called for freeing private policer profiles.
+
+ @Return        0 on success; error code otherwise.
+
+ @Cautions      Allowed before FM_PORT_SetPCD() only.
+*//***************************************************************************/
+#define FM_PORT_IOC_PCD_PLCR_FREE_PROFILES     _IO(FM_IOC_TYPE_BASE, FM_PORT_IOC_NUM(25))
+
+/**************************************************************************//**
+ @Function      FM_PORT_PcdKgModifyInitialScheme
+
+ @Description   This routine may be called only for ports that use the keygen in
+                order to change the initial scheme frame should be routed to.
+                The change may be of a scheme id (in case of direct mode),
+                from direct to indirect, or from indirect to direct - specifying the scheme id.
+
+ @Param[in]     ioc_fm_pcd_kg_scheme_select_t   A structure of parameters for defining whether
+                                                a scheme is direct/indirect, and if direct - scheme id.
+
+ @Return        0 on success; error code otherwise.
+*//***************************************************************************/
+#if defined(FM_COMPAT)
+#define FM_PORT_IOC_PCD_KG_MODIFY_INITIAL_SCHEME_COMPAT _IOW(FM_IOC_TYPE_BASE, FM_PORT_IOC_NUM(26), ioc_compat_fm_pcd_kg_scheme_select_t)
+#endif
+#define FM_PORT_IOC_PCD_KG_MODIFY_INITIAL_SCHEME _IOW(FM_IOC_TYPE_BASE, FM_PORT_IOC_NUM(26), ioc_fm_pcd_kg_scheme_select_t)
+
+/**************************************************************************//**
+ @Function      FM_PORT_PcdPlcrModifyInitialProfile
+
+ @Description   This routine may be called for ports with flows
+                e_IOC_FM_PCD_SUPPORT_PLCR_ONLY or e_IOC_FM_PCD_SUPPORT_PRS_AND_PLCR  only,
+                to change the initial Policer profile frame should be routed to.
+                The change may be of a profile and/or absolute/direct mode selection.
+
+ @Param[in]     ioc_fm_obj_t       Policer profile Id as returned from FM_PCD_PlcrSetProfile.
+
+ @Return        0 on success; error code otherwise.
+*//***************************************************************************/
+#if defined(FM_COMPAT)
+#define FM_PORT_IOC_PCD_PLCR_MODIFY_INITIAL_PROFILE_COMPAT _IOW(FM_IOC_TYPE_BASE, FM_PORT_IOC_NUM(27), ioc_compat_fm_obj_t)
+#endif
+#define FM_PORT_IOC_PCD_PLCR_MODIFY_INITIAL_PROFILE _IOW(FM_IOC_TYPE_BASE, FM_PORT_IOC_NUM(27), ioc_fm_obj_t)
+
+/**************************************************************************//**
+ @Function      FM_PORT_PcdCcModifyTree
+
+ @Description   This routine may be called to change this port connection to
+                a pre-initializes coarse classification Tree.
+
+ @Param[in]     ioc_fm_obj_t    Id of new coarse classification tree selected for this port.
+
+ @Return        0 on success; error code otherwise.
+
+ @Cautions      Allowed only following FM_PORT_SetPCD() and FM_PORT_DetachPCD()
+*//***************************************************************************/
+#if defined(FM_COMPAT)
+#define FM_PORT_IOC_PCD_CC_MODIFY_TREE_COMPAT _IOW(FM_IOC_TYPE_BASE, FM_PORT_IOC_NUM(28), ioc_compat_fm_obj_t)
+#endif
+#define FM_PORT_IOC_PCD_CC_MODIFY_TREE _IOW(FM_IOC_TYPE_BASE, FM_PORT_IOC_NUM(28), ioc_fm_obj_t)
+
+/**************************************************************************//**
+ @Function      FM_PORT_PcdKgBindSchemes
+
+ @Description   These routines may be called for modifying the binding of ports
+                to schemes. The scheme itself is not added,
+                just this specific port starts using it.
+
+ @Param[in]     ioc_fm_pcd_port_schemes_params_t    Schemes parameters structre
+
+ @Return        0 on success; error code otherwise.
+
+ @Cautions      Allowed only following FM_PORT_SetPCD().
+*//***************************************************************************/
+#if defined(FM_COMPAT)
+#define FM_PORT_IOC_PCD_KG_BIND_SCHEMES_COMPAT _IOW(FM_IOC_TYPE_BASE, FM_PORT_IOC_NUM(30), ioc_compat_fm_pcd_port_schemes_params_t)
+#endif
+#define FM_PORT_IOC_PCD_KG_BIND_SCHEMES _IOW(FM_IOC_TYPE_BASE, FM_PORT_IOC_NUM(30), ioc_fm_pcd_port_schemes_params_t)
+
+/**************************************************************************//**
+ @Function      FM_PORT_PcdKgUnbindSchemes
+
+ @Description   These routines may be called for modifying the binding of ports
+                to schemes. The scheme itself is not removed or invalidated,
+                just this specific port stops using it.
+
+ @Param[in]     ioc_fm_pcd_port_schemes_params_t    Schemes parameters structre
+
+ @Return        0 on success; error code otherwise.
+
+ @Cautions      Allowed only following FM_PORT_SetPCD().
+*//***************************************************************************/
+#if defined(FM_COMPAT)
+#define FM_PORT_IOC_PCD_KG_UNBIND_SCHEMES_COMPAT _IOW(FM_IOC_TYPE_BASE, FM_PORT_IOC_NUM(31), ioc_compat_fm_pcd_port_schemes_params_t)
+#endif
+#define FM_PORT_IOC_PCD_KG_UNBIND_SCHEMES _IOW(FM_IOC_TYPE_BASE, FM_PORT_IOC_NUM(31), ioc_fm_pcd_port_schemes_params_t)
+
+typedef struct ioc_fm_port_mac_addr_params_t {
+    uint8_t addr[ENET_NUM_OCTETS_PER_ADDRESS];
+} ioc_fm_port_mac_addr_params_t;
+
+/**************************************************************************//**
+ @Function      FM_MAC_AddHashMacAddr
+
+ @Description   Add an Address to the hash table. This is for filter purpose only.
+
+ @Param[in]     ioc_fm_port_mac_addr_params_t - Ethernet Mac address
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_MAC_Init(). It is a filter only address.
+ @Cautions      Some address need to be filtered out in upper FM blocks.
+*//***************************************************************************/
+#define FM_PORT_IOC_ADD_RX_HASH_MAC_ADDR   _IOW(FM_IOC_TYPE_BASE, FM_PORT_IOC_NUM(36), ioc_fm_port_mac_addr_params_t)
+
+/**************************************************************************//**
+ @Function      FM_MAC_RemoveHashMacAddr
+
+ @Description   Delete an Address to the hash table. This is for filter purpose only.
+
+ @Param[in]     ioc_fm_port_mac_addr_params_t - Ethernet Mac address
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_MAC_Init().
+*//***************************************************************************/
+#define FM_PORT_IOC_REMOVE_RX_HASH_MAC_ADDR   _IOW(FM_IOC_TYPE_BASE, FM_PORT_IOC_NUM(37), ioc_fm_port_mac_addr_params_t)
+
+typedef struct ioc_fm_port_tx_pause_frames_params_t {
+    uint8_t  priority;
+    uint16_t pause_time;
+    uint16_t thresh_time;
+} ioc_fm_port_tx_pause_frames_params_t;
+
+/**************************************************************************//**
+ @Function      FM_MAC_SetTxPauseFrames
+
+ @Description   Enable/Disable transmission of Pause-Frames.
+                The routine changes the default configuration:
+                pause-time - [0xf000]
+                threshold-time - [0]
+
+ @Param[in]     ioc_fm_port_tx_pause_frames_params_t A structure holding the required parameters.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_MAC_Init().
+                PFC is supported only on new mEMAC; i.e. in MACs that don't have
+                PFC support (10G-MAC and dTSEC), user should use 'FM_MAC_NO_PFC'
+                in the 'priority' field.
+*//***************************************************************************/
+#define FM_PORT_IOC_SET_TX_PAUSE_FRAMES       _IOW(FM_IOC_TYPE_BASE, FM_PORT_IOC_NUM(40), ioc_fm_port_tx_pause_frames_params_t)
+
+typedef struct ioc_fm_port_mac_statistics_t {
+    /* RMON */
+        uint64_t  e_stat_pkts_64;            /**< r-10G tr-DT 64 byte frame counter */
+        uint64_t  e_stat_pkts_65_to_127;     /**< r-10G 65 to 127 byte frame counter */
+        uint64_t  e_stat_pkts_128_to_255;    /**< r-10G 128 to 255 byte frame counter */
+        uint64_t  e_stat_pkts_256_to_511;    /**< r-10G 256 to 511 byte frame counter */
+        uint64_t  e_stat_pkts_512_to_1023;   /**< r-10G 512 to 1023 byte frame counter */
+        uint64_t  e_stat_pkts_1024_to_1518;  /**< r-10G 1024 to 1518 byte frame counter */
+        uint64_t  e_stat_pkts_1519_to_1522;  /**< r-10G 1519 to 1522 byte good frame count */
+    /* */
+        uint64_t  e_stat_fragments;          /**< Total number of packets that were less than 64 octets long with a wrong CRC.*/
+        uint64_t  e_stat_jabbers;            /**< Total number of packets longer than valid maximum length octets */
+        uint64_t  e_stat_drop_events;        /**< number of dropped packets due to internal errors of the MAC Client (during recieve). */
+        uint64_t  e_stat_CRC_align_errors;   /**< Incremented when frames of correct length but with CRC error are received.*/
+        uint64_t  e_stat_undersize_pkts;     /**< Incremented for frames under 64 bytes with a valid FCS and otherwise well formed;
+                                                This count does not include range length errors */
+        uint64_t  e_stat_oversize_pkts;      /**< Incremented for frames which exceed 1518 (non VLAN) or 1522 (VLAN) and contains
+                                                a valid FCS and otherwise well formed */
+    /* Pause */
+        uint64_t  te_stat_pause;             /**< Pause MAC Control received */
+        uint64_t  re_stat_pause;             /**< Pause MAC Control sent */
+    /* MIB II */
+        uint64_t  if_in_octets;              /**< Total number of byte received. */
+        uint64_t  if_in_pkts;                /**< Total number of packets received.*/
+        uint64_t  if_in_ucast_pkts;          /**< Total number of unicast frame received;
+                                             NOTE: this counter is not supported on dTSEC MAC */
+        uint64_t  if_in_mcast_pkts;          /**< Total number of multicast frame received*/
+        uint64_t  if_in_bcast_pkts;          /**< Total number of broadcast frame received */
+        uint64_t  if_in_discards;            /**< Frames received, but discarded due to problems within the MAC RX. */
+        uint64_t  if_in_errors;              /**< Number of frames received with error:
+                                                   - FIFO Overflow Error
+                                                   - CRC Error
+                                                   - Frame Too Long Error
+                                                   - Alignment Error
+                                                   - The dedicated Error Code (0xfe, not a code error) was received */
+        uint64_t  if_out_octets;             /**< Total number of byte sent. */
+        uint64_t  if_out_pkts;               /**< Total number of packets sent .*/
+        uint64_t  if_out_ucast_pkts;         /**< Total number of unicast frame sent;
+                                             NOTE: this counter is not supported on dTSEC MAC */
+        uint64_t  if_out_mcast_pkts;         /**< Total number of multicast frame sent */
+        uint64_t  if_out_bcast_pkts;         /**< Total number of multicast frame sent */
+        uint64_t  if_out_discards;           /**< Frames received, but discarded due to problems within the MAC TX N/A!.*/
+        uint64_t  if_out_errors;             /**< Number of frames transmitted with error:
+                                                   - FIFO Overflow Error
+                                                   - FIFO Underflow Error
+                                                   - Other */
+} ioc_fm_port_mac_statistics_t;
+
+/**************************************************************************//**
+ @Function      FM_MAC_GetStatistics
+
+ @Description   get all MAC statistics counters
+
+ @Param[out]    ioc_fm_port_mac_statistics_t    A structure holding the statistics
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_Init().
+*//***************************************************************************/
+#define FM_PORT_IOC_GET_MAC_STATISTICS        _IOR(FM_IOC_TYPE_BASE, FM_PORT_IOC_NUM(41), ioc_fm_port_mac_statistics_t)
+
+/**************************************************************************//**
+ @Function      FM_PORT_ConfigBufferPrefixContent
+
+ @Description   Defines the structure, size and content of the application buffer.
+                The prefix will
+                In Tx ports, if 'passPrsResult', the application
+                should set a value to their offsets in the prefix of
+                the FM will save the first 'privDataSize', than,
+                depending on 'passPrsResult' and 'passTimeStamp', copy parse result
+                and timeStamp, and the packet itself (in this order), to the
+                application buffer, and to offset.
+                Calling this routine changes the buffer margins definitions
+                in the internal driver data base from its default
+                configuration: Data size:  [DEFAULT_FM_SP_bufferPrefixContent_privDataSize]
+                               Pass Parser result: [DEFAULT_FM_SP_bufferPrefixContent_passPrsResult].
+                               Pass timestamp: [DEFAULT_FM_SP_bufferPrefixContent_passTimeStamp].
+
+                May be used for all ports
+
+ @Param[in]     ioc_fm_buffer_prefix_content_t  A structure holding the required parameters.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PORT_Config() and before FM_PORT_Init().
+*//***************************************************************************/
+#define FM_PORT_IOC_CONFIG_BUFFER_PREFIX_CONTENT _IOW(FM_IOC_TYPE_BASE, FM_PORT_IOC_NUM(39), ioc_fm_buffer_prefix_content_t)
+
+#if (DPAA_VERSION >= 11)
+typedef struct ioc_fm_port_vsp_alloc_params_t {
+    uint8_t     num_of_profiles;          /**< Number of Virtual Storage Profiles */
+    uint8_t     dflt_relative_id;         /**< The default Virtual-Storage-Profile-id dedicated to Rx/OP port
+                                             The same default Virtual-Storage-Profile-id will be for coupled Tx port
+                                             if relevant function called for Rx port */
+    void    *p_fm_tx_port;             /**< Handle to coupled Tx Port; not relevant for OP port. */
+}ioc_fm_port_vsp_alloc_params_t;
+
+/**************************************************************************//**
+ @Function      FM_PORT_VSPAlloc
+
+ @Description   This routine allocated VSPs per port and forces the port to work
+                in VSP mode. Note that the port is initialized by default with the
+                physical-storage-profile only.
+
+ @Param[in]     h_FmPort    A handle to a FM Port module.
+ @Param[in]     p_Params    A structure of parameters for allocation VSP's per port
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PORT_Init(), and before FM_PORT_SetPCD()
+                and also before FM_PORT_Enable() (i.e. the port should be disabled).
+*//***************************************************************************/
+#if defined(FM_COMPAT)
+#define FM_PORT_IOC_VSP_ALLOC_COMPAT _IOW(FM_IOC_TYPE_BASE, FM_PORT_IOC_NUM(38), ioc_compat_fm_port_vsp_alloc_params_t)
+#endif
+#define FM_PORT_IOC_VSP_ALLOC _IOW(FM_IOC_TYPE_BASE, FM_PORT_IOC_NUM(38), ioc_fm_port_vsp_alloc_params_t)
+#endif /* (DPAA_VERSION >= 11) */
+
+/**************************************************************************//**
+ @Function      FM_PORT_GetBmiCounters
+
+ @Description   Read port's BMI stat counters and place them into
+                a designated structure of counters.
+
+ @Param[in]     h_FmPort    A handle to a FM Port module.
+ @Param[out]    p_BmiStats  counters structure
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PORT_Init().
+*//***************************************************************************/
+
+#define FM_PORT_IOC_GET_BMI_COUNTERS _IOR(FM_IOC_TYPE_BASE, FM_PORT_IOC_NUM(42), ioc_fm_port_bmi_stats_t)
+
+typedef struct ioc_fm_port_mac_frame_size_counters_t {
+
+        e_CommMode type;
+        uint64_t  count_pkts_64;            /**< 64 byte frame counter */
+        uint64_t  count_pkts_65_to_127;     /**< 65 to 127 byte frame counter */
+        uint64_t  count_pkts_128_to_255;    /**< 128 to 255 byte frame counter */
+        uint64_t  count_pkts_256_to_511;    /**< 256 to 511 byte frame counter */
+        uint64_t  count_pkts_512_to_1023;   /**< 512 to 1023 byte frame counter */
+        uint64_t  count_pkts_1024_to_1518;  /**< 1024 to 1518 byte frame counter */
+        uint64_t  count_pkts_1519_to_1522;  /**< 1519 to 1522 byte good frame count */
+} ioc_fm_port_mac_frame_size_counters_t;
+
+/**************************************************************************//**
+ @Function      FM_MAC_GetFrameSizeCounters
+
+ @Description   get MAC statistics counters for different frame size
+
+ @Param[out]    ioc_fm_port_mac_frame_size_counters_t    A structure holding the counters
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_Init().
+*//***************************************************************************/
+#define FM_PORT_IOC_GET_MAC_FRAME_SIZE_COUNTERS        _IOR(FM_IOC_TYPE_BASE, FM_PORT_IOC_NUM(43), ioc_fm_port_mac_frame_size_counters_t)
+
+
+/** @} */ /* end of lnx_ioctl_FM_PORT_pcd_runtime_control_grp group */
+/** @} */ /* end of lnx_ioctl_FM_PORT_runtime_control_grp group */
+
+/** @} */ /* end of lnx_ioctl_FM_PORT_grp group */
+/** @} */ /* end of lnx_ioctl_FM_grp group */
+#endif /* __FM_PORT_IOCTLS_H */
diff --git a/include/uapi/linux/fmd/Peripherals/fm_test_ioctls.h b/include/uapi/linux/fmd/Peripherals/fm_test_ioctls.h
new file mode 100644
index 000000000..264670448
--- /dev/null
+++ b/include/uapi/linux/fmd/Peripherals/fm_test_ioctls.h
@@ -0,0 +1,208 @@
+/* Copyright (c) 2008-2012 Freescale Semiconductor, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/**************************************************************************//**
+ @File          fm_test_ioctls.h
+
+ @Description   FM Char device ioctls
+*//***************************************************************************/
+#ifndef __FM_TEST_IOCTLS_H
+#define __FM_TEST_IOCTLS_H
+
+#include "ioctls.h"
+
+
+/**************************************************************************//**
+ @Group         lnx_ioctl_FMT_grp Frame Manager Test Linux IOCTL API
+
+ @Description   FM-Test Linux ioctls definitions and enums
+
+ @{
+*//***************************************************************************/
+
+#define IOC_FMT_MAX_NUM_OF_PORTS        26
+
+/**************************************************************************//**
+ @Collection    TEST Parameters
+*//***************************************************************************/
+/**************************************************************************//**
+  @Description: Name of the FM-Test chardev
+*//***************************************************************************/
+#define DEV_FM_TEST_NAME                "fm-test-port"
+
+#define DEV_FM_TEST_PORTS_MINOR_BASE    0
+#define DEV_FM_TEST_MAX_MINORS          (DEV_FM_TEST_PORTS_MINOR_BASE + IOC_FMT_MAX_NUM_OF_PORTS)
+
+#define FMT_PORT_IOC_NUM(n)             n
+/* @} */
+
+/**************************************************************************//**
+ @Group         lnx_ioctl_FMT_lib_grp FM-Test library
+
+ @Description   TODO
+
+ @{
+*//***************************************************************************/
+
+/**************************************************************************//**
+ @Description   TODO
+*//***************************************************************************/
+typedef uint8_t ioc_fmt_xxx_t;
+
+#define FM_PRS_MAX 32
+#define FM_TIME_STAMP_MAX 8
+
+/**************************************************************************//**
+ @Description   FM Port buffer content description
+*//***************************************************************************/
+typedef struct ioc_fmt_buff_context_t {
+    void            *p_user_priv;
+    uint8_t         fm_prs_res[FM_PRS_MAX];
+    uint8_t         fm_time_stamp[FM_TIME_STAMP_MAX];
+} ioc_fmt_buff_context_t;
+
+#if defined(__KERNEL__) && defined(FM_COMPAT)
+typedef struct ioc_fmt_compat_buff_context_t {
+    compat_uptr_t         p_user_priv;
+    uint8_t               fm_prs_res[FM_PRS_MAX];
+    uint8_t               fm_time_stamp[FM_TIME_STAMP_MAX];
+} ioc_fmt_compat_buff_context_t;
+#endif
+
+/**************************************************************************//**
+ @Description   Buffer descriptor
+*//***************************************************************************/
+typedef struct ioc_fmt_buff_desc_t {
+    uint32_t               qid;
+    void                   *p_data;
+    uint32_t               size;
+    uint32_t               status;
+    ioc_fmt_buff_context_t buff_context;
+} ioc_fmt_buff_desc_t;
+
+#if defined(__KERNEL__) && defined(FM_COMPAT)
+typedef struct ioc_fmt_compat_buff_desc_t {
+    uint32_t                qid;
+    compat_uptr_t           p_data;
+    uint32_t                size;
+    uint32_t                status;
+    ioc_fmt_compat_buff_context_t buff_context;
+} ioc_fmt_compat_buff_desc_t;
+#endif
+
+/**************************************************************************//**
+ @Group         lnx_ioctl_FMT_runtime_control_grp FM-Test Runtime Control Unit
+
+ @Description   TODO
+ @{
+*//***************************************************************************/
+
+/** @} */ /* end of lnx_ioctl_FMT_runtime_control_grp group */
+
+
+/**************************************************************************//**
+ @Group         lnx_ioctl_FMTP_lib_grp FM-Port-Test library
+
+ @Description   TODO
+
+ @{
+*//***************************************************************************/
+
+/**************************************************************************//**
+ @Description   FM-Test FM port type
+*//***************************************************************************/
+typedef enum ioc_fmt_port_type {
+    e_IOC_FMT_PORT_T_RXTX,  /**< Standard port */
+    e_IOC_FMT_PORT_T_OP,    /**< Offline-parsing port */
+} ioc_fmt_port_type;
+
+/**************************************************************************//**
+ @Description   TODO
+*//***************************************************************************/
+typedef struct ioc_fmt_port_param_t {
+    uint8_t             fm_id;
+    ioc_fmt_port_type   fm_port_type;
+    uint8_t             fm_port_id;
+    uint32_t            num_tx_queues;
+} ioc_fmt_port_param_t;
+
+
+/**************************************************************************//**
+ @Function      FMT_PORT_IOC_INIT
+
+ @Description   TODO
+
+ @Param[in]     ioc_fmt_port_param_t  TODO
+
+ @Cautions      Allowed only after the FM equivalent port is already initialized.
+*//***************************************************************************/
+#define FMT_PORT_IOC_INIT           _IOW(FMT_IOC_TYPE_BASE, FMT_PORT_IOC_NUM(0), ioc_fmt_port_param_t)
+
+/**************************************************************************//**
+ @Function      FMT_PORT_IOC_SET_DIAG_MODE
+
+ @Description   TODO
+
+ @Param[in]     ioc_diag_mode  TODO
+
+ @Cautions      Allowed only following FMT_PORT_IOC_INIT().
+*//***************************************************************************/
+#define FMT_PORT_IOC_SET_DIAG_MODE  _IOW(FMT_IOC_TYPE_BASE, FMT_PORT_IOC_NUM(1), ioc_diag_mode)
+
+/**************************************************************************//**
+ @Function      FMT_PORT_IOC_SET_IP_HEADER_MANIP
+
+ @Description   Set IP header manipulations for this port.
+
+ @Param[in]     int     1 to enable; 0 to disable
+
+ @Cautions      Allowed only following FMT_PORT_IOC_INIT().
+*//***************************************************************************/
+#define FMT_PORT_IOC_SET_IP_HEADER_MANIP  _IOW(FMT_IOC_TYPE_BASE, FMT_PORT_IOC_NUM(2), int)
+
+/**************************************************************************//**
+ @Function      FMT_PORT_IOC_SET_DPAECHO_MODE
+
+ @Description   Set DPA in echo mode - all frame are sent back.
+
+ @Param[in]     int     1 to enable; 0 to disable
+
+ @Cautions      Allowed only following FMT_PORT_IOC_INIT().
+*//***************************************************************************/
+#define FMT_PORT_IOC_SET_DPAECHO_MODE     _IOW(FMT_IOC_TYPE_BASE, FMT_PORT_IOC_NUM(3), int)
+
+/** @} */ /* end of lnx_ioctl_FMTP_lib_grp group */
+/** @} */ /* end of lnx_ioctl_FMT_lib_grp group */
+/** @} */ /* end of lnx_ioctl_FMT_grp */
+
+
+#endif /* __FM_TEST_IOCTLS_H */
diff --git a/include/uapi/linux/fmd/integrations/Kbuild b/include/uapi/linux/fmd/integrations/Kbuild
new file mode 100644
index 000000000..e548d676c
--- /dev/null
+++ b/include/uapi/linux/fmd/integrations/Kbuild
@@ -0,0 +1 @@
+header-y += integration_ioctls.h
diff --git a/include/uapi/linux/fmd/integrations/integration_ioctls.h b/include/uapi/linux/fmd/integrations/integration_ioctls.h
new file mode 100644
index 000000000..61d696e2d
--- /dev/null
+++ b/include/uapi/linux/fmd/integrations/integration_ioctls.h
@@ -0,0 +1,56 @@
+/* Copyright (c) 2008-2012 Freescale Semiconductor, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/**************************************************************************//**
+ @File          integration_ioctls.h
+
+ @Description   External header file for Integration unit routines.
+*//***************************************************************************/
+
+#ifndef __INTG_IOCTLS_H
+#define __INTG_IOCTLS_H
+
+
+#define FM_IOC_TYPE_BASE            (NCSW_IOC_TYPE_BASE+1)
+#define FMT_IOC_TYPE_BASE           (NCSW_IOC_TYPE_BASE+3)
+
+/*#define FM_IOCTL_DBG*/
+
+#if defined(FM_IOCTL_DBG)
+    #define _fm_ioctl_dbg(format, arg...) \
+        printk("fm ioctl [%s:%u](cpu:%u) - " format, \
+            __func__, __LINE__, smp_processor_id(), ##arg)
+#else
+#   define _fm_ioctl_dbg(arg...)
+#endif
+
+#endif /* __INTG_IOCTLS_H */
diff --git a/include/uapi/linux/fmd/ioctls.h b/include/uapi/linux/fmd/ioctls.h
new file mode 100644
index 000000000..4f36cb050
--- /dev/null
+++ b/include/uapi/linux/fmd/ioctls.h
@@ -0,0 +1,96 @@
+/* Copyright (c) 2008-2012 Freescale Semiconductor, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/**************************************************************************//**
+ @File          ioctls.h
+
+ @Description   Structures and definitions for Command Relay Ioctls
+*//***************************************************************************/
+
+#ifndef __IOCTLS_H__
+#define __IOCTLS_H__
+
+#include <asm/ioctl.h>
+
+#include "integration_ioctls.h"
+
+
+/**************************************************************************//**
+ @Group         lnx_ioctl_ncsw_grp    NetCommSw Linux User-Space (IOCTL) API
+ @{
+*//***************************************************************************/
+
+#define NCSW_IOC_TYPE_BASE          0xe0    /**< defines the IOCTL type for all
+                                                 the NCSW Linux module commands */
+
+
+/**************************************************************************//**
+ @Description   IOCTL Memory allocation types.
+*//***************************************************************************/
+typedef enum ioc_mem_type {
+    e_IOC_MEM_INVALID      = 0x00000000,  /**< Invalid memory type (error) */
+    e_IOC_MEM_CACHABLE_SYS = 0x00000001,  /**< Primary DDR, cacheable segment */
+    e_IOC_MEM_NOCACHE_SYS  = 0x00000004,  /**< Primary DDR, non-cacheable segment */
+    e_IOC_MEM_SECONDARY    = 0x00000002,  /**< Either secondary DDR or SDRAM */
+    e_IOC_MEM_PRAM         = 0x00000008   /**< Multi-user RAM identifier */
+} ioc_mem_type;
+
+/**************************************************************************//**
+ @Description   Enumeration (bit flags) of communication modes (Transmit,
+                receive or both).
+*//***************************************************************************/
+typedef enum ioc_comm_mode {
+      e_IOC_COMM_MODE_NONE         = 0  /**< No transmit/receive communication */
+    , e_IOC_COMM_MODE_RX           = 1  /**< Only receive communication */
+    , e_IOC_COMM_MODE_TX           = 2  /**< Only transmit communication */
+    , e_IOC_COMM_MODE_RX_AND_TX    = 3  /**< Both transmit and receive communication */
+} ioc_comm_mode;
+
+/**************************************************************************//**
+ @Description   General Diagnostic Mode
+*//***************************************************************************/
+typedef enum ioc_diag_mode
+{
+    e_IOC_DIAG_MODE_NONE = 0,
+    e_IOC_DIAG_MODE_CTRL_LOOPBACK,      /**< loopback in the controller; E.g. MAC, TDM, etc. */
+    e_IOC_DIAG_MODE_CHIP_LOOPBACK,      /**< loopback in the chip but not in controller;
+                                         E.g. IO-pins, SerDes, etc. */
+    e_IOC_DIAG_MODE_PHY_LOOPBACK,       /**< loopback in the external PHY */
+    e_IOC_DIAG_MODE_LINE_LOOPBACK,      /**< loopback in the external line */
+    e_IOC_DIAG_MODE_CTRL_ECHO,          /**< */
+    e_IOC_DIAG_MODE_PHY_ECHO            /**< */
+} ioc_diag_mode;
+
+/** @} */ /* end of lnx_ioctl_ncsw_grp */
+
+
+#endif /* __IOCTLS_H__ */
diff --git a/include/uapi/linux/fmd/net_ioctls.h b/include/uapi/linux/fmd/net_ioctls.h
new file mode 100644
index 000000000..c99d64cfc
--- /dev/null
+++ b/include/uapi/linux/fmd/net_ioctls.h
@@ -0,0 +1,430 @@
+/* Copyright (c) 2008-2012 Freescale Semiconductor, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+
+/**************************************************************************//**
+ @File          net_ioctls.h
+
+ @Description   This file contains common and general netcomm headers definitions.
+*//***************************************************************************/
+#ifndef __NET_IOCTLS_H
+#define __NET_IOCTLS_H
+
+#include "ioctls.h"
+
+
+typedef uint8_t ioc_header_field_ppp_t;
+
+#define IOC_NET_HEADER_FIELD_PPP_PID                        (1)
+#define IOC_NET_HEADER_FIELD_PPP_COMPRESSED                 (IOC_NET_HEADER_FIELD_PPP_PID << 1)
+#define IOC_NET_HEADER_FIELD_PPP_ALL_FIELDS                 ((IOC_NET_HEADER_FIELD_PPP_PID << 2) - 1)
+
+
+typedef uint8_t ioc_header_field_pppoe_t;
+
+#define IOC_NET_HEADER_FIELD_PPPoE_VER                      (1)
+#define IOC_NET_HEADER_FIELD_PPPoE_TYPE                     (IOC_NET_HEADER_FIELD_PPPoE_VER << 1)
+#define IOC_NET_HEADER_FIELD_PPPoE_CODE                     (IOC_NET_HEADER_FIELD_PPPoE_VER << 2)
+#define IOC_NET_HEADER_FIELD_PPPoE_SID                      (IOC_NET_HEADER_FIELD_PPPoE_VER << 3)
+#define IOC_NET_HEADER_FIELD_PPPoE_LEN                      (IOC_NET_HEADER_FIELD_PPPoE_VER << 4)
+#define IOC_NET_HEADER_FIELD_PPPoE_SESSION                  (IOC_NET_HEADER_FIELD_PPPoE_VER << 5)
+#define IOC_NET_HEADER_FIELD_PPPoE_PID                      (IOC_NET_HEADER_FIELD_PPPoE_VER << 6)
+#define IOC_NET_HEADER_FIELD_PPPoE_ALL_FIELDS               ((IOC_NET_HEADER_FIELD_PPPoE_VER << 7) - 1)
+
+#define IOC_NET_HEADER_FIELD_PPPMUX_PID                     (1)
+#define IOC_NET_HEADER_FIELD_PPPMUX_CKSUM                   (IOC_NET_HEADER_FIELD_PPPMUX_PID << 1)
+#define IOC_NET_HEADER_FIELD_PPPMUX_COMPRESSED              (IOC_NET_HEADER_FIELD_PPPMUX_PID << 2)
+#define IOC_NET_HEADER_FIELD_PPPMUX_ALL_FIELDS              ((IOC_NET_HEADER_FIELD_PPPMUX_PID << 3) - 1)
+
+#define IOC_NET_HEADER_FIELD_PPPMUX_SUBFRAME_PFF            (1)
+#define IOC_NET_HEADER_FIELD_PPPMUX_SUBFRAME_LXT            (IOC_NET_HEADER_FIELD_PPPMUX_SUBFRAME_PFF << 1)
+#define IOC_NET_HEADER_FIELD_PPPMUX_SUBFRAME_LEN            (IOC_NET_HEADER_FIELD_PPPMUX_SUBFRAME_PFF << 2)
+#define IOC_NET_HEADER_FIELD_PPPMUX_SUBFRAME_PID            (IOC_NET_HEADER_FIELD_PPPMUX_SUBFRAME_PFF << 3)
+#define IOC_NET_HEADER_FIELD_PPPMUX_SUBFRAME_USE_PID        (IOC_NET_HEADER_FIELD_PPPMUX_SUBFRAME_PFF << 4)
+#define IOC_NET_HEADER_FIELD_PPPMUX_SUBFRAME_ALL_FIELDS     ((IOC_NET_HEADER_FIELD_PPPMUX_SUBFRAME_PFF << 5) - 1)
+
+
+typedef uint8_t ioc_header_field_eth_t;
+
+#define IOC_NET_HEADER_FIELD_ETH_DA                         (1)
+#define IOC_NET_HEADER_FIELD_ETH_SA                         (IOC_NET_HEADER_FIELD_ETH_DA << 1)
+#define IOC_NET_HEADER_FIELD_ETH_LENGTH                     (IOC_NET_HEADER_FIELD_ETH_DA << 2)
+#define IOC_NET_HEADER_FIELD_ETH_TYPE                       (IOC_NET_HEADER_FIELD_ETH_DA << 3)
+#define IOC_NET_HEADER_FIELD_ETH_FINAL_CKSUM                (IOC_NET_HEADER_FIELD_ETH_DA << 4)
+#define IOC_NET_HEADER_FIELD_ETH_PADDING                    (IOC_NET_HEADER_FIELD_ETH_DA << 5)
+#define IOC_NET_HEADER_FIELD_ETH_ALL_FIELDS                 ((IOC_NET_HEADER_FIELD_ETH_DA << 6) - 1)
+
+#define IOC_NET_HEADER_FIELD_ETH_ADDR_SIZE                 6
+
+typedef uint16_t ioc_header_field_ip_t;
+
+#define IOC_NET_HEADER_FIELD_IP_VER                         (1)
+#define IOC_NET_HEADER_FIELD_IP_DSCP                        (IOC_NET_HEADER_FIELD_IP_VER << 2)
+#define IOC_NET_HEADER_FIELD_IP_ECN                         (IOC_NET_HEADER_FIELD_IP_VER << 3)
+#define IOC_NET_HEADER_FIELD_IP_PROTO                       (IOC_NET_HEADER_FIELD_IP_VER << 4)
+
+#define IOC_NET_HEADER_FIELD_IP_PROTO_SIZE                  1
+
+typedef uint16_t ioc_header_field_ipv4_t;
+
+#define IOC_NET_HEADER_FIELD_IPv4_VER                       (1)
+#define IOC_NET_HEADER_FIELD_IPv4_HDR_LEN                   (IOC_NET_HEADER_FIELD_IPv4_VER << 1)
+#define IOC_NET_HEADER_FIELD_IPv4_TOS                       (IOC_NET_HEADER_FIELD_IPv4_VER << 2)
+#define IOC_NET_HEADER_FIELD_IPv4_TOTAL_LEN                 (IOC_NET_HEADER_FIELD_IPv4_VER << 3)
+#define IOC_NET_HEADER_FIELD_IPv4_ID                        (IOC_NET_HEADER_FIELD_IPv4_VER << 4)
+#define IOC_NET_HEADER_FIELD_IPv4_FLAG_D                    (IOC_NET_HEADER_FIELD_IPv4_VER << 5)
+#define IOC_NET_HEADER_FIELD_IPv4_FLAG_M                    (IOC_NET_HEADER_FIELD_IPv4_VER << 6)
+#define IOC_NET_HEADER_FIELD_IPv4_OFFSET                    (IOC_NET_HEADER_FIELD_IPv4_VER << 7)
+#define IOC_NET_HEADER_FIELD_IPv4_TTL                       (IOC_NET_HEADER_FIELD_IPv4_VER << 8)
+#define IOC_NET_HEADER_FIELD_IPv4_PROTO                     (IOC_NET_HEADER_FIELD_IPv4_VER << 9)
+#define IOC_NET_HEADER_FIELD_IPv4_CKSUM                     (IOC_NET_HEADER_FIELD_IPv4_VER << 10)
+#define IOC_NET_HEADER_FIELD_IPv4_SRC_IP                    (IOC_NET_HEADER_FIELD_IPv4_VER << 11)
+#define IOC_NET_HEADER_FIELD_IPv4_DST_IP                    (IOC_NET_HEADER_FIELD_IPv4_VER << 12)
+#define IOC_NET_HEADER_FIELD_IPv4_OPTS                      (IOC_NET_HEADER_FIELD_IPv4_VER << 13)
+#define IOC_NET_HEADER_FIELD_IPv4_OPTS_COUNT                (IOC_NET_HEADER_FIELD_IPv4_VER << 14)
+#define IOC_NET_HEADER_FIELD_IPv4_ALL_FIELDS                ((IOC_NET_HEADER_FIELD_IPv4_VER << 15) - 1)
+
+#define IOC_NET_HEADER_FIELD_IPv4_ADDR_SIZE                 4
+#define IOC_NET_HEADER_FIELD_IPv4_PROTO_SIZE                1
+
+
+typedef uint8_t ioc_header_field_ipv6_t;
+
+#define IOC_NET_HEADER_FIELD_IPv6_VER                       (1)
+#define IOC_NET_HEADER_FIELD_IPv6_TC                        (IOC_NET_HEADER_FIELD_IPv6_VER << 1)
+#define IOC_NET_HEADER_FIELD_IPv6_SRC_IP                    (IOC_NET_HEADER_FIELD_IPv6_VER << 2)
+#define IOC_NET_HEADER_FIELD_IPv6_DST_IP                    (IOC_NET_HEADER_FIELD_IPv6_VER << 3)
+#define IOC_NET_HEADER_FIELD_IPv6_NEXT_HDR                  (IOC_NET_HEADER_FIELD_IPv6_VER << 4)
+#define IOC_NET_HEADER_FIELD_IPv6_FL                        (IOC_NET_HEADER_FIELD_IPv6_VER << 5)
+#define IOC_NET_HEADER_FIELD_IPv6_HOP_LIMIT                 (IOC_NET_HEADER_FIELD_IPv6_VER << 6)
+#define IOC_NET_HEADER_FIELD_IPv6_ALL_FIELDS                ((IOC_NET_HEADER_FIELD_IPv6_VER << 7) - 1)
+
+#define IOC_NET_HEADER_FIELD_IPv6_ADDR_SIZE                 16
+#define IOC_NET_HEADER_FIELD_IPv6_NEXT_HDR_SIZE             1
+
+#define IOC_NET_HEADER_FIELD_ICMP_TYPE                      (1)
+#define IOC_NET_HEADER_FIELD_ICMP_CODE                      (IOC_NET_HEADER_FIELD_ICMP_TYPE << 1)
+#define IOC_NET_HEADER_FIELD_ICMP_CKSUM                     (IOC_NET_HEADER_FIELD_ICMP_TYPE << 2)
+#define IOC_NET_HEADER_FIELD_ICMP_ID                        (IOC_NET_HEADER_FIELD_ICMP_TYPE << 3)
+#define IOC_NET_HEADER_FIELD_ICMP_SQ_NUM                    (IOC_NET_HEADER_FIELD_ICMP_TYPE << 4)
+#define IOC_NET_HEADER_FIELD_ICMP_ALL_FIELDS                ((IOC_NET_HEADER_FIELD_ICMP_TYPE << 5) - 1)
+
+#define IOC_NET_HEADER_FIELD_ICMP_CODE_SIZE                 1
+#define IOC_NET_HEADER_FIELD_ICMP_TYPE_SIZE                 1
+
+#define IOC_NET_HEADER_FIELD_IGMP_VERSION                   (1)
+#define IOC_NET_HEADER_FIELD_IGMP_TYPE                      (IOC_NET_HEADER_FIELD_IGMP_VERSION << 1)
+#define IOC_NET_HEADER_FIELD_IGMP_CKSUM                     (IOC_NET_HEADER_FIELD_IGMP_VERSION << 2)
+#define IOC_NET_HEADER_FIELD_IGMP_DATA                      (IOC_NET_HEADER_FIELD_IGMP_VERSION << 3)
+#define IOC_NET_HEADER_FIELD_IGMP_ALL_FIELDS                ((IOC_NET_HEADER_FIELD_IGMP_VERSION << 4) - 1)
+
+
+typedef uint16_t ioc_header_field_tcp_t;
+
+#define IOC_NET_HEADER_FIELD_TCP_PORT_SRC                   (1)
+#define IOC_NET_HEADER_FIELD_TCP_PORT_DST                   (IOC_NET_HEADER_FIELD_TCP_PORT_SRC << 1)
+#define IOC_NET_HEADER_FIELD_TCP_SEQ                        (IOC_NET_HEADER_FIELD_TCP_PORT_SRC << 2)
+#define IOC_NET_HEADER_FIELD_TCP_ACK                        (IOC_NET_HEADER_FIELD_TCP_PORT_SRC << 3)
+#define IOC_NET_HEADER_FIELD_TCP_OFFSET                     (IOC_NET_HEADER_FIELD_TCP_PORT_SRC << 4)
+#define IOC_NET_HEADER_FIELD_TCP_FLAGS                      (IOC_NET_HEADER_FIELD_TCP_PORT_SRC << 5)
+#define IOC_NET_HEADER_FIELD_TCP_WINDOW                     (IOC_NET_HEADER_FIELD_TCP_PORT_SRC << 6)
+#define IOC_NET_HEADER_FIELD_TCP_CKSUM                      (IOC_NET_HEADER_FIELD_TCP_PORT_SRC << 7)
+#define IOC_NET_HEADER_FIELD_TCP_URGPTR                     (IOC_NET_HEADER_FIELD_TCP_PORT_SRC << 8)
+#define IOC_NET_HEADER_FIELD_TCP_OPTS                       (IOC_NET_HEADER_FIELD_TCP_PORT_SRC << 9)
+#define IOC_NET_HEADER_FIELD_TCP_OPTS_COUNT                 (IOC_NET_HEADER_FIELD_TCP_PORT_SRC << 10)
+#define IOC_NET_HEADER_FIELD_TCP_ALL_FIELDS                 ((IOC_NET_HEADER_FIELD_TCP_PORT_SRC << 11) - 1)
+
+#define IOC_NET_HEADER_FIELD_TCP_PORT_SIZE                  2
+
+
+typedef uint8_t ioc_header_field_sctp_t;
+
+#define IOC_NET_HEADER_FIELD_SCTP_PORT_SRC                  (1)
+#define IOC_NET_HEADER_FIELD_SCTP_PORT_DST                  (IOC_NET_HEADER_FIELD_SCTP_PORT_SRC << 1)
+#define IOC_NET_HEADER_FIELD_SCTP_VER_TAG                   (IOC_NET_HEADER_FIELD_SCTP_PORT_SRC << 2)
+#define IOC_NET_HEADER_FIELD_SCTP_CKSUM                     (IOC_NET_HEADER_FIELD_SCTP_PORT_SRC << 3)
+#define IOC_NET_HEADER_FIELD_SCTP_ALL_FIELDS                ((IOC_NET_HEADER_FIELD_SCTP_PORT_SRC << 4) - 1)
+
+#define IOC_NET_HEADER_FIELD_SCTP_PORT_SIZE                 2
+
+typedef uint8_t ioc_header_field_dccp_t;
+
+#define IOC_NET_HEADER_FIELD_DCCP_PORT_SRC                  (1)
+#define IOC_NET_HEADER_FIELD_DCCP_PORT_DST                  (IOC_NET_HEADER_FIELD_DCCP_PORT_SRC << 1)
+#define IOC_NET_HEADER_FIELD_DCCP_ALL_FIELDS                ((IOC_NET_HEADER_FIELD_DCCP_PORT_SRC << 2) - 1)
+
+#define IOC_NET_HEADER_FIELD_DCCP_PORT_SIZE                 2
+
+
+typedef uint8_t ioc_header_field_udp_t;
+
+#define IOC_NET_HEADER_FIELD_UDP_PORT_SRC                   (1)
+#define IOC_NET_HEADER_FIELD_UDP_PORT_DST                   (IOC_NET_HEADER_FIELD_UDP_PORT_SRC << 1)
+#define IOC_NET_HEADER_FIELD_UDP_LEN                        (IOC_NET_HEADER_FIELD_UDP_PORT_SRC << 2)
+#define IOC_NET_HEADER_FIELD_UDP_CKSUM                      (IOC_NET_HEADER_FIELD_UDP_PORT_SRC << 3)
+#define IOC_NET_HEADER_FIELD_UDP_ALL_FIELDS                 ((IOC_NET_HEADER_FIELD_UDP_PORT_SRC << 4) - 1)
+
+#define IOC_NET_HEADER_FIELD_UDP_PORT_SIZE                  2
+
+typedef uint8_t ioc_header_field_udp_lite_t;
+
+#define IOC_NET_HEADER_FIELD_UDP_LITE_PORT_SRC              (1)
+#define IOC_NET_HEADER_FIELD_UDP_LITE_PORT_DST              (IOC_NET_HEADER_FIELD_UDP_LITE_PORT_SRC << 1)
+#define IOC_NET_HEADER_FIELD_UDP_LITE_ALL_FIELDS            ((IOC_NET_HEADER_FIELD_UDP_LITE_PORT_SRC << 2) - 1)
+
+#define IOC_NET_HEADER_FIELD_UDP_LITE_PORT_SIZE             2
+
+typedef uint8_t ioc_header_field_udp_encap_esp_t;
+
+#define IOC_NET_HEADER_FIELD_UDP_ENCAP_ESP_PORT_SRC         (1)
+#define IOC_NET_HEADER_FIELD_UDP_ENCAP_ESP_PORT_DST         (IOC_NET_HEADER_FIELD_UDP_ENCAP_ESP_PORT_SRC << 1)
+#define IOC_NET_HEADER_FIELD_UDP_ENCAP_ESP_LEN              (IOC_NET_HEADER_FIELD_UDP_ENCAP_ESP_PORT_SRC << 2)
+#define IOC_NET_HEADER_FIELD_UDP_ENCAP_ESP_CKSUM            (IOC_NET_HEADER_FIELD_UDP_ENCAP_ESP_PORT_SRC << 3)
+#define IOC_NET_HEADER_FIELD_UDP_ENCAP_ESP_SPI              (IOC_NET_HEADER_FIELD_UDP_ENCAP_ESP_PORT_SRC << 4)
+#define IOC_NET_HEADER_FIELD_UDP_ENCAP_ESP_SEQUENCE_NUM     (IOC_NET_HEADER_FIELD_UDP_ENCAP_ESP_PORT_SRC << 5)
+#define IOC_NET_HEADER_FIELD_UDP_ENCAP_ESP_ALL_FIELDS       ((IOC_NET_HEADER_FIELD_UDP_ENCAP_ESP_PORT_SRC << 6) - 1)
+
+#define IOC_NET_HEADER_FIELD_UDP_ENCAP_ESP_PORT_SIZE        2
+#define IOC_NET_HEADER_FIELD_UDP_ENCAP_ESP_SPI_SIZE         4
+
+#define IOC_NET_HEADER_FIELD_IPHC_CID                       (1)
+#define IOC_NET_HEADER_FIELD_IPHC_CID_TYPE                  (IOC_NET_HEADER_FIELD_IPHC_CID << 1)
+#define IOC_NET_HEADER_FIELD_IPHC_HCINDEX                   (IOC_NET_HEADER_FIELD_IPHC_CID << 2)
+#define IOC_NET_HEADER_FIELD_IPHC_GEN                       (IOC_NET_HEADER_FIELD_IPHC_CID << 3)
+#define IOC_NET_HEADER_FIELD_IPHC_D_BIT                     (IOC_NET_HEADER_FIELD_IPHC_CID << 4)
+#define IOC_NET_HEADER_FIELD_IPHC_ALL_FIELDS                ((IOC_NET_HEADER_FIELD_IPHC_CID << 5) - 1)
+
+#define IOC_NET_HEADER_FIELD_SCTP_CHUNK_DATA_TYPE           (1)
+#define IOC_NET_HEADER_FIELD_SCTP_CHUNK_DATA_FLAGS          (IOC_NET_HEADER_FIELD_SCTP_CHUNK_DATA_TYPE << 1)
+#define IOC_NET_HEADER_FIELD_SCTP_CHUNK_DATA_LENGTH         (IOC_NET_HEADER_FIELD_SCTP_CHUNK_DATA_TYPE << 2)
+#define IOC_NET_HEADER_FIELD_SCTP_CHUNK_DATA_TSN            (IOC_NET_HEADER_FIELD_SCTP_CHUNK_DATA_TYPE << 3)
+#define IOC_NET_HEADER_FIELD_SCTP_CHUNK_DATA_STREAM_ID      (IOC_NET_HEADER_FIELD_SCTP_CHUNK_DATA_TYPE << 4)
+#define IOC_NET_HEADER_FIELD_SCTP_CHUNK_DATA_STREAM_SQN     (IOC_NET_HEADER_FIELD_SCTP_CHUNK_DATA_TYPE << 5)
+#define IOC_NET_HEADER_FIELD_SCTP_CHUNK_DATA_PAYLOAD_PID    (IOC_NET_HEADER_FIELD_SCTP_CHUNK_DATA_TYPE << 6)
+#define IOC_NET_HEADER_FIELD_SCTP_CHUNK_DATA_UNORDERED      (IOC_NET_HEADER_FIELD_SCTP_CHUNK_DATA_TYPE << 7)
+#define IOC_NET_HEADER_FIELD_SCTP_CHUNK_DATA_BEGGINING      (IOC_NET_HEADER_FIELD_SCTP_CHUNK_DATA_TYPE << 8)
+#define IOC_NET_HEADER_FIELD_SCTP_CHUNK_DATA_END            (IOC_NET_HEADER_FIELD_SCTP_CHUNK_DATA_TYPE << 9)
+#define IOC_NET_HEADER_FIELD_SCTP_CHUNK_DATA_ALL_FIELDS     ((IOC_NET_HEADER_FIELD_SCTP_CHUNK_DATA_TYPE << 10) - 1)
+
+#define IOC_NET_HEADER_FIELD_L2TPv2_TYPE_BIT                (1)
+#define IOC_NET_HEADER_FIELD_L2TPv2_LENGTH_BIT              (IOC_NET_HEADER_FIELD_L2TPv2_TYPE_BIT << 1)
+#define IOC_NET_HEADER_FIELD_L2TPv2_SEQUENCE_BIT            (IOC_NET_HEADER_FIELD_L2TPv2_TYPE_BIT << 2)
+#define IOC_NET_HEADER_FIELD_L2TPv2_OFFSET_BIT              (IOC_NET_HEADER_FIELD_L2TPv2_TYPE_BIT << 3)
+#define IOC_NET_HEADER_FIELD_L2TPv2_PRIORITY_BIT            (IOC_NET_HEADER_FIELD_L2TPv2_TYPE_BIT << 4)
+#define IOC_NET_HEADER_FIELD_L2TPv2_VERSION                 (IOC_NET_HEADER_FIELD_L2TPv2_TYPE_BIT << 5)
+#define IOC_NET_HEADER_FIELD_L2TPv2_LEN                     (IOC_NET_HEADER_FIELD_L2TPv2_TYPE_BIT << 6)
+#define IOC_NET_HEADER_FIELD_L2TPv2_TUNNEL_ID               (IOC_NET_HEADER_FIELD_L2TPv2_TYPE_BIT << 7)
+#define IOC_NET_HEADER_FIELD_L2TPv2_SESSION_ID              (IOC_NET_HEADER_FIELD_L2TPv2_TYPE_BIT << 8)
+#define IOC_NET_HEADER_FIELD_L2TPv2_NS                      (IOC_NET_HEADER_FIELD_L2TPv2_TYPE_BIT << 9)
+#define IOC_NET_HEADER_FIELD_L2TPv2_NR                      (IOC_NET_HEADER_FIELD_L2TPv2_TYPE_BIT << 10)
+#define IOC_NET_HEADER_FIELD_L2TPv2_OFFSET_SIZE             (IOC_NET_HEADER_FIELD_L2TPv2_TYPE_BIT << 11)
+#define IOC_NET_HEADER_FIELD_L2TPv2_FIRST_BYTE              (IOC_NET_HEADER_FIELD_L2TPv2_TYPE_BIT << 12)
+#define IOC_NET_HEADER_FIELD_L2TPv2_ALL_FIELDS              ((IOC_NET_HEADER_FIELD_L2TPv2_TYPE_BIT << 13) - 1)
+
+#define IOC_NET_HEADER_FIELD_L2TPv3_CTRL_TYPE_BIT           (1)
+#define IOC_NET_HEADER_FIELD_L2TPv3_CTRL_LENGTH_BIT         (IOC_NET_HEADER_FIELD_L2TPv3_CTRL_TYPE_BIT << 1)
+#define IOC_NET_HEADER_FIELD_L2TPv3_CTRL_SEQUENCE_BIT       (IOC_NET_HEADER_FIELD_L2TPv3_CTRL_TYPE_BIT << 2)
+#define IOC_NET_HEADER_FIELD_L2TPv3_CTRL_VERSION            (IOC_NET_HEADER_FIELD_L2TPv3_CTRL_TYPE_BIT << 3)
+#define IOC_NET_HEADER_FIELD_L2TPv3_CTRL_LENGTH             (IOC_NET_HEADER_FIELD_L2TPv3_CTRL_TYPE_BIT << 4)
+#define IOC_NET_HEADER_FIELD_L2TPv3_CTRL_CONTROL            (IOC_NET_HEADER_FIELD_L2TPv3_CTRL_TYPE_BIT << 5)
+#define IOC_NET_HEADER_FIELD_L2TPv3_CTRL_SENT               (IOC_NET_HEADER_FIELD_L2TPv3_CTRL_TYPE_BIT << 6)
+#define IOC_NET_HEADER_FIELD_L2TPv3_CTRL_RECV               (IOC_NET_HEADER_FIELD_L2TPv3_CTRL_TYPE_BIT << 7)
+#define IOC_NET_HEADER_FIELD_L2TPv3_CTRL_FIRST_BYTE         (IOC_NET_HEADER_FIELD_L2TPv3_CTRL_TYPE_BIT << 8)
+#define IOC_NET_HEADER_FIELD_L2TPv3_CTRL_ALL_FIELDS         ((IOC_NET_HEADER_FIELD_L2TPv3_CTRL_TYPE_BIT << 9) - 1)
+
+#define IOC_NET_HEADER_FIELD_L2TPv3_SESS_TYPE_BIT           (1)
+#define IOC_NET_HEADER_FIELD_L2TPv3_SESS_VERSION            (IOC_NET_HEADER_FIELD_L2TPv3_SESS_TYPE_BIT << 1)
+#define IOC_NET_HEADER_FIELD_L2TPv3_SESS_ID                 (IOC_NET_HEADER_FIELD_L2TPv3_SESS_TYPE_BIT << 2)
+#define IOC_NET_HEADER_FIELD_L2TPv3_SESS_COOKIE             (IOC_NET_HEADER_FIELD_L2TPv3_SESS_TYPE_BIT << 3)
+#define IOC_NET_HEADER_FIELD_L2TPv3_SESS_ALL_FIELDS         ((IOC_NET_HEADER_FIELD_L2TPv3_SESS_TYPE_BIT << 4) - 1)
+
+
+typedef uint8_t ioc_header_field_vlan_t;
+
+#define IOC_NET_HEADER_FIELD_VLAN_VPRI                      (1)
+#define IOC_NET_HEADER_FIELD_VLAN_CFI                       (IOC_NET_HEADER_FIELD_VLAN_VPRI << 1)
+#define IOC_NET_HEADER_FIELD_VLAN_VID                       (IOC_NET_HEADER_FIELD_VLAN_VPRI << 2)
+#define IOC_NET_HEADER_FIELD_VLAN_LENGTH                    (IOC_NET_HEADER_FIELD_VLAN_VPRI << 3)
+#define IOC_NET_HEADER_FIELD_VLAN_TYPE                      (IOC_NET_HEADER_FIELD_VLAN_VPRI << 4)
+#define IOC_NET_HEADER_FIELD_VLAN_ALL_FIELDS                ((IOC_NET_HEADER_FIELD_VLAN_VPRI << 5) - 1)
+
+#define IOC_NET_HEADER_FIELD_VLAN_TCI                       (IOC_NET_HEADER_FIELD_VLAN_VPRI | \
+                                                             IOC_NET_HEADER_FIELD_VLAN_CFI | \
+                                                             IOC_NET_HEADER_FIELD_VLAN_VID)
+
+
+typedef uint8_t ioc_header_field_llc_t;
+
+#define IOC_NET_HEADER_FIELD_LLC_DSAP                       (1)
+#define IOC_NET_HEADER_FIELD_LLC_SSAP                       (IOC_NET_HEADER_FIELD_LLC_DSAP << 1)
+#define IOC_NET_HEADER_FIELD_LLC_CTRL                       (IOC_NET_HEADER_FIELD_LLC_DSAP << 2)
+#define IOC_NET_HEADER_FIELD_LLC_ALL_FIELDS                 ((IOC_NET_HEADER_FIELD_LLC_DSAP << 3) - 1)
+
+#define IOC_NET_HEADER_FIELD_NLPID_NLPID                    (1)
+#define IOC_NET_HEADER_FIELD_NLPID_ALL_FIELDS               ((IOC_NET_HEADER_FIELD_NLPID_NLPID << 1) - 1)
+
+
+typedef uint8_t ioc_header_field_snap_t;
+
+#define IOC_NET_HEADER_FIELD_SNAP_OUI                       (1)
+#define IOC_NET_HEADER_FIELD_SNAP_PID                       (IOC_NET_HEADER_FIELD_SNAP_OUI << 1)
+#define IOC_NET_HEADER_FIELD_SNAP_ALL_FIELDS                ((IOC_NET_HEADER_FIELD_SNAP_OUI << 2) - 1)
+
+
+typedef uint8_t ioc_header_field_llc_snap_t;
+
+#define IOC_NET_HEADER_FIELD_LLC_SNAP_TYPE                  (1)
+#define IOC_NET_HEADER_FIELD_LLC_SNAP_ALL_FIELDS            ((IOC_NET_HEADER_FIELD_LLC_SNAP_TYPE << 1) - 1)
+
+#define IOC_NET_HEADER_FIELD_ARP_HTYPE                      (1)
+#define IOC_NET_HEADER_FIELD_ARP_PTYPE                      (IOC_NET_HEADER_FIELD_ARP_HTYPE << 1)
+#define IOC_NET_HEADER_FIELD_ARP_HLEN                       (IOC_NET_HEADER_FIELD_ARP_HTYPE << 2)
+#define IOC_NET_HEADER_FIELD_ARP_PLEN                       (IOC_NET_HEADER_FIELD_ARP_HTYPE << 3)
+#define IOC_NET_HEADER_FIELD_ARP_OPER                       (IOC_NET_HEADER_FIELD_ARP_HTYPE << 4)
+#define IOC_NET_HEADER_FIELD_ARP_SHA                        (IOC_NET_HEADER_FIELD_ARP_HTYPE << 5)
+#define IOC_NET_HEADER_FIELD_ARP_SPA                        (IOC_NET_HEADER_FIELD_ARP_HTYPE << 6)
+#define IOC_NET_HEADER_FIELD_ARP_THA                        (IOC_NET_HEADER_FIELD_ARP_HTYPE << 7)
+#define IOC_NET_HEADER_FIELD_ARP_TPA                        (IOC_NET_HEADER_FIELD_ARP_HTYPE << 8)
+#define IOC_NET_HEADER_FIELD_ARP_ALL_FIELDS                 ((IOC_NET_HEADER_FIELD_ARP_HTYPE << 9) - 1)
+
+#define IOC_NET_HEADER_FIELD_RFC2684_LLC                    (1)
+#define IOC_NET_HEADER_FIELD_RFC2684_NLPID                  (IOC_NET_HEADER_FIELD_RFC2684_LLC << 1)
+#define IOC_NET_HEADER_FIELD_RFC2684_OUI                    (IOC_NET_HEADER_FIELD_RFC2684_LLC << 2)
+#define IOC_NET_HEADER_FIELD_RFC2684_PID                    (IOC_NET_HEADER_FIELD_RFC2684_LLC << 3)
+#define IOC_NET_HEADER_FIELD_RFC2684_VPN_OUI                (IOC_NET_HEADER_FIELD_RFC2684_LLC << 4)
+#define IOC_NET_HEADER_FIELD_RFC2684_VPN_IDX                (IOC_NET_HEADER_FIELD_RFC2684_LLC << 5)
+#define IOC_NET_HEADER_FIELD_RFC2684_ALL_FIELDS             ((IOC_NET_HEADER_FIELD_RFC2684_LLC << 6) - 1)
+
+#define IOC_NET_HEADER_FIELD_USER_DEFINED_SRCPORT           (1)
+#define IOC_NET_HEADER_FIELD_USER_DEFINED_PCDID             (IOC_NET_HEADER_FIELD_USER_DEFINED_SRCPORT << 1)
+#define IOC_NET_HEADER_FIELD_USER_DEFINED_ALL_FIELDS        ((IOC_NET_HEADER_FIELD_USER_DEFINED_SRCPORT << 2) - 1)
+
+#define IOC_NET_HEADER_FIELD_PAYLOAD_BUFFER                 (1)
+#define IOC_NET_HEADER_FIELD_PAYLOAD_SIZE                   (IOC_NET_HEADER_FIELD_PAYLOAD_BUFFER << 1)
+#define IOC_NET_HEADER_FIELD_MAX_FRM_SIZE                   (IOC_NET_HEADER_FIELD_PAYLOAD_BUFFER << 2)
+#define IOC_NET_HEADER_FIELD_MIN_FRM_SIZE                   (IOC_NET_HEADER_FIELD_PAYLOAD_BUFFER << 3)
+#define IOC_NET_HEADER_FIELD_PAYLOAD_TYPE                   (IOC_NET_HEADER_FIELD_PAYLOAD_BUFFER << 4)
+#define IOC_NET_HEADER_FIELD_FRAME_SIZE                     (IOC_NET_HEADER_FIELD_PAYLOAD_BUFFER << 5)
+#define IOC_NET_HEADER_FIELD_PAYLOAD_ALL_FIELDS             ((IOC_NET_HEADER_FIELD_PAYLOAD_BUFFER << 6) - 1)
+
+
+typedef uint8_t ioc_header_field_gre_t;
+
+#define IOC_NET_HEADER_FIELD_GRE_TYPE                       (1)
+#define IOC_NET_HEADER_FIELD_GRE_ALL_FIELDS                 ((IOC_NET_HEADER_FIELD_GRE_TYPE << 1) - 1)
+
+
+typedef uint8_t ioc_header_field_minencap_t;
+
+#define IOC_NET_HEADER_FIELD_MINENCAP_SRC_IP                (1)
+#define IOC_NET_HEADER_FIELD_MINENCAP_DST_IP                (IOC_NET_HEADER_FIELD_MINENCAP_SRC_IP << 1)
+#define IOC_NET_HEADER_FIELD_MINENCAP_TYPE                  (IOC_NET_HEADER_FIELD_MINENCAP_SRC_IP << 2)
+#define IOC_NET_HEADER_FIELD_MINENCAP_ALL_FIELDS            ((IOC_NET_HEADER_FIELD_MINENCAP_SRC_IP << 3) - 1)
+
+
+typedef uint8_t ioc_header_field_ipsec_ah_t;
+
+#define IOC_NET_HEADER_FIELD_IPSEC_AH_SPI                   (1)
+#define IOC_NET_HEADER_FIELD_IPSEC_AH_NH                    (IOC_NET_HEADER_FIELD_IPSEC_AH_SPI << 1)
+#define IOC_NET_HEADER_FIELD_IPSEC_AH_ALL_FIELDS            ((IOC_NET_HEADER_FIELD_IPSEC_AH_SPI << 2) - 1)
+
+
+typedef uint8_t ioc_header_field_ipsec_esp_t;
+
+#define IOC_NET_HEADER_FIELD_IPSEC_ESP_SPI                  (1)
+#define IOC_NET_HEADER_FIELD_IPSEC_ESP_SEQUENCE_NUM         (IOC_NET_HEADER_FIELD_IPSEC_ESP_SPI << 1)
+#define IOC_NET_HEADER_FIELD_IPSEC_ESP_ALL_FIELDS           ((IOC_NET_HEADER_FIELD_IPSEC_ESP_SPI << 2) - 1)
+
+#define IOC_NET_HEADER_FIELD_IPSEC_ESP_SPI_SIZE             4
+
+
+typedef uint8_t ioc_header_field_mpls_t;
+
+#define IOC_NET_HEADER_FIELD_MPLS_LABEL_STACK               (1)
+#define IOC_NET_HEADER_FIELD_MPLS_LABEL_STACK_ALL_FIELDS    ((IOC_NET_HEADER_FIELD_MPLS_LABEL_STACK << 1) - 1)
+
+
+typedef uint8_t ioc_header_field_macsec_t;
+
+#define IOC_NET_HEADER_FIELD_MACSEC_SECTAG                  (1)
+#define IOC_NET_HEADER_FIELD_MACSEC_ALL_FIELDS              ((IOC_NET_HEADER_FIELD_MACSEC_SECTAG << 1) - 1)
+
+
+typedef enum {
+    e_IOC_NET_HEADER_TYPE_NONE = 0,
+    e_IOC_NET_HEADER_TYPE_PAYLOAD,
+    e_IOC_NET_HEADER_TYPE_ETH,
+    e_IOC_NET_HEADER_TYPE_VLAN,
+    e_IOC_NET_HEADER_TYPE_IPv4,
+    e_IOC_NET_HEADER_TYPE_IPv6,
+    e_IOC_NET_HEADER_TYPE_IP,
+    e_IOC_NET_HEADER_TYPE_TCP,
+    e_IOC_NET_HEADER_TYPE_UDP,
+    e_IOC_NET_HEADER_TYPE_UDP_LITE,
+    e_IOC_NET_HEADER_TYPE_IPHC,
+    e_IOC_NET_HEADER_TYPE_SCTP,
+    e_IOC_NET_HEADER_TYPE_SCTP_CHUNK_DATA,
+    e_IOC_NET_HEADER_TYPE_PPPoE,
+    e_IOC_NET_HEADER_TYPE_PPP,
+    e_IOC_NET_HEADER_TYPE_PPPMUX,
+    e_IOC_NET_HEADER_TYPE_PPPMUX_SUBFRAME,
+    e_IOC_NET_HEADER_TYPE_L2TPv2,
+    e_IOC_NET_HEADER_TYPE_L2TPv3_CTRL,
+    e_IOC_NET_HEADER_TYPE_L2TPv3_SESS,
+    e_IOC_NET_HEADER_TYPE_LLC,
+    e_IOC_NET_HEADER_TYPE_LLC_SNAP,
+    e_IOC_NET_HEADER_TYPE_NLPID,
+    e_IOC_NET_HEADER_TYPE_SNAP,
+    e_IOC_NET_HEADER_TYPE_MPLS,
+    e_IOC_NET_HEADER_TYPE_IPSEC_AH,
+    e_IOC_NET_HEADER_TYPE_IPSEC_ESP,
+    e_IOC_NET_HEADER_TYPE_UDP_ENCAP_ESP, /* RFC 3948 */
+    e_IOC_NET_HEADER_TYPE_MACSEC,
+    e_IOC_NET_HEADER_TYPE_GRE,
+    e_IOC_NET_HEADER_TYPE_MINENCAP,
+    e_IOC_NET_HEADER_TYPE_DCCP,
+    e_IOC_NET_HEADER_TYPE_ICMP,
+    e_IOC_NET_HEADER_TYPE_IGMP,
+    e_IOC_NET_HEADER_TYPE_ARP,
+    e_IOC_NET_HEADER_TYPE_CAPWAP,
+    e_IOC_NET_HEADER_TYPE_CAPWAP_DTLS,
+    e_IOC_NET_HEADER_TYPE_RFC2684,
+    e_IOC_NET_HEADER_TYPE_USER_DEFINED_L2,
+    e_IOC_NET_HEADER_TYPE_USER_DEFINED_L3,
+    e_IOC_NET_HEADER_TYPE_USER_DEFINED_L4,
+    e_IOC_NET_HEADER_TYPE_USER_DEFINED_SHIM1,
+    e_IOC_NET_HEADER_TYPE_USER_DEFINED_SHIM2,
+    e_IOC_NET_MAX_HEADER_TYPE_COUNT
+} ioc_net_header_type;
+
+
+#endif /* __NET_IOCTLS_H */
diff --git a/include/uapi/linux/fsl_mc.h b/include/uapi/linux/fsl_mc.h
new file mode 100644
index 000000000..4989c1bed
--- /dev/null
+++ b/include/uapi/linux/fsl_mc.h
@@ -0,0 +1,34 @@
+/* SPDX-License-Identifier: GPL-2.0 WITH Linux-syscall-note */
+/*
+ * Management Complex (MC) userspace public interface
+ *
+ * Copyright 2018 NXP
+ *
+ */
+#ifndef _UAPI_FSL_MC_H_
+#define _UAPI_FSL_MC_H_
+
+#include <linux/types.h>
+
+#define MC_CMD_NUM_OF_PARAMS	7
+
+/**
+ * struct fsl_mc_command - Management Complex (MC) command structure
+ * @header: MC command header
+ * @params: MC command parameters
+ *
+ * Used by FSL_MC_SEND_MC_COMMAND
+ */
+struct fsl_mc_command {
+	__le64 header;
+	__le64 params[MC_CMD_NUM_OF_PARAMS];
+};
+
+#define FSL_MC_SEND_CMD_IOCTL_TYPE	'R'
+#define FSL_MC_SEND_CMD_IOCTL_SEQ	0xE0
+
+#define FSL_MC_SEND_MC_COMMAND \
+	_IOWR(FSL_MC_SEND_CMD_IOCTL_TYPE, FSL_MC_SEND_CMD_IOCTL_SEQ, \
+	struct fsl_mc_command)
+
+#endif /* _UAPI_FSL_MC_H_ */
diff --git a/include/uapi/linux/hantrodec.h b/include/uapi/linux/hantrodec.h
new file mode 100644
index 000000000..4add50e85
--- /dev/null
+++ b/include/uapi/linux/hantrodec.h
@@ -0,0 +1,93 @@
+/*****************************************************************************
+*
+*    The GPL License (GPL)
+*
+*    Copyright (c) 2015-2017, VeriSilicon Inc.
+*    Copyright (c) 2011-2014, Google Inc.
+*
+*    This program is free software; you can redistribute it and/or
+*    modify it under the terms of the GNU General Public License
+*    as published by the Free Software Foundation; either version 2
+*    of the License, or (at your option) any later version.
+*
+*    This program is distributed in the hope that it will be useful,
+*    but WITHOUT ANY WARRANTY; without even the implied warranty of
+*    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+*    GNU General Public License for more details.
+*
+*    You should have received a copy of the GNU General Public License
+*    along with this program; if not, write to the Free Software Foundation,
+*    Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
+*
+*****************************************************************************/
+
+#ifndef _UAPI_HANTRODEC_H_
+#define _UAPI_HANTRODEC_H_
+#include <linux/ioctl.h>
+#include <linux/types.h>
+
+#undef PDEBUG
+#ifdef HANTRODEC_DEBUG
+#  ifdef __KERNEL__
+#    define PDEBUG(fmt, args...) pr_info("hantrodec: " fmt, ## args)
+#  else
+#    define PDEBUG(fmt, args...) fprintf(stderr, fmt, ## args)
+#  endif
+#else
+#  define PDEBUG(fmt, args...)
+#endif
+
+struct core_desc {
+	__u32 id; /* id of the Core */
+	__u32 *regs; /* pointer to user registers */
+	__u32 size; /* size of register space */
+};
+
+/* Use 'k' as magic number */
+#define HANTRODEC_IOC_MAGIC  'k'
+
+/*
+ * S means "Set" through a ptr,
+ * T means "Tell" directly with the argument value
+ * G means "Get": reply by setting through a pointer
+ * Q means "Query": response is on the return value
+ * X means "eXchange": G and S atomically
+ * H means "sHift": T and Q atomically
+ */
+
+#define HANTRODEC_PP_INSTANCE       _IO(HANTRODEC_IOC_MAGIC, 1)
+#define HANTRODEC_HW_PERFORMANCE    _IO(HANTRODEC_IOC_MAGIC, 2)
+#define HANTRODEC_IOCGHWOFFSET      _IOR(HANTRODEC_IOC_MAGIC,  3, unsigned long *)
+#define HANTRODEC_IOCGHWIOSIZE      _IOR(HANTRODEC_IOC_MAGIC,  4, unsigned int *)
+
+#define HANTRODEC_IOC_CLI           _IO(HANTRODEC_IOC_MAGIC,  5)
+#define HANTRODEC_IOC_STI           _IO(HANTRODEC_IOC_MAGIC,  6)
+#define HANTRODEC_IOC_MC_OFFSETS    _IOR(HANTRODEC_IOC_MAGIC, 7, unsigned long *)
+#define HANTRODEC_IOC_MC_CORES      _IOR(HANTRODEC_IOC_MAGIC, 8, unsigned int *)
+
+
+#define HANTRODEC_IOCS_DEC_PUSH_REG  _IOW(HANTRODEC_IOC_MAGIC, 9, struct core_desc *)
+#define HANTRODEC_IOCS_PP_PUSH_REG   _IOW(HANTRODEC_IOC_MAGIC, 10, struct core_desc *)
+
+#define HANTRODEC_IOCH_DEC_RESERVE   _IO(HANTRODEC_IOC_MAGIC, 11)
+#define HANTRODEC_IOCT_DEC_RELEASE   _IO(HANTRODEC_IOC_MAGIC, 12)
+#define HANTRODEC_IOCQ_PP_RESERVE    _IO(HANTRODEC_IOC_MAGIC, 13)
+#define HANTRODEC_IOCT_PP_RELEASE    _IO(HANTRODEC_IOC_MAGIC, 14)
+
+#define HANTRODEC_IOCX_DEC_WAIT      _IOWR(HANTRODEC_IOC_MAGIC, 15, struct core_desc *)
+#define HANTRODEC_IOCX_PP_WAIT       _IOWR(HANTRODEC_IOC_MAGIC, 16, struct core_desc *)
+
+#define HANTRODEC_IOCS_DEC_PULL_REG  _IOWR(HANTRODEC_IOC_MAGIC, 17, struct core_desc *)
+#define HANTRODEC_IOCS_PP_PULL_REG   _IOWR(HANTRODEC_IOC_MAGIC, 18, struct core_desc *)
+
+#define HANTRODEC_IOCG_CORE_WAIT     _IOR(HANTRODEC_IOC_MAGIC, 19, int *)
+
+#define HANTRODEC_IOX_ASIC_ID        _IOWR(HANTRODEC_IOC_MAGIC, 20, __u32 *)
+
+#define HANTRODEC_IOCG_CORE_ID       _IO(HANTRODEC_IOC_MAGIC, 21)
+
+#define HANTRODEC_DEBUG_STATUS       _IO(HANTRODEC_IOC_MAGIC, 29)
+
+#define HANTRODEC_IOC_MAXNR 29
+
+#endif /* !_UAPI_HANTRODEC_H_ */
diff --git a/include/uapi/linux/hx280enc.h b/include/uapi/linux/hx280enc.h
new file mode 100755
index 000000000..bc52bf1b0
--- /dev/null
+++ b/include/uapi/linux/hx280enc.h
@@ -0,0 +1,92 @@
+ /*****************************************************************************
+ * Encoder device driver (kernel module header)
+ *
+ * Copyright (C) 2012 Google Finland Oy.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+ *
+--------------------------------------------------------------------------------
+--
+--  Abstract : 6280/7280/8270/8290/H1 Encoder device driver (kernel module)
+--
+*****************************************************************************/
+#ifndef _UAPI_HX280ENC_H_
+#define _UAPI_HX280ENC_H_
+#include <linux/ioctl.h>    /* needed for the _IOW etc stuff used later */
+#include <linux/types.h>
+
+/*
+ * Macros to help debugging
+ */
+
+#undef PDEBUG   /* undef it, just in case */
+#ifdef HX280ENC_DEBUG
+#  ifdef __KERNEL__
+    /* This one if debugging is on, and kernel space */
+#    define PDEBUG(fmt, args...) printk(KERN_INFO "hmp4e: " fmt, ## args)
+#  else
+    /* This one for user space */
+#    define PDEBUG(fmt, args...) printf(__FILE__ ":%d: " fmt, __LINE__, ## args)
+#  endif
+#else
+#  define PDEBUG(fmt, args...)  /* not debugging: nothing */
+#endif
+
+struct enc_regs_buffer {
+	__u32 core_id;
+	__u32 *regs;
+	__u32 offset;
+	__u32 size;
+	__u32 *reserved;
+};
+
+/*
+ * Ioctl definitions
+ */
+
+/* Use 'k' as magic number */
+#define HX280ENC_IOC_MAGIC  'k'
+/*
+ * S means "Set" through a ptr,
+ * T means "Tell" directly with the argument value
+ * G means "Get": reply by setting through a pointer
+ * Q means "Query": response is on the return value
+ * X means "eXchange": G and S atomically
+ * H means "sHift": T and Q atomically
+ */
+ /*
+  * #define HX280ENC_IOCGBUFBUSADDRESS _IOR(HX280ENC_IOC_MAGIC,  1, unsigned long *)
+  * #define HX280ENC_IOCGBUFSIZE       _IOR(HX280ENC_IOC_MAGIC,  2, unsigned int *)
+  */
+#define HX280ENC_IOCGHWOFFSET      _IOR(HX280ENC_IOC_MAGIC,  3, unsigned long *)
+#define HX280ENC_IOCGHWIOSIZE      _IOR(HX280ENC_IOC_MAGIC,  4, unsigned int *)
+#define HX280ENC_IOC_CLI           _IO(HX280ENC_IOC_MAGIC,  5)
+#define HX280ENC_IOC_STI           _IO(HX280ENC_IOC_MAGIC,  6)
+#define HX280ENC_IOCXVIRT2BUS      _IOWR(HX280ENC_IOC_MAGIC,  7, unsigned long *)
+
+#define HX280ENC_IOCHARDRESET      _IO(HX280ENC_IOC_MAGIC, 8)   /* debugging tool */
+#define HX280ENC_IOCGSRAMOFFSET    _IOR(HX280ENC_IOC_MAGIC,  9, unsigned long *)
+#define HX280ENC_IOCGSRAMEIOSIZE    _IOR(HX280ENC_IOC_MAGIC,  10, unsigned int *)
+
+#define HX280ENC_IOCH_ENC_RESERVE   _IOR(HX280ENC_IOC_MAGIC, 11, unsigned int *)
+#define HX280ENC_IOCH_ENC_RELEASE   _IOR(HX280ENC_IOC_MAGIC, 12, unsigned int *)
+#define HX280ENC_IOCG_CORE_WAIT     _IOR(HX280ENC_IOC_MAGIC, 13, unsigned int *)
+
+#define HX280ENC_IOC_WRITE_REGS     _IOW(HX280ENC_IOC_MAGIC, 14, struct enc_regs_buffer *)
+#define HX280ENC_IOC_READ_REGS      _IOR(HX280ENC_IOC_MAGIC, 15, struct enc_regs_buffer *)
+
+#define HX280ENC_IOC_MAXNR 30
+
+#endif /* !_UAPI_HX280ENC_H_ */
diff --git a/include/uapi/linux/imx_vpu.h b/include/uapi/linux/imx_vpu.h
new file mode 100755
index 000000000..b2c36852b
--- /dev/null
+++ b/include/uapi/linux/imx_vpu.h
@@ -0,0 +1,112 @@
+/* SPDX-License-Identifier: GPL-2.0 WITH Linux-syscall-note */
+/*
+ * Copyright 2018-2020 NXP
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+#ifndef _UAPI__LINUX_IMX_VPU_H
+#define _UAPI__LINUX_IMX_VPU_H
+
+#include <linux/videodev2.h>
+#include <linux/v4l2-controls.h>
+
+/*imx v4l2 controls & extension controls*/
+
+//ctrls & extension ctrls definitions
+#define V4L2_CID_NON_FRAME		(V4L2_CID_USER_IMX_BASE)
+#define V4L2_CID_DIS_REORDER		(V4L2_CID_USER_IMX_BASE + 1)
+#define V4L2_CID_ROI_COUNT		(V4L2_CID_USER_IMX_BASE + 2)
+#define V4L2_CID_ROI			(V4L2_CID_USER_IMX_BASE + 3)
+#define V4L2_CID_IPCM_COUNT		(V4L2_CID_USER_IMX_BASE + 4)
+#define V4L2_CID_IPCM			(V4L2_CID_USER_IMX_BASE + 5)
+#define V4L2_CID_HDR10META		(V4L2_CID_USER_IMX_BASE + 6)
+#define V4L2_CID_SECUREMODE		(V4L2_CID_USER_IMX_BASE + 7)
+#define V4L2_CID_SC_ENABLE		(V4L2_CID_USER_IMX_BASE + 8)
+
+#define V4L2_MAX_ROI_REGIONS		8
+struct v4l2_enc_roi_param {
+	struct v4l2_rect rect;
+	__u32 enable;
+	__s32 qp_delta;
+	__u32 reserved[2];
+};
+
+struct v4l2_enc_roi_params {
+	__u32 num_roi_regions;
+	struct v4l2_enc_roi_param roi_params[V4L2_MAX_ROI_REGIONS];
+	__u32 config_store;
+	__u32 reserved[2];
+};
+
+#define V4L2_MAX_IPCM_REGIONS		2
+struct v4l2_enc_ipcm_param {
+	struct v4l2_rect rect;
+	__u32 enable;
+	__u32 reserved[2];
+};
+struct v4l2_enc_ipcm_params {
+	__u32 num_ipcm_regions;
+	struct v4l2_enc_ipcm_param ipcm_params[V4L2_MAX_IPCM_REGIONS];
+	__u32 config_store;
+	__u32 reserved[2];
+};
+
+struct v4l2_hdr10_meta {
+	__u32 hasHdr10Meta;
+	__u32 redPrimary[2];
+	__u32 greenPrimary[2];
+	__u32 bluePrimary[2];
+	__u32 whitePoint[2];
+	__u32 maxMasteringLuminance;
+	__u32 minMasteringLuminance;
+	__u32 maxContentLightLevel;
+	__u32 maxFrameAverageLightLevel;
+};
+
+/*imx v4l2 command*/
+#define V4L2_DEC_CMD_IMX_BASE		(0x08000000)
+#define V4L2_DEC_CMD_RESET		(V4L2_DEC_CMD_IMX_BASE + 1)
+
+/*imx v4l2 event*/
+//error happened in dec/enc
+#define V4L2_EVENT_CODEC_ERROR		(V4L2_EVENT_PRIVATE_START + 1)
+//frame loss in dec/enc
+#define V4L2_EVENT_SKIP					(V4L2_EVENT_PRIVATE_START + 2)
+//crop area change in dec, not reso change
+#define V4L2_EVENT_CROPCHANGE			(V4L2_EVENT_PRIVATE_START + 3)
+//some options can't be handled by codec, so might be ignored or updated. But codec could go on.
+#define V4L2_EVENT_INVALID_OPTION		(V4L2_EVENT_PRIVATE_START + 4)
+
+/*imx v4l2 warning msg, attached with event V4L2_EVENT_INVALID_OPTION*/
+enum {
+	UNKONW_WARNING = -1,		//not known warning type
+	RIOREGION_NOTALLOW,		//(part of)roi region can not work with media setting and be ignored by enc
+	IPCMREGION_NOTALLOW,		//(part of)ipcm region can not work with media setting and be ignored by enc
+	LEVEL_UPDATED,				//current level cant't work with media setting and be updated by enc
+};
+
+/* imx v4l2 formats */
+/*raw formats*/
+#define V4L2_PIX_FMT_BGR565		v4l2_fourcc('B', 'G', 'R', 'P') /* 16  BGR-5-6-5     */
+#define V4L2_PIX_FMT_NV12X			v4l2_fourcc('N', 'V', 'X', '2') /* Y/CbCr 4:2:0 for 10bit  */
+#define V4L2_PIX_FMT_DTRC			v4l2_fourcc('D', 'T', 'R', 'C') /* 8bit tile output, uncompressed */
+#define V4L2_PIX_FMT_P010			v4l2_fourcc('P', '0', '1', '0')	/*ms p010, data stored in upper 10 bits of 16 */
+#define V4L2_PIX_FMT_TILEX			v4l2_fourcc('D', 'T', 'R', 'X') /* 10 bit tile output, uncompressed */
+#define V4L2_PIX_FMT_RFC			v4l2_fourcc('R', 'F', 'C', '0') /* 8bit tile output, with rfc*/
+#define V4L2_PIX_FMT_RFCX			v4l2_fourcc('R', 'F', 'C', 'X') /* 10 bit tile output, with rfc */
+#define V4L2_PIX_FMT_411SP			v4l2_fourcc('4', '1', 'S', 'P') /* YUV 411 Semi planar */
+
+/*codec format*/
+#define V4L2_PIX_FMT_AV1			v4l2_fourcc('A', 'V', '1', '0')	/* av1 */
+#define V4L2_PIX_FMT_RV				v4l2_fourcc('R', 'V', '0', '0')	/* rv */
+#define V4L2_PIX_FMT_AVS			v4l2_fourcc('A', 'V', 'S', '0')	/* avs */
+/*codec formats*/
+#endif	//#ifndef _UAPI__LINUX_IMX_VPU_H
+
diff --git a/include/uapi/linux/ipu.h b/include/uapi/linux/ipu.h
new file mode 100644
index 000000000..c92f292bc
--- /dev/null
+++ b/include/uapi/linux/ipu.h
@@ -0,0 +1,293 @@
+/*
+ * Copyright (C) 2013-2015 Freescale Semiconductor, Inc. All Rights Reserved
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+/*!
+ * @defgroup IPU MXC Image Processing Unit (IPU) Driver
+ */
+/*!
+ * @file uapi/linux/ipu.h
+ *
+ * @brief This file contains the IPU driver API declarations.
+ *
+ * @ingroup IPU
+ */
+
+#ifndef __ASM_ARCH_IPU_H__
+#define __ASM_ARCH_IPU_H__
+
+#include <linux/types.h>
+#include <linux/videodev2.h>
+
+#ifndef __KERNEL__
+#ifndef __cplusplus
+typedef unsigned char bool;
+#endif
+#define irqreturn_t int
+#define dma_addr_t int
+#define uint32_t unsigned int
+#define uint16_t unsigned short
+#define uint8_t unsigned char
+#define u32 unsigned int
+#define u8 unsigned char
+#define __u32 u32
+#endif
+
+/*!
+ * Enumeration of IPU rotation modes
+ */
+typedef enum {
+	/* Note the enum values correspond to BAM value */
+	IPU_ROTATE_NONE = 0,
+	IPU_ROTATE_VERT_FLIP = 1,
+	IPU_ROTATE_HORIZ_FLIP = 2,
+	IPU_ROTATE_180 = 3,
+	IPU_ROTATE_90_RIGHT = 4,
+	IPU_ROTATE_90_RIGHT_VFLIP = 5,
+	IPU_ROTATE_90_RIGHT_HFLIP = 6,
+	IPU_ROTATE_90_LEFT = 7,
+} ipu_rotate_mode_t;
+
+/*!
+ * Enumeration of VDI MOTION select
+ */
+typedef enum {
+	MED_MOTION = 0,
+	LOW_MOTION = 1,
+	HIGH_MOTION = 2,
+} ipu_motion_sel;
+
+/*!
+ * Enumeration of DI ports for ADC.
+ */
+typedef enum {
+	DISP0,
+	DISP1,
+	DISP2,
+	DISP3
+} display_port_t;
+
+/*  IPU Pixel format definitions */
+/*  Four-character-code (FOURCC) */
+#define fourcc(a, b, c, d)\
+	 (((__u32)(a)<<0)|((__u32)(b)<<8)|((__u32)(c)<<16)|((__u32)(d)<<24))
+
+/*!
+ * @name IPU Pixel Formats
+ *
+ * Pixel formats are defined with ASCII FOURCC code. The pixel format codes are
+ * the same used by V4L2 API.
+ */
+
+/*! @{ */
+/*! @name GPU Tile Formats */
+/*! @{ */
+#define IPU_PIX_FMT_GPU32_SB_ST  fourcc('5', 'P', '4', 'S') /*!< 32bit split buf 4x4 standard */
+#define IPU_PIX_FMT_GPU32_SB_SRT fourcc('5', 'P', '4', 'R') /*!< 32bit split buf 4x4 super */
+#define IPU_PIX_FMT_GPU32_ST     fourcc('5', 'I', '4', 'S') /*!< 32bit single buf 4x4 standard */
+#define IPU_PIX_FMT_GPU32_SRT    fourcc('5', 'I', '4', 'R') /*!< 32bit single buf 4x4 super */
+#define IPU_PIX_FMT_GPU16_SB_ST  fourcc('4', 'P', '8', 'S') /*!< 16bit split buf 8x4 standard */
+#define IPU_PIX_FMT_GPU16_SB_SRT fourcc('4', 'P', '8', 'R') /*!< 16bit split buf 8x4 super */
+#define IPU_PIX_FMT_GPU16_ST     fourcc('4', 'I', '8', 'S') /*!< 16bit single buf 8x4 standard */
+#define IPU_PIX_FMT_GPU16_SRT    fourcc('4', 'I', '8', 'R') /*!< 16bit single buf 8x4 super */
+
+/*! @{ */
+/*! @name Generic or Raw Data Formats */
+/*! @{ */
+#define IPU_PIX_FMT_GENERIC fourcc('I', 'P', 'U', '0')	/*!< IPU Generic Data */
+#define IPU_PIX_FMT_GENERIC_32 fourcc('I', 'P', 'U', '1')	/*!< IPU Generic Data */
+#define IPU_PIX_FMT_GENERIC_16 fourcc('I', 'P', 'U', '2')	/*!< IPU Generic Data */
+#define IPU_PIX_FMT_LVDS666 fourcc('L', 'V', 'D', '6')	/*!< IPU Generic Data */
+#define IPU_PIX_FMT_LVDS888 fourcc('L', 'V', 'D', '8')	/*!< IPU Generic Data */
+/*! @} */
+/*! @name RGB Formats */
+/*! @{ */
+#define IPU_PIX_FMT_RGB332  fourcc('R', 'G', 'B', '1')	/*!<  8  RGB-3-3-2    */
+#define IPU_PIX_FMT_RGB555  fourcc('R', 'G', 'B', 'O')	/*!< 16  RGB-5-5-5    */
+#define IPU_PIX_FMT_RGB565  fourcc('R', 'G', 'B', 'P')	/*!< 1 6  RGB-5-6-5   */
+#define IPU_PIX_FMT_BGRA4444 fourcc('4', '4', '4', '4')	/*!< 16  RGBA-4-4-4-4 */
+#define IPU_PIX_FMT_BGRA5551 fourcc('5', '5', '5', '1')	/*!< 16  RGBA-5-5-5-1 */
+#define IPU_PIX_FMT_RGB666  fourcc('R', 'G', 'B', '6')	/*!< 18  RGB-6-6-6    */
+#define IPU_PIX_FMT_BGR666  fourcc('B', 'G', 'R', '6')	/*!< 18  BGR-6-6-6    */
+#define IPU_PIX_FMT_BGR24   fourcc('B', 'G', 'R', '3')	/*!< 24  BGR-8-8-8    */
+#define IPU_PIX_FMT_RGB24   fourcc('R', 'G', 'B', '3')	/*!< 24  RGB-8-8-8    */
+#define IPU_PIX_FMT_GBR24   fourcc('G', 'B', 'R', '3')	/*!< 24  GBR-8-8-8    */
+#define IPU_PIX_FMT_BGR32   fourcc('B', 'G', 'R', '4')	/*!< 32  BGR-8-8-8-8  */
+#define IPU_PIX_FMT_BGRA32  fourcc('B', 'G', 'R', 'A')	/*!< 32  BGR-8-8-8-8  */
+#define IPU_PIX_FMT_RGB32   fourcc('R', 'G', 'B', '4')	/*!< 32  RGB-8-8-8-8  */
+#define IPU_PIX_FMT_RGBA32  fourcc('R', 'G', 'B', 'A')	/*!< 32  RGB-8-8-8-8  */
+#define IPU_PIX_FMT_ABGR32  fourcc('A', 'B', 'G', 'R')	/*!< 32  ABGR-8-8-8-8 */
+/*! @} */
+/*! @name YUV Interleaved Formats */
+/*! @{ */
+#define IPU_PIX_FMT_YUYV    fourcc('Y', 'U', 'Y', 'V')	/*!< 16 YUV 4:2:2 */
+#define IPU_PIX_FMT_UYVY    fourcc('U', 'Y', 'V', 'Y')	/*!< 16 YUV 4:2:2 */
+#define IPU_PIX_FMT_YVYU    fourcc('Y', 'V', 'Y', 'U')  /*!< 16 YVYU 4:2:2 */
+#define IPU_PIX_FMT_VYUY    fourcc('V', 'Y', 'U', 'Y')  /*!< 16 VYYU 4:2:2 */
+#define IPU_PIX_FMT_Y41P    fourcc('Y', '4', '1', 'P')	/*!< 12 YUV 4:1:1 */
+#define IPU_PIX_FMT_YUV444  fourcc('Y', '4', '4', '4')	/*!< 24 YUV 4:4:4 */
+#define IPU_PIX_FMT_VYU444  fourcc('V', '4', '4', '4')	/*!< 24 VYU 4:4:4 */
+#define IPU_PIX_FMT_AYUV    fourcc('A', 'Y', 'U', 'V')	/*!< 32 AYUV 4:4:4:4 */
+/* two planes -- one Y, one Cb + Cr interleaved  */
+#define IPU_PIX_FMT_NV12    fourcc('N', 'V', '1', '2') /* 12  Y/CbCr 4:2:0  */
+#define PRE_PIX_FMT_NV21    fourcc('N', 'V', '2', '1') /* 12  Y/CbCr 4:2:0  */
+#define IPU_PIX_FMT_NV16    fourcc('N', 'V', '1', '6') /* 16  Y/CbCr 4:2:2  */
+#define PRE_PIX_FMT_NV61    fourcc('N', 'V', '6', '1') /* 16  Y/CbCr 4:2:2  */
+/* two planes -- 12  tiled Y/CbCr 4:2:0  */
+#define IPU_PIX_FMT_TILED_NV12    fourcc('T', 'N', 'V', 'P')
+#define IPU_PIX_FMT_TILED_NV12F   fourcc('T', 'N', 'V', 'F')
+
+/*! @} */
+/*! @name YUV Planar Formats */
+/*! @{ */
+#define IPU_PIX_FMT_GREY    fourcc('G', 'R', 'E', 'Y')	/*!< 8  Greyscale */
+#define IPU_PIX_FMT_YVU410P fourcc('Y', 'V', 'U', '9')	/*!< 9  YVU 4:1:0 */
+#define IPU_PIX_FMT_YUV410P fourcc('Y', 'U', 'V', '9')	/*!< 9  YUV 4:1:0 */
+#define IPU_PIX_FMT_YVU420P fourcc('Y', 'V', '1', '2')	/*!< 12 YVU 4:2:0 */
+#define IPU_PIX_FMT_YUV420P fourcc('I', '4', '2', '0')	/*!< 12 YUV 4:2:0 */
+#define IPU_PIX_FMT_YUV420P2 fourcc('Y', 'U', '1', '2')	/*!< 12 YUV 4:2:0 */
+#define IPU_PIX_FMT_YVU422P fourcc('Y', 'V', '1', '6')	/*!< 16 YVU 4:2:2 */
+#define IPU_PIX_FMT_YUV422P fourcc('4', '2', '2', 'P')	/*!< 16 YUV 4:2:2 */
+/* non-interleaved 4:4:4 */
+#define IPU_PIX_FMT_YUV444P fourcc('4', '4', '4', 'P')	/*!< 24 YUV 4:4:4 */
+/*! @} */
+#define IPU_PIX_FMT_TILED_NV12_MBALIGN	(16)
+#define TILED_NV12_FRAME_SIZE(w, h)	\
+		(ALIGN((w) * (h), SZ_4K) + ALIGN((w) * (h) / 2, SZ_4K))
+/* IPU device */
+typedef enum {
+	RGB_CS,
+	YUV_CS,
+	NULL_CS
+} cs_t;
+
+struct ipu_pos {
+	u32 x;
+	u32 y;
+};
+
+struct ipu_crop {
+	struct ipu_pos pos;
+	u32 w;
+	u32 h;
+};
+
+struct ipu_deinterlace {
+	bool	enable;
+	u8	motion; /*see ipu_motion_sel*/
+#define IPU_DEINTERLACE_FIELD_TOP	0
+#define IPU_DEINTERLACE_FIELD_BOTTOM	1
+#define IPU_DEINTERLACE_FIELD_MASK	\
+		(IPU_DEINTERLACE_FIELD_TOP | IPU_DEINTERLACE_FIELD_BOTTOM)
+	/* deinterlace frame rate double flags */
+#define IPU_DEINTERLACE_RATE_EN		0x80
+#define IPU_DEINTERLACE_RATE_FRAME1	0x40
+#define IPU_DEINTERLACE_RATE_MASK	\
+		(IPU_DEINTERLACE_RATE_EN | IPU_DEINTERLACE_RATE_FRAME1)
+#define IPU_DEINTERLACE_MAX_FRAME	2
+	u8	field_fmt;
+};
+
+struct ipu_input {
+	u32 width;
+	u32 height;
+	u32 format;
+	struct ipu_crop crop;
+	dma_addr_t paddr;
+
+	struct ipu_deinterlace deinterlace;
+	dma_addr_t paddr_n; /*valid when deinterlace enable*/
+};
+
+struct ipu_alpha {
+#define IPU_ALPHA_MODE_GLOBAL	0
+#define IPU_ALPHA_MODE_LOCAL	1
+	u8 mode;
+	u8 gvalue; /* 0~255 */
+	dma_addr_t loc_alp_paddr;
+};
+
+struct ipu_colorkey {
+	bool enable;
+	u32 value; /* RGB 24bit */
+};
+
+struct ipu_overlay {
+	u32	width;
+	u32	height;
+	u32	format;
+	struct ipu_crop crop;
+	struct ipu_alpha alpha;
+	struct ipu_colorkey colorkey;
+	dma_addr_t paddr;
+};
+
+struct ipu_output {
+	u32	width;
+	u32	height;
+	u32	format;
+	u8	rotate;
+	struct ipu_crop crop;
+	dma_addr_t paddr;
+};
+
+struct ipu_task {
+	struct ipu_input input;
+	struct ipu_output output;
+
+	bool overlay_en;
+	struct ipu_overlay overlay;
+
+#define IPU_TASK_PRIORITY_NORMAL 0
+#define IPU_TASK_PRIORITY_HIGH	1
+	u8	priority;
+
+#define	IPU_TASK_ID_ANY	0
+#define	IPU_TASK_ID_VF	1
+#define	IPU_TASK_ID_PP	2
+#define	IPU_TASK_ID_MAX 3
+	u8	task_id;
+
+	int	timeout;
+};
+
+enum {
+	IPU_CHECK_OK = 0,
+	IPU_CHECK_WARN_INPUT_OFFS_NOT8ALIGN = 0x1,
+	IPU_CHECK_WARN_OUTPUT_OFFS_NOT8ALIGN = 0x2,
+	IPU_CHECK_WARN_OVERLAY_OFFS_NOT8ALIGN = 0x4,
+	IPU_CHECK_ERR_MIN,
+	IPU_CHECK_ERR_INPUT_CROP,
+	IPU_CHECK_ERR_OUTPUT_CROP,
+	IPU_CHECK_ERR_OVERLAY_CROP,
+	IPU_CHECK_ERR_INPUT_OVER_LIMIT,
+	IPU_CHECK_ERR_OV_OUT_NO_FIT,
+	IPU_CHECK_ERR_OVERLAY_WITH_VDI,
+	IPU_CHECK_ERR_PROC_NO_NEED,
+	IPU_CHECK_ERR_SPLIT_INPUTW_OVER,
+	IPU_CHECK_ERR_SPLIT_INPUTH_OVER,
+	IPU_CHECK_ERR_SPLIT_OUTPUTW_OVER,
+	IPU_CHECK_ERR_SPLIT_OUTPUTH_OVER,
+	IPU_CHECK_ERR_SPLIT_WITH_ROT,
+	IPU_CHECK_ERR_NOT_SUPPORT,
+	IPU_CHECK_ERR_NOT16ALIGN,
+	IPU_CHECK_ERR_W_DOWNSIZE_OVER,
+	IPU_CHECK_ERR_H_DOWNSIZE_OVER,
+};
+
+/* IOCTL commands */
+#define IPU_CHECK_TASK		_IOWR('I', 0x1, struct ipu_task)
+#define IPU_QUEUE_TASK		_IOW('I', 0x2, struct ipu_task)
+#define IPU_ALLOC		_IOWR('I', 0x3, int)
+#define IPU_FREE		_IOW('I', 0x4, int)
+
+#endif
diff --git a/include/uapi/linux/isl29023.h b/include/uapi/linux/isl29023.h
new file mode 100644
index 000000000..9fddf4282
--- /dev/null
+++ b/include/uapi/linux/isl29023.h
@@ -0,0 +1,47 @@
+/*
+ * Copyright (C) 2011-2014 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+
+#ifndef __UAPI_LINUX_ISL29023_H__
+#define __UAPI_LINUX_ISL29023_H__
+
+#include <linux/types.h>
+
+#define ISL29023_PD_MODE	0x0
+#define ISL29023_ALS_ONCE_MODE	0x1
+#define ISL29023_IR_ONCE_MODE	0x2
+#define ISL29023_ALS_CONT_MODE	0x5
+#define ISL29023_IR_CONT_MODE	0x6
+
+#define ISL29023_INT_PERSISTS_1		0x0
+#define ISL29023_INT_PERSISTS_4		0x1
+#define ISL29023_INT_PERSISTS_8		0x2
+#define ISL29023_INT_PERSISTS_16	0x3
+
+#define ISL29023_RES_16		0x0
+#define ISL29023_RES_12		0x1
+#define ISL29023_RES_8		0x2
+#define ISL29023_RES_4		0x3
+
+#define ISL29023_RANGE_1K	0x0
+#define ISL29023_RANGE_4K	0x1
+#define ISL29023_RANGE_16K	0x2
+#define ISL29023_RANGE_64K	0x3
+
+#endif
diff --git a/include/uapi/linux/media-bus-format.h b/include/uapi/linux/media-bus-format.h
index 84fa53ffb..b9a8a3e61 100644
--- a/include/uapi/linux/media-bus-format.h
+++ b/include/uapi/linux/media-bus-format.h
@@ -63,6 +63,11 @@
 #define MEDIA_BUS_FMT_RGB101010_1X30		0x1018
 #define MEDIA_BUS_FMT_RGB121212_1X36		0x1019
 #define MEDIA_BUS_FMT_RGB161616_1X48		0x101a
+#define MEDIA_BUS_FMT_RGB888_1X30_PADLO		0x101b
+#define MEDIA_BUS_FMT_RGB666_1X30_PADLO		0x101c
+#define MEDIA_BUS_FMT_RGB101010_1X7X5_SPWG	0x101d
+#define MEDIA_BUS_FMT_RGB101010_1X7X5_JEIDA	0x101e
+#define MEDIA_BUS_FMT_RGB565_1X30_PADLO		0x101f
 
 /* YUV (including grey) - next is	0x202e */
 #define MEDIA_BUS_FMT_Y8_1X8			0x2001
diff --git a/include/uapi/linux/mxc_asrc.h b/include/uapi/linux/mxc_asrc.h
new file mode 100644
index 000000000..84ebb9e14
--- /dev/null
+++ b/include/uapi/linux/mxc_asrc.h
@@ -0,0 +1,166 @@
+/*
+ * Copyright 2008-2014 Freescale Semiconductor, Inc. All Rights Reserved.
+ *
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ *
+ * @file mxc_asrc.h
+ *
+ * @brief i.MX Asynchronous Sample Rate Converter
+ *
+ * @ingroup Audio
+ */
+
+#ifndef __MXC_ASRC_UAPI_H__
+#define __MXC_ASRC_UAPI_H__
+
+#define ASRC_IOC_MAGIC		'C'
+
+#define ASRC_REQ_PAIR		_IOWR(ASRC_IOC_MAGIC, 0, struct asrc_req)
+#define ASRC_CONFIG_PAIR	_IOWR(ASRC_IOC_MAGIC, 1, struct asrc_config)
+#define ASRC_RELEASE_PAIR	_IOW(ASRC_IOC_MAGIC, 2, enum asrc_pair_index)
+#define ASRC_CONVERT		_IOW(ASRC_IOC_MAGIC, 3, struct asrc_convert_buffer)
+#define ASRC_START_CONV		_IOW(ASRC_IOC_MAGIC, 4, enum asrc_pair_index)
+#define ASRC_STOP_CONV		_IOW(ASRC_IOC_MAGIC, 5, enum asrc_pair_index)
+#define ASRC_STATUS		_IOW(ASRC_IOC_MAGIC, 6, struct asrc_status_flags)
+#define ASRC_FLUSH		_IOW(ASRC_IOC_MAGIC, 7, enum asrc_pair_index)
+
+enum asrc_pair_index {
+	ASRC_INVALID_PAIR = -1,
+	ASRC_PAIR_A = 0,
+	ASRC_PAIR_B = 1,
+	ASRC_PAIR_C = 2,
+	ASRC_PAIR_D = 3,
+};
+
+enum asrc_inclk {
+	INCLK_NONE = 0x03,
+	INCLK_ESAI_RX = 0x00,
+	INCLK_SSI1_RX = 0x01,
+	INCLK_SSI2_RX = 0x02,
+	INCLK_SSI3_RX = 0x07,
+	INCLK_SPDIF_RX = 0x04,
+	INCLK_MLB_CLK = 0x05,
+	INCLK_PAD = 0x06,
+	INCLK_ESAI_TX = 0x08,
+	INCLK_SSI1_TX = 0x09,
+	INCLK_SSI2_TX = 0x0a,
+	INCLK_SSI3_TX = 0x0b,
+	INCLK_SPDIF_TX = 0x0c,
+	INCLK_ASRCK1_CLK = 0x0f,
+
+	/* clocks for imx8 */
+	INCLK_AUD_PLL_DIV_CLK0 = 0x10,
+	INCLK_AUD_PLL_DIV_CLK1 = 0x11,
+	INCLK_AUD_CLK0         = 0x12,
+	INCLK_AUD_CLK1         = 0x13,
+	INCLK_ESAI0_RX_CLK     = 0x14,
+	INCLK_ESAI0_TX_CLK     = 0x15,
+	INCLK_SPDIF0_RX        = 0x16,
+	INCLK_SPDIF1_RX        = 0x17,
+	INCLK_SAI0_RX_BCLK     = 0x18,
+	INCLK_SAI0_TX_BCLK     = 0x19,
+	INCLK_SAI1_RX_BCLK     = 0x1a,
+	INCLK_SAI1_TX_BCLK     = 0x1b,
+	INCLK_SAI2_RX_BCLK     = 0x1c,
+	INCLK_SAI3_RX_BCLK     = 0x1d,
+	INCLK_ASRC0_MUX_CLK    = 0x1e,
+
+	INCLK_ESAI1_RX_CLK     = 0x20,
+	INCLK_ESAI1_TX_CLK     = 0x21,
+	INCLK_SAI6_TX_BCLK     = 0x22,
+	INCLK_HDMI_RX_SAI0_RX_BCLK     = 0x24,
+	INCLK_HDMI_TX_SAI0_TX_BCLK     = 0x25,
+};
+
+enum asrc_outclk {
+	OUTCLK_NONE = 0x03,
+	OUTCLK_ESAI_TX = 0x00,
+	OUTCLK_SSI1_TX = 0x01,
+	OUTCLK_SSI2_TX = 0x02,
+	OUTCLK_SSI3_TX = 0x07,
+	OUTCLK_SPDIF_TX = 0x04,
+	OUTCLK_MLB_CLK = 0x05,
+	OUTCLK_PAD = 0x06,
+	OUTCLK_ESAI_RX = 0x08,
+	OUTCLK_SSI1_RX = 0x09,
+	OUTCLK_SSI2_RX = 0x0a,
+	OUTCLK_SSI3_RX = 0x0b,
+	OUTCLK_SPDIF_RX = 0x0c,
+	OUTCLK_ASRCK1_CLK = 0x0f,
+
+	/* clocks for imx8 */
+	OUTCLK_AUD_PLL_DIV_CLK0 = 0x10,
+	OUTCLK_AUD_PLL_DIV_CLK1 = 0x11,
+	OUTCLK_AUD_CLK0         = 0x12,
+	OUTCLK_AUD_CLK1         = 0x13,
+	OUTCLK_ESAI0_RX_CLK     = 0x14,
+	OUTCLK_ESAI0_TX_CLK     = 0x15,
+	OUTCLK_SPDIF0_RX        = 0x16,
+	OUTCLK_SPDIF1_RX        = 0x17,
+	OUTCLK_SAI0_RX_BCLK     = 0x18,
+	OUTCLK_SAI0_TX_BCLK     = 0x19,
+	OUTCLK_SAI1_RX_BCLK     = 0x1a,
+	OUTCLK_SAI1_TX_BCLK     = 0x1b,
+	OUTCLK_SAI2_RX_BCLK     = 0x1c,
+	OUTCLK_SAI3_RX_BCLK     = 0x1d,
+	OUTCLK_ASRCO_MUX_CLK    = 0x1e,
+
+	OUTCLK_ESAI1_RX_CLK     = 0x20,
+	OUTCLK_ESAI1_TX_CLK     = 0x21,
+	OUTCLK_SAI6_TX_BCLK     = 0x22,
+	OUTCLK_HDMI_RX_SAI0_RX_BCLK     = 0x24,
+	OUTCLK_HDMI_TX_SAI0_TX_BCLK     = 0x25,
+};
+
+struct asrc_config {
+	enum asrc_pair_index pair;
+	unsigned int channel_num;
+	unsigned int dma_buffer_size;
+	unsigned int input_sample_rate;
+	unsigned int output_sample_rate;
+	snd_pcm_format_t input_format;
+	snd_pcm_format_t output_format;
+	enum asrc_inclk inclk;
+	enum asrc_outclk outclk;
+};
+
+struct asrc_req {
+	unsigned int chn_num;
+	enum asrc_pair_index index;
+	uint64_t supported_in_format;
+	uint64_t supported_out_format;
+};
+
+struct asrc_querybuf {
+	unsigned int buffer_index;
+	unsigned int input_length;
+	unsigned int output_length;
+	unsigned long input_offset;
+	unsigned long output_offset;
+};
+
+struct asrc_convert_buffer {
+	void *input_buffer_vaddr;
+	void *output_buffer_vaddr;
+	unsigned int input_buffer_length;
+	unsigned int output_buffer_length;
+};
+
+struct asrc_status_flags {
+	enum asrc_pair_index index;
+	unsigned int overload_error;
+};
+
+enum asrc_error_status {
+	ASRC_TASK_Q_OVERLOAD		= 0x01,
+	ASRC_OUTPUT_TASK_OVERLOAD	= 0x02,
+	ASRC_INPUT_TASK_OVERLOAD	= 0x04,
+	ASRC_OUTPUT_BUFFER_OVERFLOW	= 0x08,
+	ASRC_INPUT_BUFFER_UNDERRUN	= 0x10,
+};
+#endif/* __MXC_ASRC_UAPI_H__ */
diff --git a/include/uapi/linux/mxc_dcic.h b/include/uapi/linux/mxc_dcic.h
new file mode 100644
index 000000000..83e3e2c68
--- /dev/null
+++ b/include/uapi/linux/mxc_dcic.h
@@ -0,0 +1,47 @@
+/*
+ * Copyright (C) 2014-2015 Freescale Semiconductor, Inc. All Rights Reserved
+ */
+
+/*
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+
+/*!
+ * @file uapi/linux/mxc_dcic.h
+ *
+ * @brief MXC DCIC private header file
+ *
+ * @ingroup MXC DCIC
+ */
+#ifndef __ASM_ARCH_MXC_DCIC_H__
+#define __ASM_ARCH_MXC_DCIC_H__
+
+#define DCIC_IOC_ALLOC_ROI_NUM	_IO('D', 10)
+#define DCIC_IOC_FREE_ROI_NUM	_IO('D', 11)
+#define DCIC_IOC_CONFIG_DCIC	_IO('D', 12)
+#define DCIC_IOC_CONFIG_ROI		_IO('D', 13)
+#define DCIC_IOC_GET_RESULT		_IO('D', 14)
+
+struct roi_params {
+	unsigned int roi_n;
+	unsigned int ref_sig;
+	unsigned int start_y;
+	unsigned int start_x;
+	unsigned int end_y;
+	unsigned int end_x;
+	char freeze;
+};
+
+#endif
diff --git a/include/uapi/linux/mxc_dsp.h b/include/uapi/linux/mxc_dsp.h
new file mode 100644
index 000000000..10c282f88
--- /dev/null
+++ b/include/uapi/linux/mxc_dsp.h
@@ -0,0 +1,153 @@
+/*
+ * Copyright 2018 NXP
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ *    this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ *    this list of conditions and the following disclaimer in the documentation
+ *    and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+ * THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef __MXC_DSP_UAPI_H__
+#define __MXC_DSP_UAPI_H__
+
+#define DSP_IOC_MAGIC		'H'
+#define DSP_CLIENT_REGISTER   _IOW(DSP_IOC_MAGIC, 0, unsigned int)
+#define DSP_CLIENT_UNREGISTER _IOW(DSP_IOC_MAGIC, 1, unsigned int)
+#define DSP_IPC_MSG_SEND      _IOW(DSP_IOC_MAGIC, 2, unsigned int)
+#define DSP_IPC_MSG_RECV      _IOW(DSP_IOC_MAGIC, 3, unsigned int)
+#define DSP_GET_SHMEM_INFO    _IOW(DSP_IOC_MAGIC, 4, unsigned int)
+#define DSP_LOAD_LIB          _IOW(DSP_IOC_MAGIC, 5, unsigned int)
+#define DSP_UNLOAD_LIB        _IOW(DSP_IOC_MAGIC, 6, unsigned int)
+
+
+#define CODEC_MP3_DEC		1
+#define CODEC_AAC_DEC		2
+#define CODEC_DAB_DEC		3
+#define CODEC_MP2_DEC		4
+#define CODEC_BSAC_DEC		5
+#define CODEC_DRM_DEC		6
+#define CODEC_SBC_DEC		7
+#define CODEC_SBC_ENC		8
+#define CODEC_PCM_DEC		9
+#define CODEC_DEMO_DEC		10
+
+#define RENDER_ESAI		0x10
+#define RENDER_SAI		0x11
+
+enum DSP_ERROR_TYPE {
+	XA_SUCCESS = 0,
+
+	XA_ERROR_STREAM,
+	XA_PARA_ERROR,
+	XA_INSUFFICIENT_MEM,
+	XA_ERR_UNKNOWN,
+	XA_PROFILE_NOT_SUPPORT,
+	XA_INIT_ERR,
+	XA_NO_OUTPUT,
+
+	XA_NOT_ENOUGH_DATA = 0x100,
+	XA_CAPIBILITY_CHANGE = 0x200,
+	XA_END_OF_STREAM = 0x300, /* no output */
+};
+
+/* Parameter type to Set /Get */
+enum DSP_ParaType {
+/* Set parmameters */
+/* common  */
+	XA_SAMPLERATE = 0,
+	XA_CHANNEL,
+	XA_FRAMED,        /* one whole frame input */
+	XA_DEPTH,
+	XA_CODEC_DATA,
+	XA_BITRATE,
+	XA_DOWNMIX_STEREO,
+	XA_STREAM_TYPE,
+	XA_CHAN_MAP_TABLE,
+	//UNIA_CHANNEL_MASK,
+	XA_TO_STEREO,
+
+/* dedicate for mp3 dec */
+	XA_MP3_DEC_CRC_CHECK = 0x120,
+	XA_MP3_DEC_MCH_ENABLE,
+	XA_MP3_DEC_NONSTD_STRM_SUPPORT,
+
+/* dedicate for bsac dec */
+	XA_BSAC_DEC_DECODELAYERS = 0x130,
+
+/* dedicate for aacplus dec */
+	XA_AACPLUS_DEC_BDOWNSAMPLE = 0x140,
+	XA_AACPLUS_DEC_BBITSTREAMDOWNMIX,
+	XA_AACPLUS_DEC_CHANROUTING,
+
+/* dedicate for dabplus dec */
+	XA_DABPLUS_DEC_BDOWNSAMPLE = 0x150,
+	XA_DABPLUS_DEC_BBITSTREAMDOWNMIX,
+	XA_DABPLUS_DEC_CHANROUTING,
+
+/* dedicate for sbc enc */
+	XA_SBC_ENC_SUBBANDS = 0x160,
+	XA_SBC_ENC_BLOCKS,
+	XA_SBC_ENC_SNR,
+	XA_SBC_ENC_BITPOOL,
+	XA_SBC_ENC_CHMODE,
+
+/* Get parmameters */
+	XA_CODEC_DESCRIPTION = 0x200,
+	XA_OUTPUT_PCM_FORMAT,
+	XA_CONSUMED_LENGTH,
+	XA_OUTBUF_ALLOC_SIZE,
+	XA_CONSUMED_CYCLES,
+
+};
+
+#define XA_STREAM_DABPLUS_BASE  0x30
+enum DSP_StreamType {
+    /* AAC/AACPLUS file format */
+	XA_STREAM_UNKNOWN = 0,
+	XA_STREAM_ADTS,
+	XA_STREAM_ADIF,
+	XA_STREAM_RAW,
+
+	XA_STREAM_LATM,
+	XA_STREAM_LATM_OUTOFBAND_CONFIG,
+	XA_STREAM_LOAS,
+
+    /* DABPLUS file format */
+	XA_STREAM_DABPLUS_RAW_SIDEINFO = XA_STREAM_DABPLUS_BASE,
+	XA_STREAM_DABPLUS,
+
+    /* BSAC file raw format */
+	XA_STREAM_BSAC_RAW,
+
+};
+
+/* sbc_enc-specific channel modes */
+enum DSP_SbcEncChmode {
+	XA_CHMODE_MONO =   0,
+	XA_CHMODE_DUAL =   1,
+	XA_CHMODE_STEREO = 2,
+	XA_CHMODE_JOINT =  3,
+};
+
+struct shmem_info {
+	unsigned int phys_addr;
+	unsigned int size;
+};
+
+#endif/* __MXC_DSP_UAPI_H__ */
diff --git a/include/uapi/linux/mxc_mlb.h b/include/uapi/linux/mxc_mlb.h
new file mode 100644
index 000000000..20ba5240e
--- /dev/null
+++ b/include/uapi/linux/mxc_mlb.h
@@ -0,0 +1,55 @@
+/*
+ * mxc_mlb.h
+ *
+ * Copyright 2008-2013 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+#ifndef _MXC_MLB_UAPI_H
+#define _MXC_MLB_UAPI_H
+
+/* define IOCTL command */
+#define MLB_DBG_RUNTIME		_IO('S', 0x09)
+#define MLB_SET_FPS		_IOW('S', 0x10, unsigned int)
+#define MLB_GET_VER		_IOR('S', 0x11, unsigned long)
+#define MLB_SET_DEVADDR		_IOR('S', 0x12, unsigned char)
+
+/*!
+ * set channel address for each logical channel
+ * the MSB 16bits is for tx channel, the left LSB is for rx channel
+ */
+#define MLB_CHAN_SETADDR	_IOW('S', 0x13, unsigned int)
+#define MLB_CHAN_STARTUP	_IO('S', 0x14)
+#define MLB_CHAN_SHUTDOWN	_IO('S', 0x15)
+#define MLB_CHAN_GETEVENT	_IOR('S', 0x16, unsigned long)
+
+#define MLB_SET_ISOC_BLKSIZE_188 _IO('S', 0x17)
+#define MLB_SET_ISOC_BLKSIZE_196 _IO('S', 0x18)
+#define MLB_SET_SYNC_QUAD	_IOW('S', 0x19, unsigned int)
+#define MLB_IRQ_ENABLE		_IO('S', 0x20)
+#define MLB_IRQ_DISABLE		_IO('S', 0x21)
+
+/*!
+ * MLB event define
+ */
+enum {
+	MLB_EVT_TX_PROTO_ERR_CUR = 1 << 0,
+	MLB_EVT_TX_BRK_DETECT_CUR = 1 << 1,
+	MLB_EVT_TX_PROTO_ERR_PREV = 1 << 8,
+	MLB_EVT_TX_BRK_DETECT_PREV = 1 << 9,
+	MLB_EVT_RX_PROTO_ERR_CUR = 1 << 16,
+	MLB_EVT_RX_BRK_DETECT_CUR = 1 << 17,
+	MLB_EVT_RX_PROTO_ERR_PREV = 1 << 24,
+	MLB_EVT_RX_BRK_DETECT_PREV = 1 << 25,
+};
+
+
+#endif				/* _MXC_MLB_H */
diff --git a/include/uapi/linux/mxc_sim_interface.h b/include/uapi/linux/mxc_sim_interface.h
new file mode 100644
index 000000000..9ac3c029a
--- /dev/null
+++ b/include/uapi/linux/mxc_sim_interface.h
@@ -0,0 +1,124 @@
+/*
+ * Copyright (C) 2015 Freescale Semiconductor, Inc. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+#ifndef UAPI_MXC_SIM_INTERFACE_H
+#define UAPI_MXC_SIM_INTERFACE_H
+
+#define SIM_ATR_LENGTH_MAX 32
+
+/* Raw ATR SIM_IOCTL_GET_ATR */
+typedef struct {
+	unsigned int size;/* length of ATR received */
+	unsigned char *atr_buffer;/* raw ATR string received */
+	int errval;/* The error vale reported to user space after completing ATR*/
+} sim_atr_t;
+
+/* ISO7816-3 protocols */
+#define SIM_PROTOCOL_T0  1
+#define SIM_PROTOCOL_T1  2
+
+/* Transfer types for SIM_IOCTL_XFER */
+#define SIM_XFER_TYPE_TPDU 1
+#define SIM_XFER_TYPE_PTS  2
+
+typedef struct {
+	unsigned int wwt;
+	unsigned int cwt;
+	unsigned int bwt;
+	unsigned int bgt;
+	unsigned int cgt;
+} sim_timing_t;
+
+/* Transfer data for SIM_IOCTL_XFER */
+typedef struct {
+	unsigned char *xmt_buffer;	/* transmit buffer pointer */
+	int xmt_length;/* transmit buffer length */
+	int timeout;/* transfer timeout in milliseconds */
+	int errval;/* The error vale reported to user space after completing transmitting*/
+} sim_xmt_t;
+
+typedef struct {
+	unsigned char *rcv_buffer;	/* receive buffer pointer */
+	int rcv_length;	/* receive buffer length */
+	int timeout;/* transfer timeout in milliseconds */
+	int errval;/* The error vale reported to user space after receiving*/
+} sim_rcv_t;
+
+typedef struct {
+	unsigned char di;
+	unsigned char fi;
+} sim_baud_t;
+
+/* Interface power states */
+#define SIM_POWER_OFF			(0)
+#define SIM_POWER_ON			(1)
+
+/* Return values for SIM_IOCTL_GET_PRESENSE */
+#define SIM_PRESENT_REMOVED		(0)
+#define SIM_PRESENT_DETECTED		(1)
+#define SIM_PRESENT_OPERATIONAL		(2)
+
+/* The error value */
+#define SIM_OK				(0)
+#define SIM_ERROR_CWT			(1 << 0)
+#define SIM_ERROR_BWT			(1 << 1)
+#define SIM_ERROR_PARITY		(1 << 2)
+#define SIM_ERROR_INVALID_TS		(1 << 3)
+#define SIM_ERROR_FRAME			(1 << 4)
+#define SIM_ERROR_ATR_TIMEROUT		(1 << 5)
+#define SIM_ERROR_NACK_THRESHOLD	(1 << 6)
+#define SIM_ERROR_BGT			(1 << 7)
+#define SIM_ERROR_ATR_DELAY		(1 << 8)
+
+/* Return values for SIM_IOCTL_GET_ERROR */
+#define SIM_E_ACCESS			(1)
+#define SIM_E_TPDUSHORT			(2)
+#define SIM_E_PTSEMPTY			(3)
+#define SIM_E_INVALIDXFERTYPE		(4)
+#define SIM_E_INVALIDXMTLENGTH		(5)
+#define SIM_E_INVALIDRCVLENGTH		(6)
+#define SIM_E_NACK			(7)
+#define SIM_E_TIMEOUT			(8)
+#define SIM_E_NOCARD			(9)
+#define SIM_E_PARAM_FI_INVALID		(10)
+#define SIM_E_PARAM_DI_INVALID		(11)
+#define SIM_E_PARAM_FBYD_WITHFRACTION	(12)
+#define SIM_E_PARAM_FBYD_NOTDIVBY8OR12	(13)
+#define SIM_E_PARAM_DIVISOR_RANGE	(14)
+#define SIM_E_MALLOC			(15)
+#define SIM_E_IRQ			(16)
+#define SIM_E_POWERED_ON		(17)
+#define SIM_E_POWERED_OFF		(18)
+
+/* ioctl encodings */
+#define SIM_IOCTL_BASE			(0xc0)
+#define SIM_IOCTL_GET_PRESENSE		_IOR(SIM_IOCTL_BASE, 1, int)
+#define SIM_IOCTL_GET_ATR		_IOR(SIM_IOCTL_BASE, 2, sim_atr_t)
+#define SIM_IOCTL_XMT			_IOR(SIM_IOCTL_BASE, 3, sim_xmt_t)
+#define SIM_IOCTL_RCV			_IOR(SIM_IOCTL_BASE, 4, sim_rcv_t)
+#define SIM_IOCTL_ACTIVATE		_IO(SIM_IOCTL_BASE, 5)
+#define SIM_IOCTL_DEACTIVATE		_IO(SIM_IOCTL_BASE, 6)
+#define SIM_IOCTL_WARM_RESET		_IO(SIM_IOCTL_BASE, 7)
+#define SIM_IOCTL_COLD_RESET		_IO(SIM_IOCTL_BASE, 8)
+#define SIM_IOCTL_CARD_LOCK		_IO(SIM_IOCTL_BASE, 9)
+#define SIM_IOCTL_CARD_EJECT		_IO(SIM_IOCTL_BASE, 10)
+#define SIM_IOCTL_SET_PROTOCOL		_IOR(SIM_IOCTL_BASE, 11, unsigned int)
+#define SIM_IOCTL_SET_TIMING		_IOR(SIM_IOCTL_BASE, 12, sim_timing_t)
+#define SIM_IOCTL_SET_BAUD		_IOR(SIM_IOCTL_BASE, 13, sim_baud_t)
+#define SIM_IOCTL_WAIT			_IOR(SIM_IOCTL_BASE, 14, unsigned int)
+
+#endif
diff --git a/include/uapi/linux/mxc_v4l2.h b/include/uapi/linux/mxc_v4l2.h
new file mode 100644
index 000000000..f261b925a
--- /dev/null
+++ b/include/uapi/linux/mxc_v4l2.h
@@ -0,0 +1,73 @@
+/*
+ * Copyright (C) 2013-2015 Freescale Semiconductor, Inc. All Rights Reserved
+ */
+
+/*
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+
+/*!
+ * @file uapi/linux/mxc_v4l2.h
+ *
+ * @brief MXC V4L2 private header file
+ *
+ * @ingroup MXC V4L2
+ */
+
+#ifndef __ASM_ARCH_MXC_V4L2_H__
+#define __ASM_ARCH_MXC_V4L2_H__
+
+/*
+ * For IPUv1 and IPUv3, V4L2_CID_MXC_ROT means encoder ioctl ID.
+ * And V4L2_CID_MXC_VF_ROT is viewfinder ioctl ID only for IPUv1 and IPUv3.
+ */
+#define V4L2_CID_MXC_ROT		(V4L2_CID_PRIVATE_BASE + 0)
+#define V4L2_CID_MXC_FLASH		(V4L2_CID_PRIVATE_BASE + 1)
+#define V4L2_CID_MXC_VF_ROT		(V4L2_CID_PRIVATE_BASE + 2)
+#define V4L2_CID_MXC_MOTION		(V4L2_CID_PRIVATE_BASE + 3)
+#define V4L2_CID_MXC_SWITCH_CAM		(V4L2_CID_PRIVATE_BASE + 6)
+
+#define V4L2_MXC_ROTATE_NONE			0
+#define V4L2_MXC_ROTATE_VERT_FLIP		1
+#define V4L2_MXC_ROTATE_HORIZ_FLIP		2
+#define V4L2_MXC_ROTATE_180			3
+#define V4L2_MXC_ROTATE_90_RIGHT		4
+#define V4L2_MXC_ROTATE_90_RIGHT_VFLIP		5
+#define V4L2_MXC_ROTATE_90_RIGHT_HFLIP		6
+#define V4L2_MXC_ROTATE_90_LEFT			7
+
+struct v4l2_mxc_offset {
+	uint32_t u_offset;
+	uint32_t v_offset;
+};
+
+struct v4l2_mxc_dest_crop {
+	__u32			type;	/* enum v4l2_buf_type */
+	struct v4l2_mxc_offset   offset;
+};
+
+/*
+ * Private IOCTLs
+ *
+ * VIDIOC_S_INOUT_CROP: Set input stream crop size
+ * VIDIOC_G_INOUT_CROP: Get input stream crop size
+ */
+#define VIDIOC_S_INPUT_CROP \
+	_IOWR('V', BASE_VIDIOC_PRIVATE + 1, struct v4l2_crop)
+#define VIDIOC_G_INPUT_CROP \
+	_IOWR('V', BASE_VIDIOC_PRIVATE + 2, struct v4l2_crop)
+#define VIDIOC_S_DEST_CROP \
+	_IOWR('V', BASE_VIDIOC_PRIVATE + 3, struct v4l2_mxc_dest_crop)
+#endif
diff --git a/include/uapi/linux/mxcfb.h b/include/uapi/linux/mxcfb.h
new file mode 100644
index 000000000..3a9840907
--- /dev/null
+++ b/include/uapi/linux/mxcfb.h
@@ -0,0 +1,198 @@
+/*
+ * Copyright (C) 2013-2015 Freescale Semiconductor, Inc. All Rights Reserved
+ */
+
+/*
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+
+/*
+ * @file uapi/linux/mxcfb.h
+ *
+ * @brief Global header file for the MXC frame buffer
+ *
+ * @ingroup Framebuffer
+ */
+#ifndef __ASM_ARCH_MXCFB_H__
+#define __ASM_ARCH_MXCFB_H__
+
+#include <linux/fb.h>
+
+#define FB_SYNC_OE_LOW_ACT	0x80000000
+#define FB_SYNC_CLK_LAT_FALL	0x40000000
+#define FB_SYNC_DATA_INVERT	0x20000000
+#define FB_SYNC_CLK_IDLE_EN	0x10000000
+#define FB_SYNC_SHARP_MODE	0x08000000
+#define FB_SYNC_SWAP_RGB	0x04000000
+#define FB_ACCEL_TRIPLE_FLAG	0x00000000
+#define FB_ACCEL_DOUBLE_FLAG	0x00000001
+
+struct mxcfb_gbl_alpha {
+	int enable;
+	int alpha;
+};
+
+struct mxcfb_loc_alpha {
+	int enable;
+	int alpha_in_pixel;
+	unsigned long alpha_phy_addr0;
+	unsigned long alpha_phy_addr1;
+};
+
+struct mxcfb_color_key {
+	int enable;
+	__u32 color_key;
+};
+
+struct mxcfb_pos {
+	__u16 x;
+	__u16 y;
+};
+
+struct mxcfb_gamma {
+	int enable;
+	int constk[16];
+	int slopek[16];
+};
+
+struct mxcfb_gpu_split_fmt {
+	struct fb_var_screeninfo var;
+	unsigned long offset;
+};
+
+struct mxcfb_rect {
+	__u32 top;
+	__u32 left;
+	__u32 width;
+	__u32 height;
+};
+
+#define GRAYSCALE_8BIT				0x1
+#define GRAYSCALE_8BIT_INVERTED			0x2
+#define GRAYSCALE_4BIT                          0x3
+#define GRAYSCALE_4BIT_INVERTED                 0x4
+
+#define AUTO_UPDATE_MODE_REGION_MODE		0
+#define AUTO_UPDATE_MODE_AUTOMATIC_MODE		1
+
+#define UPDATE_SCHEME_SNAPSHOT			0
+#define UPDATE_SCHEME_QUEUE			1
+#define UPDATE_SCHEME_QUEUE_AND_MERGE		2
+
+#define UPDATE_MODE_PARTIAL			0x0
+#define UPDATE_MODE_FULL			0x1
+
+#define WAVEFORM_MODE_GLR16			4
+#define WAVEFORM_MODE_GLD16			5
+#define WAVEFORM_MODE_AUTO			257
+
+#define TEMP_USE_AMBIENT			0x1000
+
+#define EPDC_FLAG_ENABLE_INVERSION		0x01
+#define EPDC_FLAG_FORCE_MONOCHROME		0x02
+#define EPDC_FLAG_USE_CMAP			0x04
+#define EPDC_FLAG_USE_ALT_BUFFER		0x100
+#define EPDC_FLAG_TEST_COLLISION		0x200
+#define EPDC_FLAG_GROUP_UPDATE			0x400
+#define EPDC_FLAG_USE_DITHERING_Y1		0x2000
+#define EPDC_FLAG_USE_DITHERING_Y4		0x4000
+#define EPDC_FLAG_USE_REGAL				0x8000
+
+enum mxcfb_dithering_mode {
+	EPDC_FLAG_USE_DITHERING_PASSTHROUGH = 0x0,
+	EPDC_FLAG_USE_DITHERING_FLOYD_STEINBERG,
+	EPDC_FLAG_USE_DITHERING_ATKINSON,
+	EPDC_FLAG_USE_DITHERING_ORDERED,
+	EPDC_FLAG_USE_DITHERING_QUANT_ONLY,
+	EPDC_FLAG_USE_DITHERING_MAX,
+};
+
+#define FB_POWERDOWN_DISABLE			-1
+
+struct mxcfb_alt_buffer_data {
+	__u32 phys_addr;
+	__u32 width;	/* width of entire buffer */
+	__u32 height;	/* height of entire buffer */
+	struct mxcfb_rect alt_update_region;	/* region within buffer to update */
+};
+
+struct mxcfb_update_data {
+	struct mxcfb_rect update_region;
+	__u32 waveform_mode;
+	__u32 update_mode;
+	__u32 update_marker;
+	int temp;
+	unsigned int flags;
+	int dither_mode;
+	int quant_bit;
+	struct mxcfb_alt_buffer_data alt_buffer_data;
+};
+
+struct mxcfb_update_marker_data {
+	__u32 update_marker;
+	__u32 collision_test;
+};
+
+/*
+ * Structure used to define waveform modes for driver
+ * Needed for driver to perform auto-waveform selection
+ */
+struct mxcfb_waveform_modes {
+	int mode_init;
+	int mode_du;
+	int mode_gc4;
+	int mode_gc8;
+	int mode_gc16;
+	int mode_gc32;
+};
+
+/*
+ * Structure used to define a 5*3 matrix of parameters for
+ * setting IPU DP CSC module related to this framebuffer.
+ */
+struct mxcfb_csc_matrix {
+	int param[5][3];
+};
+
+#define MXCFB_WAIT_FOR_VSYNC	_IOW('F', 0x20, u_int32_t)
+#define MXCFB_SET_GBL_ALPHA     _IOW('F', 0x21, struct mxcfb_gbl_alpha)
+#define MXCFB_SET_CLR_KEY       _IOW('F', 0x22, struct mxcfb_color_key)
+#define MXCFB_SET_OVERLAY_POS   _IOWR('F', 0x24, struct mxcfb_pos)
+#define MXCFB_GET_FB_IPU_CHAN 	_IOR('F', 0x25, u_int32_t)
+#define MXCFB_SET_LOC_ALPHA     _IOWR('F', 0x26, struct mxcfb_loc_alpha)
+#define MXCFB_SET_LOC_ALP_BUF    _IOW('F', 0x27, unsigned long)
+#define MXCFB_SET_GAMMA	       _IOW('F', 0x28, struct mxcfb_gamma)
+#define MXCFB_GET_FB_IPU_DI 	_IOR('F', 0x29, u_int32_t)
+#define MXCFB_GET_DIFMT	       _IOR('F', 0x2A, u_int32_t)
+#define MXCFB_GET_FB_BLANK     _IOR('F', 0x2B, u_int32_t)
+#define MXCFB_SET_DIFMT		_IOW('F', 0x2C, u_int32_t)
+#define MXCFB_CSC_UPDATE	_IOW('F', 0x2D, struct mxcfb_csc_matrix)
+#define MXCFB_SET_GPU_SPLIT_FMT	_IOW('F', 0x2F, struct mxcfb_gpu_split_fmt)
+#define MXCFB_SET_PREFETCH	_IOW('F', 0x30, int)
+#define MXCFB_GET_PREFETCH	_IOR('F', 0x31, int)
+
+/* IOCTLs for E-ink panel updates */
+#define MXCFB_SET_WAVEFORM_MODES	_IOW('F', 0x2B, struct mxcfb_waveform_modes)
+#define MXCFB_SET_TEMPERATURE		_IOW('F', 0x2C, int32_t)
+#define MXCFB_SET_AUTO_UPDATE_MODE	_IOW('F', 0x2D, __u32)
+#define MXCFB_SEND_UPDATE		_IOW('F', 0x2E, struct mxcfb_update_data)
+#define MXCFB_WAIT_FOR_UPDATE_COMPLETE	_IOWR('F', 0x2F, struct mxcfb_update_marker_data)
+#define MXCFB_SET_PWRDOWN_DELAY		_IOW('F', 0x30, int32_t)
+#define MXCFB_GET_PWRDOWN_DELAY		_IOR('F', 0x31, int32_t)
+#define MXCFB_SET_UPDATE_SCHEME		_IOW('F', 0x32, __u32)
+#define MXCFB_GET_WORK_BUFFER		_IOWR('F', 0x34, unsigned long)
+#define MXCFB_DISABLE_EPDC_ACCESS	_IO('F', 0x35)
+#define MXCFB_ENABLE_EPDC_ACCESS	_IO('F', 0x36)
+#endif
diff --git a/include/uapi/linux/pxp_device.h b/include/uapi/linux/pxp_device.h
new file mode 100644
index 000000000..9b56c8c0e
--- /dev/null
+++ b/include/uapi/linux/pxp_device.h
@@ -0,0 +1,66 @@
+/*
+ * Copyright (C) 2013-2014 Freescale Semiconductor, Inc. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
+ *
+ */
+#ifndef _UAPI_PXP_DEVICE
+#define _UAPI_PXP_DEVICE
+
+#include <linux/pxp_dma.h>
+
+struct pxp_chan_handle {
+	unsigned int handle;
+	int hist_status;
+};
+
+struct pxp_mem_desc {
+	unsigned int handle;
+	unsigned int size;
+	dma_addr_t phys_addr;
+	void *virt_uaddr;		/* virtual user space address */
+	unsigned int mtype;
+	__u32 flags;
+	__s32 fd;
+};
+
+struct pxp_mem_flush {
+	unsigned int handle;
+	unsigned int type;
+};
+
+#define PXP_IOC_MAGIC  'P'
+
+#define PXP_IOC_GET_CHAN      _IOR(PXP_IOC_MAGIC, 0, struct pxp_mem_desc)
+#define PXP_IOC_PUT_CHAN      _IOW(PXP_IOC_MAGIC, 1, struct pxp_mem_desc)
+#define PXP_IOC_CONFIG_CHAN   _IOW(PXP_IOC_MAGIC, 2, struct pxp_mem_desc)
+#define PXP_IOC_START_CHAN    _IOW(PXP_IOC_MAGIC, 3, struct pxp_mem_desc)
+#define PXP_IOC_GET_PHYMEM    _IOWR(PXP_IOC_MAGIC, 4, struct pxp_mem_desc)
+#define PXP_IOC_PUT_PHYMEM    _IOW(PXP_IOC_MAGIC, 5, struct pxp_mem_desc)
+#define PXP_IOC_WAIT4CMPLT    _IOWR(PXP_IOC_MAGIC, 6, struct pxp_mem_desc)
+#define PXP_IOC_FLUSH_PHYMEM   _IOR(PXP_IOC_MAGIC, 7, struct pxp_mem_flush)
+#define PXP_IOC_EXPBUF        _IOR(PXP_IOC_MAGIC, 8, struct pxp_mem_desc)
+
+/* Memory types supported*/
+#define MEMORY_TYPE_UNCACHED 0x0
+#define MEMORY_TYPE_WC	     0x1
+#define MEMORY_TYPE_CACHED   0x2
+
+/* Cache flush operations */
+#define CACHE_CLEAN      0x1
+#define CACHE_INVALIDATE 0x2
+#define CACHE_FLUSH      0x4
+
+#endif
diff --git a/include/uapi/linux/pxp_dma.h b/include/uapi/linux/pxp_dma.h
new file mode 100644
index 000000000..2888f44fa
--- /dev/null
+++ b/include/uapi/linux/pxp_dma.h
@@ -0,0 +1,347 @@
+/*
+ * Copyright (C) 2013-2015 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright 2017 NXP
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
+ *
+ */
+#ifndef _UAPI_PXP_DMA
+#define _UAPI_PXP_DMA
+
+#include <linux/posix_types.h>
+#include <linux/types.h>
+
+#ifndef __KERNEL__
+typedef unsigned long dma_addr_t;
+typedef unsigned char bool;
+#endif
+
+/*  PXP Pixel format definitions */
+/*  Four-character-code (FOURCC) */
+#define fourcc(a, b, c, d)\
+	(((__u32)(a)<<0)|((__u32)(b)<<8)|((__u32)(c)<<16)|((__u32)(d)<<24))
+
+/*!
+ * @name PXP Pixel Formats
+ *
+ * Pixel formats are defined with ASCII FOURCC code. The pixel format codes are
+ * the same used by V4L2 API.
+ */
+
+/*! @} */
+/*! @name RGB Formats */
+/*! @{ */
+#define PXP_PIX_FMT_RGB332  fourcc('R', 'G', 'B', '1')	/*!<  8  RGB-3-3-2    */
+#define PXP_PIX_FMT_RGB444  fourcc('R', '4', '4', '4')	/* 16  xxxxrrrr ggggbbbb */
+#define PXP_PIX_FMT_ARGB444 fourcc('A', 'R', '1', '2')	/* 16  aaaarrrr ggggbbbb */
+#define PXP_PIX_FMT_RGBA444 fourcc('R', 'A', '1', '2')	/* 16  rrrrgggg bbbbaaaa */
+#define PXP_PIX_FMT_XRGB444 fourcc('X', 'R', '1', '2')	/* 16  xxxxrrrr ggggbbbb */
+#define PXP_PIX_FMT_RGB555  fourcc('R', 'G', 'B', 'O')	/*!< 16  RGB-5-5-5    */
+#define PXP_PIX_FMT_ARGB555 fourcc('A', 'R', '1', '5')	/*!< 16  ARGB-1-5-5-5 */
+#define PXP_PIX_FMT_RGBA555 fourcc('R', 'A', '1', '5')	/*!< 16  RGBA-5-5-5-1 */
+#define PXP_PIX_FMT_XRGB555 fourcc('X', 'R', '1', '5')	/*!< 16  XRGB-1-5-5-5 */
+#define PXP_PIX_FMT_RGB565  fourcc('R', 'G', 'B', 'P')	/*!< 16  RGB-5-6-5    */
+#define PXP_PIX_FMT_BGR565  fourcc('B', 'G', 'R', 'P')	/*!< 16  BGR-5-6-5    */
+#define PXP_PIX_FMT_RGB666  fourcc('R', 'G', 'B', '6')	/*!< 18  RGB-6-6-6    */
+#define PXP_PIX_FMT_BGR666  fourcc('B', 'G', 'R', '6')	/*!< 18  BGR-6-6-6    */
+#define PXP_PIX_FMT_BGR24   fourcc('B', 'G', 'R', '3')	/*!< 24  BGR-8-8-8    */
+#define PXP_PIX_FMT_RGB24   fourcc('R', 'G', 'B', '3')	/*!< 24  RGB-8-8-8    */
+#define PXP_PIX_FMT_XBGR32  fourcc('X', 'B', 'G', 'R')	/*!< 32  XBGR-8-8-8-8 */
+#define PXP_PIX_FMT_BGRX32  fourcc('B', 'G', 'R', 'X')	/*!< 32  BGRX-8-8-8-8 */
+#define PXP_PIX_FMT_BGRA32  fourcc('B', 'G', 'R', 'A')	/*!< 32  BGRA-8-8-8-8 */
+#define PXP_PIX_FMT_XRGB32  fourcc('X', 'R', 'G', 'B')	/*!< 32  XRGB-8-8-8-8 */
+#define PXP_PIX_FMT_RGBX32  fourcc('R', 'G', 'B', 'X')	/*!< 32  RGBX-8-8-8-8 */
+#define PXP_PIX_FMT_ARGB32  fourcc('A', 'R', 'G', 'B')	/*!< 32  ARGB-8-8-8-8 */
+#define PXP_PIX_FMT_RGBA32  fourcc('R', 'G', 'B', 'A')	/*!< 32  RGBA-8-8-8-8 */
+#define PXP_PIX_FMT_ABGR32  fourcc('A', 'B', 'G', 'R')	/*!< 32  ABGR-8-8-8-8 */
+#define PXP_PIX_FMT_RGB32	PXP_PIX_FMT_XRGB32
+/*! @} */
+/*! @name YUV Interleaved Formats */
+/*! @{ */
+#define PXP_PIX_FMT_YUYV    fourcc('Y', 'U', 'Y', 'V')	/*!< 16 YUV 4:2:2 */
+#define PXP_PIX_FMT_UYVY    fourcc('U', 'Y', 'V', 'Y')	/*!< 16 YUV 4:2:2 */
+#define PXP_PIX_FMT_VYUY    fourcc('V', 'Y', 'U', 'Y')  /*!< 16 YVU 4:2:2 */
+#define PXP_PIX_FMT_YVYU    fourcc('Y', 'V', 'Y', 'U')  /*!< 16 YVU 4:2:2 */
+#define PXP_PIX_FMT_Y41P    fourcc('Y', '4', '1', 'P')	/*!< 12 YUV 4:1:1 */
+#define PXP_PIX_FMT_VUY444  fourcc('V', 'U', 'Y', 'A')	/*!< 32 VUYA 8:8:8 */
+#define PXP_PIX_FMT_YUV444  fourcc('A', 'Y', 'U', 'V') /*!< 32 AYUV 8:8:8 */
+#define PXP_PIX_FMT_YVU444  fourcc('A', 'Y', 'V', 'U') /*!< 32 AYUV 8:8:8 */
+/* two planes -- one Y, one Cb + Cr interleaved  */
+#define PXP_PIX_FMT_NV12    fourcc('N', 'V', '1', '2')	/* 12  Y/CbCr 4:2:0  */
+#define PXP_PIX_FMT_NV21    fourcc('N', 'V', '2', '1')	/* 12  Y/CbCr 4:2:0  */
+#define PXP_PIX_FMT_NV16    fourcc('N', 'V', '1', '6')	/* 12  Y/CbCr 4:2:2  */
+#define PXP_PIX_FMT_NV61    fourcc('N', 'V', '6', '1')	/* 12  Y/CbCr 4:2:2  */
+/*! @} */
+/*! @name YUV Planar Formats */
+/*! @{ */
+#define PXP_PIX_FMT_GREY    fourcc('G', 'R', 'E', 'Y')	/*!< 8  Greyscale */
+#define PXP_PIX_FMT_GY04    fourcc('G', 'Y', '0', '4') /*!< 4  Greyscale */
+#define PXP_PIX_FMT_YVU410P fourcc('Y', 'V', 'U', '9')	/*!< 9  YVU 4:1:0 */
+#define PXP_PIX_FMT_YUV410P fourcc('Y', 'U', 'V', '9')	/*!< 9  YUV 4:1:0 */
+#define PXP_PIX_FMT_YVU420P fourcc('Y', 'V', '1', '2')	/*!< 12 YVU 4:2:0 */
+#define PXP_PIX_FMT_YUV420P fourcc('I', '4', '2', '0')	/*!< 12 YUV 4:2:0 */
+#define PXP_PIX_FMT_YUV420P2 fourcc('Y', 'U', '1', '2')	/*!< 12 YUV 4:2:0 */
+#define PXP_PIX_FMT_YVU422P fourcc('Y', 'V', '1', '6')	/*!< 16 YVU 4:2:2 */
+#define PXP_PIX_FMT_YUV422P fourcc('4', '2', '2', 'P')	/*!< 16 YUV 4:2:2 */
+/*! @} */
+
+#define PXP_LUT_NONE			0x0
+#define PXP_LUT_INVERT			0x1
+#define PXP_LUT_BLACK_WHITE		0x2
+#define PXP_LUT_USE_CMAP		0x4
+
+/* dithering modes enum */
+#define PXP_DITHER_PASS_THROUGH 0
+#define PXP_DITHER_FLOYD	1
+#define PXP_DITHER_ATKINSON	2
+#define PXP_DITHER_ORDERED	3
+#define PXP_DITHER_QUANT_ONLY	4
+
+#define NR_PXP_VIRT_CHANNEL	16
+
+#define PXP_IOC_MAGIC  'P'
+
+#define PXP_IOC_GET_CHAN      _IOR(PXP_IOC_MAGIC, 0, struct pxp_mem_desc)
+#define PXP_IOC_PUT_CHAN      _IOW(PXP_IOC_MAGIC, 1, struct pxp_mem_desc)
+#define PXP_IOC_CONFIG_CHAN   _IOW(PXP_IOC_MAGIC, 2, struct pxp_mem_desc)
+#define PXP_IOC_START_CHAN    _IOW(PXP_IOC_MAGIC, 3, struct pxp_mem_desc)
+#define PXP_IOC_GET_PHYMEM    _IOWR(PXP_IOC_MAGIC, 4, struct pxp_mem_desc)
+#define PXP_IOC_PUT_PHYMEM    _IOW(PXP_IOC_MAGIC, 5, struct pxp_mem_desc)
+#define PXP_IOC_WAIT4CMPLT    _IOWR(PXP_IOC_MAGIC, 6, struct pxp_mem_desc)
+
+#define PXP_IOC_FILL_DATA    _IOWR(PXP_IOC_MAGIC, 7, struct pxp_mem_desc)
+#define PXP_IOC_EXPBUF       _IOR(PXP_IOC_MAGIC, 8, struct pxp_mem_desc)
+
+#define ALPHA_MODE_ROP		0x1
+#define ALPHA_MODE_LEGACY	0x2
+#define ALPHA_MODE_PORTER_DUFF	0x3
+
+#define PXP_DEVICE_LEGACY
+
+/* Order significant! */
+enum pxp_channel_status {
+	PXP_CHANNEL_FREE,
+	PXP_CHANNEL_INITIALIZED,
+	PXP_CHANNEL_READY,
+};
+
+enum pxp_working_mode {
+	PXP_MODE_LEGACY			= 0x1,
+	PXP_MODE_STANDARD		= 0x2,
+	PXP_MODE_ADVANCED		= 0x4,
+};
+
+enum pxp_buffer_flag {
+	PXP_BUF_FLAG_WFE_A_FETCH0	= 0x0001,
+	PXP_BUF_FLAG_WFE_A_FETCH1	= 0x0002,
+	PXP_BUF_FLAG_WFE_A_STORE0	= 0x0004,
+	PXP_BUF_FLAG_WFE_A_STORE1	= 0x0008,
+	PXP_BUF_FLAG_WFE_B_FETCH0	= 0x0010,
+	PXP_BUF_FLAG_WFE_B_FETCH1	= 0x0020,
+	PXP_BUF_FLAG_WFE_B_STORE0	= 0x0040,
+	PXP_BUF_FLAG_WFE_B_STORE1	= 0x0080,
+	PXP_BUF_FLAG_DITHER_FETCH0	= 0x0100,
+	PXP_BUF_FLAG_DITHER_FETCH1	= 0x0200,
+	PXP_BUF_FLAG_DITHER_STORE0	= 0x0400,
+	PXP_BUF_FLAG_DITHER_STORE1	= 0x0800,
+};
+
+enum pxp_engine_ctrl {
+	PXP_ENABLE_ROTATE0		= 0x001,
+	PXP_ENABLE_ROTATE1		= 0x002,
+	PXP_ENABLE_LUT			= 0x004,
+	PXP_ENABLE_CSC2			= 0x008,
+	PXP_ENABLE_ALPHA_B		= 0x010,
+	PXP_ENABLE_INPUT_FETCH_SOTRE	= 0x020,
+	PXP_ENABLE_WFE_B		= 0x040,
+	PXP_ENABLE_WFE_A		= 0x080,
+	PXP_ENABLE_DITHER		= 0x100,
+	PXP_ENABLE_PS_AS_OUT		= 0x200,
+	PXP_ENABLE_COLLISION_DETECT     = 0x400,
+	PXP_ENABLE_HANDSHAKE		= 0x1000,
+	PXP_ENABLE_DITHER_BYPASS	= 0x2000,
+};
+
+enum pxp_op_type {
+	PXP_OP_2D			= 0x001,
+	PXP_OP_DITHER			= 0x002,
+	PXP_OP_WFE_A			= 0x004,
+	PXP_OP_WFE_B			= 0x008,
+};
+
+struct rect {
+	int top;		/* Upper left coordinate of rectangle */
+	int left;
+	int width;
+	int height;
+};
+
+#define ALPHA_MODE_STRAIGHT	0x0
+#define ALPHA_MODE_INVERSED	0x1
+
+#define GLOBAL_ALPHA_MODE_ON	0x0
+#define GLOBAL_ALPHA_MODE_OFF	0x1
+#define GLOBAL_ALPHA_MODE_SCALE	0x2
+
+#define FACTOR_MODE_ONE		0x0
+#define FACTOR_MODE_ZERO	0x1
+#define FACTOR_MODE_STRAIGHT	0x2
+#define FACTOR_MODE_INVERSED	0x3
+
+#define COLOR_MODE_STRAIGHT	0x0
+#define COLOR_MODE_MULTIPLY	0x1
+
+struct pxp_alpha {
+	unsigned int alpha_mode;
+	unsigned int global_alpha_mode;
+	unsigned int global_alpha_value;
+	unsigned int factor_mode;
+	unsigned int color_mode;
+};
+
+struct pxp_layer_param {
+	unsigned short left;
+	unsigned short top;
+	unsigned short width;
+	unsigned short height;
+	unsigned short stride; /* aka pitch */
+	unsigned int pixel_fmt;
+
+	unsigned int flag;
+	/* layers combining parameters
+	 * (these are ignored for S0 and output
+	 * layers, and only apply for OL layer)
+	 */
+	bool combine_enable;
+	unsigned int color_key_enable;
+	unsigned int color_key;
+	bool global_alpha_enable;
+	/* global alpha is either override or multiply */
+	bool global_override;
+	unsigned char global_alpha;
+	bool alpha_invert;
+	bool local_alpha_enable;
+	int comp_mask;
+
+	struct pxp_alpha alpha;
+	struct rect crop;
+
+	dma_addr_t paddr;
+};
+
+struct pxp_collision_info {
+	unsigned int pixel_cnt;
+	unsigned int rect_min_x;
+	unsigned int rect_min_y;
+	unsigned int rect_max_x;
+	unsigned int rect_max_y;
+	unsigned int victim_luts[2];
+};
+
+struct pxp_proc_data {
+	/* S0 Transformation Info */
+	int scaling;
+	int hflip;
+	int vflip;
+	int rotate;
+	int rot_pos;
+	int yuv;
+	unsigned int alpha_mode;
+
+	/* Source rectangle (srect) defines the sub-rectangle
+	 * within S0 to undergo processing.
+	 */
+	struct rect srect;
+	/* Dest rect (drect) defines how to position the processed
+	 * source rectangle (after resizing) within the output frame,
+	 * whose dimensions are defined in pxp->pxp_conf_state.out_param
+	 */
+	struct rect drect;
+
+	/* Current S0 configuration */
+	unsigned int bgcolor;
+	unsigned char fill_en;
+
+	/* Output overlay support */
+	int overlay_state;
+
+	/* LUT transformation on Y data */
+	int lut_transform;
+	unsigned char *lut_map; /* 256 entries */
+	bool lut_map_updated; /* Map recently changed */
+	bool combine_enable;
+
+	enum pxp_op_type op_type;
+
+	/* LUT cleanup */
+	__u64 lut_sels;
+
+	/* the mode pxp's working against */
+	enum pxp_working_mode working_mode;
+	enum pxp_engine_ctrl engine_enable;
+
+	/* wfe */
+/*
+ * partial:
+ *         0 - full update
+ *         1 - partial update
+ * alpha_en:
+ *         0 - upd is {Y4[3:0],4'b0000} format
+ *         1 - upd is {Y4[3:0],3'b000,alpha} format
+ * reagl_en:
+ *         0 - use normal waveform algorithm
+ *         1 - enable reagl/-d waveform algorithm
+ * detection_only:
+ *         0 - write working buffer
+ *         1 - do no write working buffer, detection only
+ * lut:
+ *         valid value 0-63
+ *         set to the lut used for next update
+ */
+	bool partial_update;
+	bool alpha_en;
+	bool lut_update;
+	bool reagl_en;		/* enable reagl/-d */
+	bool reagl_d_en;	/* enable reagl or reagl-d */
+	bool detection_only;
+	bool pxp_legacy;
+	int lut;
+	bool lut_cleanup;
+	unsigned int lut_status_1;
+	unsigned int lut_status_2;
+
+	/* Dithering specific data */
+	int dither_mode;
+	unsigned int quant_bit;
+};
+
+struct pxp_config_data {
+	struct pxp_layer_param s0_param;
+	struct pxp_layer_param ol_param[1];
+	struct pxp_layer_param out_param;
+	struct pxp_layer_param wfe_a_fetch_param[2];
+	struct pxp_layer_param wfe_a_store_param[2];
+	struct pxp_layer_param wfe_b_fetch_param[2];
+	struct pxp_layer_param wfe_b_store_param[2];
+	struct pxp_layer_param dither_fetch_param[2];
+	struct pxp_layer_param dither_store_param[2];
+	struct pxp_proc_data proc_data;
+	int layer_nr;
+
+	/* Users don't touch */
+	int handle;
+};
+
+#endif
diff --git a/include/uapi/linux/rpmsg.h b/include/uapi/linux/rpmsg.h
index e14c6dab4..1637e6817 100644
--- a/include/uapi/linux/rpmsg.h
+++ b/include/uapi/linux/rpmsg.h
@@ -9,11 +9,13 @@
 #include <linux/ioctl.h>
 #include <linux/types.h>
 
+#define RPMSG_ADDR_ANY		0xFFFFFFFF
+
 /**
  * struct rpmsg_endpoint_info - endpoint info representation
  * @name: name of service
- * @src: local address
- * @dst: destination address
+ * @src: local address. To set to RPMSG_ADDR_ANY if not used.
+ * @dst: destination address. To set to RPMSG_ADDR_ANY if not used.
  */
 struct rpmsg_endpoint_info {
 	char name[32];
@@ -21,7 +23,24 @@ struct rpmsg_endpoint_info {
 	__u32 dst;
 };
 
+/**
+ * Instantiate a new rmpsg char device endpoint.
+ */
 #define RPMSG_CREATE_EPT_IOCTL	_IOW(0xb5, 0x1, struct rpmsg_endpoint_info)
+
+/**
+ * Destroy a rpmsg char device endpoint created by the RPMSG_CREATE_EPT_IOCTL.
+ */
 #define RPMSG_DESTROY_EPT_IOCTL	_IO(0xb5, 0x2)
 
+/**
+ * Instantiate a new local rpmsg service device.
+ */
+#define RPMSG_CREATE_DEV_IOCTL	_IOW(0xb5, 0x3, struct rpmsg_endpoint_info)
+
+/**
+ * Release a local rpmsg device.
+ */
+#define RPMSG_RELEASE_DEV_IOCTL	_IOW(0xb5, 0x4, struct rpmsg_endpoint_info)
+
 #endif
diff --git a/include/uapi/linux/rpmsg_types.h b/include/uapi/linux/rpmsg_types.h
new file mode 100644
index 000000000..36e3b9404
--- /dev/null
+++ b/include/uapi/linux/rpmsg_types.h
@@ -0,0 +1,11 @@
+/* SPDX-License-Identifier: GPL-2.0 WITH Linux-syscall-note */
+#ifndef _UAPI_LINUX_RPMSG_TYPES_H
+#define _UAPI_LINUX_RPMSG_TYPES_H
+
+#include <linux/types.h>
+
+typedef __u16 __bitwise __rpmsg16;
+typedef __u32 __bitwise __rpmsg32;
+typedef __u64 __bitwise __rpmsg64;
+
+#endif /* _UAPI_LINUX_RPMSG_TYPES_H */
diff --git a/include/uapi/linux/tsn.h b/include/uapi/linux/tsn.h
new file mode 100644
index 000000000..fb304c9b1
--- /dev/null
+++ b/include/uapi/linux/tsn.h
@@ -0,0 +1,1207 @@
+/* SPDX-License-Identifier: (GPL-2.0+ OR BSD-3-Clause) WITH Linux-syscall-note */
+/* Copyright 2017-2019 NXP */
+
+#ifndef __UAPI_GENL_TSN_H
+#define __UAPI_GENL_TSN_H
+
+#define	TSN_GENL_NAME		"TSN_GEN_CTRL"
+#define	TSN_GENL_VERSION	0x1
+
+#define MAX_USER_SIZE 0
+#define MAX_ATTR_SIZE 3072
+#define MAX_TOTAL_MSG_SIZE  (MAX_USER_SIZE + MAX_ATTR_SIZE)
+#define MAX_ENTRY_SIZE 2048
+#define MAX_ENTRY_NUMBER 128
+#define MAX_IFNAME_COUNT 64
+
+#define TSN_MULTICAST_GROUP_QBV	"qbv"
+#define TSN_MULTICAST_GROUP_QCI	"qci"
+
+/* multicast groups */
+enum tsn_multicast_groups {
+	TSN_MCGRP_QBV,
+	TSN_MCGRP_QCI,
+	TSN_MCGRP_MAX
+};
+
+enum tsn_capability {
+	TSN_CAP_QBV = 0x1,
+	TSN_CAP_QCI = 0x2,
+	TSN_CAP_QBU = 0x4,
+	TSN_CAP_CBS = 0x8, /* Credit-based Shapter Qav */
+	TSN_CAP_CB  = 0x10, /* 8021CB redundancy and replication */
+	TSN_CAP_TBS = 0x20, /* Time Based schedule */
+	TSN_CAP_CTH = 0x40, /* cut through */
+};
+
+/*
+ * Commands sent from userspace
+ * Not versioned. New commands should only be inserted at the enum's end
+ * prior to __TSN_CMD_MAX
+ */
+
+enum {
+	TSN_CMD_UNSPEC = 0,	/* Reserved */
+	TSN_CMD_QBV_SET,
+	TSN_CMD_QBV_GET,
+	TSN_CMD_QBV_GET_STATUS,
+	TSN_CMD_CB_STREAMID_SET,
+	TSN_CMD_CB_STREAMID_GET,
+	TSN_CMD_CB_STREAMID_GET_COUNTS,
+	TSN_CMD_QCI_CAP_GET, /* Qci capability get length capability get */
+	TSN_CMD_QCI_SFI_SET,
+	TSN_CMD_QCI_SFI_GET,
+	TSN_CMD_QCI_SFI_GET_COUNTS,
+	TSN_CMD_QCI_SGI_SET,
+	TSN_CMD_QCI_SGI_GET,
+	TSN_CMD_QCI_SGI_GET_STATUS,
+	TSN_CMD_QCI_FMI_SET,
+	TSN_CMD_QCI_FMI_GET,
+	TSN_CMD_CBS_SET,
+	TSN_CMD_CBS_GET,
+	TSN_CMD_QBU_SET,
+	TSN_CMD_QBU_GET_STATUS,
+	TSN_CMD_QAV_SET_CBS,
+	TSN_CMD_QAV_GET_CBS,
+	TSN_CMD_TSD_SET,
+	TSN_CMD_TSD_GET,
+	TSN_CMD_CT_SET,
+	TSN_CMD_CBGEN_SET,
+	TSN_CMD_CBREC_SET,
+	TSN_CMD_CBSTAT_GET,
+	TSN_CMD_PCPMAP_SET_UNUSE,
+	TSN_CMD_DSCP_SET,
+	TSN_CMD_ECHO,			/* user->kernel request/get-response */
+	TSN_CMD_REPLY,			/* kernel->user event */
+	TSN_CMD_CAP_GET,
+	__TSN_CMD_MAX,
+};
+#define TSN_CMD_MAX (__TSN_CMD_MAX - 1)
+
+
+enum {
+	TSN_CMD_ATTR_UNSPEC = 0,
+	TSN_CMD_ATTR_MESG,		/* demo message  */
+	TSN_CMD_ATTR_DATA,		/* demo data */
+	TSN_ATTR_IFNAME,
+	TSN_ATTR_PORT_NUMBER,
+	TSN_ATTR_QBV,
+	TSN_ATTR_STREAM_IDENTIFY, /* stream identify */
+	TSN_ATTR_QCI_SP,		/* psfp port capbility parameters */
+	TSN_ATTR_QCI_SFI,		/* psfp stream filter instance */
+	TSN_ATTR_QCI_SGI,		/* psfp stream gate instance */
+	TSN_ATTR_QCI_FMI,		/* psfp flow meter instance */
+	TSN_ATTR_CBS,			/* credit-based shaper */
+	TSN_ATTR_TSD,			/* Time Specific Departure */
+	TSN_ATTR_QBU,			/* preemption */
+	TSN_ATTR_CT,			/* cut through */
+	TSN_ATTR_CBGEN,			/* 802.1CB sequence generate */
+	TSN_ATTR_CBREC,			/* 802.1CB sequence recover */
+	TSN_ATTR_CBSTAT,                 /* 802.1CB status */
+	TSN_ATTR_PCPMAP_UNUSE,
+	TSN_ATTR_DSCP,
+	TSN_ATTR_CAP,		/* TSN capbility */
+	__TSN_CMD_ATTR_MAX,
+};
+#define TSN_CMD_ATTR_MAX (__TSN_CMD_ATTR_MAX - 1)
+
+enum {
+	TSN_CAP_ATTR_UNSPEC,
+	TSN_CAP_ATTR_QBV,
+	TSN_CAP_ATTR_QCI,
+	TSN_CAP_ATTR_QBU,
+	TSN_CAP_ATTR_CBS,
+	TSN_CAP_ATTR_CB,
+	TSN_CAP_ATTR_TBS,
+	TSN_CAP_ATTR_CTH,
+	__TSN_CAP_ATTR_MAX,
+	TSN_CAP_ATTR_MAX = __TSN_CAP_ATTR_MAX - 1,
+};
+
+enum {
+	TSN_QBU_ATTR_UNSPEC,
+	TSN_QBU_ATTR_ADMIN_STATE,
+	TSN_QBU_ATTR_HOLD_ADVANCE,
+	TSN_QBU_ATTR_RELEASE_ADVANCE,
+	TSN_QBU_ATTR_ACTIVE,
+	TSN_QBU_ATTR_HOLD_REQUEST,
+	__TSN_QBU_ATTR_MAX,
+	TSN_QBU_ATTR_MAX = __TSN_QBU_ATTR_MAX - 1,
+};
+
+enum {
+	TSN_CBS_ATTR_UNSPEC,
+	TSN_CBS_ATTR_TC_INDEX,
+	TSN_CBS_ATTR_BW,
+	__TSN_CBS_ATTR_MAX,
+	TSN_CBS_ATTR_MAX = __TSN_CBS_ATTR_MAX - 1,
+};
+
+enum {
+	TSN_TSD_ATTR_UNSPEC,
+	TSN_TSD_ATTR_DISABLE,
+	TSN_TSD_ATTR_ENABLE,
+	TSN_TSD_ATTR_PERIOD,
+	TSN_TSD_ATTR_MAX_FRM_NUM,
+	TSN_TSD_ATTR_CYCLE_NUM,
+	TSN_TSD_ATTR_LOSS_STEPS,
+	TSN_TSD_ATTR_SYN_IMME,
+	__TSN_TSD_ATTR_MAX,
+	TSN_TSD_ATTR_MAX = __TSN_TSD_ATTR_MAX - 1,
+};
+
+enum {
+	TSN_STREAMID_ATTR_UNSPEC,
+	TSN_STREAMID_ATTR_INDEX,
+	TSN_STREAMID_ATTR_ENABLE,
+	TSN_STREAMID_ATTR_DISABLE,
+	TSN_STREAMID_ATTR_STREAM_HANDLE,
+	TSN_STREAMID_ATTR_IFOP,
+	TSN_STREAMID_ATTR_OFOP,
+	TSN_STREAMID_ATTR_IFIP,
+	TSN_STREAMID_ATTR_OFIP,
+	TSN_STREAMID_ATTR_TYPE,
+	TSN_STREAMID_ATTR_NDMAC,
+	TSN_STREAMID_ATTR_NTAGGED,
+	TSN_STREAMID_ATTR_NVID,
+	TSN_STREAMID_ATTR_SMAC,
+	TSN_STREAMID_ATTR_STAGGED,
+	TSN_STREAMID_ATTR_SVID,
+	TSN_STREAMID_ATTR_COUNTERS_PSI,
+	TSN_STREAMID_ATTR_COUNTERS_PSO,
+	TSN_STREAMID_ATTR_COUNTERS_PSPPI,
+	TSN_STREAMID_ATTR_COUNTERS_PSPPO,
+	__TSN_STREAMID_ATTR_MAX,
+	TSN_STREAMID_ATTR_MAX = __TSN_STREAMID_ATTR_MAX - 1,
+};
+
+enum {
+	TSN_QCI_STREAM_ATTR_UNSPEC = 0,
+	TSN_QCI_STREAM_ATTR_MAX_SFI,
+	TSN_QCI_STREAM_ATTR_MAX_SGI,
+	TSN_QCI_STREAM_ATTR_MAX_FMI,
+	TSN_QCI_STREAM_ATTR_SLM,
+	__TSN_QCI_STREAM_ATTR_MAX,
+	TSN_QCI_STREAM_ATTR_MAX = __TSN_QCI_STREAM_ATTR_MAX - 1,
+};
+
+enum {
+	TSN_QCI_SFI_ATTR_UNSPEC = 0,
+	TSN_QCI_SFI_ATTR_INDEX,
+	TSN_QCI_SFI_ATTR_ENABLE,
+	TSN_QCI_SFI_ATTR_DISABLE,
+	TSN_QCI_SFI_ATTR_STREAM_HANDLE,
+	TSN_QCI_SFI_ATTR_PRIO_SPEC,
+	TSN_QCI_SFI_ATTR_GATE_ID,
+	TSN_QCI_SFI_ATTR_FILTER_TYPE,
+	TSN_QCI_SFI_ATTR_FLOW_ID,
+	TSN_QCI_SFI_ATTR_MAXSDU,
+	TSN_QCI_SFI_ATTR_COUNTERS,
+	TSN_QCI_SFI_ATTR_OVERSIZE_ENABLE,
+	TSN_QCI_SFI_ATTR_OVERSIZE,
+	__TSN_QCI_SFI_ATTR_MAX,
+	TSN_QCI_SFI_ATTR_MAX = __TSN_QCI_SFI_ATTR_MAX - 1,
+};
+
+enum {
+	TSN_QCI_SFI_ATTR_COUNTERS_UNSPEC = 0,
+	TSN_QCI_SFI_ATTR_MATCH,
+	TSN_QCI_SFI_ATTR_PASS,
+	TSN_QCI_SFI_ATTR_DROP,
+	TSN_QCI_SFI_ATTR_SDU_DROP,
+	TSN_QCI_SFI_ATTR_SDU_PASS,
+	TSN_QCI_SFI_ATTR_RED,
+	__TSN_QCI_SFI_ATTR_COUNT_MAX,
+	TSN_QCI_SFI_ATTR_COUNT_MAX = __TSN_QCI_SFI_ATTR_COUNT_MAX - 1,
+};
+
+enum {
+	TSN_QCI_SGI_ATTR_UNSPEC = 0,
+	TSN_QCI_SGI_ATTR_INDEX,
+	TSN_QCI_SGI_ATTR_ENABLE,
+	TSN_QCI_SGI_ATTR_DISABLE,
+	TSN_QCI_SGI_ATTR_CONFCHANGE,
+	TSN_QCI_SGI_ATTR_IRXEN,		/* Invalid rx enable*/
+	TSN_QCI_SGI_ATTR_IRX,
+	TSN_QCI_SGI_ATTR_OEXEN,		/* Octet exceed enable */
+	TSN_QCI_SGI_ATTR_OEX,
+	TSN_QCI_SGI_ATTR_ADMINENTRY,
+	TSN_QCI_SGI_ATTR_OPERENTRY,
+	TSN_QCI_SGI_ATTR_CCTIME,	/* config change time */
+	TSN_QCI_SGI_ATTR_TICKG,
+	TSN_QCI_SGI_ATTR_CUTIME,
+	TSN_QCI_SGI_ATTR_CPENDING,
+	TSN_QCI_SGI_ATTR_CCERROR,
+	__TSN_QCI_SGI_ATTR_MAX,
+	TSN_QCI_SGI_ATTR_MAX = __TSN_QCI_SGI_ATTR_MAX - 1,
+};
+
+enum {
+	TSN_SGI_ATTR_CTRL_UNSPEC = 0,
+	TSN_SGI_ATTR_CTRL_INITSTATE,
+	TSN_SGI_ATTR_CTRL_LEN,
+	TSN_SGI_ATTR_CTRL_CYTIME,
+	TSN_SGI_ATTR_CTRL_CYTIMEEX,
+	TSN_SGI_ATTR_CTRL_BTIME,
+	TSN_SGI_ATTR_CTRL_INITIPV,
+	TSN_SGI_ATTR_CTRL_GCLENTRY,
+	__TSN_SGI_ATTR_CTRL_MAX,
+	TSN_SGI_ATTR_CTRL_MAX = __TSN_SGI_ATTR_CTRL_MAX - 1,
+};
+
+enum {
+	TSN_SGI_ATTR_GCL_UNSPEC = 0,
+	TSN_SGI_ATTR_GCL_GATESTATE,
+	TSN_SGI_ATTR_GCL_IPV,
+	TSN_SGI_ATTR_GCL_INTERVAL,
+	TSN_SGI_ATTR_GCL_OCTMAX,
+	__TSN_SGI_ATTR_GCL_MAX,
+	TSN_SGI_ATTR_GCL_MAX = __TSN_SGI_ATTR_GCL_MAX - 1,
+};
+
+enum {
+	TSN_QCI_FMI_ATTR_UNSPEC = 0,
+	TSN_QCI_FMI_ATTR_INDEX,
+	TSN_QCI_FMI_ATTR_ENABLE,
+	TSN_QCI_FMI_ATTR_DISABLE,
+	TSN_QCI_FMI_ATTR_CIR,
+	TSN_QCI_FMI_ATTR_CBS,
+	TSN_QCI_FMI_ATTR_EIR,
+	TSN_QCI_FMI_ATTR_EBS,
+	TSN_QCI_FMI_ATTR_CF,
+	TSN_QCI_FMI_ATTR_CM,
+	TSN_QCI_FMI_ATTR_DROPYL,
+	TSN_QCI_FMI_ATTR_MAREDEN,
+	TSN_QCI_FMI_ATTR_MARED,
+	TSN_QCI_FMI_ATTR_COUNTERS,
+	__TSN_QCI_FMI_ATTR_MAX,
+	TSN_QCI_FMI_ATTR_MAX = __TSN_QCI_FMI_ATTR_MAX - 1,
+};
+
+enum {
+	TSN_QBV_ATTR_UNSPEC,
+	TSN_QBV_ATTR_ENABLE,
+	TSN_QBV_ATTR_DISABLE,
+	TSN_QBV_ATTR_CONFIGCHANGE,
+	TSN_QBV_ATTR_CONFIGCHANGETIME,
+	TSN_QBV_ATTR_MAXSDU,
+	TSN_QBV_ATTR_GRANULARITY,
+	TSN_QBV_ATTR_CURRENTTIME,
+	TSN_QBV_ATTR_CONFIGPENDING,
+	TSN_QBV_ATTR_CONFIGCHANGEERROR,
+	TSN_QBV_ATTR_ADMINENTRY,
+	TSN_QBV_ATTR_OPERENTRY,
+	TSN_QBV_ATTR_LISTMAX,
+	__TSN_QBV_ATTR_MAX,
+	TSN_QBV_ATTR_MAX = __TSN_QBV_ATTR_MAX - 1,
+};
+
+enum {
+	TSN_QBV_ATTR_CTRL_UNSPEC,
+	TSN_QBV_ATTR_CTRL_LISTCOUNT,
+	TSN_QBV_ATTR_CTRL_GATESTATE,
+	TSN_QBV_ATTR_CTRL_CYCLETIME,
+	TSN_QBV_ATTR_CTRL_CYCLETIMEEXT,
+	TSN_QBV_ATTR_CTRL_BASETIME,
+	TSN_QBV_ATTR_CTRL_LISTENTRY,
+	__TSN_QBV_ATTR_CTRL_MAX,
+	TSN_QBV_ATTR_CTRL_MAX = __TSN_QBV_ATTR_CTRL_MAX - 1,
+};
+
+enum {
+	TSN_QBV_ATTR_ENTRY_UNSPEC,
+	TSN_QBV_ATTR_ENTRY_ID,
+	TSN_QBV_ATTR_ENTRY_GC,
+	TSN_QBV_ATTR_ENTRY_TM,
+	__TSN_QBV_ATTR_ENTRY_MAX,
+	TSN_QBV_ATTR_ENTRY_MAX = __TSN_QBV_ATTR_ENTRY_MAX - 1,
+};
+
+enum {
+	TSN_CT_ATTR_UNSPEC,
+	TSN_CT_ATTR_QUEUE_STATE,
+	__TSN_CT_ATTR_MAX,
+	TSN_CT_ATTR_MAX = __TSN_CT_ATTR_MAX - 1,
+};
+
+enum {
+	TSN_CBGEN_ATTR_UNSPEC,
+	TSN_CBGEN_ATTR_INDEX,
+	TSN_CBGEN_ATTR_PORT_MASK,
+	TSN_CBGEN_ATTR_SPLIT_MASK,
+	TSN_CBGEN_ATTR_SEQ_LEN,
+	TSN_CBGEN_ATTR_SEQ_NUM,
+	__TSN_CBGEN_ATTR_MAX,
+	TSN_CBGEN_ATTR_MAX = __TSN_CBGEN_ATTR_MAX - 1,
+};
+
+enum {
+	TSN_CBREC_ATTR_UNSPEC,
+	TSN_CBREC_ATTR_INDEX,
+	TSN_CBREC_ATTR_SEQ_LEN,
+	TSN_CBREC_ATTR_HIS_LEN,
+	TSN_CBREC_ATTR_TAG_POP_EN,
+	__TSN_CBREC_ATTR_MAX,
+	TSN_CBREC_ATTR_MAX = __TSN_CBREC_ATTR_MAX - 1,
+};
+
+enum {
+	TSN_CBSTAT_ATTR_UNSPEC,
+	TSN_CBSTAT_ATTR_INDEX,
+	TSN_CBSTAT_ATTR_GEN_REC,
+	TSN_CBSTAT_ATTR_ERR,
+	TSN_CBSTAT_ATTR_SEQ_NUM,
+	TSN_CBSTAT_ATTR_SEQ_LEN,
+	TSN_CBSTAT_ATTR_SPLIT_MASK,
+	TSN_CBSTAT_ATTR_PORT_MASK,
+	TSN_CBSTAT_ATTR_HIS_LEN,
+	TSN_CBSTAT_ATTR_SEQ_HIS,
+	__TSN_CBSTAT_ATTR_MAX,
+	TSN_CBSTAT_ATTR_MAX = __TSN_CBSTAT_ATTR_MAX - 1,
+};
+
+enum {
+	TSN_DSCP_ATTR_UNSPEC,
+	TSN_DSCP_ATTR_DISABLE,
+	TSN_DSCP_ATTR_INDEX,
+	TSN_DSCP_ATTR_COS,
+	TSN_DSCP_ATTR_DPL,
+	__TSN_DSCP_ATTR_MAX,
+	TSN_DSCP_ATTR_MAX = __TSN_DSCP_ATTR_MAX - 1,
+};
+
+#define ptptime_t __u64
+
+#define MAX_QUEUE_CNT 8
+
+struct tsn_preempt_status {
+	/* The value of admin_state shows a 8-bits vector value for showing
+	 * the framePreemptionAdminStatus parameter and PreemptionPriority
+	 * for the traffic class. Bit-7 is the highest priority traffic class
+	 * and the bit-0 is the lowest priority traffic class.
+	 * The bit is express (0) and is preemptible (1).
+	 */
+	__u8 admin_state;
+	/* The value of the holdAdvance parameter for the port in nanoseconds.
+	 * There is no default value; the holdAdvance is a property of the
+	 * underlying MAC." This parameter corresponds to the holdAdvance
+	 * parameter in 802.1Qbu.
+	 */
+	__u32 hold_advance;
+
+	/* The value of the releaseAdvance parameter for the port in
+	 * nanoseconds.  There is no default value; the releaseAdvance is a
+	 * property of the underlying MAC." This parameter corresponds to the
+	 * releaseAdvance parameter in 802.1Qbu.
+	 */
+	__u32 release_advance;
+
+	/* The value is active (TRUE) when preemption is operationally active
+	 * for the port, and idle (FALSE) otherwise.  This parameter corresponds
+	 * to the preemptionActive parameter in 802.1Qbu.
+	 */
+	__u8 preemption_active;
+
+	/* The value is hold (1) when the sequence of gate operations for
+	 * the port has executed a Set-And-Hold-MAC operation, and release
+	 * (2) when the sequence of gate operations has executed a
+	 * Set-And-Release-MAC operation. The value of this object is release
+	 * (FALSE) on system initialization.  This parameter corresponds to the
+	 * holdRequest parameter in 802.1Qbu.
+	 */
+	__u8 hold_request;
+};
+
+enum tsn_tx_mode  {
+	TX_MODE_STRICT,
+	TX_MODE_CBS,
+	TX_MODE_ETS,
+	TX_MODE_VENDOR_DEFINE = 255,
+};
+
+#define QUEUE_TX_MASK ((1 << TX_MODE_STRICT) | (1 << TX_MODE_CBS) \
+			| (1 << TX_MODE_ETS) | (1 << TX_MODE_VENDOR_DEFINE))
+
+struct cbs_status {
+	__u8 delta_bw; /* percentage, 0~100 */
+	__u32 idleslope;
+	__s32 sendslope;
+	__u32 maxframesize;
+	__u32 hicredit;
+	__s32 locredit;
+	__u32 maxninference;
+};
+
+struct tx_queue {
+	/* tx_queue_capbility shows the queue's capability mask.
+	 * refer the enum tsn_tx_mode
+	 */
+	__u8 capability;
+
+	/* tx_queue_mode is current queue working mode */
+	__u8 mode;
+
+	/* prio is showing the queue priority */
+	__u8 prio;
+
+	/* mstat shows the status data of cbs or priority */
+	union {
+		struct cbs_status cbs;
+	};
+};
+
+struct port_status {
+	/* txqueue_cnt shows how many queues in this port */
+	__u8 queue_cnt;
+
+	/* max_rate(Mbit/s) is the port transmit rate current port is setting */
+	__u32 max_rate;
+
+	/* tsn_capability mask the tsn capability */
+	__u32 tsn_capability;
+};
+
+enum tsn_cb_streamid_type {
+	STREAMID_RESERVED = 0,
+	/* Null Stream identification */
+	STREAMID_NULL,
+	/* Source MAC and VLAN Stream identification */
+	STREAMID_SMAC_VLAN,
+	/* Active Destination MAC and VLAN stream identification */
+	STREAMID_DMAC_VLAN,
+	/* IP stream identification */
+	STREAMID_IP,
+};
+
+/* When instantiating an instance of the Null Stream identification function
+ * 8021CB(6.4) for a particular input Stream, the managed objects in the
+ * following subsections serve as the tsnStreamIdParameters managed object
+ * 8021CB claus(9.1.1.7).
+ */
+struct tsn_cb_null_streamid {
+	/* tsnCpeNullDownDestMac. Specifies the destination_address that
+	 * identifies a packet in an Enhanced Internal Sublayer Service (EISS)
+	 * indication primitive, to the Null Stream identification function.
+	 */
+	__u64 dmac;
+
+	/* tsnCpeNullDownTagged. It can take the following values:
+	 * 1 tagged: A frame must have a VLAN tag to be recognized as belonging
+	 * to the Stream.
+	 * 2 priority: A frame must be untagged, or have a VLAN tag with a VLAN
+	 * ID = 0 to be recognized as belonging to the Stream.
+	 * 3 all: A frame is recognized as belonging to the Stream whether
+	 * tagged or not.
+	 */
+	__u8 tagged;
+
+	/* tsnCpeNullDownVlan. Specifies the vlan_identifier parameter that
+	 * identifies a packet in an EISS indication primitive to the Null
+	 * Stream identification function. A value of 0 indicates that the vlan
+	 * _identifier parameter is ignored on EISS indication primitives.
+	 */
+	__u16 vid;
+};
+
+struct tsn_cb_source_streamid {
+	__u64 smac;
+	__u8 tagged;
+	__u16 vid;
+};
+
+struct tsn_cb_dest_streamid {
+	__u64 down_dmac;
+	__u8 down_tagged;
+	__u16 down_vid;
+	__u8 down_prio;
+	__u64 up_dmac;
+	__u8 up_tagged;
+	__u16 up_vid;
+	__u8 up_prio;
+};
+
+struct tsn_cb_ip_streamid {
+	__u64 dmac;
+	__u8 tagged;
+	__u16 vid;
+	__u64 siph;
+	__u64 sipl;
+	__u64 diph;
+	__u64 dipl;
+	__u8 dscp;
+	__u8 npt;
+	__u16 sport;
+	__u16 dport;
+};
+
+/* 802.1CB stream identify table clause 9.1 */
+struct tsn_cb_streamid {
+	/* The objects in a given entry of the Stream identity table are used
+	 * to control packets whose stream_handle subparameter is equal to the
+	 * entry tsnStreamIdHandle object.
+	 */
+	__s32 handle;
+
+	/* The list of ports on which an in-facing Stream identification
+	 * function in the output (towards the system forwarding function)
+	 * direction Only Active Destination MAC and VLAN Stream identification
+	 * (or nothing) can be configured.
+	 */
+	__u32 ifac_oport;
+
+	/* The list of ports on which an out-facing Stream identification
+	 * function in the output (towards the physical interface) direction.
+	 * Only Active Destination MAC and VLAN Stream identification
+	 * (or nothing) can be configured.
+	 */
+	__u32 ofac_oport;
+
+	/* The list of ports on which an in-facing Stream identification
+	 * function in the input (coming from the system forwarding function)
+	 * direction
+	 */
+	__u32 ifac_iport;
+
+	/* The list of ports on which an out-facing Stream identification
+	 * function in the input (coming from the physical interface) direction
+	 * .
+	 */
+	__u32 ofac_iport;
+
+	/* An enumerated value indicating the method used to identify packets
+	 * belonging to the Stream.
+	 * The Organizationally Unique Identifier (OUI) or Company Identifier
+	 * (CID) to identify the organization defining the enumerated type
+	 * should be: 00-80-C2
+	 * 1: null stream identification
+	 * 2: source mac and vlan stream identification
+	 * 3: activ destination mac and vlan stream identification
+	 * 4: ip stream identifaciton
+	 */
+	__u8 type;
+
+	/* tsnStreamIdParameters The number of controlling parameters for a
+	 * Stream identification method, their types and values, are specific
+	 * to the tsnStreamIdIdentificationType
+	 */
+	union {
+		struct tsn_cb_null_streamid nid;
+		struct tsn_cb_source_streamid sid;
+		struct tsn_cb_dest_streamid did;
+		struct tsn_cb_ip_streamid iid;
+	} para;
+};
+
+/* Following counters are instantiated for each port on which the Stream
+ * identification function (6.2) is configured. The counters are indexed by
+ * port number, facing (in-facing or out-facing), and stream_handle value
+ * (tsnStreamIdHandle, 9.1.1.1).
+ */
+struct tsn_cb_streamid_counters {
+	struct {
+		__u64 input;
+		__u64 output;
+	} per_stream;
+
+	struct {
+		__u64 input;
+		__u64 output;
+	} per_streamport[32];
+};
+
+/* 802.1Qci Stream Parameter Table, read from port */
+struct tsn_qci_psfp_stream_param {
+	/* MaxStreamFilterInstances.
+	 * The maximum number of Stream Filter instances supported by this
+	 * Bridge component.
+	 */
+	__s32 max_sf_instance;
+
+	/* MaxStreamGateInstances
+	 * The maximum number of Stream Gate instances supported by this Bridge
+	 * component.
+	 */
+	__s32 max_sg_instance;
+
+	/* MaxFlowMeterInstances
+	 * The maximum number of Flow Meter instances supported by this Bridge
+	 * component.
+	 */
+	__s32 max_fm_instance;
+
+	/* SupportedListMax
+	 * The maximum value supported by this Bridge component of the
+	 * AdminControlListLength and OperControlListLength parameters.
+	 */
+	__s32 supported_list_max;
+};
+
+/* 802.1Qci Stream Filter Instance Table, counters part only. */
+struct tsn_qci_psfp_sfi_counters {
+	/* The MatchingFramesCount counter counts received frames that match
+	 * this stream filter.
+	 */
+	__u64 matching_frames_count;
+
+	/* The PassingFramesCount counter counts received frames that pass the
+	 * gate associated with this stream filter.
+	 */
+	__u64 passing_frames_count;
+
+	/* The NotPassingFramesCount counter counts received frames that do not
+	 * pass the gate associated with this stream filter.
+	 */
+	__u64 not_passing_frames_count;
+
+	/* The PassingSDUCount counter counts received frames that pass the SDU
+	 * size filter specification associated with this stream filter.
+	 */
+	__u64 passing_sdu_count;
+
+	/* The NotPassingSDUCount counter counts received frames that do not
+	 * pass the SDU size filter specification associated with this stream
+	 * filter.
+	 */
+	__u64 not_passing_sdu_count;
+
+	/* The  REDFramesCount counter counts received random early detection
+	 * (RED) frames associated with this stream filter.
+	 */
+	__u64 red_frames_count;
+};
+
+/* 802.1Qci Stream Filter Instance Table, configuration part only. */
+struct tsn_qci_psfp_sfi_conf {
+
+	/* The StreamHandleSpec parameter contains a stream identifier
+	 * specification value. A value of -1 denotes the wild card value; zero
+	 * or positive values denote stream identifier values.
+	 */
+	__s32 stream_handle_spec;
+
+	/* The PrioritySpec parameter contains a priority specification value.
+	 * A value of -1 denotes the wild card value; zero or positive values
+	 * denote priority values.
+	 */
+	__s8 priority_spec;
+
+	/* The StreamGateInstanceID parameter contains the index of an entry in
+	 * the Stream Gate Table.
+	 */
+	__u32 stream_gate_instance_id;
+
+	/* The filter specifications. The actions specified in a filter
+	 * specification can result in a frame passing or failing the specified
+	 * filter. Frames that fail a filter are discarded.
+	 */
+	struct {
+		/* The MaximumSDUSize parameter specifies the maximum allowed
+		 * frame size for the stream. Any frame exceeding this value
+		 * will be dropped.  A value of 0 denote that the MaximumSDUSize
+		 * filter is disabled for this stream.
+		 */
+		__u16 maximum_sdu_size;
+
+		/* The FlowMeterInstanceID parameter contains the index of an
+		 * entry in the Flow Meter Table.  A value of -1 denotes that
+		 * no flow meter is assigned; zero or positive values denote
+		 * flow meter IDs.
+		 */
+		__s32 flow_meter_instance_id;
+	} stream_filter;
+
+	/* The StreamBlockedDueToOversizeFrameEnable object contains a Boolean
+	 * value that indicates whether the StreamBlockedDueToOversizeFrame
+	 * function is enabled (TRUE) or disabled (FALSE).
+	 */
+	__u8 block_oversize_enable;
+
+	/* The StreamBlockedDueToOversizeFrame object contains a Boolean value
+	 * that indicates whether, if the StreamBlockedDueToOversizeFrame
+	 * function is enabled, all frames are to be discarded (TRUE) or not
+	 * (FALSE).
+	 */
+	__u8 block_oversize;
+};
+
+/* 802.1Qci Stream Gate Control List Entry. */
+struct tsn_qci_psfp_gcl {
+	/* The GateState parameter specifies a desired state, open (true) or
+	 * closed (false), for the stream gate.
+	 */
+	__u8 gate_state;
+
+	/* An IPV is encoded as a signed integer.  A negative denotes the null
+	 * value; zero or positive values denote internal priority values.
+	 */
+	__s8 ipv;
+
+	/* A TimeInterval is encoded in 4 octets as a 32-bit unsigned integer,
+	 * representing a number of nanoseconds.
+	 */
+	__u32 time_interval;
+
+	/* The maximum number of octets that are permitted to pass the gate
+	 * during the specified TimeInterval.  If zero, there is no maximum.
+	 */
+	__u32 octet_max;
+
+};
+
+/* 802.1Qci Stream Gate Admin/Operation common list control parameters */
+struct tsn_qci_sg_control {
+	/* The administrative/operation value of the GateStates parameter
+	 * for the stream gate.  A value of false indicates closed;
+	 * a value of true indicates open.
+	 */
+	__u8 gate_states;
+
+	/* The administrative/operation value of the ListMax parameter for the
+	 * gate. The integer value indicates the number of entries (TLVs) in
+	 * the AdminControlList/OperControlList.
+	 */
+	__u8 control_list_length;
+
+	/* The administrative/operation value of the CycleTime parameter for
+	 * the gate.  The value is an unsigned integer number of nanoseconds.
+	 */
+	__u32 cycle_time;
+
+	/* The administrative/operation value of the CycleTimeExtension
+	 * parameter for the gate.  The value is an unsigned integer number
+	 * of nanoseconds.
+	 */
+	__u32 cycle_time_extension;
+
+	/* The administrative/operation value of the BaseTime parameter for the
+	 * gate.  The value is a representation of a PTPtime value, consisting
+	 * of a 48-bit integer number of seconds and a 32-bit integer number of
+	 * nanoseconds.
+	 */
+	ptptime_t base_time;
+
+	/* The administrative/operation value of the IPV parameter for the gate.
+	 * A value of -1 denotes the null value; zero or positive values denote
+	 * internal priority values.
+	 */
+	__s8 init_ipv;
+
+	/* control_list contend the gate control list of
+	 * administrative/operation
+	 */
+	struct tsn_qci_psfp_gcl *gcl;
+};
+
+/* 802.1Qci Stream Gate Instance Table, configuration part only. */
+struct tsn_qci_psfp_sgi_conf {
+	/* The GateEnabled parameter determines whether the stream gate is
+	 * active (true) or inactive (false).
+	 */
+	__u8 gate_enabled;
+
+	/* The ConfigChange parameter signals the start of a configuration
+	 * change when it is set to TRUE. This should only be done when the
+	 * various administrative parameters are all set to appropriate values.
+	 */
+	__u8 config_change;
+
+	/* admin control parameters with admin control list */
+	struct tsn_qci_sg_control admin;
+
+	/* The GateClosedDueToInvalidRxEnable object contains a Boolean value
+	 * that indicates whether the GateClosedDueToInvalidRx function is
+	 * enabled (TRUE) or disabled (FALSE).
+	 */
+	__u8 block_invalid_rx_enable;
+
+	/* The GateClosedDueToInvalidRx object contains a Boolean value that
+	 * indicates whether, if the GateClosedDueToInvalidRx function is
+	 * enabled, all frames are to be discarded (TRUE) or not (FALSE).
+	 */
+	__u8 block_invalid_rx;
+
+	/* The GateClosedDueToOctetsExceededEnable object contains a Boolean
+	 * value that indicates whether the GateClosedDueToOctetsExceeded
+	 * function is enabled (TRUE) or disabled (FALSE).
+	 */
+	__u8 block_octets_exceeded_enable;
+
+	/* The GateClosedDueToOctetsExceeded object contains a Boolean value
+	 * that indicates whether, if the GateClosedDueToOctetsExceeded
+	 * function is enabled, all frames are to be discarded (TRUE) or not
+	 * (FALSE).
+	 */
+	__u8 block_octets_exceeded;
+};
+
+/* 802.1Qci Stream Gate Instance Table, status part only. */
+struct tsn_psfp_sgi_status {
+
+	/* admin control parameters with admin control list */
+	struct tsn_qci_sg_control oper;
+
+	/* The PTPtime at which the next config change is scheduled to occur.
+	 * The value is a representation of a PTPtime value, consisting of a
+	 * 48-bit integer number of seconds and a 32-bit integer number of
+	 * nanoseconds.
+	 */
+	ptptime_t config_change_time;
+
+	/* The granularity of the cycle time clock, represented as an unsigned
+	 * number of tenths of nanoseconds.
+	 */
+	__u32 tick_granularity;
+
+	/* The current time, in PTPtime, as maintained by the local system.
+	 * The value is a representation of a PTPtime value, consisting of a
+	 * 48-bit integer number of seconds and a 32-bit integer number of
+	 * nanoseconds.
+	 */
+	ptptime_t current_time;
+
+	/* The value of the ConfigPending state machine variable.  The value is
+	 * TRUE if a configuration change is in progress but has not yet
+	 * completed.
+	 */
+	__u8 config_pending;
+
+	/* A counter of the number of times that a re-configuration of the
+	 * traffic schedule has been requested with the old schedule still
+	 * running and the requested base time was in the past.
+	 */
+	__u64 config_change_error;
+
+};
+
+/* 802.1Qci Flow Meter Instance Table. */
+struct tsn_qci_psfp_fmi {
+	/* The FlowMeterCIR parameter contains an integer value that represents
+	 * the CIR value for the flow meter, in kbit/s.
+	 */
+	__u32 cir;
+
+	/* The FlowMeterCBS parameter contains an integer value that represents
+	 * the CBS value for the flow meter, in octets.
+	 */
+	__u32 cbs;
+
+	/* The FlowMeterEIR parameter contains an integer value that represents
+	 * the EIR value for the flow meter, in kbit/s.
+	 */
+	__u32 eir;
+
+	/* The FlowMeterEBS parameter contains an integer value that represents
+	 * the EBS value for the flow meter, in octets.
+	 */
+	__u32 ebs;
+
+	/* The FlowMeterCF parameter contains a Boolean value that represents
+	 * the CF value for the flow meter, as a Boolean value indicating no
+	 * coupling (FALSE) or coupling (TRUE).
+	 */
+	__u8 cf;
+
+	/* The FlowMeterCM parameter contains a Boolean value that represents
+	 * the CM value for the flow meter, as a Boolean value indicating
+	 * colorBlind (FALSE) or colorAware (TRUE).
+	 */
+	__u8 cm;
+
+	/* The FlowMeterDropOnYellow parameter contains a Boolean value that
+	 * indicates whether yellow frames are dropped (TRUE) or have
+	 * drop_eligible set to TRUE (FALSE).
+	 */
+	__u8 drop_on_yellow;
+
+	/* The FlowMeterMarkAllFramesRedEnable parameter contains a Boolean
+	 * value that indicates whether the MarkAllFramesRed function
+	 * is enabled (TRUE) or disabled (FALSE).
+	 */
+	__u8 mark_red_enable;
+
+	/* The FlowMeterMarkAllFramesRed parameter contains a Boolean value
+	 * that indicates whether, if the MarkAllFramesRed function is enabled,
+	 * all frames are to be discarded (TRUE) or not (FALSE).
+	 */
+	__u8 mark_red;
+};
+
+struct tsn_qci_psfp_fmi_counters {
+	__u64 bytecount;
+	__u64 drop;
+	__u64 dr0_green;
+	__u64 dr1_green;
+	__u64 dr2_yellow;
+	__u64 remark_yellow;
+	__u64 dr3_red;
+	__u64 remark_red;
+};
+
+/* 802.1cb */
+struct tsn_seq_gen_conf {
+
+	/* The InputPortMask parameter contains a port mask.
+	 * If the packet is from input port belonging to this
+	 * port mask then it's on known stream and sequence
+	 * generation parameters can be applied.
+	 */
+	__u8 iport_mask;
+
+	/* The SplitMask parameter contains a output port mask
+	 * used to add redundant paths.
+	 */
+	__u8 split_mask;
+
+	/* The SequenceSpaceLenLog parameter is a value to specifies
+	 * number of bits to be used for sequence number.
+	 */
+	__u8 seq_len;
+
+	/* The SequenceNumber parameter is a value to used for
+	 * outgoing packet's sequence number generation.
+	 */
+	__u32 seq_num;
+};
+
+struct tsn_seq_rec_conf {
+
+	/* The SequenceSpaceLenLog parameter is a value to specifies
+	 * number of bits to be used for sequence number.
+	 */
+	__u8 seq_len;
+
+	/* The HistorySpaceLenLog parameter is a value to specifies
+	 * number of bits to be used for history register.
+	 */
+	__u8 his_len;
+
+	/* The RTagPopEnable parameter contains a __u8 to enable removal
+	 * of redundancy tag from the packet.
+	 */
+	__u8 rtag_pop_en;
+};
+
+struct tsn_cb_status {
+
+	/* The GenRecover parameter contains a value specifies type
+	 * of stream sequence parameters:
+	 *	0: Stream sequence parameters are for generation.
+	 *	1: Stream sequence parameters are for recovery.
+	 */
+	__u8 gen_rec;
+
+	/* The ErrStatus parameter indicates stream's error status
+	 * 1: This switch is expected to sequence the stream,
+	 *    but the incoming packet has sequence number.
+	 * 2: This switch is expected to recover the stream,
+	 *    but the incoming packet is NONSEQ.
+	 */
+	__u8 err;
+
+	/* The SequenceNumber parameter is a value to used for
+	 * outgoing packet's sequence number generation.
+	 */
+	__u32 seq_num;
+
+	/* The SequenceSpaceLenLog parameter is a value to specifies
+	 * number of bits to be used for sequence number.
+	 */
+	__u8 seq_len;
+
+	/* The SplitMask parameter contains a output port mask
+	 * used to add redundant paths.
+	 */
+	__u8 split_mask;
+
+	/* The InputPortMask parameter contains a port mask.
+	 * If the packet is from input port belonging to this
+	 * port mask then it's on known stream and sequence
+	 * generation parameters can be applied.
+	 */
+	__u8 iport_mask;
+
+	/* The HistorySpaceLenLog parameter is a value to specifies
+	 * number of bits to be used for history register.
+	 */
+	__u8 his_len;
+
+	/* The SequenceHistory parameter Maintains history of sequence
+	 * numbers of received packets.
+	 */
+	__u32 seq_his;
+};
+
+/* An entry for gate control list */
+struct tsn_qbv_entry {
+	/* Octet represent the gate states for the corresponding traffic
+	 * classes.
+	 * The MS bit corresponds to traffic class 7.
+	 * The LS bit to traffic class 0.
+	 * A bit value of 0 indicates closed;
+	 * A bit value of 1 indicates open.
+	 */
+	__u8 gate_state;
+
+	/* A TimeInterval is encoded in 4 octets as a 32-bit unsigned integer,
+	 * representing a number of nanoseconds.
+	 */
+	__u32 time_interval;
+};
+
+/* The administrative/operation time and gate list */
+struct tsn_qbv_basic {
+	/* The administrative/operation value of the GateStates parameter for
+	 * the Port.
+	 * The bits of the octet represent the gate states for the
+	 * corresponding traffic classes; the MS bit corresponds to traffic
+	 * class 7, the LS bit to traffic class 0. A bit value of 0 indicates
+	 * closed; a bit value of 1 indicates open.
+	 * The value of this object MUST be retained
+	 * across reinitializations of the management system.
+	 */
+	__u8 gate_states;
+
+	/* The administrative/operation value of the ListMax parameter for the
+	 * port. The integer value indicates the number of entries (TLVs) in
+	 * the AdminControlList. The value of this object MUST be retained
+	 * across reinitializations of the management system.
+	 */
+	__u32 control_list_length;
+
+	/* The administrative/operation value of the AdminCycleTime
+	 * parameter for the Port. The numerator and denominator together
+	 * represent the cycle time as a rational number of seconds.  The value
+	 * of this object MUST be retained across reinitializations of the
+	 * management system.
+	 */
+	__u32 cycle_time;
+
+	/* The administrative/operation value of the CycleTimeExtension
+	 * parameter for the Port. The value is an unsigned integer number of
+	 * nanoseconds.
+	 * The value of this object MUST be retained across reinitializations
+	 * of the management system.
+	 */
+
+	__u32 cycle_time_extension;
+
+	/* The administrative/operation value of the BaseTime parameter for the
+	 * Port.  The value is a representation of a PTPtime value, consisting
+	 * of a 48-bit integer number of seconds and a 32-bit integer number of
+	 * nanoseconds.
+	 * The value of this object MUST be retained across reinitializations of
+	 * the management system.
+	 */
+	ptptime_t base_time;
+
+	/* admin_control_list represent the AdminControlList/OperControlList.
+	 * The administrative version of the gate control list for the Port.
+	 */
+	struct tsn_qbv_entry *control_list;
+};
+
+struct tsn_qbv_conf {
+	/* The GateEnabled parameter determines whether traffic scheduling is
+	 * active (true) or inactive (false).  The value of this object MUST be
+	 * retained across reinitializations of the management system.
+	 */
+	__u8 gate_enabled;
+
+	/* The maxsdu parameter denoting the maximum SDU size supported by the
+	 * queue.
+	 */
+	__u32 maxsdu;
+
+	/* The ConfigChange parameter signals the start of a configuration
+	 * change when it is set to TRUE. This should only be done when the
+	 * various administrative parameters are all set to appropriate values.
+	 */
+	__u8 config_change;
+
+	/* The admin parameter signals the admin relate cycletime, basictime,
+	 * gatelist paraters.
+	 */
+	struct tsn_qbv_basic admin;
+};
+
+/* 802.1Qbv (Time Aware Shaper) port status */
+struct tsn_qbv_status {
+	/* The PTPtime at which the next config change is scheduled to occur.
+	 * The value is a representation of a PTPtime value, consisting of a
+	 * 48-bit integer number of seconds and a 32-bit integer number of
+	 * nanoseconds.  The value of this object MUST be retained across
+	 * reinitializations of the management system.
+	 */
+	ptptime_t config_change_time;
+
+	/* The granularity of the cycle time clock, represented as an unsigned
+	 * number of tenths of nanoseconds.  The value of this object MUST be
+	 * retained across reinitializations of the management system.
+	 */
+	__u32 tick_granularity;
+
+	/* The current time, in PTPtime, as maintained by the local system.
+	 * The value is a representation of a PTPtime value, consisting of a
+	 * 48-bit integer number of seconds and a 32-bit integer number of
+	 * nanoseconds.
+	 */
+	ptptime_t  current_time;
+
+	/* The value of the ConfigPending state machine variable.  The value is
+	 * TRUE if a configuration change is in progress but has not yet
+	 * completed.
+	 */
+	__u8 config_pending;
+
+	/* A counter of the number of times that a re-configuration of the
+	 * traffic schedule has been requested with the old schedule still
+	 * running and the requested base time was in the past.
+	 */
+	__u64 config_change_error;
+
+	/* The maximum value supported by this Port of the
+	 * AdminControlListLength and OperControlListLength parameters.
+	 */
+	__u32 supported_list_max;
+
+	/* Operation settings parameters and Oper gate list */
+	struct tsn_qbv_basic oper;
+};
+
+/* Time Specific Departure parameters */
+struct tsn_tsd {
+	__u8 enable;
+
+	/* The cycle time, in units of microsecond(us)*/
+	__u32 period;
+
+	/* The maximum number of frames which could be transmitted on one cycle
+	 *  The exceeding frames will be transmitted on next cycle.
+	 */
+	__u32 maxFrameNum;
+
+	/* Specify the time of the first cycle begins.
+	 *      1:  begin when the queue get the first frame to transmit.
+	 *      2:  begin immediately at the end of setting function.
+	 */
+	__u32 syn_flag;
+};
+
+struct tsn_tsd_status {
+	__u8 enable;
+	__u32 period;
+	__u32 maxFrameNum;
+	__u32 flag;
+	__u32 cycleNum;
+	__u32 loss_steps;
+};
+
+struct tsn_qos_switch_dscp_conf {
+	__u8 trust;
+	__u8 cos;
+	__u8 dpl;
+	__u8 remark;
+	__u8 dscp; /* New ingress translated DSCP value */
+};
+
+#endif /* _UAPI_GENL_TSN_H */
diff --git a/include/uapi/linux/videodev2.h b/include/uapi/linux/videodev2.h
index 534eaa4d3..52a057700 100644
--- a/include/uapi/linux/videodev2.h
+++ b/include/uapi/linux/videodev2.h
@@ -247,6 +247,12 @@ enum v4l2_colorspace {
 
 	/* DCI-P3 colorspace, used by cinema projectors */
 	V4L2_COLORSPACE_DCI_P3        = 12,
+
+	/* Generic film (colour filters using Illuminant C) */
+	V4L2_COLORSPACE_GENERIC_FILM  = 13,
+
+	/* SMPTE ST 428-1 */
+	V4L2_COLORSPACE_ST428         = 14,
 };
 
 /*
@@ -276,6 +282,20 @@ enum v4l2_xfer_func {
 	 * V4L2_COLORSPACE_RAW: V4L2_XFER_FUNC_NONE
 	 *
 	 * V4L2_COLORSPACE_DCI_P3: V4L2_XFER_FUNC_DCI_P3
+	 *
+	 * V4L2_XFER_FUNC_LINEAR: Linear transfer characteristics
+	 *
+	 * V4L2_XFER_FUNC_GAMMA22: Assumed display gamma 2.2
+	 *
+	 * V4L2_XFER_FUNC_GAMMA28: Assumed display gamma 2.8
+	 *
+	 * V4L2_XFER_FUNC_HLG: STD-B67, Rec. ITU-R BT.2100-2 hybrid-log-gamma
+	 *
+	 * V4L2_XFER_FUNC_XVYCC: IEC 61966-2-4
+	 *
+	 * V4L2_XFER_FUNC_BT1361: Rec. ITU-R BT.1361-0 extended colour gamut
+	 *
+	 * V4L2_XFER_FUNC_ST428: SMPTE ST 428-1
 	 */
 	V4L2_XFER_FUNC_DEFAULT     = 0,
 	V4L2_XFER_FUNC_709         = 1,
@@ -285,6 +305,13 @@ enum v4l2_xfer_func {
 	V4L2_XFER_FUNC_NONE        = 5,
 	V4L2_XFER_FUNC_DCI_P3      = 6,
 	V4L2_XFER_FUNC_SMPTE2084   = 7,
+	V4L2_XFER_FUNC_LINEAR      = 8,
+	V4L2_XFER_FUNC_GAMMA22     = 9,
+	V4L2_XFER_FUNC_GAMMA28     = 10,
+	V4L2_XFER_FUNC_HLG         = 11,
+	V4L2_XFER_FUNC_XVYCC       = 12,
+	V4L2_XFER_FUNC_BT1361      = 13,
+	V4L2_XFER_FUNC_ST428       = 14,
 };
 
 /*
@@ -345,6 +372,9 @@ enum v4l2_ycbcr_encoding {
 
 	/* SMPTE 240M -- Obsolete HDTV */
 	V4L2_YCBCR_ENC_SMPTE240M      = 8,
+
+	/* KR=0.30, KB=0.11 or equivalent */
+	V4L2_YCBCR_ENC_BT470_6M       = 9,
 };
 
 /*
@@ -562,6 +592,8 @@ struct v4l2_pix_format {
 #define V4L2_PIX_FMT_ARGB32  v4l2_fourcc('B', 'A', '2', '4') /* 32  ARGB-8-8-8-8  */
 #define V4L2_PIX_FMT_XRGB32  v4l2_fourcc('B', 'X', '2', '4') /* 32  XRGB-8-8-8-8  */
 
+#define V4L2_PIX_FMT_RGBA    v4l2_fourcc('R', 'G', 'B', 'A') /* 32  RGBA-8-8-8-8  */
+
 /* Grey formats */
 #define V4L2_PIX_FMT_GREY    v4l2_fourcc('G', 'R', 'E', 'Y') /*  8  Greyscale     */
 #define V4L2_PIX_FMT_Y4      v4l2_fourcc('Y', '0', '4', ' ') /*  4  Greyscale     */
@@ -592,6 +624,7 @@ struct v4l2_pix_format {
 #define V4L2_PIX_FMT_YUV444  v4l2_fourcc('Y', '4', '4', '4') /* 16  xxxxyyyy uuuuvvvv */
 #define V4L2_PIX_FMT_YUV555  v4l2_fourcc('Y', 'U', 'V', 'O') /* 16  YUV-5-5-5     */
 #define V4L2_PIX_FMT_YUV565  v4l2_fourcc('Y', 'U', 'V', 'P') /* 16  YUV-5-6-5     */
+#define V4L2_PIX_FMT_YUV24   v4l2_fourcc('Y', 'U', 'V', '3') /* 24  YUV-8-8-8     */
 #define V4L2_PIX_FMT_YUV32   v4l2_fourcc('Y', 'U', 'V', '4') /* 32  YUV-8-8-8-8   */
 #define V4L2_PIX_FMT_AYUV32  v4l2_fourcc('A', 'Y', 'U', 'V') /* 32  AYUV-8-8-8-8  */
 #define V4L2_PIX_FMT_XYUV32  v4l2_fourcc('X', 'Y', 'U', 'V') /* 32  XYUV-8-8-8-8  */
@@ -2437,6 +2470,13 @@ struct v4l2_dbg_register {
 	__u64 val;
 } __attribute__ ((packed));
 
+/* VIDIOC_DBG_G_CHIP_IDENT */
+struct v4l2_dbg_chip_ident {
+	struct v4l2_dbg_match match;
+	__u32 ident;       /* chip identifier as specified in <media/v4l2-chip-ident.h> */
+	__u32 revision;    /* chip revision, chip specific */
+} __attribute__ ((packed));
+
 #define V4L2_CHIP_FL_READABLE (1 << 0)
 #define V4L2_CHIP_FL_WRITABLE (1 << 1)
 
@@ -2542,6 +2582,12 @@ struct v4l2_create_buffers {
 #define	VIDIOC_DBG_S_REGISTER	 _IOW('V', 79, struct v4l2_dbg_register)
 #define	VIDIOC_DBG_G_REGISTER	_IOWR('V', 80, struct v4l2_dbg_register)
 
+/* Experimental, meant for debugging, testing and internal use.
+   Never use this ioctl in applications!
+   Note: this ioctl is deprecated in favor of VIDIOC_DBG_G_CHIP_INFO and
+   will go away in the future. */
+#define VIDIOC_DBG_G_CHIP_IDENT _IOWR('V', 81, struct v4l2_dbg_chip_ident)
+
 #define VIDIOC_S_HW_FREQ_SEEK	 _IOW('V', 82, struct v4l2_hw_freq_seek)
 #define	VIDIOC_S_DV_TIMINGS	_IOWR('V', 87, struct v4l2_dv_timings)
 #define	VIDIOC_G_DV_TIMINGS	_IOWR('V', 88, struct v4l2_dv_timings)
diff --git a/include/video/dpu.h b/include/video/dpu.h
new file mode 100644
index 000000000..4115da97a
--- /dev/null
+++ b/include/video/dpu.h
@@ -0,0 +1,754 @@
+/*
+ * Copyright (C) 2016 Freescale Semiconductor, Inc.
+ * Copyright 2017-2020 NXP
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the
+ * Free Software Foundation; either version 2 of the License, or (at your
+ * option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+ * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * for more details.
+ */
+
+#ifndef __DRM_DPU_H__
+#define __DRM_DPU_H__
+
+#include <drm/drm_crtc.h>
+#include <drm/drm_modes.h>
+#include <video/videomode.h>
+
+struct dpu_soc;
+
+enum dpu_irq {
+	IRQ_STORE9_SHDLOAD		= 0,
+	IRQ_STORE9_FRAMECOMPLETE	= 1,
+	IRQ_STORE9_SEQCOMPLETE		= 2,
+	IRQ_EXTDST0_SHDLOAD		= 3,
+	IRQ_EXTDST0_FRAMECOMPLETE	= 4,
+	IRQ_EXTDST0_SEQCOMPLETE		= 5,
+	IRQ_EXTDST4_SHDLOAD		= 6,
+	IRQ_EXTDST4_FRAMECOMPLETE	= 7,
+	IRQ_EXTDST4_SEQCOMPLETE		= 8,
+	IRQ_EXTDST1_SHDLOAD		= 9,
+	IRQ_EXTDST1_FRAMECOMPLETE	= 10,
+	IRQ_EXTDST1_SEQCOMPLETE		= 11,
+	IRQ_EXTDST5_SHDLOAD		= 12,
+	IRQ_EXTDST5_FRAMECOMPLETE	= 13,
+	IRQ_EXTDST5_SEQCOMPLETE		= 14,
+	IRQ_DISENGCFG_SHDLOAD0		= 15,
+	IRQ_DISENGCFG_FRAMECOMPLETE0	= 16,
+	IRQ_DISENGCFG_SEQCOMPLETE0	= 17,
+	IRQ_FRAMEGEN0_INT0		= 18,
+	IRQ_FRAMEGEN0_INT1		= 19,
+	IRQ_FRAMEGEN0_INT2		= 20,
+	IRQ_FRAMEGEN0_INT3		= 21,
+	IRQ_SIG0_SHDLOAD		= 22,
+	IRQ_SIG0_VALID			= 23,
+	IRQ_SIG0_ERROR			= 24,
+	IRQ_DISENGCFG_SHDLOAD1		= 25,
+	IRQ_DISENGCFG_FRAMECOMPLETE1	= 26,
+	IRQ_DISENGCFG_SEQCOMPLETE1	= 27,
+	IRQ_FRAMEGEN1_INT0		= 28,
+	IRQ_FRAMEGEN1_INT1		= 29,
+	IRQ_FRAMEGEN1_INT2		= 30,
+	IRQ_FRAMEGEN1_INT3		= 31,
+	IRQ_SIG1_SHDLOAD		= 32,
+	IRQ_SIG1_VALID			= 33,
+	IRQ_SIG1_ERROR			= 34,
+	IRQ_RESERVED			= 35,
+	IRQ_CMDSEQ_ERROR		= 36,
+	IRQ_COMCTRL_SW0			= 37,
+	IRQ_COMCTRL_SW1			= 38,
+	IRQ_COMCTRL_SW2			= 39,
+	IRQ_COMCTRL_SW3			= 40,
+	IRQ_FRAMEGEN0_PRIMSYNC_ON	= 41,
+	IRQ_FRAMEGEN0_PRIMSYNC_OFF	= 42,
+	IRQ_FRAMEGEN0_SECSYNC_ON	= 43,
+	IRQ_FRAMEGEN0_SECSYNC_OFF	= 44,
+	IRQ_FRAMEGEN1_PRIMSYNC_ON	= 45,
+	IRQ_FRAMEGEN1_PRIMSYNC_OFF	= 46,
+	IRQ_FRAMEGEN1_SECSYNC_ON	= 47,
+	IRQ_FRAMEGEN1_SECSYNC_OFF	= 48,
+};
+
+typedef enum {
+	ID_NONE		= 0x00,	/*  0 */
+	ID_FETCHDECODE9	= 0x01,	/*  1 */
+	ID_FETCHPERSP9	= 0x02,	/*  2 */
+	ID_FETCHECO9	= 0x03,	/*  3 */
+	ID_ROP9		= 0x04,	/*  4 */
+	ID_CLUT9	= 0x05,	/*  5 */
+	ID_MATRIX9	= 0x06,	/*  6 */
+	ID_HSCALER9	= 0x07,	/*  7 */
+	ID_VSCALER9	= 0x08,	/*  8 */
+	ID_FILTER9	= 0x09,	/*  9 */
+	ID_BLITBLEND9	= 0x0A,	/* 10 */
+	ID_CONSTFRAME0	= 0x0C,	/* 12 */
+	ID_CONSTFRAME4	= 0x0E,	/* 14 */
+	ID_CONSTFRAME1	= 0x10,	/* 16 */
+	ID_CONSTFRAME5	= 0x12,	/* 18 */
+	ID_FETCHWARP2	= 0x14,	/* 20 */
+	ID_FETCHECO2	= 0x15,	/* 21 */
+	ID_FETCHDECODE0	= 0x16,	/* 22 */
+	ID_FETCHECO0	= 0x17,	/* 23 */
+	ID_FETCHDECODE1	= 0x18,	/* 24 */
+	ID_FETCHECO1	= 0x19,	/* 25 */
+	ID_FETCHLAYER0	= 0x1a, /* 26 */
+	ID_MATRIX4	= 0x1B,	/* 27 */
+	ID_HSCALER4	= 0x1C,	/* 28 */
+	ID_VSCALER4	= 0x1D,	/* 29 */
+	ID_MATRIX5	= 0x1E,	/* 30 */
+	ID_HSCALER5	= 0x1F,	/* 31 */
+	ID_VSCALER5	= 0x20,	/* 32 */
+	ID_LAYERBLEND0	= 0x21,	/* 33 */
+	ID_LAYERBLEND1	= 0x22,	/* 34 */
+	ID_LAYERBLEND2	= 0x23,	/* 35 */
+	ID_LAYERBLEND3	= 0x24,	/* 36 */
+} dpu_block_id_t;
+
+typedef enum {
+	DEC_SIG_SEL_FRAMEGEN = 0,
+	DEC_SIG_SEL_GAMMACOR,
+	DEC_SIG_SEL_MATRIX,
+	DEC_SIG_SEL_DITHER,
+} dec_sig_sel_t;
+
+typedef enum {
+	ED_SRC_DISABLE		= ID_NONE,
+	ED_SRC_BLITBLEND9	= ID_BLITBLEND9,
+	ED_SRC_CONSTFRAME0	= ID_CONSTFRAME0,
+	ED_SRC_CONSTFRAME1	= ID_CONSTFRAME1,
+	ED_SRC_CONSTFRAME4	= ID_CONSTFRAME4,
+	ED_SRC_CONSTFRAME5	= ID_CONSTFRAME5,
+	ED_SRC_MATRIX4		= ID_MATRIX4,
+	ED_SRC_HSCALER4		= ID_HSCALER4,
+	ED_SRC_VSCALER4		= ID_VSCALER4,
+	/* content stream(extdst 0/1) only */
+	ED_SRC_MATRIX5		= ID_MATRIX5,
+	ED_SRC_HSCALER5		= ID_HSCALER5,
+	ED_SRC_VSCALER5		= ID_VSCALER5,
+	/* content stream(extdst 0/1) only */
+	ED_SRC_LAYERBLEND3	= ID_LAYERBLEND3,
+	ED_SRC_LAYERBLEND2	= ID_LAYERBLEND2,
+	ED_SRC_LAYERBLEND1	= ID_LAYERBLEND1,
+	ED_SRC_LAYERBLEND0	= ID_LAYERBLEND0,
+} extdst_src_sel_t;
+
+typedef enum {
+	SINGLE,	/* Reconfig pipeline after explicit trigger */
+	AUTO,	/* Reconfig pipeline after every kick when idle */
+} ed_sync_mode_t;
+
+typedef enum {
+	PSTATUS_EMPTY,
+	PSTATUS_RUNNING,
+	PSTATUS_RUNNING_RETRIGGERED,
+	PSTATUS_RESERVED
+} ed_pipeline_status_t;
+
+typedef enum {
+	SOFTWARE = 0,		/* kick generation by KICK field only */
+	EXTERNAL = BIT(8),	/* kick signal from external allowed */
+} ed_kick_mode_t;
+
+typedef enum {
+	FD_SRC_DISABLE		= ID_NONE,
+	FD_SRC_FETCHECO0	= ID_FETCHECO0,
+	FD_SRC_FETCHECO1	= ID_FETCHECO1,
+	FD_SRC_FETCHECO2	= ID_FETCHECO2,
+	FD_SRC_FETCHDECODE0	= ID_FETCHDECODE0,
+	FD_SRC_FETCHDECODE1	= ID_FETCHDECODE1,
+	FD_SRC_FETCHWARP2	= ID_FETCHWARP2,
+} fd_dynamic_src_sel_t;
+
+typedef enum {
+	/* RL and RLAD decoder */
+	FETCHTYPE__DECODE,
+	/* fractional plane(8 layers) */
+	FETCHTYPE__LAYER,
+	/* arbitrary warping and fractional plane(8 layers) */
+	FETCHTYPE__WARP,
+	/* minimum feature set for alpha, chroma and coordinate planes */
+	FETCHTYPE__ECO,
+	/* affine, perspective and arbitrary warping */
+	FETCHTYPE__PERSP,
+	/* affine and arbitrary warping */
+	FETCHTYPE__ROT,
+	/* RL and RLAD decoder, reduced feature set */
+	FETCHTYPE__DECODEL,
+	/* fractional plane(8 layers), reduced feature set */
+	FETCHTYPE__LAYERL,
+	/* affine and arbitrary warping, reduced feature set */
+	FETCHTYPE__ROTL,
+} fetchtype_t;
+
+typedef enum {
+	/* No side-by-side synchronization. */
+	FGSYNCMODE__OFF = 0,
+	/* Framegen is master. */
+	FGSYNCMODE__MASTER = 1 << 1,
+	/* Runs in cyclic synchronization mode. */
+	FGSYNCMODE__SLAVE_CYC = 2 << 1,
+	/* Runs in one time synchronization mode. */
+	FGSYNCMODE__SLAVE_ONCE = 3 << 1,
+} fgsyncmode_t;
+
+typedef enum {
+	FGDM__BLACK,
+	/* Constant Color Background is shown. */
+	FGDM__CONSTCOL,
+	FGDM__PRIM,
+	FGDM__SEC,
+	FGDM__PRIM_ON_TOP,
+	FGDM__SEC_ON_TOP,
+	/* White color background with test pattern is shown. */
+	FGDM__TEST,
+} fgdm_t;
+
+typedef enum {
+	HS_SRC_SEL__DISABLE		= ID_NONE,
+	HS_SRC_SEL__MATRIX9		= ID_MATRIX9,
+	HS_SRC_SEL__VSCALER9		= ID_VSCALER9,
+	HS_SRC_SEL__FILTER9		= ID_FILTER9,
+	HS_SRC_SEL__FETCHDECODE0	= ID_FETCHDECODE0,
+	HS_SRC_SEL__FETCHDECODE1	= ID_FETCHDECODE1,
+	HS_SRC_SEL__MATRIX4		= ID_MATRIX4,
+	HS_SRC_SEL__VSCALER4		= ID_VSCALER4,
+	HS_SRC_SEL__MATRIX5		= ID_MATRIX5,
+	HS_SRC_SEL__VSCALER5		= ID_VSCALER5,
+} hs_src_sel_t;
+
+typedef enum {
+	/* common options */
+	LB_PRIM_SEL__DISABLE		= ID_NONE,
+	LB_PRIM_SEL__BLITBLEND9		= ID_BLITBLEND9,
+	LB_PRIM_SEL__CONSTFRAME0	= ID_CONSTFRAME0,
+	LB_PRIM_SEL__CONSTFRAME1	= ID_CONSTFRAME1,
+	LB_PRIM_SEL__CONSTFRAME4	= ID_CONSTFRAME4,
+	LB_PRIM_SEL__CONSTFRAME5	= ID_CONSTFRAME5,
+	LB_PRIM_SEL__MATRIX4		= ID_MATRIX4,
+	LB_PRIM_SEL__HSCALER4		= ID_HSCALER4,
+	LB_PRIM_SEL__VSCALER4		= ID_VSCALER4,
+	LB_PRIM_SEL__MATRIX5		= ID_MATRIX5,
+	LB_PRIM_SEL__HSCALER5		= ID_HSCALER5,
+	LB_PRIM_SEL__VSCALER5		= ID_VSCALER5,
+	/*
+	 * special options:
+	 * layerblend(n) has n special options,
+	 * from layerblend0 to layerblend(n - 1), e.g.,
+	 * layerblend3 has 3 special options -
+	 * layerblend0/1/2.
+	 */
+	LB_PRIM_SEL__LAYERBLEND3	= ID_LAYERBLEND3,
+	LB_PRIM_SEL__LAYERBLEND2	= ID_LAYERBLEND2,
+	LB_PRIM_SEL__LAYERBLEND1	= ID_LAYERBLEND1,
+	LB_PRIM_SEL__LAYERBLEND0	= ID_LAYERBLEND0,
+} lb_prim_sel_t;
+
+typedef enum {
+	LB_SEC_SEL__DISABLE		= ID_NONE,
+	LB_SEC_SEL__FETCHWARP2		= ID_FETCHWARP2,
+	LB_SEC_SEL__FETCHDECODE0	= ID_FETCHDECODE0,
+	LB_SEC_SEL__FETCHDECODE1	= ID_FETCHDECODE1,
+	LB_SEC_SEL__MATRIX4		= ID_MATRIX4,
+	LB_SEC_SEL__HSCALER4		= ID_HSCALER4,
+	LB_SEC_SEL__VSCALER4		= ID_VSCALER4,
+	LB_SEC_SEL__MATRIX5		= ID_MATRIX5,
+	LB_SEC_SEL__HSCALER5		= ID_HSCALER5,
+	LB_SEC_SEL__VSCALER5		= ID_VSCALER5,
+	LB_SEC_SEL__FETCHLAYER0		= ID_FETCHLAYER0,
+} lb_sec_sel_t;
+
+typedef enum {
+	PRIMARY,	/* background plane */
+	SECONDARY,	/* foreground plane */
+	BOTH,
+} lb_shadow_sel_t;
+
+typedef enum {
+	LB_NEUTRAL,	/* Output is same as primary input. */
+	LB_BLEND,
+} lb_mode_t;
+
+typedef enum {
+	/* Constant 0 indicates frame or top field. */
+	SCALER_ALWAYS0 = 0x0,
+	/* Constant 1 indicates bottom field. */
+	SCALER_ALWAYS1 = 0x1 << 12,
+	/* Output field polarity is taken from input field polarity. */
+	SCALER_INPUT = 0x2 << 12,
+	/* Output field polarity toggles, starting with 0 after reset. */
+	SCALER_TOGGLE = 0x3 << 12,
+} scaler_field_mode_t;
+
+typedef enum {
+	/* pointer-sampling */
+	SCALER_NEAREST = 0x0,
+	/* box filter */
+	SCALER_LINEAR = 0x100,
+} scaler_filter_mode_t;
+
+typedef enum {
+	SCALER_DOWNSCALE = 0x0,
+	SCALER_UPSCALE = 0x10,
+} scaler_scale_mode_t;
+
+typedef enum {
+	/* Pixel by-pass the scaler, all other settings are ignored. */
+	SCALER_NEUTRAL = 0x0,
+	/* Scaler is active. */
+	SCALER_ACTIVE = 0x1,
+} scaler_mode_t;
+
+typedef enum {
+	VS_SRC_SEL__DISABLE		= ID_NONE,
+	VS_SRC_SEL__MATRIX9		= ID_MATRIX9,
+	VS_SRC_SEL__HSCALER9		= ID_HSCALER9,
+	VS_SRC_SEL__FETCHDECODE0	= ID_FETCHDECODE0,
+	VS_SRC_SEL__FETCHDECODE1	= ID_FETCHDECODE1,
+	VS_SRC_SEL__MATRIX4		= ID_MATRIX4,
+	VS_SRC_SEL__HSCALER4		= ID_HSCALER4,
+	VS_SRC_SEL__MATRIX5		= ID_MATRIX5,
+	VS_SRC_SEL__HSCALER5		= ID_HSCALER5,
+} vs_src_sel_t;
+
+#define CLKEN_MASK		(0x3 << 24)
+#define CLKEN_MASK_SHIFT	24
+typedef enum {
+	CLKEN__DISABLE = 0x0,
+	CLKEN__AUTOMATIC = 0x1,
+	CLKEN__FULL = 0x3,
+} pixengcfg_clken_t;
+
+/* fetch unit types */
+enum {
+	FU_T_NA,
+	FU_T_FD,
+	FU_T_FE,
+	FU_T_FL,
+	FU_T_FW,
+};
+
+enum dpu_crc_source {
+	DPU_CRC_SRC_NONE,
+	DPU_CRC_SRC_FRAMEGEN,
+	DPU_CRC_SRC_FRAMEGEN_ROI,
+};
+
+struct dpu_fetchunit;
+
+struct dpu_fetchunit_ops {
+	void (*set_burstlength)(struct dpu_fetchunit *fu,
+			        unsigned int x_offset, unsigned int mt_w,
+			        int bpp, dma_addr_t baddr, bool use_prefetch);
+
+	void (*set_baseaddress)(struct dpu_fetchunit *fu, unsigned int width,
+			        unsigned int x_offset, unsigned int y_offset,
+			        unsigned int mt_w, unsigned int mt_h,
+			        int bpp, dma_addr_t baddr);
+
+	void (*set_src_bpp)(struct dpu_fetchunit *fu, int bpp);
+
+	void (*set_src_stride)(struct dpu_fetchunit *fu,
+			       unsigned int width, unsigned int x_offset,
+			       unsigned int mt_w, int bpp, unsigned int stride,
+			       dma_addr_t baddr, bool use_prefetch);
+
+	void (*set_src_buf_dimensions)(struct dpu_fetchunit *fu,
+				       unsigned int w, unsigned int h, u32 fmt,
+				       bool deinterlace);
+
+	void (*set_fmt)(struct dpu_fetchunit *fu, u32 fmt,
+			enum drm_color_encoding color_encoding,
+			enum drm_color_range color_range,
+			bool deinterlace);
+
+	void (*set_pixel_blend_mode)(struct dpu_fetchunit *fu,
+				     unsigned int pixel_blend_mode, u16 alpha,
+				     u32 fb_format);
+
+	void (*enable_src_buf)(struct dpu_fetchunit *fu);
+	void (*disable_src_buf)(struct dpu_fetchunit *fu);
+	bool (*is_enabled)(struct dpu_fetchunit *fu);
+
+	void (*set_framedimensions)(struct dpu_fetchunit *fu,
+				    unsigned int w, unsigned int h,
+				    bool deinterlace);
+
+	void (*set_controltrigger)(struct dpu_fetchunit *fu);
+
+	unsigned int (*get_stream_id)(struct dpu_fetchunit *fu);
+	void (*set_stream_id)(struct dpu_fetchunit *fu, unsigned int id);
+};
+
+struct dpu_fetchunit {
+	void __iomem *pec_base;
+	void __iomem *base;
+	char *name;
+	struct mutex mutex;
+	int id;
+	int sub_id;	/* for fractional fetch units */
+	int type;
+	bool inuse;
+	struct dpu_soc *dpu;
+	/* see DPU_PLANE_SRC_xxx */
+	unsigned int stream_id;
+	struct dprc *dprc;
+	const struct dpu_fetchunit_ops *ops;
+};
+
+int dpu_map_irq(struct dpu_soc *dpu, int irq);
+
+/* Constant Frame Unit */
+struct dpu_constframe;
+void constframe_shden(struct dpu_constframe *cf, bool enable);
+void constframe_framedimensions(struct dpu_constframe *cf, unsigned int w,
+				unsigned int h);
+void constframe_framedimensions_copy_prim(struct dpu_constframe *cf);
+void constframe_constantcolor(struct dpu_constframe *cf, unsigned int r,
+			      unsigned int g, unsigned int b, unsigned int a);
+void constframe_controltrigger(struct dpu_constframe *cf, bool trigger);
+struct dpu_constframe *dpu_cf_get(struct dpu_soc *dpu, int id);
+void dpu_cf_put(struct dpu_constframe *cf);
+struct dpu_constframe *dpu_aux_cf_peek(struct dpu_constframe *cf);
+
+/* Display Engine Configuration Unit */
+struct dpu_disengcfg;
+void disengcfg_sig_select(struct dpu_disengcfg *dec, dec_sig_sel_t sig_sel);
+struct dpu_disengcfg *dpu_dec_get(struct dpu_soc *dpu, int id);
+void dpu_dec_put(struct dpu_disengcfg *dec);
+struct dpu_disengcfg *dpu_aux_dec_peek(struct dpu_disengcfg *dec);
+
+/* External Destination Unit */
+struct dpu_extdst;
+void extdst_pixengcfg_shden(struct dpu_extdst *ed, bool enable);
+void extdst_pixengcfg_powerdown(struct dpu_extdst *ed, bool powerdown);
+void extdst_pixengcfg_sync_mode(struct dpu_extdst *ed, ed_sync_mode_t mode);
+void extdst_pixengcfg_reset(struct dpu_extdst *ed, bool reset);
+void extdst_pixengcfg_div(struct dpu_extdst *ed, u16 div);
+void extdst_pixengcfg_syncmode_master(struct dpu_extdst *ed, bool enable);
+int extdst_pixengcfg_src_sel(struct dpu_extdst *ed, extdst_src_sel_t src);
+void extdst_pixengcfg_sel_shdldreq(struct dpu_extdst *ed);
+void extdst_pixengcfg_shdldreq(struct dpu_extdst *ed, u32 req_mask);
+void extdst_pixengcfg_sync_trigger(struct dpu_extdst *ed);
+void extdst_pixengcfg_trigger_sequence_complete(struct dpu_extdst *ed);
+bool extdst_pixengcfg_is_sync_busy(struct dpu_extdst *ed);
+ed_pipeline_status_t extdst_pixengcfg_pipeline_status(struct dpu_extdst *ed);
+void extdst_shden(struct dpu_extdst *ed, bool enable);
+void extdst_kick_mode(struct dpu_extdst *ed, ed_kick_mode_t mode);
+void extdst_perfcountmode(struct dpu_extdst *ed, bool enable);
+void extdst_gamma_apply_enable(struct dpu_extdst *ed, bool enable);
+void extdst_kick(struct dpu_extdst *ed);
+void extdst_cnt_err_clear(struct dpu_extdst *ed);
+bool extdst_cnt_err_status(struct dpu_extdst *ed);
+u32 extdst_last_control_word(struct dpu_extdst *ed);
+void extdst_pixel_cnt(struct dpu_extdst *ed, u16 *x, u16 *y);
+void extdst_last_pixel_cnt(struct dpu_extdst *ed, u16 *x, u16 *y);
+u32 extdst_perfresult(struct dpu_extdst *ed);
+bool extdst_is_master(struct dpu_extdst *ed);
+struct dpu_extdst *dpu_ed_get(struct dpu_soc *dpu, int id);
+void dpu_ed_put(struct dpu_extdst *ed);
+struct dpu_extdst *dpu_aux_ed_peek(struct dpu_extdst *ed);
+
+/* Fetch Decode Unit */
+int fetchdecode_pixengcfg_dynamic_src_sel(struct dpu_fetchunit *fu,
+					  fd_dynamic_src_sel_t src);
+void fetchdecode_layeroffset(struct dpu_fetchunit *fd, unsigned int x,
+			     unsigned int y);
+void fetchdecode_clipoffset(struct dpu_fetchunit *fd, unsigned int x,
+			    unsigned int y);
+void fetchdecode_clipdimensions(struct dpu_fetchunit *fd, unsigned int w,
+				unsigned int h);
+void fetchdecode_rgb_constantcolor(struct dpu_fetchunit *fd,
+					u8 r, u8 g, u8 b, u8 a);
+void fetchdecode_yuv_constantcolor(struct dpu_fetchunit *fd,
+					u8 y, u8 u, u8 v);
+int fetchdecode_fetchtype(struct dpu_fetchunit *fd, fetchtype_t *type);
+u32 fetchdecode_get_vproc_mask(struct dpu_fetchunit *fd);
+bool fetchdecode_need_fetcheco(struct dpu_fetchunit *fd, u32 fmt);
+struct dpu_fetchunit *dpu_fd_get(struct dpu_soc *dpu, int id);
+void dpu_fd_put(struct dpu_fetchunit *fu);
+
+/* Fetch ECO Unit */
+void fetcheco_layeroffset(struct dpu_fetchunit *fu, unsigned int x,
+			  unsigned int y);
+void fetcheco_clipoffset(struct dpu_fetchunit *fu, unsigned int x,
+			 unsigned int y);
+void fetcheco_clipdimensions(struct dpu_fetchunit *fu, unsigned int w,
+			     unsigned int h);
+void fetcheco_frameresampling(struct dpu_fetchunit *fu, unsigned int x,
+			      unsigned int y);
+int fetcheco_fetchtype(struct dpu_fetchunit *fu, fetchtype_t *type);
+dpu_block_id_t fetcheco_get_block_id(struct dpu_fetchunit *fu);
+struct dpu_fetchunit *dpu_fe_get(struct dpu_soc *dpu, int id);
+void dpu_fe_put(struct dpu_fetchunit *fu);
+
+/* Fetch Layer Unit */
+void fetchlayer_rgb_constantcolor(struct dpu_fetchunit *fu,
+					u8 r, u8 g, u8 b, u8 a);
+void fetchlayer_yuv_constantcolor(struct dpu_fetchunit *fu, u8 y, u8 u, u8 v);
+int fetchlayer_fetchtype(struct dpu_fetchunit *fu, fetchtype_t *type);
+struct dpu_fetchunit *dpu_fl_get(struct dpu_soc *dpu, int id);
+void dpu_fl_put(struct dpu_fetchunit *fu);
+
+/* Fetch Warp Unit */
+void fetchwarp_rgb_constantcolor(struct dpu_fetchunit *fu,
+				 u8 r, u8 g, u8 b, u8 a);
+void fetchwarp_yuv_constantcolor(struct dpu_fetchunit *fu, u8 y, u8 u, u8 v);
+int fetchwarp_fetchtype(struct dpu_fetchunit *fu, fetchtype_t *type);
+struct dpu_fetchunit *dpu_fw_get(struct dpu_soc *dpu, int id);
+void dpu_fw_put(struct dpu_fetchunit *fu);
+
+/* Frame Generator Unit */
+struct dpu_framegen;
+void framegen_enable(struct dpu_framegen *fg);
+void framegen_disable(struct dpu_framegen *fg);
+void framegen_enable_pixel_link(struct dpu_framegen *fg);
+void framegen_disable_pixel_link(struct dpu_framegen *fg);
+void framegen_shdtokgen(struct dpu_framegen *fg);
+void framegen_syncmode(struct dpu_framegen *fg, fgsyncmode_t mode);
+void framegen_cfg_videomode(struct dpu_framegen *fg, struct drm_display_mode *m,
+			    bool side_by_side, unsigned int encoder_type);
+void framegen_pkickconfig(struct dpu_framegen *fg, bool enable);
+void framegen_syncmode_fixup(struct dpu_framegen *fg, bool enable);
+void framegen_displaymode(struct dpu_framegen *fg, fgdm_t mode);
+void framegen_panic_displaymode(struct dpu_framegen *fg, fgdm_t mode);
+void framegen_wait_done(struct dpu_framegen *fg, struct drm_display_mode *m);
+void framegen_read_timestamp(struct dpu_framegen *fg,
+			     u32 *frame_index, u32 *line_index);
+void framegen_wait_for_frame_counter_moving(struct dpu_framegen *fg);
+bool framegen_secondary_requests_to_read_empty_fifo(struct dpu_framegen *fg);
+void framegen_secondary_clear_channel_status(struct dpu_framegen *fg);
+bool framegen_secondary_is_syncup(struct dpu_framegen *fg);
+void framegen_wait_for_secondary_syncup(struct dpu_framegen *fg);
+void framegen_enable_clock(struct dpu_framegen *fg);
+void framegen_disable_clock(struct dpu_framegen *fg);
+bool framegen_is_master(struct dpu_framegen *fg);
+bool framegen_is_slave(struct dpu_framegen *fg);
+struct dpu_framegen *dpu_fg_get(struct dpu_soc *dpu, int id);
+void dpu_fg_put(struct dpu_framegen *fg);
+struct dpu_framegen *dpu_aux_fg_peek(struct dpu_framegen *fg);
+
+/* Horizontal Scaler Unit */
+struct dpu_hscaler;
+int hscaler_pixengcfg_dynamic_src_sel(struct dpu_hscaler *hs, hs_src_sel_t src);
+void hscaler_pixengcfg_clken(struct dpu_hscaler *hs, pixengcfg_clken_t clken);
+void hscaler_shden(struct dpu_hscaler *hs, bool enable);
+void hscaler_setup1(struct dpu_hscaler *hs, unsigned int src, unsigned int dst);
+void hscaler_setup2(struct dpu_hscaler *hs, u32 phase_offset);
+void hscaler_output_size(struct dpu_hscaler *hs, u32 line_num);
+void hscaler_filter_mode(struct dpu_hscaler *hs, scaler_filter_mode_t m);
+void hscaler_scale_mode(struct dpu_hscaler *hs, scaler_scale_mode_t m);
+void hscaler_mode(struct dpu_hscaler *hs, scaler_mode_t m);
+bool hscaler_is_enabled(struct dpu_hscaler *hs);
+dpu_block_id_t hscaler_get_block_id(struct dpu_hscaler *hs);
+unsigned int hscaler_get_stream_id(struct dpu_hscaler *hs);
+void hscaler_set_stream_id(struct dpu_hscaler *hs, unsigned int id);
+struct dpu_hscaler *dpu_hs_get(struct dpu_soc *dpu, int id);
+void dpu_hs_put(struct dpu_hscaler *hs);
+
+/* Layer Blend Unit */
+struct dpu_layerblend;
+int layerblend_pixengcfg_dynamic_prim_sel(struct dpu_layerblend *lb,
+					  lb_prim_sel_t prim);
+void layerblend_pixengcfg_dynamic_sec_sel(struct dpu_layerblend *lb,
+					  lb_sec_sel_t sec);
+void layerblend_pixengcfg_clken(struct dpu_layerblend *lb,
+				pixengcfg_clken_t clken);
+void layerblend_shden(struct dpu_layerblend *lb, bool enable);
+void layerblend_shdtoksel(struct dpu_layerblend *lb, lb_shadow_sel_t sel);
+void layerblend_shdldsel(struct dpu_layerblend *lb, lb_shadow_sel_t sel);
+void layerblend_control(struct dpu_layerblend *lb, lb_mode_t mode);
+void layerblend_blendcontrol(struct dpu_layerblend *lb, unsigned int zpos,
+			     unsigned int pixel_blend_mode, u16 alpha);
+void layerblend_position(struct dpu_layerblend *lb, int x, int y);
+struct dpu_layerblend *dpu_lb_get(struct dpu_soc *dpu, int id);
+void dpu_lb_put(struct dpu_layerblend *lb);
+
+/* Signature Unit */
+#define MAX_DPU_SIGNATURE_WIN_NUM	8
+struct dpu_signature;
+void signature_shden(struct dpu_signature *sig, bool enable);
+void signature_shdldsel_local(struct dpu_signature *sig);
+void signature_shdldsel_global(struct dpu_signature *sig);
+void
+signature_global_panic(struct dpu_signature *sig, unsigned int win, bool enable);
+void
+signature_local_panic(struct dpu_signature *sig, unsigned int win, bool enable);
+void
+signature_alpha_mask(struct dpu_signature *sig, unsigned int win, bool enable);
+void signature_crc(struct dpu_signature *sig, unsigned int win, bool enable);
+void
+signature_eval_win(struct dpu_signature *sig, unsigned int win, bool enable);
+void signature_win(struct dpu_signature *sig, unsigned int win,
+		   int xul, int yul, int xlr, int ylr);
+void signature_crc_value(struct dpu_signature *sig, unsigned int win,
+			 u32 *red, u32 *green, u32 *blue);
+void signature_shdldreq(struct dpu_signature *sig, u8 win_mask);
+void signature_continuous_mode(struct dpu_signature *sig, bool enable);
+void signature_kick(struct dpu_signature *sig);
+bool signature_is_idle(struct dpu_signature *sig);
+void signature_wait_for_idle(struct dpu_signature *sig);
+bool signature_is_valid(struct dpu_signature *sig);
+bool signature_is_error(struct dpu_signature *sig, u8 *err_win_mask);
+struct dpu_signature *dpu_sig_get(struct dpu_soc *dpu, int id);
+void dpu_sig_put(struct dpu_signature *sig);
+struct dpu_signature *dpu_aux_sig_peek(struct dpu_signature *sig);
+
+/* Store Unit */
+struct dpu_store;
+void store_pixengcfg_syncmode_fixup(struct dpu_store *st, bool enable);
+struct dpu_store *dpu_st_get(struct dpu_soc *dpu, int id);
+void dpu_st_put(struct dpu_store *st);
+
+/* Timing Controller Unit */
+struct dpu_tcon;
+int tcon_set_fmt(struct dpu_tcon *tcon, u32 bus_format);
+void tcon_set_operation_mode(struct dpu_tcon *tcon);
+void tcon_cfg_videomode(struct dpu_tcon *tcon,
+			struct drm_display_mode *m, bool side_by_side);
+bool tcon_is_master(struct dpu_tcon *tcon);
+bool tcon_is_slave(struct dpu_tcon *tcon);
+void tcon_configure_pc(struct dpu_tcon *tcon, unsigned int di,
+			unsigned int frame_width, u32 mode, u32 format);
+void tcon_enable_pc(struct dpu_tcon *tcon);
+void tcon_disable_pc(struct dpu_tcon *tcon);
+struct dpu_tcon *dpu_tcon_get(struct dpu_soc *dpu, int id);
+void dpu_tcon_put(struct dpu_tcon *tcon);
+struct dpu_tcon *dpu_aux_tcon_peek(struct dpu_tcon *tcon);
+
+/* Vertical Scaler Unit */
+struct dpu_vscaler;
+int vscaler_pixengcfg_dynamic_src_sel(struct dpu_vscaler *vs, vs_src_sel_t src);
+void vscaler_pixengcfg_clken(struct dpu_vscaler *vs, pixengcfg_clken_t clken);
+void vscaler_shden(struct dpu_vscaler *vs, bool enable);
+void vscaler_setup1(struct dpu_vscaler *vs, u32 src, u32 dst, bool deinterlace);
+void vscaler_setup2(struct dpu_vscaler *vs, bool deinterlace);
+void vscaler_setup3(struct dpu_vscaler *vs, bool deinterlace);
+void vscaler_setup4(struct dpu_vscaler *vs, u32 phase_offset);
+void vscaler_setup5(struct dpu_vscaler *vs, u32 phase_offset);
+void vscaler_output_size(struct dpu_vscaler *vs, u32 line_num);
+void vscaler_field_mode(struct dpu_vscaler *vs, scaler_field_mode_t m);
+void vscaler_filter_mode(struct dpu_vscaler *vs, scaler_filter_mode_t m);
+void vscaler_scale_mode(struct dpu_vscaler *vs, scaler_scale_mode_t m);
+void vscaler_mode(struct dpu_vscaler *vs, scaler_mode_t m);
+bool vscaler_is_enabled(struct dpu_vscaler *vs);
+dpu_block_id_t vscaler_get_block_id(struct dpu_vscaler *vs);
+unsigned int vscaler_get_stream_id(struct dpu_vscaler *vs);
+void vscaler_set_stream_id(struct dpu_vscaler *vs, unsigned int id);
+struct dpu_vscaler *dpu_vs_get(struct dpu_soc *dpu, int id);
+void dpu_vs_put(struct dpu_vscaler *vs);
+
+struct dpu_fetchunit *fetchdecode_get_fetcheco(struct dpu_fetchunit *fu);
+struct dpu_hscaler *fetchdecode_get_hscaler(struct dpu_fetchunit *fu);
+struct dpu_vscaler *fetchdecode_get_vscaler(struct dpu_fetchunit *fu);
+
+unsigned int dpu_get_syncmode_min_prate(struct dpu_soc *dpu);
+unsigned int dpu_get_singlemode_max_width(struct dpu_soc *dpu);
+unsigned int dpu_get_master_stream_id(struct dpu_soc *dpu);
+
+bool dpu_vproc_has_fetcheco_cap(u32 cap_mask);
+bool dpu_vproc_has_hscale_cap(u32 cap_mask);
+bool dpu_vproc_has_vscale_cap(u32 cap_mask);
+
+u32 dpu_vproc_get_fetcheco_cap(u32 cap_mask);
+u32 dpu_vproc_get_hscale_cap(u32 cap_mask);
+u32 dpu_vproc_get_vscale_cap(u32 cap_mask);
+
+unsigned int fetchunit_burst_size_fixup_tkt343664(dma_addr_t baddr);
+unsigned int
+fetchunit_stride_fixup_tkt339017(unsigned int stride, unsigned int burst_size,
+				 dma_addr_t baddr, bool nonzero_mod);
+void fetchunit_get_dprc(struct dpu_fetchunit *fu, void *data);
+void fetchunit_shden(struct dpu_fetchunit *fu, bool enable);
+void fetchunit_baddr_autoupdate(struct dpu_fetchunit *fu, u8 layer_mask);
+void fetchunit_shdldreq_sticky(struct dpu_fetchunit *fu, u8 layer_mask);
+void fetchunit_set_burstlength(struct dpu_fetchunit *fu,
+			       unsigned int x_offset, unsigned int mt_w,
+			       int bpp, dma_addr_t baddr, bool use_prefetch);
+void fetchunit_set_baseaddress(struct dpu_fetchunit *fu, unsigned int width,
+			       unsigned int x_offset, unsigned int y_offset,
+			       unsigned int mt_w, unsigned int mt_h,
+			       int bpp, dma_addr_t baddr);
+void fetchunit_set_src_bpp(struct dpu_fetchunit *fu, int bpp);
+void fetchunit_set_src_stride(struct dpu_fetchunit *fu,
+			      unsigned int width, unsigned int x_offset,
+			      unsigned int mt_w, int bpp, unsigned int stride,
+			      dma_addr_t baddr, bool use_prefetch);
+void fetchunit_set_pixel_blend_mode(struct dpu_fetchunit *fu,
+				    unsigned int pixel_blend_mode, u16 alpha,
+				    u32 fb_format);
+void fetchunit_enable_src_buf(struct dpu_fetchunit *fu);
+void fetchunit_disable_src_buf(struct dpu_fetchunit *fu);
+bool fetchunit_is_enabled(struct dpu_fetchunit *fu);
+unsigned int fetchunit_get_stream_id(struct dpu_fetchunit *fu);
+void fetchunit_set_stream_id(struct dpu_fetchunit *fu, unsigned int id);
+bool fetchunit_is_fetchdecode(struct dpu_fetchunit *fu);
+bool fetchunit_is_fetcheco(struct dpu_fetchunit *fu);
+bool fetchunit_is_fetchlayer(struct dpu_fetchunit *fu);
+bool fetchunit_is_fetchwarp(struct dpu_fetchunit *fu);
+
+/*
+ * to avoid on-the-fly/hot plane resource migration
+ * between two display interfaces
+ */
+#define DPU_PLANE_SRC_TO_DISP_STREAM0	BIT(0)
+#define DPU_PLANE_SRC_TO_DISP_STREAM1	BIT(1)
+#define DPU_PLANE_SRC_DISABLED		0
+
+struct dpu_plane_res {
+	struct dpu_extdst	*ed[2];
+	struct dpu_fetchunit	*fd[2];
+	struct dpu_fetchunit	*fe[2];
+	struct dpu_fetchunit	*fl[1];
+	struct dpu_fetchunit	*fw[1];
+	struct dpu_framegen	*fg[2];
+	struct dpu_hscaler	*hs[2];
+	struct dpu_layerblend	*lb[4];
+	struct dpu_vscaler	*vs[2];
+};
+
+/*
+ * Each DPU plane can be a primary plane or an overlay plane
+ * of one of the DPU's two CRTCs.
+ */
+#define	DPU_PLANE_SRC_FL0_ID	BIT(0)
+#define	DPU_PLANE_SRC_FW2_ID	BIT(1)
+#define	DPU_PLANE_SRC_FD0_ID	BIT(2)
+#define	DPU_PLANE_SRC_FD1_ID	BIT(3)
+
+struct dpu_plane_grp {
+	struct dpu_plane_res	res;
+	unsigned int		hw_plane_num;
+	unsigned int		hw_plane_fetcheco_num;
+	unsigned int		hw_plane_hscaler_num;
+	unsigned int		hw_plane_vscaler_num;
+	unsigned int		id;
+	bool			has_vproc;
+
+	/* used when assigning plane source */
+	struct mutex		mutex;
+	u32			src_mask;
+	u32			src_a_mask;
+	u32			src_use_vproc_mask;
+};
+
+static inline struct dpu_plane_grp *plane_res_to_grp(struct dpu_plane_res *res)
+{
+	return container_of(res, struct dpu_plane_grp, res);
+}
+
+struct dpu_client_platformdata {
+	const unsigned int	stream_id;
+	unsigned int		di_grp_id;
+	struct dpu_plane_grp	*plane_grp;
+
+	/* Store9 could be shared bewteen display engine and blit engine */
+	struct dpu_store	*st9;
+
+	struct device_node	*of_node;
+};
+#endif /* __DRM_DPU_H__ */
diff --git a/include/video/imx-lcdif.h b/include/video/imx-lcdif.h
new file mode 100644
index 000000000..d5005b10a
--- /dev/null
+++ b/include/video/imx-lcdif.h
@@ -0,0 +1,44 @@
+/*
+ * Copyright 2018 NXP
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#ifndef __IMX_LCDIF_H__
+#define __IMX_LCDIF_H__
+
+struct lcdif_soc;
+struct videomode;
+
+struct lcdif_client_platformdata {
+	struct device_node *of_node;
+};
+
+int  lcdif_vblank_irq_get(struct lcdif_soc *lcdif);
+void lcdif_vblank_irq_enable(struct lcdif_soc *lcdif);
+void lcdif_vblank_irq_disable(struct lcdif_soc *lcdif);
+void lcdif_vblank_irq_clear(struct lcdif_soc *lcdif);
+
+int  lcdif_get_bus_fmt_from_pix_fmt(struct lcdif_soc *lcdif,
+				    uint32_t format);
+int  lcdif_set_pix_fmt(struct lcdif_soc *lcdif, u32 format);
+void lcdif_set_bus_fmt(struct lcdif_soc *lcdif, u32 bus_format);
+void lcdif_set_fb_addr(struct lcdif_soc *lcdif, int id, u32 addr);
+void lcdif_set_mode(struct lcdif_soc *lcdif, struct videomode *vmode);
+void lcdif_set_fb_hcrop(struct lcdif_soc *lcdif, u32 src_w,
+			u32 fb_w, bool crop);
+void lcdif_enable_controller(struct lcdif_soc *lcdif);
+void lcdif_disable_controller(struct lcdif_soc *lcdif);
+void lcdif_dump_registers(struct lcdif_soc *lcdif);
+long lcdif_pix_clk_round_rate(struct lcdif_soc *lcdif,
+			      unsigned long rate);
+
+#endif
diff --git a/include/video/imx-lcdifv3.h b/include/video/imx-lcdifv3.h
new file mode 100644
index 000000000..f201edfe4
--- /dev/null
+++ b/include/video/imx-lcdifv3.h
@@ -0,0 +1,36 @@
+/* SPDX-License-Identifier: GPL-2.0+ */
+/*
+ * Copyright 2019 NXP
+ */
+
+#ifndef __IMX_LCDIFV3_H__
+#define __IMX_LCDIFV3_H__
+
+struct lcdifv3_soc;
+struct videomode;
+
+struct lcdifv3_client_platformdata {
+	struct device_node *of_node;
+};
+
+int  lcdifv3_vblank_irq_get(struct lcdifv3_soc *lcdifv3);
+void lcdifv3_vblank_irq_enable(struct lcdifv3_soc *lcdifv3);
+void lcdifv3_vblank_irq_disable(struct lcdifv3_soc *lcdifv3);
+void lcdifv3_vblank_irq_clear(struct lcdifv3_soc *lcdifv3);
+
+int  lcdifv3_get_bus_fmt_from_pix_fmt(struct lcdifv3_soc *lcdifv3,
+				    uint32_t format);
+int  lcdifv3_set_pix_fmt(struct lcdifv3_soc *lcdifv3, u32 format);
+void lcdifv3_set_bus_fmt(struct lcdifv3_soc *lcdifv3, u32 bus_format);
+void lcdifv3_set_fb_addr(struct lcdifv3_soc *lcdifv3, int id, u32 addr);
+void lcdifv3_set_mode(struct lcdifv3_soc *lcdifv3, struct videomode *vmode);
+void lcdifv3_set_fb_hcrop(struct lcdifv3_soc *lcdifv3, u32 src_w,
+			u32 fb_w, bool crop);
+void lcdifv3_en_shadow_load(struct lcdifv3_soc *lcdifv3);
+void lcdifv3_enable_controller(struct lcdifv3_soc *lcdifv3);
+void lcdifv3_disable_controller(struct lcdifv3_soc *lcdifv3);
+void lcdifv3_dump_registers(struct lcdifv3_soc *lcdifv3);
+long lcdifv3_pix_clk_round_rate(struct lcdifv3_soc *lcdifv3,
+				unsigned long rate);
+
+#endif
diff --git a/include/video/imx8-pc.h b/include/video/imx8-pc.h
new file mode 100644
index 000000000..e30017d78
--- /dev/null
+++ b/include/video/imx8-pc.h
@@ -0,0 +1,33 @@
+/*
+ * Copyright 2018,2019 NXP
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the
+ * Free Software Foundation; either version 2 of the License, or (at your
+ * option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+ * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * for more details.
+ */
+
+#ifndef _IMX8_PIXEL_COMBINER_H_
+#define _IMX8_PIXEL_COMBINER_H_
+
+enum {
+	PC_BYPASS,
+	PC_COMBINE,
+	PC_CONVERSION,
+	PC_SPLIT_RGB,
+};
+
+struct pc;
+
+void pc_enable(struct pc *pc);
+void pc_disable(struct pc *pc);
+void pc_configure(struct pc *pc, unsigned int di, unsigned int frame_width,
+		u32 mode, u32 format);
+struct pc *pc_lookup_by_phandle(struct device *dev, const char *name);
+
+#endif
diff --git a/include/video/imx8-prefetch.h b/include/video/imx8-prefetch.h
new file mode 100644
index 000000000..56073c4af
--- /dev/null
+++ b/include/video/imx8-prefetch.h
@@ -0,0 +1,75 @@
+/*
+ * Copyright 2017-2019 NXP
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the
+ * Free Software Foundation; either version 2 of the License, or (at your
+ * option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+ * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * for more details.
+ */
+
+#ifndef _IMX8_PREFETCH_H_
+#define _IMX8_PREFETCH_H_
+
+#define PRG_HANDSHAKE_8LINES		8
+#define PRG_HANDSHAKE_4LINES		4
+#define AMPHION_STRIPE_WIDTH		8
+#define AMPHION_STRIPE_HEIGHT		128
+#define AMPHION_UV_STRIPE_HEIGHT	AMPHION_STRIPE_HEIGHT
+#define AMPHION_Y_STRIPE_HEIGHT		(2 * AMPHION_STRIPE_HEIGHT)
+#define VIVANTE_TILE_WIDTH		4
+#define VIVANTE_TILE_HEIGHT		4
+#define VIVANTE_SUPER_TILE_WIDTH	64
+#define VIVANTE_SUPER_TILE_HEIGHT	64
+
+struct prg;
+struct prg *
+prg_lookup_by_phandle(struct device *dev, const char *name, int index);
+void prg_enable(struct prg *prg);
+void prg_disable(struct prg *prg);
+void prg_configure(struct prg *prg, unsigned int width, unsigned int height,
+		   unsigned int x_offset, unsigned int y_offset,
+		   unsigned int stride, unsigned int bits_per_pixel,
+		   unsigned long baddr, u32 format, u64 modifier,
+		   bool start);
+void prg_reg_update(struct prg *prg);
+void prg_shadow_enable(struct prg *prg);
+bool prg_stride_supported(struct prg *prg, unsigned int stride);
+bool prg_stride_double_check(struct prg *prg,
+			     unsigned int width, unsigned int x_offset,
+			     unsigned int bits_per_pixel, u64 modifier,
+			     unsigned int stride, dma_addr_t baddr);
+void prg_set_auxiliary(struct prg *prg);
+void prg_set_primary(struct prg *prg);
+void prg_set_blit(struct prg *prg);
+
+struct dprc;
+struct dprc *
+dprc_lookup_by_phandle(struct device *dev, const char *name, int index);
+void dprc_enable(struct dprc *dprc);
+void dprc_disable(struct dprc *dprc);
+void dprc_configure(struct dprc *dprc, unsigned int stream_id,
+		    unsigned int width, unsigned int height,
+		    unsigned int x_offset, unsigned int y_offset,
+		    unsigned int stride, u32 format, u64 modifier,
+		    unsigned long baddr, unsigned long uv_baddr,
+		    bool start, bool aux_start, bool interlace_frame);
+void dprc_disable_repeat_en(struct dprc *dprc);
+void dprc_reg_update(struct dprc *dprc);
+void dprc_first_frame_handle(struct dprc *dprc);
+void dprc_irq_handle(struct dprc *dprc);
+void dprc_enable_ctrl_done_irq(struct dprc *dprc);
+bool dprc_format_supported(struct dprc *dprc, u32 format, u64 modifier);
+bool dprc_stride_supported(struct dprc *dprc,
+			   unsigned int stride, unsigned int uv_stride,
+			   unsigned int width, u32 format);
+bool dprc_stride_double_check(struct dprc *dprc,
+			      unsigned int width, unsigned int x_offset,
+			      u32 format, u64 modifier,
+			      dma_addr_t baddr, dma_addr_t uv_baddr);
+
+#endif
diff --git a/include/video/mxc_edid.h b/include/video/mxc_edid.h
new file mode 100644
index 000000000..ff7ddd92a
--- /dev/null
+++ b/include/video/mxc_edid.h
@@ -0,0 +1,107 @@
+/*
+ * Copyright 2009-2015 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+/*!
+ * @defgroup Framebuffer Framebuffer Driver for SDC and ADC.
+ */
+
+/*!
+ * @file mxc_edid.h
+ *
+ * @brief MXC EDID tools
+ *
+ * @ingroup Framebuffer
+ */
+
+#ifndef MXC_EDID_H
+#define MXC_EDID_H
+
+#include <linux/fb.h>
+
+#define FB_VMODE_ASPECT_4_3	0x10
+#define FB_VMODE_ASPECT_16_9	0x20
+#define FB_VMODE_ASPECT_MASK	(FB_VMODE_ASPECT_4_3 | FB_VMODE_ASPECT_16_9)
+
+enum cea_audio_coding_types {
+	AUDIO_CODING_TYPE_REF_STREAM_HEADER	=  0,
+	AUDIO_CODING_TYPE_LPCM			=  1,
+	AUDIO_CODING_TYPE_AC3			=  2,
+	AUDIO_CODING_TYPE_MPEG1			=  3,
+	AUDIO_CODING_TYPE_MP3			=  4,
+	AUDIO_CODING_TYPE_MPEG2			=  5,
+	AUDIO_CODING_TYPE_AACLC			=  6,
+	AUDIO_CODING_TYPE_DTS			=  7,
+	AUDIO_CODING_TYPE_ATRAC			=  8,
+	AUDIO_CODING_TYPE_SACD			=  9,
+	AUDIO_CODING_TYPE_EAC3			= 10,
+	AUDIO_CODING_TYPE_DTS_HD		= 11,
+	AUDIO_CODING_TYPE_MLP			= 12,
+	AUDIO_CODING_TYPE_DST			= 13,
+	AUDIO_CODING_TYPE_WMAPRO		= 14,
+	AUDIO_CODING_TYPE_RESERVED		= 15,
+};
+
+struct mxc_hdmi_3d_format {
+	unsigned char vic_order_2d;
+	unsigned char struct_3d;
+	unsigned char detail_3d;
+	unsigned char reserved;
+};
+
+struct mxc_edid_cfg {
+	bool cea_underscan;
+	bool cea_basicaudio;
+	bool cea_ycbcr444;
+	bool cea_ycbcr422;
+	bool hdmi_cap;
+
+	/*VSD*/
+	bool vsd_support_ai;
+	bool vsd_dc_48bit;
+	bool vsd_dc_36bit;
+	bool vsd_dc_30bit;
+	bool vsd_dc_y444;
+	bool vsd_dvi_dual;
+
+	bool vsd_cnc0;
+	bool vsd_cnc1;
+	bool vsd_cnc2;
+	bool vsd_cnc3;
+
+	u8 vsd_video_latency;
+	u8 vsd_audio_latency;
+	u8 vsd_I_video_latency;
+	u8 vsd_I_audio_latency;
+
+	u8 physical_address[4];
+	u8 hdmi_vic[64];
+	struct mxc_hdmi_3d_format hdmi_3d_format[64];
+	u16 hdmi_3d_mask_all;
+	u16 hdmi_3d_struct_all;
+	u32 vsd_max_tmdsclk_rate;
+
+	u8 max_channels;
+	u8 sample_sizes;
+	u8 sample_rates;
+	u8 speaker_alloc;
+};
+
+extern const struct fb_videomode mxc_cea_mode[64];
+
+int mxc_edid_var_to_vic(struct fb_var_screeninfo *var);
+int mxc_edid_mode_to_vic(const struct fb_videomode *mode);
+int mxc_edid_read(struct i2c_adapter *adp, unsigned short addr,
+	unsigned char *edid, struct mxc_edid_cfg *cfg, struct fb_info *fbi);
+int mxc_edid_parse_ext_blk(unsigned char *edid, struct mxc_edid_cfg *cfg,
+	struct fb_monspecs *specs);
+#endif
diff --git a/include/video/mxc_hdmi.h b/include/video/mxc_hdmi.h
new file mode 100644
index 000000000..79eb3024f
--- /dev/null
+++ b/include/video/mxc_hdmi.h
@@ -0,0 +1,1015 @@
+/*
+ * Copyright (C) 2011-2015 Freescale Semiconductor, Inc.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+#ifndef __MXC_HDMI_H__
+#define __MXC_HDMI_H__
+
+/*
+ * Hdmi controller registers
+ */
+
+/* Identification Registers */
+#define HDMI_DESIGN_ID                          0x0000
+#define HDMI_REVISION_ID                        0x0001
+#define HDMI_PRODUCT_ID0                        0x0002
+#define HDMI_PRODUCT_ID1                        0x0003
+#define HDMI_CONFIG0_ID                         0x0004
+#define HDMI_CONFIG1_ID                         0x0005
+#define HDMI_CONFIG2_ID                         0x0006
+#define HDMI_CONFIG3_ID                         0x0007
+
+/* Interrupt Registers */
+#define HDMI_IH_FC_STAT0                        0x0100
+#define HDMI_IH_FC_STAT1                        0x0101
+#define HDMI_IH_FC_STAT2                        0x0102
+#define HDMI_IH_AS_STAT0                        0x0103
+#define HDMI_IH_PHY_STAT0                       0x0104
+#define HDMI_IH_I2CM_STAT0                      0x0105
+#define HDMI_IH_CEC_STAT0                       0x0106
+#define HDMI_IH_VP_STAT0                        0x0107
+#define HDMI_IH_I2CMPHY_STAT0                   0x0108
+#define HDMI_IH_AHBDMAAUD_STAT0                 0x0109
+
+#define HDMI_IH_MUTE_FC_STAT0                   0x0180
+#define HDMI_IH_MUTE_FC_STAT1                   0x0181
+#define HDMI_IH_MUTE_FC_STAT2                   0x0182
+#define HDMI_IH_MUTE_AS_STAT0                   0x0183
+#define HDMI_IH_MUTE_PHY_STAT0                  0x0184
+#define HDMI_IH_MUTE_I2CM_STAT0                 0x0185
+#define HDMI_IH_MUTE_CEC_STAT0                  0x0186
+#define HDMI_IH_MUTE_VP_STAT0                   0x0187
+#define HDMI_IH_MUTE_I2CMPHY_STAT0              0x0188
+#define HDMI_IH_MUTE_AHBDMAAUD_STAT0            0x0189
+#define HDMI_IH_MUTE                            0x01FF
+
+/* Video Sample Registers */
+#define HDMI_TX_INVID0                          0x0200
+#define HDMI_TX_INSTUFFING                      0x0201
+#define HDMI_TX_GYDATA0                         0x0202
+#define HDMI_TX_GYDATA1                         0x0203
+#define HDMI_TX_RCRDATA0                        0x0204
+#define HDMI_TX_RCRDATA1                        0x0205
+#define HDMI_TX_BCBDATA0                        0x0206
+#define HDMI_TX_BCBDATA1                        0x0207
+
+/* Video Packetizer Registers */
+#define HDMI_VP_STATUS                          0x0800
+#define HDMI_VP_PR_CD                           0x0801
+#define HDMI_VP_STUFF                           0x0802
+#define HDMI_VP_REMAP                           0x0803
+#define HDMI_VP_CONF                            0x0804
+#define HDMI_VP_STAT                            0x0805
+#define HDMI_VP_INT                             0x0806
+#define HDMI_VP_MASK                            0x0807
+#define HDMI_VP_POL                             0x0808
+
+/* Frame Composer Registers */
+#define HDMI_FC_INVIDCONF                       0x1000
+#define HDMI_FC_INHACTV0                        0x1001
+#define HDMI_FC_INHACTV1                        0x1002
+#define HDMI_FC_INHBLANK0                       0x1003
+#define HDMI_FC_INHBLANK1                       0x1004
+#define HDMI_FC_INVACTV0                        0x1005
+#define HDMI_FC_INVACTV1                        0x1006
+#define HDMI_FC_INVBLANK                        0x1007
+#define HDMI_FC_HSYNCINDELAY0                   0x1008
+#define HDMI_FC_HSYNCINDELAY1                   0x1009
+#define HDMI_FC_HSYNCINWIDTH0                   0x100A
+#define HDMI_FC_HSYNCINWIDTH1                   0x100B
+#define HDMI_FC_VSYNCINDELAY                    0x100C
+#define HDMI_FC_VSYNCINWIDTH                    0x100D
+#define HDMI_FC_INFREQ0                         0x100E
+#define HDMI_FC_INFREQ1                         0x100F
+#define HDMI_FC_INFREQ2                         0x1010
+#define HDMI_FC_CTRLDUR                         0x1011
+#define HDMI_FC_EXCTRLDUR                       0x1012
+#define HDMI_FC_EXCTRLSPAC                      0x1013
+#define HDMI_FC_CH0PREAM                        0x1014
+#define HDMI_FC_CH1PREAM                        0x1015
+#define HDMI_FC_CH2PREAM                        0x1016
+#define HDMI_FC_AVICONF3                        0x1017
+#define HDMI_FC_GCP                             0x1018
+#define HDMI_FC_AVICONF0                        0x1019
+#define HDMI_FC_AVICONF1                        0x101A
+#define HDMI_FC_AVICONF2                        0x101B
+#define HDMI_FC_AVIVID                          0x101C
+#define HDMI_FC_AVIETB0                         0x101D
+#define HDMI_FC_AVIETB1                         0x101E
+#define HDMI_FC_AVISBB0                         0x101F
+#define HDMI_FC_AVISBB1                         0x1020
+#define HDMI_FC_AVIELB0                         0x1021
+#define HDMI_FC_AVIELB1                         0x1022
+#define HDMI_FC_AVISRB0                         0x1023
+#define HDMI_FC_AVISRB1                         0x1024
+#define HDMI_FC_AUDICONF0                       0x1025
+#define HDMI_FC_AUDICONF1                       0x1026
+#define HDMI_FC_AUDICONF2                       0x1027
+#define HDMI_FC_AUDICONF3                       0x1028
+#define HDMI_FC_VSDIEEEID0                      0x1029
+#define HDMI_FC_VSDSIZE                         0x102A
+#define HDMI_FC_VSDIEEEID1                      0x1030
+#define HDMI_FC_VSDIEEEID2                      0x1031
+#define HDMI_FC_VSDPAYLOAD0                     0x1032
+#define HDMI_FC_VSDPAYLOAD1                     0x1033
+#define HDMI_FC_VSDPAYLOAD2                     0x1034
+#define HDMI_FC_VSDPAYLOAD3                     0x1035
+#define HDMI_FC_VSDPAYLOAD4                     0x1036
+#define HDMI_FC_VSDPAYLOAD5                     0x1037
+#define HDMI_FC_VSDPAYLOAD6                     0x1038
+#define HDMI_FC_VSDPAYLOAD7                     0x1039
+#define HDMI_FC_VSDPAYLOAD8                     0x103A
+#define HDMI_FC_VSDPAYLOAD9                     0x103B
+#define HDMI_FC_VSDPAYLOAD10                    0x103C
+#define HDMI_FC_VSDPAYLOAD11                    0x103D
+#define HDMI_FC_VSDPAYLOAD12                    0x103E
+#define HDMI_FC_VSDPAYLOAD13                    0x103F
+#define HDMI_FC_VSDPAYLOAD14                    0x1040
+#define HDMI_FC_VSDPAYLOAD15                    0x1041
+#define HDMI_FC_VSDPAYLOAD16                    0x1042
+#define HDMI_FC_VSDPAYLOAD17                    0x1043
+#define HDMI_FC_VSDPAYLOAD18                    0x1044
+#define HDMI_FC_VSDPAYLOAD19                    0x1045
+#define HDMI_FC_VSDPAYLOAD20                    0x1046
+#define HDMI_FC_VSDPAYLOAD21                    0x1047
+#define HDMI_FC_VSDPAYLOAD22                    0x1048
+#define HDMI_FC_VSDPAYLOAD23                    0x1049
+#define HDMI_FC_SPDVENDORNAME0                  0x104A
+#define HDMI_FC_SPDVENDORNAME1                  0x104B
+#define HDMI_FC_SPDVENDORNAME2                  0x104C
+#define HDMI_FC_SPDVENDORNAME3                  0x104D
+#define HDMI_FC_SPDVENDORNAME4                  0x104E
+#define HDMI_FC_SPDVENDORNAME5                  0x104F
+#define HDMI_FC_SPDVENDORNAME6                  0x1050
+#define HDMI_FC_SPDVENDORNAME7                  0x1051
+#define HDMI_FC_SDPPRODUCTNAME0                 0x1052
+#define HDMI_FC_SDPPRODUCTNAME1                 0x1053
+#define HDMI_FC_SDPPRODUCTNAME2                 0x1054
+#define HDMI_FC_SDPPRODUCTNAME3                 0x1055
+#define HDMI_FC_SDPPRODUCTNAME4                 0x1056
+#define HDMI_FC_SDPPRODUCTNAME5                 0x1057
+#define HDMI_FC_SDPPRODUCTNAME6                 0x1058
+#define HDMI_FC_SDPPRODUCTNAME7                 0x1059
+#define HDMI_FC_SDPPRODUCTNAME8                 0x105A
+#define HDMI_FC_SDPPRODUCTNAME9                 0x105B
+#define HDMI_FC_SDPPRODUCTNAME10                0x105C
+#define HDMI_FC_SDPPRODUCTNAME11                0x105D
+#define HDMI_FC_SDPPRODUCTNAME12                0x105E
+#define HDMI_FC_SDPPRODUCTNAME13                0x105F
+#define HDMI_FC_SDPPRODUCTNAME14                0x1060
+#define HDMI_FC_SPDPRODUCTNAME15                0x1061
+#define HDMI_FC_SPDDEVICEINF                    0x1062
+#define HDMI_FC_AUDSCONF                        0x1063
+#define HDMI_FC_AUDSSTAT                        0x1064
+#define HDMI_FC_DATACH0FILL                     0x1070
+#define HDMI_FC_DATACH1FILL                     0x1071
+#define HDMI_FC_DATACH2FILL                     0x1072
+#define HDMI_FC_CTRLQHIGH                       0x1073
+#define HDMI_FC_CTRLQLOW                        0x1074
+#define HDMI_FC_ACP0                            0x1075
+#define HDMI_FC_ACP28                           0x1076
+#define HDMI_FC_ACP27                           0x1077
+#define HDMI_FC_ACP26                           0x1078
+#define HDMI_FC_ACP25                           0x1079
+#define HDMI_FC_ACP24                           0x107A
+#define HDMI_FC_ACP23                           0x107B
+#define HDMI_FC_ACP22                           0x107C
+#define HDMI_FC_ACP21                           0x107D
+#define HDMI_FC_ACP20                           0x107E
+#define HDMI_FC_ACP19                           0x107F
+#define HDMI_FC_ACP18                           0x1080
+#define HDMI_FC_ACP17                           0x1081
+#define HDMI_FC_ACP16                           0x1082
+#define HDMI_FC_ACP15                           0x1083
+#define HDMI_FC_ACP14                           0x1084
+#define HDMI_FC_ACP13                           0x1085
+#define HDMI_FC_ACP12                           0x1086
+#define HDMI_FC_ACP11                           0x1087
+#define HDMI_FC_ACP10                           0x1088
+#define HDMI_FC_ACP9                            0x1089
+#define HDMI_FC_ACP8                            0x108A
+#define HDMI_FC_ACP7                            0x108B
+#define HDMI_FC_ACP6                            0x108C
+#define HDMI_FC_ACP5                            0x108D
+#define HDMI_FC_ACP4                            0x108E
+#define HDMI_FC_ACP3                            0x108F
+#define HDMI_FC_ACP2                            0x1090
+#define HDMI_FC_ACP1                            0x1091
+#define HDMI_FC_ISCR1_0                         0x1092
+#define HDMI_FC_ISCR1_16                        0x1093
+#define HDMI_FC_ISCR1_15                        0x1094
+#define HDMI_FC_ISCR1_14                        0x1095
+#define HDMI_FC_ISCR1_13                        0x1096
+#define HDMI_FC_ISCR1_12                        0x1097
+#define HDMI_FC_ISCR1_11                        0x1098
+#define HDMI_FC_ISCR1_10                        0x1099
+#define HDMI_FC_ISCR1_9                         0x109A
+#define HDMI_FC_ISCR1_8                         0x109B
+#define HDMI_FC_ISCR1_7                         0x109C
+#define HDMI_FC_ISCR1_6                         0x109D
+#define HDMI_FC_ISCR1_5                         0x109E
+#define HDMI_FC_ISCR1_4                         0x109F
+#define HDMI_FC_ISCR1_3                         0x10A0
+#define HDMI_FC_ISCR1_2                         0x10A1
+#define HDMI_FC_ISCR1_1                         0x10A2
+#define HDMI_FC_ISCR2_15                        0x10A3
+#define HDMI_FC_ISCR2_14                        0x10A4
+#define HDMI_FC_ISCR2_13                        0x10A5
+#define HDMI_FC_ISCR2_12                        0x10A6
+#define HDMI_FC_ISCR2_11                        0x10A7
+#define HDMI_FC_ISCR2_10                        0x10A8
+#define HDMI_FC_ISCR2_9                         0x10A9
+#define HDMI_FC_ISCR2_8                         0x10AA
+#define HDMI_FC_ISCR2_7                         0x10AB
+#define HDMI_FC_ISCR2_6                         0x10AC
+#define HDMI_FC_ISCR2_5                         0x10AD
+#define HDMI_FC_ISCR2_4                         0x10AE
+#define HDMI_FC_ISCR2_3                         0x10AF
+#define HDMI_FC_ISCR2_2                         0x10B0
+#define HDMI_FC_ISCR2_1                         0x10B1
+#define HDMI_FC_ISCR2_0                         0x10B2
+#define HDMI_FC_DATAUTO0                        0x10B3
+#define HDMI_FC_DATAUTO1                        0x10B4
+#define HDMI_FC_DATAUTO2                        0x10B5
+#define HDMI_FC_DATMAN                          0x10B6
+#define HDMI_FC_DATAUTO3                        0x10B7
+#define HDMI_FC_RDRB0                           0x10B8
+#define HDMI_FC_RDRB1                           0x10B9
+#define HDMI_FC_RDRB2                           0x10BA
+#define HDMI_FC_RDRB3                           0x10BB
+#define HDMI_FC_RDRB4                           0x10BC
+#define HDMI_FC_RDRB5                           0x10BD
+#define HDMI_FC_RDRB6                           0x10BE
+#define HDMI_FC_RDRB7                           0x10BF
+#define HDMI_FC_STAT0                           0x10D0
+#define HDMI_FC_INT0                            0x10D1
+#define HDMI_FC_MASK0                           0x10D2
+#define HDMI_FC_POL0                            0x10D3
+#define HDMI_FC_STAT1                           0x10D4
+#define HDMI_FC_INT1                            0x10D5
+#define HDMI_FC_MASK1                           0x10D6
+#define HDMI_FC_POL1                            0x10D7
+#define HDMI_FC_STAT2                           0x10D8
+#define HDMI_FC_INT2                            0x10D9
+#define HDMI_FC_MASK2                           0x10DA
+#define HDMI_FC_POL2                            0x10DB
+#define HDMI_FC_PRCONF                          0x10E0
+
+#define HDMI_FC_GMD_STAT                        0x1100
+#define HDMI_FC_GMD_EN                          0x1101
+#define HDMI_FC_GMD_UP                          0x1102
+#define HDMI_FC_GMD_CONF                        0x1103
+#define HDMI_FC_GMD_HB                          0x1104
+#define HDMI_FC_GMD_PB0                         0x1105
+#define HDMI_FC_GMD_PB1                         0x1106
+#define HDMI_FC_GMD_PB2                         0x1107
+#define HDMI_FC_GMD_PB3                         0x1108
+#define HDMI_FC_GMD_PB4                         0x1109
+#define HDMI_FC_GMD_PB5                         0x110A
+#define HDMI_FC_GMD_PB6                         0x110B
+#define HDMI_FC_GMD_PB7                         0x110C
+#define HDMI_FC_GMD_PB8                         0x110D
+#define HDMI_FC_GMD_PB9                         0x110E
+#define HDMI_FC_GMD_PB10                        0x110F
+#define HDMI_FC_GMD_PB11                        0x1110
+#define HDMI_FC_GMD_PB12                        0x1111
+#define HDMI_FC_GMD_PB13                        0x1112
+#define HDMI_FC_GMD_PB14                        0x1113
+#define HDMI_FC_GMD_PB15                        0x1114
+#define HDMI_FC_GMD_PB16                        0x1115
+#define HDMI_FC_GMD_PB17                        0x1116
+#define HDMI_FC_GMD_PB18                        0x1117
+#define HDMI_FC_GMD_PB19                        0x1118
+#define HDMI_FC_GMD_PB20                        0x1119
+#define HDMI_FC_GMD_PB21                        0x111A
+#define HDMI_FC_GMD_PB22                        0x111B
+#define HDMI_FC_GMD_PB23                        0x111C
+#define HDMI_FC_GMD_PB24                        0x111D
+#define HDMI_FC_GMD_PB25                        0x111E
+#define HDMI_FC_GMD_PB26                        0x111F
+#define HDMI_FC_GMD_PB27                        0x1120
+
+#define HDMI_FC_DBGFORCE                        0x1200
+#define HDMI_FC_DBGAUD0CH0                      0x1201
+#define HDMI_FC_DBGAUD1CH0                      0x1202
+#define HDMI_FC_DBGAUD2CH0                      0x1203
+#define HDMI_FC_DBGAUD0CH1                      0x1204
+#define HDMI_FC_DBGAUD1CH1                      0x1205
+#define HDMI_FC_DBGAUD2CH1                      0x1206
+#define HDMI_FC_DBGAUD0CH2                      0x1207
+#define HDMI_FC_DBGAUD1CH2                      0x1208
+#define HDMI_FC_DBGAUD2CH2                      0x1209
+#define HDMI_FC_DBGAUD0CH3                      0x120A
+#define HDMI_FC_DBGAUD1CH3                      0x120B
+#define HDMI_FC_DBGAUD2CH3                      0x120C
+#define HDMI_FC_DBGAUD0CH4                      0x120D
+#define HDMI_FC_DBGAUD1CH4                      0x120E
+#define HDMI_FC_DBGAUD2CH4                      0x120F
+#define HDMI_FC_DBGAUD0CH5                      0x1210
+#define HDMI_FC_DBGAUD1CH5                      0x1211
+#define HDMI_FC_DBGAUD2CH5                      0x1212
+#define HDMI_FC_DBGAUD0CH6                      0x1213
+#define HDMI_FC_DBGAUD1CH6                      0x1214
+#define HDMI_FC_DBGAUD2CH6                      0x1215
+#define HDMI_FC_DBGAUD0CH7                      0x1216
+#define HDMI_FC_DBGAUD1CH7                      0x1217
+#define HDMI_FC_DBGAUD2CH7                      0x1218
+#define HDMI_FC_DBGTMDS0                        0x1219
+#define HDMI_FC_DBGTMDS1                        0x121A
+#define HDMI_FC_DBGTMDS2                        0x121B
+
+/* HDMI Source PHY Registers */
+#define HDMI_PHY_CONF0                          0x3000
+#define HDMI_PHY_TST0                           0x3001
+#define HDMI_PHY_TST1                           0x3002
+#define HDMI_PHY_TST2                           0x3003
+#define HDMI_PHY_STAT0                          0x3004
+#define HDMI_PHY_INT0                           0x3005
+#define HDMI_PHY_MASK0                          0x3006
+#define HDMI_PHY_POL0                           0x3007
+
+/* HDMI Master PHY Registers */
+#define HDMI_PHY_I2CM_SLAVE_ADDR                0x3020
+#define HDMI_PHY_I2CM_ADDRESS_ADDR              0x3021
+#define HDMI_PHY_I2CM_DATAO_1_ADDR              0x3022
+#define HDMI_PHY_I2CM_DATAO_0_ADDR              0x3023
+#define HDMI_PHY_I2CM_DATAI_1_ADDR              0x3024
+#define HDMI_PHY_I2CM_DATAI_0_ADDR              0x3025
+#define HDMI_PHY_I2CM_OPERATION_ADDR            0x3026
+#define HDMI_PHY_I2CM_INT_ADDR                  0x3027
+#define HDMI_PHY_I2CM_CTLINT_ADDR               0x3028
+#define HDMI_PHY_I2CM_DIV_ADDR                  0x3029
+#define HDMI_PHY_I2CM_SOFTRSTZ_ADDR             0x302a
+#define HDMI_PHY_I2CM_SS_SCL_HCNT_1_ADDR        0x302b
+#define HDMI_PHY_I2CM_SS_SCL_HCNT_0_ADDR        0x302c
+#define HDMI_PHY_I2CM_SS_SCL_LCNT_1_ADDR        0x302d
+#define HDMI_PHY_I2CM_SS_SCL_LCNT_0_ADDR        0x302e
+#define HDMI_PHY_I2CM_FS_SCL_HCNT_1_ADDR        0x302f
+#define HDMI_PHY_I2CM_FS_SCL_HCNT_0_ADDR        0x3030
+#define HDMI_PHY_I2CM_FS_SCL_LCNT_1_ADDR        0x3031
+#define HDMI_PHY_I2CM_FS_SCL_LCNT_0_ADDR        0x3032
+
+/* Audio Sampler Registers */
+#define HDMI_AUD_CONF0                          0x3100
+#define HDMI_AUD_CONF1                          0x3101
+#define HDMI_AUD_INT                            0x3102
+#define HDMI_AUD_CONF2                          0x3103
+#define HDMI_AUD_N1                             0x3200
+#define HDMI_AUD_N2                             0x3201
+#define HDMI_AUD_N3                             0x3202
+#define HDMI_AUD_CTS1                           0x3203
+#define HDMI_AUD_CTS2                           0x3204
+#define HDMI_AUD_CTS3                           0x3205
+#define HDMI_AUD_INPUTCLKFS                     0x3206
+#define HDMI_AUD_SPDIFINT			0x3302
+#define HDMI_AUD_CONF0_HBR                      0x3400
+#define HDMI_AUD_HBR_STATUS                     0x3401
+#define HDMI_AUD_HBR_INT                        0x3402
+#define HDMI_AUD_HBR_POL                        0x3403
+#define HDMI_AUD_HBR_MASK                       0x3404
+
+/* Generic Parallel Audio Interface Registers */
+/* Not used as GPAUD interface is not enabled in hw */
+#define HDMI_GP_CONF0                           0x3500
+#define HDMI_GP_CONF1                           0x3501
+#define HDMI_GP_CONF2                           0x3502
+#define HDMI_GP_STAT                            0x3503
+#define HDMI_GP_INT                             0x3504
+#define HDMI_GP_MASK                            0x3505
+#define HDMI_GP_POL                             0x3506
+
+/* Audio DMA Registers */
+#define HDMI_AHB_DMA_CONF0                      0x3600
+#define HDMI_AHB_DMA_START                      0x3601
+#define HDMI_AHB_DMA_STOP                       0x3602
+#define HDMI_AHB_DMA_THRSLD                     0x3603
+#define HDMI_AHB_DMA_STRADDR0                   0x3604
+#define HDMI_AHB_DMA_STRADDR1                   0x3605
+#define HDMI_AHB_DMA_STRADDR2                   0x3606
+#define HDMI_AHB_DMA_STRADDR3                   0x3607
+#define HDMI_AHB_DMA_STPADDR0                   0x3608
+#define HDMI_AHB_DMA_STPADDR1                   0x3609
+#define HDMI_AHB_DMA_STPADDR2                   0x360a
+#define HDMI_AHB_DMA_STPADDR3                   0x360b
+#define HDMI_AHB_DMA_BSTADDR0                   0x360c
+#define HDMI_AHB_DMA_BSTADDR1                   0x360d
+#define HDMI_AHB_DMA_BSTADDR2                   0x360e
+#define HDMI_AHB_DMA_BSTADDR3                   0x360f
+#define HDMI_AHB_DMA_MBLENGTH0                  0x3610
+#define HDMI_AHB_DMA_MBLENGTH1                  0x3611
+#define HDMI_AHB_DMA_STAT                       0x3612
+#define HDMI_AHB_DMA_INT                        0x3613
+#define HDMI_AHB_DMA_MASK                       0x3614
+#define HDMI_AHB_DMA_POL                        0x3615
+#define HDMI_AHB_DMA_CONF1                      0x3616
+#define HDMI_AHB_DMA_BUFFSTAT                   0x3617
+#define HDMI_AHB_DMA_BUFFINT                    0x3618
+#define HDMI_AHB_DMA_BUFFMASK                   0x3619
+#define HDMI_AHB_DMA_BUFFPOL                    0x361a
+
+/* Main Controller Registers */
+#define HDMI_MC_SFRDIV                          0x4000
+#define HDMI_MC_CLKDIS                          0x4001
+#define HDMI_MC_SWRSTZ                          0x4002
+#define HDMI_MC_OPCTRL                          0x4003
+#define HDMI_MC_FLOWCTRL                        0x4004
+#define HDMI_MC_PHYRSTZ                         0x4005
+#define HDMI_MC_LOCKONCLOCK                     0x4006
+#define HDMI_MC_HEACPHY_RST                     0x4007
+
+/* Color Space  Converter Registers */
+#define HDMI_CSC_CFG                            0x4100
+#define HDMI_CSC_SCALE                          0x4101
+#define HDMI_CSC_COEF_A1_MSB                    0x4102
+#define HDMI_CSC_COEF_A1_LSB                    0x4103
+#define HDMI_CSC_COEF_A2_MSB                    0x4104
+#define HDMI_CSC_COEF_A2_LSB                    0x4105
+#define HDMI_CSC_COEF_A3_MSB                    0x4106
+#define HDMI_CSC_COEF_A3_LSB                    0x4107
+#define HDMI_CSC_COEF_A4_MSB                    0x4108
+#define HDMI_CSC_COEF_A4_LSB                    0x4109
+#define HDMI_CSC_COEF_B1_MSB                    0x410A
+#define HDMI_CSC_COEF_B1_LSB                    0x410B
+#define HDMI_CSC_COEF_B2_MSB                    0x410C
+#define HDMI_CSC_COEF_B2_LSB                    0x410D
+#define HDMI_CSC_COEF_B3_MSB                    0x410E
+#define HDMI_CSC_COEF_B3_LSB                    0x410F
+#define HDMI_CSC_COEF_B4_MSB                    0x4110
+#define HDMI_CSC_COEF_B4_LSB                    0x4111
+#define HDMI_CSC_COEF_C1_MSB                    0x4112
+#define HDMI_CSC_COEF_C1_LSB                    0x4113
+#define HDMI_CSC_COEF_C2_MSB                    0x4114
+#define HDMI_CSC_COEF_C2_LSB                    0x4115
+#define HDMI_CSC_COEF_C3_MSB                    0x4116
+#define HDMI_CSC_COEF_C3_LSB                    0x4117
+#define HDMI_CSC_COEF_C4_MSB                    0x4118
+#define HDMI_CSC_COEF_C4_LSB                    0x4119
+
+/* HDCP Interrupt Registers */
+#define HDMI_A_APIINTCLR                        0x5006
+#define HDMI_A_APIINTSTAT                       0x5007
+#define HDMI_A_APIINTMSK                        0x5008
+
+/* CEC Engine Registers */
+#define HDMI_CEC_CTRL                           0x7D00
+#define HDMI_CEC_STAT                           0x7D01
+#define HDMI_CEC_MASK                           0x7D02
+#define HDMI_CEC_POLARITY                       0x7D03
+#define HDMI_CEC_INT                            0x7D04
+#define HDMI_CEC_ADDR_L                         0x7D05
+#define HDMI_CEC_ADDR_H                         0x7D06
+#define HDMI_CEC_TX_CNT                         0x7D07
+#define HDMI_CEC_RX_CNT                         0x7D08
+#define HDMI_CEC_TX_DATA0                       0x7D10
+#define HDMI_CEC_TX_DATA1                       0x7D11
+#define HDMI_CEC_TX_DATA2                       0x7D12
+#define HDMI_CEC_TX_DATA3                       0x7D13
+#define HDMI_CEC_TX_DATA4                       0x7D14
+#define HDMI_CEC_TX_DATA5                       0x7D15
+#define HDMI_CEC_TX_DATA6                       0x7D16
+#define HDMI_CEC_TX_DATA7                       0x7D17
+#define HDMI_CEC_TX_DATA8                       0x7D18
+#define HDMI_CEC_TX_DATA9                       0x7D19
+#define HDMI_CEC_TX_DATA10                      0x7D1a
+#define HDMI_CEC_TX_DATA11                      0x7D1b
+#define HDMI_CEC_TX_DATA12                      0x7D1c
+#define HDMI_CEC_TX_DATA13                      0x7D1d
+#define HDMI_CEC_TX_DATA14                      0x7D1e
+#define HDMI_CEC_TX_DATA15                      0x7D1f
+#define HDMI_CEC_RX_DATA0                       0x7D20
+#define HDMI_CEC_RX_DATA1                       0x7D21
+#define HDMI_CEC_RX_DATA2                       0x7D22
+#define HDMI_CEC_RX_DATA3                       0x7D23
+#define HDMI_CEC_RX_DATA4                       0x7D24
+#define HDMI_CEC_RX_DATA5                       0x7D25
+#define HDMI_CEC_RX_DATA6                       0x7D26
+#define HDMI_CEC_RX_DATA7                       0x7D27
+#define HDMI_CEC_RX_DATA8                       0x7D28
+#define HDMI_CEC_RX_DATA9                       0x7D29
+#define HDMI_CEC_RX_DATA10                      0x7D2a
+#define HDMI_CEC_RX_DATA11                      0x7D2b
+#define HDMI_CEC_RX_DATA12                      0x7D2c
+#define HDMI_CEC_RX_DATA13                      0x7D2d
+#define HDMI_CEC_RX_DATA14                      0x7D2e
+#define HDMI_CEC_RX_DATA15                      0x7D2f
+#define HDMI_CEC_LOCK                           0x7D30
+#define HDMI_CEC_WKUPCTRL                       0x7D31
+
+/* I2C Master Registers (E-DDC) */
+#define HDMI_I2CM_SLAVE                         0x7E00
+#define HDMI_I2CM_ADDRESS                       0x7E01
+#define HDMI_I2CM_DATAO                         0x7E02
+#define HDMI_I2CM_DATAI                         0x7E03
+#define HDMI_I2CM_OPERATION                     0x7E04
+#define HDMI_I2CM_INT                           0x7E05
+#define HDMI_I2CM_CTLINT                        0x7E06
+#define HDMI_I2CM_DIV                           0x7E07
+#define HDMI_I2CM_SEGADDR                       0x7E08
+#define HDMI_I2CM_SOFTRSTZ                      0x7E09
+#define HDMI_I2CM_SEGPTR                        0x7E0A
+#define HDMI_I2CM_SS_SCL_HCNT_1_ADDR            0x7E0B
+#define HDMI_I2CM_SS_SCL_HCNT_0_ADDR            0x7E0C
+#define HDMI_I2CM_SS_SCL_LCNT_1_ADDR            0x7E0D
+#define HDMI_I2CM_SS_SCL_LCNT_0_ADDR            0x7E0E
+#define HDMI_I2CM_FS_SCL_HCNT_1_ADDR            0x7E0F
+#define HDMI_I2CM_FS_SCL_HCNT_0_ADDR            0x7E10
+#define HDMI_I2CM_FS_SCL_LCNT_1_ADDR            0x7E11
+#define HDMI_I2CM_FS_SCL_LCNT_0_ADDR            0x7E12
+
+/* Random Number Generator Registers (RNG) */
+#define HDMI_RNG_BASE                           0x8000
+
+
+/*
+ * Register field definitions
+ */
+enum {
+/* IH_FC_INT2 field values */
+	HDMI_IH_FC_INT2_OVERFLOW_MASK = 0x03,
+	HDMI_IH_FC_INT2_LOW_PRIORITY_OVERFLOW = 0x02,
+	HDMI_IH_FC_INT2_HIGH_PRIORITY_OVERFLOW = 0x01,
+
+/* IH_FC_STAT2 field values */
+	HDMI_IH_FC_STAT2_OVERFLOW_MASK = 0x03,
+	HDMI_IH_FC_STAT2_LOW_PRIORITY_OVERFLOW = 0x02,
+	HDMI_IH_FC_STAT2_HIGH_PRIORITY_OVERFLOW = 0x01,
+
+/* IH_PHY_STAT0 field values */
+	HDMI_IH_PHY_STAT0_RX_SENSE3 = 0x20,
+	HDMI_IH_PHY_STAT0_RX_SENSE2 = 0x10,
+	HDMI_IH_PHY_STAT0_RX_SENSE1 = 0x8,
+	HDMI_IH_PHY_STAT0_RX_SENSE0 = 0x4,
+	HDMI_IH_PHY_STAT0_TX_PHY_LOCK = 0x2,
+	HDMI_IH_PHY_STAT0_HPD = 0x1,
+
+/* IH_CEC_STAT0 field values */
+	HDMI_IH_CEC_STAT0_WAKEUP = 0x40,
+	HDMI_IH_CEC_STAT0_ERROR_FOLL = 0x20,
+	HDMI_IH_CEC_STAT0_ERROR_INIT = 0x10,
+	HDMI_IH_CEC_STAT0_ARB_LOST = 0x8,
+	HDMI_IH_CEC_STAT0_NACK = 0x4,
+	HDMI_IH_CEC_STAT0_EOM = 0x2,
+	HDMI_IH_CEC_STAT0_DONE = 0x1,
+
+
+/* IH_MUTE_I2CMPHY_STAT0 field values */
+	HDMI_IH_MUTE_I2CMPHY_STAT0_I2CMPHYDONE = 0x2,
+	HDMI_IH_MUTE_I2CMPHY_STAT0_I2CMPHYERROR = 0x1,
+
+/* IH_PHY_STAT0 field values */
+	HDMI_IH_MUTE_PHY_STAT0_RX_SENSE3 = 0x20,
+	HDMI_IH_MUTE_PHY_STAT0_RX_SENSE2 = 0x10,
+	HDMI_IH_MUTE_PHY_STAT0_RX_SENSE1 = 0x8,
+	HDMI_IH_MUTE_PHY_STAT0_RX_SENSE0 = 0x4,
+	HDMI_IH_MUTE_PHY_STAT0_TX_PHY_LOCK = 0x2,
+	HDMI_IH_MUTE_PHY_STAT0_HPD = 0x1,
+
+/* IH_AHBDMAAUD_STAT0 field values */
+	HDMI_IH_AHBDMAAUD_STAT0_ERROR = 0x20,
+	HDMI_IH_AHBDMAAUD_STAT0_LOST = 0x10,
+	HDMI_IH_AHBDMAAUD_STAT0_RETRY = 0x08,
+	HDMI_IH_AHBDMAAUD_STAT0_DONE = 0x04,
+	HDMI_IH_AHBDMAAUD_STAT0_BUFFFULL = 0x02,
+	HDMI_IH_AHBDMAAUD_STAT0_BUFFEMPTY = 0x01,
+
+/* IH_MUTE_FC_STAT2 field values */
+	HDMI_IH_MUTE_FC_STAT2_OVERFLOW_MASK = 0x03,
+	HDMI_IH_MUTE_FC_STAT2_LOW_PRIORITY_OVERFLOW = 0x02,
+	HDMI_IH_MUTE_FC_STAT2_HIGH_PRIORITY_OVERFLOW = 0x01,
+
+/* IH_MUTE_AHBDMAAUD_STAT0 field values */
+	HDMI_IH_MUTE_AHBDMAAUD_STAT0_ERROR = 0x20,
+	HDMI_IH_MUTE_AHBDMAAUD_STAT0_LOST = 0x10,
+	HDMI_IH_MUTE_AHBDMAAUD_STAT0_RETRY = 0x08,
+	HDMI_IH_MUTE_AHBDMAAUD_STAT0_DONE = 0x04,
+	HDMI_IH_MUTE_AHBDMAAUD_STAT0_BUFFFULL = 0x02,
+	HDMI_IH_MUTE_AHBDMAAUD_STAT0_BUFFEMPTY = 0x01,
+
+/* IH_MUTE field values */
+	HDMI_IH_MUTE_MUTE_WAKEUP_INTERRUPT = 0x2,
+	HDMI_IH_MUTE_MUTE_ALL_INTERRUPT = 0x1,
+
+/* TX_INVID0 field values */
+	HDMI_TX_INVID0_INTERNAL_DE_GENERATOR_MASK = 0x80,
+	HDMI_TX_INVID0_INTERNAL_DE_GENERATOR_ENABLE = 0x80,
+	HDMI_TX_INVID0_INTERNAL_DE_GENERATOR_DISABLE = 0x00,
+	HDMI_TX_INVID0_VIDEO_MAPPING_MASK = 0x1F,
+	HDMI_TX_INVID0_VIDEO_MAPPING_OFFSET = 0,
+
+/* TX_INSTUFFING field values */
+	HDMI_TX_INSTUFFING_BDBDATA_STUFFING_MASK = 0x4,
+	HDMI_TX_INSTUFFING_BDBDATA_STUFFING_ENABLE = 0x4,
+	HDMI_TX_INSTUFFING_BDBDATA_STUFFING_DISABLE = 0x0,
+	HDMI_TX_INSTUFFING_RCRDATA_STUFFING_MASK = 0x2,
+	HDMI_TX_INSTUFFING_RCRDATA_STUFFING_ENABLE = 0x2,
+	HDMI_TX_INSTUFFING_RCRDATA_STUFFING_DISABLE = 0x0,
+	HDMI_TX_INSTUFFING_GYDATA_STUFFING_MASK = 0x1,
+	HDMI_TX_INSTUFFING_GYDATA_STUFFING_ENABLE = 0x1,
+	HDMI_TX_INSTUFFING_GYDATA_STUFFING_DISABLE = 0x0,
+
+/* VP_PR_CD field values */
+	HDMI_VP_PR_CD_COLOR_DEPTH_MASK = 0xF0,
+	HDMI_VP_PR_CD_COLOR_DEPTH_OFFSET = 4,
+	HDMI_VP_PR_CD_DESIRED_PR_FACTOR_MASK = 0x0F,
+	HDMI_VP_PR_CD_DESIRED_PR_FACTOR_OFFSET = 0,
+
+/* VP_STUFF field values */
+	HDMI_VP_STUFF_IDEFAULT_PHASE_MASK = 0x20,
+	HDMI_VP_STUFF_IDEFAULT_PHASE_OFFSET = 5,
+	HDMI_VP_STUFF_IFIX_PP_TO_LAST_MASK = 0x10,
+	HDMI_VP_STUFF_IFIX_PP_TO_LAST_OFFSET = 4,
+	HDMI_VP_STUFF_ICX_GOTO_P0_ST_MASK = 0x8,
+	HDMI_VP_STUFF_ICX_GOTO_P0_ST_OFFSET = 3,
+	HDMI_VP_STUFF_YCC422_STUFFING_MASK = 0x4,
+	HDMI_VP_STUFF_YCC422_STUFFING_STUFFING_MODE = 0x4,
+	HDMI_VP_STUFF_YCC422_STUFFING_DIRECT_MODE = 0x0,
+	HDMI_VP_STUFF_PP_STUFFING_MASK = 0x2,
+	HDMI_VP_STUFF_PP_STUFFING_STUFFING_MODE = 0x2,
+	HDMI_VP_STUFF_PP_STUFFING_DIRECT_MODE = 0x0,
+	HDMI_VP_STUFF_PR_STUFFING_MASK = 0x1,
+	HDMI_VP_STUFF_PR_STUFFING_STUFFING_MODE = 0x1,
+	HDMI_VP_STUFF_PR_STUFFING_DIRECT_MODE = 0x0,
+
+/* VP_CONF field values */
+	HDMI_VP_CONF_BYPASS_EN_MASK = 0x40,
+	HDMI_VP_CONF_BYPASS_EN_ENABLE = 0x40,
+	HDMI_VP_CONF_BYPASS_EN_DISABLE = 0x00,
+	HDMI_VP_CONF_PP_EN_ENMASK = 0x20,
+	HDMI_VP_CONF_PP_EN_ENABLE = 0x20,
+	HDMI_VP_CONF_PP_EN_DISABLE = 0x00,
+	HDMI_VP_CONF_PR_EN_MASK = 0x10,
+	HDMI_VP_CONF_PR_EN_ENABLE = 0x10,
+	HDMI_VP_CONF_PR_EN_DISABLE = 0x00,
+	HDMI_VP_CONF_YCC422_EN_MASK = 0x8,
+	HDMI_VP_CONF_YCC422_EN_ENABLE = 0x8,
+	HDMI_VP_CONF_YCC422_EN_DISABLE = 0x0,
+	HDMI_VP_CONF_BYPASS_SELECT_MASK = 0x4,
+	HDMI_VP_CONF_BYPASS_SELECT_VID_PACKETIZER = 0x4,
+	HDMI_VP_CONF_BYPASS_SELECT_PIX_REPEATER = 0x0,
+	HDMI_VP_CONF_OUTPUT_SELECTOR_MASK = 0x3,
+	HDMI_VP_CONF_OUTPUT_SELECTOR_BYPASS = 0x3,
+	HDMI_VP_CONF_OUTPUT_SELECTOR_YCC422 = 0x1,
+	HDMI_VP_CONF_OUTPUT_SELECTOR_PP = 0x0,
+
+/* VP_REMAP field values */
+	HDMI_VP_REMAP_MASK = 0x3,
+	HDMI_VP_REMAP_YCC422_24bit = 0x2,
+	HDMI_VP_REMAP_YCC422_20bit = 0x1,
+	HDMI_VP_REMAP_YCC422_16bit = 0x0,
+
+/* FC_INVIDCONF field values */
+	HDMI_FC_INVIDCONF_HDCP_KEEPOUT_MASK = 0x80,
+	HDMI_FC_INVIDCONF_HDCP_KEEPOUT_ACTIVE = 0x80,
+	HDMI_FC_INVIDCONF_HDCP_KEEPOUT_INACTIVE = 0x00,
+	HDMI_FC_INVIDCONF_VSYNC_IN_POLARITY_MASK = 0x40,
+	HDMI_FC_INVIDCONF_VSYNC_IN_POLARITY_ACTIVE_HIGH = 0x40,
+	HDMI_FC_INVIDCONF_VSYNC_IN_POLARITY_ACTIVE_LOW = 0x00,
+	HDMI_FC_INVIDCONF_HSYNC_IN_POLARITY_MASK = 0x20,
+	HDMI_FC_INVIDCONF_HSYNC_IN_POLARITY_ACTIVE_HIGH = 0x20,
+	HDMI_FC_INVIDCONF_HSYNC_IN_POLARITY_ACTIVE_LOW = 0x00,
+	HDMI_FC_INVIDCONF_DE_IN_POLARITY_MASK = 0x10,
+	HDMI_FC_INVIDCONF_DE_IN_POLARITY_ACTIVE_HIGH = 0x10,
+	HDMI_FC_INVIDCONF_DE_IN_POLARITY_ACTIVE_LOW = 0x00,
+	HDMI_FC_INVIDCONF_DVI_MODEZ_MASK = 0x8,
+	HDMI_FC_INVIDCONF_DVI_MODEZ_HDMI_MODE = 0x8,
+	HDMI_FC_INVIDCONF_DVI_MODEZ_DVI_MODE = 0x0,
+	HDMI_FC_INVIDCONF_R_V_BLANK_IN_OSC_MASK = 0x2,
+	HDMI_FC_INVIDCONF_R_V_BLANK_IN_OSC_ACTIVE_HIGH = 0x2,
+	HDMI_FC_INVIDCONF_R_V_BLANK_IN_OSC_ACTIVE_LOW = 0x0,
+	HDMI_FC_INVIDCONF_IN_I_P_MASK = 0x1,
+	HDMI_FC_INVIDCONF_IN_I_P_INTERLACED = 0x1,
+	HDMI_FC_INVIDCONF_IN_I_P_PROGRESSIVE = 0x0,
+
+/* FC_AUDICONF0 field values */
+	HDMI_FC_AUDICONF0_CC_OFFSET = 4,
+	HDMI_FC_AUDICONF0_CC_MASK = 0x70,
+	HDMI_FC_AUDICONF0_CT_OFFSET = 0,
+	HDMI_FC_AUDICONF0_CT_MASK = 0xF,
+
+/* FC_AUDICONF1 field values */
+	HDMI_FC_AUDICONF1_SS_OFFSET = 3,
+	HDMI_FC_AUDICONF1_SS_MASK = 0x18,
+	HDMI_FC_AUDICONF1_SF_OFFSET = 0,
+	HDMI_FC_AUDICONF1_SF_MASK = 0x7,
+
+/* FC_AUDICONF3 field values */
+	HDMI_FC_AUDICONF3_LFEPBL_OFFSET = 5,
+	HDMI_FC_AUDICONF3_LFEPBL_MASK = 0x60,
+	HDMI_FC_AUDICONF3_DM_INH_OFFSET = 4,
+	HDMI_FC_AUDICONF3_DM_INH_MASK = 0x10,
+	HDMI_FC_AUDICONF3_LSV_OFFSET = 0,
+	HDMI_FC_AUDICONF3_LSV_MASK = 0xF,
+
+/* FC_AUDSCHNLS0 field values */
+	HDMI_FC_AUDSCHNLS0_CGMSA_OFFSET = 4,
+	HDMI_FC_AUDSCHNLS0_CGMSA_MASK = 0x30,
+	HDMI_FC_AUDSCHNLS0_COPYRIGHT_OFFSET = 0,
+	HDMI_FC_AUDSCHNLS0_COPYRIGHT_MASK = 0x01,
+
+/* FC_AUDSCHNLS3-6 field values */
+	HDMI_FC_AUDSCHNLS3_OIEC_CH0_OFFSET = 0,
+	HDMI_FC_AUDSCHNLS3_OIEC_CH0_MASK = 0x0f,
+	HDMI_FC_AUDSCHNLS3_OIEC_CH1_OFFSET = 4,
+	HDMI_FC_AUDSCHNLS3_OIEC_CH1_MASK = 0xf0,
+	HDMI_FC_AUDSCHNLS4_OIEC_CH2_OFFSET = 0,
+	HDMI_FC_AUDSCHNLS4_OIEC_CH2_MASK = 0x0f,
+	HDMI_FC_AUDSCHNLS4_OIEC_CH3_OFFSET = 4,
+	HDMI_FC_AUDSCHNLS4_OIEC_CH3_MASK = 0xf0,
+
+	HDMI_FC_AUDSCHNLS5_OIEC_CH0_OFFSET = 0,
+	HDMI_FC_AUDSCHNLS5_OIEC_CH0_MASK = 0x0f,
+	HDMI_FC_AUDSCHNLS5_OIEC_CH1_OFFSET = 4,
+	HDMI_FC_AUDSCHNLS5_OIEC_CH1_MASK = 0xf0,
+	HDMI_FC_AUDSCHNLS6_OIEC_CH2_OFFSET = 0,
+	HDMI_FC_AUDSCHNLS6_OIEC_CH2_MASK = 0x0f,
+	HDMI_FC_AUDSCHNLS6_OIEC_CH3_OFFSET = 4,
+	HDMI_FC_AUDSCHNLS6_OIEC_CH3_MASK = 0xf0,
+
+/* HDMI_FC_AUDSCHNLS7 field values */
+	HDMI_FC_AUDSCHNLS7_ACCURACY_OFFSET = 4,
+	HDMI_FC_AUDSCHNLS7_ACCURACY_MASK = 0x30,
+
+/* HDMI_FC_AUDSCHNLS8 field values */
+	HDMI_FC_AUDSCHNLS8_ORIGSAMPFREQ_MASK = 0xf0,
+	HDMI_FC_AUDSCHNLS8_ORIGSAMPFREQ_OFFSET = 4,
+	HDMI_FC_AUDSCHNLS8_WORDLEGNTH_MASK = 0x0f,
+	HDMI_FC_AUDSCHNLS8_WORDLEGNTH_OFFSET = 0,
+
+/* FC_AUDSCONF field values */
+	HDMI_FC_AUDSCONF_AUD_PACKET_SAMPFIT_MASK = 0xF0,
+	HDMI_FC_AUDSCONF_AUD_PACKET_SAMPFIT_OFFSET = 4,
+	HDMI_FC_AUDSCONF_AUD_PACKET_LAYOUT_MASK = 0x1,
+	HDMI_FC_AUDSCONF_AUD_PACKET_LAYOUT_OFFSET = 0,
+	HDMI_FC_AUDSCONF_AUD_PACKET_LAYOUT_LAYOUT1 = 0x1,
+	HDMI_FC_AUDSCONF_AUD_PACKET_LAYOUT_LAYOUT0 = 0x0,
+
+/* FC_STAT2 field values */
+	HDMI_FC_STAT2_OVERFLOW_MASK = 0x03,
+	HDMI_FC_STAT2_LOW_PRIORITY_OVERFLOW = 0x02,
+	HDMI_FC_STAT2_HIGH_PRIORITY_OVERFLOW = 0x01,
+
+/* FC_INT2 field values */
+	HDMI_FC_INT2_OVERFLOW_MASK = 0x03,
+	HDMI_FC_INT2_LOW_PRIORITY_OVERFLOW = 0x02,
+	HDMI_FC_INT2_HIGH_PRIORITY_OVERFLOW = 0x01,
+
+/* FC_MASK2 field values */
+	HDMI_FC_MASK2_OVERFLOW_MASK = 0x03,
+	HDMI_FC_MASK2_LOW_PRIORITY_OVERFLOW = 0x02,
+	HDMI_FC_MASK2_HIGH_PRIORITY_OVERFLOW = 0x01,
+
+/* FC_PRCONF field values */
+	HDMI_FC_PRCONF_INCOMING_PR_FACTOR_MASK = 0xF0,
+	HDMI_FC_PRCONF_INCOMING_PR_FACTOR_OFFSET = 4,
+	HDMI_FC_PRCONF_OUTPUT_PR_FACTOR_MASK = 0x0F,
+	HDMI_FC_PRCONF_OUTPUT_PR_FACTOR_OFFSET = 0,
+
+/* FC_AVICONF0-FC_AVICONF3 field values */
+	HDMI_FC_AVICONF0_PIX_FMT_MASK = 0x03,
+	HDMI_FC_AVICONF0_PIX_FMT_RGB = 0x00,
+	HDMI_FC_AVICONF0_PIX_FMT_YCBCR422 = 0x01,
+	HDMI_FC_AVICONF0_PIX_FMT_YCBCR444 = 0x02,
+	HDMI_FC_AVICONF0_ACTIVE_FMT_MASK = 0x40,
+	HDMI_FC_AVICONF0_ACTIVE_FMT_INFO_PRESENT = 0x40,
+	HDMI_FC_AVICONF0_ACTIVE_FMT_NO_INFO = 0x00,
+	HDMI_FC_AVICONF0_BAR_DATA_MASK = 0x0C,
+	HDMI_FC_AVICONF0_BAR_DATA_NO_DATA = 0x00,
+	HDMI_FC_AVICONF0_BAR_DATA_VERT_BAR = 0x04,
+	HDMI_FC_AVICONF0_BAR_DATA_HORIZ_BAR = 0x08,
+	HDMI_FC_AVICONF0_BAR_DATA_VERT_HORIZ_BAR = 0x0C,
+	HDMI_FC_AVICONF0_SCAN_INFO_MASK = 0x30,
+	HDMI_FC_AVICONF0_SCAN_INFO_OVERSCAN = 0x10,
+	HDMI_FC_AVICONF0_SCAN_INFO_UNDERSCAN = 0x20,
+	HDMI_FC_AVICONF0_SCAN_INFO_NODATA = 0x00,
+
+	HDMI_FC_AVICONF1_ACTIVE_ASPECT_RATIO_MASK = 0x0F,
+	HDMI_FC_AVICONF1_ACTIVE_ASPECT_RATIO_USE_CODED = 0x08,
+	HDMI_FC_AVICONF1_ACTIVE_ASPECT_RATIO_4_3 = 0x09,
+	HDMI_FC_AVICONF1_ACTIVE_ASPECT_RATIO_16_9 = 0x0A,
+	HDMI_FC_AVICONF1_ACTIVE_ASPECT_RATIO_14_9 = 0x0B,
+	HDMI_FC_AVICONF1_CODED_ASPECT_RATIO_MASK = 0x30,
+	HDMI_FC_AVICONF1_CODED_ASPECT_RATIO_NO_DATA = 0x00,
+	HDMI_FC_AVICONF1_CODED_ASPECT_RATIO_4_3 = 0x10,
+	HDMI_FC_AVICONF1_CODED_ASPECT_RATIO_16_9 = 0x20,
+	HDMI_FC_AVICONF1_COLORIMETRY_MASK = 0xC0,
+	HDMI_FC_AVICONF1_COLORIMETRY_NO_DATA = 0x00,
+	HDMI_FC_AVICONF1_COLORIMETRY_SMPTE = 0x40,
+	HDMI_FC_AVICONF1_COLORIMETRY_ITUR = 0x80,
+	HDMI_FC_AVICONF1_COLORIMETRY_EXTENDED_INFO = 0xC0,
+
+	HDMI_FC_AVICONF2_SCALING_MASK = 0x03,
+	HDMI_FC_AVICONF2_SCALING_NONE = 0x00,
+	HDMI_FC_AVICONF2_SCALING_HORIZ = 0x01,
+	HDMI_FC_AVICONF2_SCALING_VERT = 0x02,
+	HDMI_FC_AVICONF2_SCALING_HORIZ_VERT = 0x03,
+	HDMI_FC_AVICONF2_RGB_QUANT_MASK = 0x0C,
+	HDMI_FC_AVICONF2_RGB_QUANT_DEFAULT = 0x00,
+	HDMI_FC_AVICONF2_RGB_QUANT_LIMITED_RANGE = 0x04,
+	HDMI_FC_AVICONF2_RGB_QUANT_FULL_RANGE = 0x08,
+	HDMI_FC_AVICONF2_EXT_COLORIMETRY_MASK = 0x70,
+	HDMI_FC_AVICONF2_EXT_COLORIMETRY_XVYCC601 = 0x00,
+	HDMI_FC_AVICONF2_EXT_COLORIMETRY_XVYCC709 = 0x10,
+	HDMI_FC_AVICONF2_EXT_COLORIMETRY_SYCC601 = 0x20,
+	HDMI_FC_AVICONF2_EXT_COLORIMETRY_ADOBE_YCC601 = 0x30,
+	HDMI_FC_AVICONF2_EXT_COLORIMETRY_ADOBE_RGB = 0x40,
+	HDMI_FC_AVICONF2_IT_CONTENT_MASK = 0x80,
+	HDMI_FC_AVICONF2_IT_CONTENT_NO_DATA = 0x00,
+	HDMI_FC_AVICONF2_IT_CONTENT_VALID = 0x80,
+
+	HDMI_FC_AVICONF3_IT_CONTENT_TYPE_MASK = 0x03,
+	HDMI_FC_AVICONF3_IT_CONTENT_TYPE_GRAPHICS = 0x00,
+	HDMI_FC_AVICONF3_IT_CONTENT_TYPE_PHOTO = 0x01,
+	HDMI_FC_AVICONF3_IT_CONTENT_TYPE_CINEMA = 0x02,
+	HDMI_FC_AVICONF3_IT_CONTENT_TYPE_GAME = 0x03,
+	HDMI_FC_AVICONF3_QUANT_RANGE_MASK = 0x0C,
+	HDMI_FC_AVICONF3_QUANT_RANGE_LIMITED = 0x00,
+	HDMI_FC_AVICONF3_QUANT_RANGE_FULL = 0x04,
+
+/* FC_DBGFORCE field values */
+	HDMI_FC_DBGFORCE_FORCEAUDIO = 0x10,
+	HDMI_FC_DBGFORCE_FORCEVIDEO = 0x1,
+
+/* PHY_CONF0 field values */
+	HDMI_PHY_CONF0_PDZ_MASK = 0x80,
+	HDMI_PHY_CONF0_PDZ_OFFSET = 7,
+	HDMI_PHY_CONF0_ENTMDS_MASK = 0x40,
+	HDMI_PHY_CONF0_ENTMDS_OFFSET = 6,
+	HDMI_PHY_CONF0_SPARECTRL = 0x20,
+	HDMI_PHY_CONF0_GEN2_PDDQ_MASK = 0x10,
+	HDMI_PHY_CONF0_GEN2_PDDQ_OFFSET = 4,
+	HDMI_PHY_CONF0_GEN2_TXPWRON_MASK = 0x8,
+	HDMI_PHY_CONF0_GEN2_TXPWRON_OFFSET = 3,
+	HDMI_PHY_CONF0_GEN2_ENHPDRXSENSE_MASK = 0x4,
+	HDMI_PHY_CONF0_GEN2_ENHPDRXSENSE_OFFSET = 2,
+	HDMI_PHY_CONF0_SELDATAENPOL_MASK = 0x2,
+	HDMI_PHY_CONF0_SELDATAENPOL_OFFSET = 1,
+	HDMI_PHY_CONF0_SELDIPIF_MASK = 0x1,
+	HDMI_PHY_CONF0_SELDIPIF_OFFSET = 0,
+
+/* PHY_TST0 field values */
+	HDMI_PHY_TST0_TSTCLR_MASK = 0x20,
+	HDMI_PHY_TST0_TSTCLR_OFFSET = 5,
+	HDMI_PHY_TST0_TSTEN_MASK = 0x10,
+	HDMI_PHY_TST0_TSTEN_OFFSET = 4,
+	HDMI_PHY_TST0_TSTCLK_MASK = 0x1,
+	HDMI_PHY_TST0_TSTCLK_OFFSET = 0,
+
+/* PHY_STAT0 field values */
+	HDMI_PHY_RX_SENSE3 = 0x80,
+	HDMI_PHY_RX_SENSE2 = 0x40,
+	HDMI_PHY_RX_SENSE1 = 0x20,
+	HDMI_PHY_RX_SENSE0 = 0x10,
+	HDMI_PHY_HPD = 0x02,
+	HDMI_PHY_TX_PHY_LOCK = 0x01,
+
+/* PHY_I2CM_SLAVE_ADDR field values */
+	HDMI_PHY_I2CM_SLAVE_ADDR_PHY_GEN2 = 0x69,
+	HDMI_PHY_I2CM_SLAVE_ADDR_HEAC_PHY = 0x49,
+
+/* PHY_I2CM_OPERATION_ADDR field values */
+	HDMI_PHY_I2CM_OPERATION_ADDR_WRITE = 0x10,
+	HDMI_PHY_I2CM_OPERATION_ADDR_READ = 0x1,
+
+/* HDMI_PHY_I2CM_INT_ADDR */
+	HDMI_PHY_I2CM_INT_ADDR_DONE_POL = 0x08,
+	HDMI_PHY_I2CM_INT_ADDR_DONE_MASK = 0x04,
+
+/* HDMI_PHY_I2CM_CTLINT_ADDR */
+	HDMI_PHY_I2CM_CTLINT_ADDR_NAC_POL = 0x80,
+	HDMI_PHY_I2CM_CTLINT_ADDR_NAC_MASK = 0x40,
+	HDMI_PHY_I2CM_CTLINT_ADDR_ARBITRATION_POL = 0x08,
+	HDMI_PHY_I2CM_CTLINT_ADDR_ARBITRATION_MASK = 0x04,
+
+/* AUD_CTS3 field values */
+	HDMI_AUD_CTS3_N_SHIFT_OFFSET = 5,
+	HDMI_AUD_CTS3_N_SHIFT_MASK = 0xe0,
+	HDMI_AUD_CTS3_N_SHIFT_1 = 0,
+	HDMI_AUD_CTS3_N_SHIFT_16 = 0x20,
+	HDMI_AUD_CTS3_N_SHIFT_32 = 0x40,
+	HDMI_AUD_CTS3_N_SHIFT_64 = 0x60,
+	HDMI_AUD_CTS3_N_SHIFT_128 = 0x80,
+	HDMI_AUD_CTS3_N_SHIFT_256 = 0xa0,
+	/* note that the CTS3 MANUAL bit has been removed
+	   from our part. Can't set it, will read as 0. */
+	HDMI_AUD_CTS3_CTS_MANUAL = 0x10,
+	HDMI_AUD_CTS3_AUDCTS19_16_MASK = 0x0f,
+
+/* AHB_DMA_CONF0 field values */
+	HDMI_AHB_DMA_CONF0_SW_FIFO_RST_OFFSET = 7,
+	HDMI_AHB_DMA_CONF0_SW_FIFO_RST_MASK = 0x80,
+	HDMI_AHB_DMA_CONF0_HBR = 0x10,
+	HDMI_AHB_DMA_CONF0_EN_HLOCK_OFFSET = 3,
+	HDMI_AHB_DMA_CONF0_EN_HLOCK_MASK = 0x08,
+	HDMI_AHB_DMA_CONF0_INCR_TYPE_OFFSET = 1,
+	HDMI_AHB_DMA_CONF0_INCR_TYPE_MASK = 0x06,
+	HDMI_AHB_DMA_CONF0_INCR4 = 0x0,
+	HDMI_AHB_DMA_CONF0_INCR8 = 0x2,
+	HDMI_AHB_DMA_CONF0_INCR16 = 0x4,
+	HDMI_AHB_DMA_CONF0_BURST_MODE = 0x1,
+
+/* HDMI_AHB_DMA_START field values */
+	HDMI_AHB_DMA_START_START_OFFSET = 0,
+	HDMI_AHB_DMA_START_START_MASK = 0x01,
+
+/* HDMI_AHB_DMA_STOP field values */
+	HDMI_AHB_DMA_STOP_STOP_OFFSET = 0,
+	HDMI_AHB_DMA_STOP_STOP_MASK = 0x01,
+
+/* AHB_DMA_STAT, AHB_DMA_INT, AHB_DMA_MASK, AHB_DMA_POL field values */
+	HDMI_AHB_DMA_DONE = 0x80,
+	HDMI_AHB_DMA_RETRY_SPLIT = 0x40,
+	HDMI_AHB_DMA_LOSTOWNERSHIP = 0x20,
+	HDMI_AHB_DMA_ERROR = 0x10,
+	HDMI_AHB_DMA_FIFO_THREMPTY = 0x04,
+	HDMI_AHB_DMA_FIFO_FULL = 0x02,
+	HDMI_AHB_DMA_FIFO_EMPTY = 0x01,
+
+/* AHB_DMA_BUFFSTAT, AHB_DMA_BUFFINT, AHB_DMA_BUFFMASK, AHB_DMA_BUFFPOL field values */
+	HDMI_AHB_DMA_BUFFSTAT_FULL = 0x02,
+	HDMI_AHB_DMA_BUFFSTAT_EMPTY = 0x01,
+
+/* MC_CLKDIS field values */
+	HDMI_MC_CLKDIS_HDCPCLK_DISABLE = 0x40,
+	HDMI_MC_CLKDIS_CECCLK_DISABLE = 0x20,
+	HDMI_MC_CLKDIS_CSCCLK_DISABLE = 0x10,
+	HDMI_MC_CLKDIS_AUDCLK_DISABLE = 0x8,
+	HDMI_MC_CLKDIS_PREPCLK_DISABLE = 0x4,
+	HDMI_MC_CLKDIS_TMDSCLK_DISABLE = 0x2,
+	HDMI_MC_CLKDIS_PIXELCLK_DISABLE = 0x1,
+
+/* MC_SWRSTZ field values */
+	HDMI_MC_SWRSTZ_TMDSSWRST_REQ = 0x02,
+
+/* MC_FLOWCTRL field values */
+	HDMI_MC_FLOWCTRL_FEED_THROUGH_OFF_MASK = 0x1,
+	HDMI_MC_FLOWCTRL_FEED_THROUGH_OFF_CSC_IN_PATH = 0x1,
+	HDMI_MC_FLOWCTRL_FEED_THROUGH_OFF_CSC_BYPASS = 0x0,
+
+/* MC_PHYRSTZ field values */
+	HDMI_MC_PHYRSTZ_ASSERT = 0x0,
+	HDMI_MC_PHYRSTZ_DEASSERT = 0x1,
+
+/* MC_HEACPHY_RST field values */
+	HDMI_MC_HEACPHY_RST_ASSERT = 0x1,
+	HDMI_MC_HEACPHY_RST_DEASSERT = 0x0,
+
+/* CSC_CFG field values */
+	HDMI_CSC_CFG_INTMODE_MASK = 0x30,
+	HDMI_CSC_CFG_INTMODE_OFFSET = 4,
+	HDMI_CSC_CFG_INTMODE_DISABLE = 0x00,
+	HDMI_CSC_CFG_INTMODE_CHROMA_INT_FORMULA1 = 0x10,
+	HDMI_CSC_CFG_INTMODE_CHROMA_INT_FORMULA2 = 0x20,
+	HDMI_CSC_CFG_DECMODE_MASK = 0x3,
+	HDMI_CSC_CFG_DECMODE_OFFSET = 0,
+	HDMI_CSC_CFG_DECMODE_DISABLE = 0x0,
+	HDMI_CSC_CFG_DECMODE_CHROMA_INT_FORMULA1 = 0x1,
+	HDMI_CSC_CFG_DECMODE_CHROMA_INT_FORMULA2 = 0x2,
+	HDMI_CSC_CFG_DECMODE_CHROMA_INT_FORMULA3 = 0x3,
+
+/* CSC_SCALE field values */
+	HDMI_CSC_SCALE_CSC_COLORDE_PTH_MASK = 0xF0,
+	HDMI_CSC_SCALE_CSC_COLORDE_PTH_24BPP = 0x00,
+	HDMI_CSC_SCALE_CSC_COLORDE_PTH_30BPP = 0x50,
+	HDMI_CSC_SCALE_CSC_COLORDE_PTH_36BPP = 0x60,
+	HDMI_CSC_SCALE_CSC_COLORDE_PTH_48BPP = 0x70,
+	HDMI_CSC_SCALE_CSCSCALE_MASK = 0x03,
+
+/* I2CM_OPERATION field values */
+	HDMI_I2CM_OPERATION_WRITE = 0x10,
+	HDMI_I2CM_OPERATION_READ_EXT = 0x2,
+	HDMI_I2CM_OPERATION_READ = 0x1,
+
+/* HDMI_I2CM_INT */
+	HDMI_I2CM_INT_DONE_POL = 0x08,
+	HDMI_I2CM_INT_DONE_MASK = 0x04,
+
+/* HDMI_I2CM_CTLINT */
+	HDMI_I2CM_CTLINT_NAC_POL = 0x80,
+	HDMI_I2CM_CTLINT_NAC_MASK = 0x40,
+	HDMI_I2CM_CTLINT_ARBITRATION_POL = 0x08,
+	HDMI_I2CM_CTLINT_ARBITRATION_MASK = 0x04,
+
+};
+
+enum imx_hdmi_type {
+	IMX6DL_HDMI,
+	IMX6Q_HDMI,
+};
+
+/* IOCTL commands */
+#define HDMI_IOC_MAGIC  'H'
+
+#define HDMI_IOC_GET_RESOURCE	_IO(HDMI_IOC_MAGIC, 0)
+#define HDMI_IOC_GET_CPU_TYPE	_IO(HDMI_IOC_MAGIC, 1)
+
+
+#endif /* __MXC_HDMI_H__ */
diff --git a/include/xen/interface/io/i2cif.h b/include/xen/interface/io/i2cif.h
new file mode 100644
index 000000000..c50467042
--- /dev/null
+++ b/include/xen/interface/io/i2cif.h
@@ -0,0 +1,95 @@
+/******************************************************************************
+ * i2cif.h
+ *
+ * I2C device I/O interface for Xen guest OSes.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a copy
+ * of this software and associated documentation files (the "Software"), to
+ * deal in the Software without restriction, including without limitation the
+ * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
+ * sell copies of the Software, and to permit persons to whom the Software is
+ * furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+ * DEALINGS IN THE SOFTWARE.
+ *
+ * Copyright 2018-2019 NXP
+ *
+ * Authors: Peng Fan <peng.fan@nxp.com>
+ */
+
+#ifndef __XEN_PUBLIC_IO_I2CIF_H__
+#define __XEN_PUBLIC_IO_I2CIF_H__
+
+#include <xen/interface/io/ring.h>
+#include <xen/interface/grant_table.h>
+
+#define I2CIF_BUF_LEN	I2C_SMBUS_BLOCK_MAX + 2
+#define I2CIF_MAX_MSG	2
+
+#define I2CIF_M_RD		0x0001	/* read data, from slave to master */
+					/* I2C_M_RD is guaranteed to be 0x0001! */
+#define I2CIF_M_TEN		0x0010	/* this is a ten bit chip address */
+#define I2CIF_M_RECV_LEN	0x0400	/* length will be first received byte */
+#define I2CIF_M_NO_RD_ACK	0x0800	/* if I2CIF_FUNC_PROTOCOL_MANGLING */
+#define I2CIF_M_IGNORE_NAK	0x1000	/* if I2CIF_FUNC_PROTOCOL_MANGLING */
+#define I2CIF_M_REV_DIR_ADDR	0x2000	/* if I2CIF_FUNC_PROTOCOL_MANGLING */
+#define I2CIF_M_NOSTART		0x4000	/* if I2CIF_FUNC_NOSTART */
+#define I2CIF_M_STOP		0x8000	/* if I2CIF_FUNC_PROTOCOL_MANGLING */
+
+#define I2CIF_FUNC_I2C				0x00000001
+#define I2CIF_FUNC_10BIT_ADDR			0x00000002
+#define I2CIF_FUNC_PROTOCOL_MANGLING		0x00000004 /* I2C_M_IGNORE_NAK etc. */
+#define I2CIF_FUNC_SMBUS_PEC			0x00000008
+#define I2CIF_FUNC_NOSTART			0x00000010 /* I2C_M_NOSTART */
+#define I2CIF_FUNC_SLAVE			0x00000020
+#define I2CIF_FUNC_SMBUS_BLOCK_PROC_CALL	0x00008000 /* SMBus 2.0 */
+#define I2CIF_FUNC_SMBUS_QUICK			0x00010000
+#define I2CIF_FUNC_SMBUS_READ_BYTE		0x00020000
+#define I2CIF_FUNC_SMBUS_WRITE_BYTE		0x00040000
+#define I2CIF_FUNC_SMBUS_READ_BYTE_DATA		0x00080000
+#define I2CIF_FUNC_SMBUS_WRITE_BYTE_DATA	0x00100000
+#define I2CIF_FUNC_SMBUS_READ_WORD_DATA		0x00200000
+#define I2CIF_FUNC_SMBUS_WRITE_WORD_DATA	0x00400000
+#define I2CIF_FUNC_SMBUS_PROC_CALL		0x00800000
+#define I2CIF_FUNC_SMBUS_READ_BLOCK_DATA	0x01000000
+#define I2CIF_FUNC_SMBUS_WRITE_BLOCK_DATA	0x02000000
+#define I2CIF_FUNC_SMBUS_READ_I2C_BLOCK		0x04000000 /* I2C-like block xfer  */
+#define I2CIF_FUNC_SMBUS_WRITE_I2C_BLOCK	0x08000000 /* w/ 1-byte reg. addr. */
+#define I2CIF_FUNC_SMBUS_HOST_NOTIFY		0x10000000
+
+#define I2CIF_ADAPTER_NAME_LEN	32
+
+struct i2cif_request {
+	struct {
+		__u16 addr;	/* slave address */
+		__u16 flags;	/* msg flags */
+		__u16 len;	/* msg length */
+	} msg[I2CIF_MAX_MSG];
+	int num_msg;
+	__u8 write_buf[I2CIF_BUF_LEN];
+
+	bool is_smbus;
+	__u16 addr;
+	__u16 flags;
+	__u8 read_write;
+	__u8 command;
+	int protocol;
+};
+
+struct i2cif_response {
+	int result;
+	__u8 read_buf[I2CIF_BUF_LEN];
+};
+
+DEFINE_RING_TYPES(i2cif, struct i2cif_request, struct i2cif_response);
+
+#endif
