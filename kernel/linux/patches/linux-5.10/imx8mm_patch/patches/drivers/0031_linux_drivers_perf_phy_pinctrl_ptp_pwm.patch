commit b6289a195980e52cfee7c22d22c25c8337875be3
Author: zhaoxc0502 <zhaoxc0502@thundersoft.com>
Date:   Thu Jun 16 17:26:27 2022 +0800

    linux_drivers_perf_phy_pinctrl_ptp_pwm
    
    Change-Id: I50a0069a60f92f57dd6112f6a9700811be19e564

diff --git a/drivers/perf/fsl_imx8_ddr_perf.c b/drivers/perf/fsl_imx8_ddr_perf.c
index 7f7bc0993..557aad5a6 100644
--- a/drivers/perf/fsl_imx8_ddr_perf.c
+++ b/drivers/perf/fsl_imx8_ddr_perf.c
@@ -5,6 +5,7 @@
  */
 
 #include <linux/bitfield.h>
+#include <linux/clk.h>
 #include <linux/init.h>
 #include <linux/interrupt.h>
 #include <linux/io.h>
@@ -14,12 +15,15 @@
 #include <linux/of_device.h>
 #include <linux/of_irq.h>
 #include <linux/perf_event.h>
+#include <linux/spinlock.h>
 #include <linux/slab.h>
 
 #define COUNTER_CNTL		0x0
 #define COUNTER_READ		0x20
 
 #define COUNTER_DPCR1		0x30
+#define COUNTER_MUX_CNTL	0x50
+#define COUNTER_MASK_COMP	0x54
 
 #define CNTL_OVER		0x1
 #define CNTL_CLEAR		0x2
@@ -28,9 +32,18 @@
 #define CNTL_CLEAR_MASK		0xFFFFFFFD
 #define CNTL_OVER_MASK		0xFFFFFFFE
 
+#define CNTL_CP_SHIFT		16
+#define CNTL_CP_MASK		(0xFF << CNTL_CP_SHIFT)
 #define CNTL_CSV_SHIFT		24
 #define CNTL_CSV_MASK		(0xFF << CNTL_CSV_SHIFT)
 
+#define READ_PORT_SHIFT		0
+#define READ_PORT_MASK		(0x7 << READ_PORT_SHIFT)
+#define READ_CHANNEL_REVERT	0x00000008	/* bit 3 for read channel select */
+#define WRITE_PORT_SHIFT	8
+#define WRITE_PORT_MASK		(0x7 << WRITE_PORT_SHIFT)
+#define WRITE_CHANNEL_REVERT	0x00000800	/* bit 11 for write channel select */
+
 #define EVENT_CYCLES_ID		0
 #define EVENT_CYCLES_COUNTER	0
 #define NUM_COUNTERS		4
@@ -40,32 +53,56 @@
 #define to_ddr_pmu(p)		container_of(p, struct ddr_pmu, pmu)
 
 #define DDR_PERF_DEV_NAME	"imx8_ddr"
+#define DB_PERF_DEV_NAME	"imx8_db"
 #define DDR_CPUHP_CB_NAME	DDR_PERF_DEV_NAME "_perf_pmu"
 
 static DEFINE_IDA(ddr_ida);
+static DEFINE_IDA(db_ida);
 
 /* DDR Perf hardware feature */
 #define DDR_CAP_AXI_ID_FILTER			0x1     /* support AXI ID filter */
 #define DDR_CAP_AXI_ID_FILTER_ENHANCED		0x3     /* support enhanced AXI ID filter */
+#define DDR_CAP_AXI_ID_PORT_CHANNEL_FILTER	0x4	/* support AXI ID PORT CHANNEL filter */
+
+/* Perf type */
+#define DDR_PERF_TYPE		0x1	/* ddr Perf */
+#define DB_PERF_TYPE		0x2	/* db Perf */
 
 struct fsl_ddr_devtype_data {
 	unsigned int quirks;    /* quirks needed for different DDR Perf core */
+	unsigned int type;	/* types of Perf, point the location of Perf */
 };
 
-static const struct fsl_ddr_devtype_data imx8_devtype_data;
+static const struct fsl_ddr_devtype_data imx8_devtype_data = {
+	.type = DDR_PERF_TYPE,
+};
 
 static const struct fsl_ddr_devtype_data imx8m_devtype_data = {
 	.quirks = DDR_CAP_AXI_ID_FILTER,
+	.type = DDR_PERF_TYPE,
 };
 
 static const struct fsl_ddr_devtype_data imx8mp_devtype_data = {
 	.quirks = DDR_CAP_AXI_ID_FILTER_ENHANCED,
+	.type = DDR_PERF_TYPE,
+};
+
+static const struct fsl_ddr_devtype_data imx8dxl_devtype_data = {
+	.quirks = DDR_CAP_AXI_ID_PORT_CHANNEL_FILTER,
+	.type = DDR_PERF_TYPE,
+};
+
+static const struct fsl_ddr_devtype_data imx8dxl_db_devtype_data = {
+	.quirks = DDR_CAP_AXI_ID_PORT_CHANNEL_FILTER,
+	.type = DB_PERF_TYPE,
 };
 
 static const struct of_device_id imx_ddr_pmu_dt_ids[] = {
 	{ .compatible = "fsl,imx8-ddr-pmu", .data = &imx8_devtype_data},
 	{ .compatible = "fsl,imx8m-ddr-pmu", .data = &imx8m_devtype_data},
 	{ .compatible = "fsl,imx8mp-ddr-pmu", .data = &imx8mp_devtype_data},
+	{ .compatible = "fsl,imx8dxl-ddr-pmu", .data = &imx8dxl_devtype_data},
+	{ .compatible = "fsl,imx8dxl-db-pmu", .data = &imx8dxl_db_devtype_data},
 	{ /* sentinel */ }
 };
 MODULE_DEVICE_TABLE(of, imx_ddr_pmu_dt_ids);
@@ -82,11 +119,15 @@ struct ddr_pmu {
 	const struct fsl_ddr_devtype_data *devtype_data;
 	int irq;
 	int id;
+	spinlock_t lock;
+	struct clk *clk_ipg;
+	struct clk *clk_cnt;
 };
 
 enum ddr_perf_filter_capabilities {
 	PERF_CAP_AXI_ID_FILTER = 0,
 	PERF_CAP_AXI_ID_FILTER_ENHANCED,
+	PERF_CAP_AXI_ID_PORT_CHANNEL_FILTER,
 	PERF_CAP_AXI_ID_FEAT_MAX,
 };
 
@@ -100,6 +141,8 @@ static u32 ddr_perf_filter_cap_get(struct ddr_pmu *pmu, int cap)
 	case PERF_CAP_AXI_ID_FILTER_ENHANCED:
 		quirks &= DDR_CAP_AXI_ID_FILTER_ENHANCED;
 		return quirks == DDR_CAP_AXI_ID_FILTER_ENHANCED;
+	case PERF_CAP_AXI_ID_PORT_CHANNEL_FILTER:
+		return !!(quirks & DDR_CAP_AXI_ID_PORT_CHANNEL_FILTER);
 	default:
 		WARN(1, "unknown filter cap %d\n", cap);
 	}
@@ -131,6 +174,7 @@ static ssize_t ddr_perf_filter_cap_show(struct device *dev,
 static struct attribute *ddr_perf_filter_cap_attr[] = {
 	PERF_FILTER_EXT_ATTR_ENTRY(filter, PERF_CAP_AXI_ID_FILTER),
 	PERF_FILTER_EXT_ATTR_ENTRY(enhanced_filter, PERF_CAP_AXI_ID_FILTER_ENHANCED),
+	PERF_FILTER_EXT_ATTR_ENTRY(super_filter, PERF_CAP_AXI_ID_PORT_CHANNEL_FILTER),
 	NULL,
 };
 
@@ -216,14 +260,30 @@ static struct attribute_group ddr_perf_events_attr_group = {
 	.attrs = ddr_perf_events_attrs,
 };
 
+static struct attribute *db_perf_events_attrs[] = {
+	IMX8_DDR_PMU_EVENT_ATTR(cycles, EVENT_CYCLES_ID),
+	IMX8_DDR_PMU_EVENT_ATTR(axid-read, 0x41),
+	IMX8_DDR_PMU_EVENT_ATTR(axid-write, 0x42),
+	NULL,
+};
+
+static struct attribute_group db_perf_events_attr_group = {
+	.name = "events",
+	.attrs = db_perf_events_attrs,
+};
+
 PMU_FORMAT_ATTR(event, "config:0-7");
 PMU_FORMAT_ATTR(axi_id, "config1:0-15");
 PMU_FORMAT_ATTR(axi_mask, "config1:16-31");
+PMU_FORMAT_ATTR(axi_port, "config2:0-2");
+PMU_FORMAT_ATTR(axi_channel, "config2:3-3");
 
 static struct attribute *ddr_perf_format_attrs[] = {
 	&format_attr_event.attr,
 	&format_attr_axi_id.attr,
 	&format_attr_axi_mask.attr,
+	&format_attr_axi_port.attr,
+	&format_attr_axi_channel.attr,
 	NULL,
 };
 
@@ -232,7 +292,8 @@ static struct attribute_group ddr_perf_format_attr_group = {
 	.attrs = ddr_perf_format_attrs,
 };
 
-static const struct attribute_group *attr_groups[] = {
+static const struct attribute_group *ddr_attr_groups[] = {
+
 	&ddr_perf_events_attr_group,
 	&ddr_perf_format_attr_group,
 	&ddr_perf_cpumask_attr_group,
@@ -240,6 +301,35 @@ static const struct attribute_group *attr_groups[] = {
 	NULL,
 };
 
+static const struct attribute_group *db_attr_groups[] = {
+	&db_perf_events_attr_group,
+	&ddr_perf_format_attr_group,
+	&ddr_perf_cpumask_attr_group,
+	&ddr_perf_filter_cap_attr_group,
+	NULL,
+};
+
+static int ddr_perf_clks_enable(struct ddr_pmu *pmu)
+{
+	int err;
+
+	err = clk_prepare_enable(pmu->clk_ipg);
+	if (err)
+		return err;
+
+	err = clk_prepare_enable(pmu->clk_cnt);
+	if (err)
+		clk_disable_unprepare(pmu->clk_ipg);
+
+	return err;
+}
+
+static void ddr_perf_clks_disable(struct ddr_pmu *pmu)
+{
+	clk_disable_unprepare(pmu->clk_cnt);
+	clk_disable_unprepare(pmu->clk_ipg);
+}
+
 static bool ddr_perf_is_filtered(struct perf_event *event)
 {
 	return event->attr.config == 0x41 || event->attr.config == 0x42;
@@ -368,16 +458,19 @@ static void ddr_perf_event_update(struct perf_event *event)
 	struct hw_perf_event *hwc = &event->hw;
 	u64 delta, prev_raw_count, new_raw_count;
 	int counter = hwc->idx;
+	unsigned long flags;
 
-	do {
-		prev_raw_count = local64_read(&hwc->prev_count);
-		new_raw_count = ddr_perf_read_counter(pmu, counter);
-	} while (local64_cmpxchg(&hwc->prev_count, prev_raw_count,
-			new_raw_count) != prev_raw_count);
+	spin_lock_irqsave(&pmu->lock, flags);
+
+	prev_raw_count = local64_read(&hwc->prev_count);
+	new_raw_count = ddr_perf_read_counter(pmu, counter);
 
 	delta = (new_raw_count - prev_raw_count) & 0xFFFFFFFF;
 
 	local64_add(delta, &event->count);
+	local64_set(&hwc->prev_count, new_raw_count);
+
+	spin_unlock_irqrestore(&pmu->lock, flags);
 }
 
 static void ddr_perf_counter_enable(struct ddr_pmu *pmu, int config,
@@ -396,6 +489,20 @@ static void ddr_perf_counter_enable(struct ddr_pmu *pmu, int config,
 		writel(0, pmu->base + reg);
 		val = CNTL_EN | CNTL_CLEAR;
 		val |= FIELD_PREP(CNTL_CSV_MASK, config);
+
+		/*
+		 * Workaround for i.MX8MP:
+		 * Common counters and byte counters share the same COUNTER_CNTL,
+		 * and byte counters could overflow before cycle counter. Need set
+		 * counter parameter(CP) of cycle counter to give it initial value
+		 * which can speed up cycle counter overflow frequency.
+		 */
+		if ((pmu->devtype_data->quirks & DDR_CAP_AXI_ID_FILTER_ENHANCED) ==
+		    DDR_CAP_AXI_ID_FILTER_ENHANCED) {
+			if (counter == EVENT_CYCLES_COUNTER)
+				val |= FIELD_PREP(CNTL_CP_MASK, 0xe8);
+		}
+
 		writel(val, pmu->base + reg);
 	} else {
 		/* Disable counter */
@@ -404,13 +511,29 @@ static void ddr_perf_counter_enable(struct ddr_pmu *pmu, int config,
 	}
 }
 
+static bool ddr_perf_counter_overflow(struct ddr_pmu *pmu, int counter)
+{
+	int val;
+
+	val = readl_relaxed(pmu->base + counter * 4 + COUNTER_CNTL);
+
+	return val & CNTL_OVER ? true : false;
+}
+
 static void ddr_perf_event_start(struct perf_event *event, int flags)
 {
 	struct ddr_pmu *pmu = to_ddr_pmu(event->pmu);
 	struct hw_perf_event *hwc = &event->hw;
 	int counter = hwc->idx;
 
-	local64_set(&hwc->prev_count, 0);
+	/* Workaround for i.MX865 */
+	if ((pmu->devtype_data->quirks & DDR_CAP_AXI_ID_FILTER_ENHANCED) ==
+	     DDR_CAP_AXI_ID_FILTER_ENHANCED) {
+		if (counter == EVENT_CYCLES_COUNTER)
+			local64_set(&hwc->prev_count, 0xe8000000);
+	} else {
+		local64_set(&hwc->prev_count, 0);
+	}
 
 	ddr_perf_counter_enable(pmu, event->attr.config, counter, true);
 
@@ -424,6 +547,7 @@ static int ddr_perf_event_add(struct perf_event *event, int flags)
 	int counter;
 	int cfg = event->attr.config;
 	int cfg1 = event->attr.config1;
+	int cfg2 = event->attr.config2;
 
 	if (pmu->devtype_data->quirks & DDR_CAP_AXI_ID_FILTER) {
 		int i;
@@ -447,6 +571,28 @@ static int ddr_perf_event_add(struct perf_event *event, int flags)
 		return -EOPNOTSUPP;
 	}
 
+	if (pmu->devtype_data->quirks & DDR_CAP_AXI_ID_PORT_CHANNEL_FILTER) {
+		if (ddr_perf_is_filtered(event)) {
+			/* revert axi id masking(axi_mask) value */
+			cfg1 ^= AXI_MASKING_REVERT;
+			writel(cfg1, pmu->base + COUNTER_MASK_COMP + ((counter - 1) << 4));
+
+			if (cfg == 0x41) {
+				/* revert axi read channel(axi_channel) value */
+				cfg2 ^= READ_CHANNEL_REVERT;
+
+				cfg2 |= FIELD_PREP(READ_PORT_MASK, cfg2);
+			} else {
+				/* revert axi write channel(axi_channel) value */
+				cfg2 ^= WRITE_CHANNEL_REVERT;
+
+				cfg2 |= FIELD_PREP(WRITE_PORT_MASK, cfg2);
+			}
+
+			writel(cfg2, pmu->base + COUNTER_MUX_CNTL + ((counter - 1) << 4));
+		}
+	}
+
 	pmu->events[counter] = event;
 	pmu->active_events++;
 	hwc->idx = counter;
@@ -507,7 +653,7 @@ static void ddr_perf_pmu_disable(struct pmu *pmu)
 				      false);
 }
 
-static int ddr_perf_init(struct ddr_pmu *pmu, void __iomem *base,
+static void ddr_perf_init(struct ddr_pmu *pmu, void __iomem *base,
 			 struct device *dev)
 {
 	*pmu = (struct ddr_pmu) {
@@ -515,7 +661,6 @@ static int ddr_perf_init(struct ddr_pmu *pmu, void __iomem *base,
 			.module	      = THIS_MODULE,
 			.capabilities = PERF_PMU_CAP_NO_EXCLUDE,
 			.task_ctx_nr = perf_invalid_context,
-			.attr_groups = attr_groups,
 			.event_init  = ddr_perf_event_init,
 			.add	     = ddr_perf_event_add,
 			.del	     = ddr_perf_event_del,
@@ -528,14 +673,11 @@ static int ddr_perf_init(struct ddr_pmu *pmu, void __iomem *base,
 		.base = base,
 		.dev = dev,
 	};
-
-	pmu->id = ida_simple_get(&ddr_ida, 0, 0, GFP_KERNEL);
-	return pmu->id;
 }
 
 static irqreturn_t ddr_perf_irq_handler(int irq, void *p)
 {
-	int i;
+	int i, ret;
 	struct ddr_pmu *pmu = (struct ddr_pmu *) p;
 	struct perf_event *event, *cycle_event = NULL;
 
@@ -547,7 +689,7 @@ static irqreturn_t ddr_perf_irq_handler(int irq, void *p)
 	/*
 	 * When the cycle counter overflows, all counters are stopped,
 	 * and an IRQ is raised. If any other counter overflows, it
-	 * continues counting, and no IRQ is raised.
+	 * stop counting, and no IRQ is raised.
 	 *
 	 * Cycles occur at least 4 times as often as other events, so we
 	 * can update all events on a cycle counter overflow and not
@@ -567,12 +709,44 @@ static irqreturn_t ddr_perf_irq_handler(int irq, void *p)
 			cycle_event = event;
 	}
 
+	spin_lock(&pmu->lock);
+
+	for (i = 0; i < NUM_COUNTERS; i++) {
+		if (!pmu->events[i])
+			continue;
+
+		event = pmu->events[i];
+
+		if (event->hw.idx == EVENT_CYCLES_COUNTER)
+			continue;
+
+		/* check non-cycle counters overflow */
+		ret = ddr_perf_counter_overflow(pmu, event->hw.idx);
+		if (ret)
+			dev_warn(pmu->dev, "Event Counter%d overflow happened, data incorrect!!\n", i);
+
+		/* clear non-cycle counters */
+		ddr_perf_counter_enable(pmu, event->attr.config, event->hw.idx, true);
+
+		local64_set(&event->hw.prev_count, 0);
+	}
+
+	/* Workaround for i.MX865 */
+	if ((pmu->devtype_data->quirks & DDR_CAP_AXI_ID_FILTER_ENHANCED) ==
+	    DDR_CAP_AXI_ID_FILTER_ENHANCED) {
+		if (cycle_event)
+			local64_set(&cycle_event->hw.prev_count, 0xe8000000);
+	} else {
+		if (cycle_event)
+			local64_set(&cycle_event->hw.prev_count, 0);
+	}
+
+	spin_unlock(&pmu->lock);
+
 	ddr_perf_counter_enable(pmu,
 			      EVENT_CYCLES_ID,
 			      EVENT_CYCLES_COUNTER,
 			      true);
-	if (cycle_event)
-		ddr_perf_event_update(cycle_event);
 
 	return IRQ_HANDLED;
 }
@@ -603,7 +777,6 @@ static int ddr_perf_probe(struct platform_device *pdev)
 	struct device_node *np;
 	void __iomem *base;
 	char *name;
-	int num;
 	int ret;
 	int irq;
 
@@ -617,19 +790,43 @@ static int ddr_perf_probe(struct platform_device *pdev)
 	if (!pmu)
 		return -ENOMEM;
 
-	num = ddr_perf_init(pmu, base, &pdev->dev);
+	ddr_perf_init(pmu, base, &pdev->dev);
 
 	platform_set_drvdata(pdev, pmu);
+	spin_lock_init(&pmu->lock);
+
+	pmu->devtype_data = of_device_get_match_data(&pdev->dev);
+	if (pmu->devtype_data->type & DDR_PERF_TYPE) {
+		pmu->pmu.attr_groups = ddr_attr_groups;
+		pmu->id = ida_simple_get(&ddr_ida, 0, 0, GFP_KERNEL);
+		name = devm_kasprintf(&pdev->dev, GFP_KERNEL, DDR_PERF_DEV_NAME "%d", pmu->id);
+	} else if (pmu->devtype_data->type & DB_PERF_TYPE) {
+		pmu->pmu.attr_groups = db_attr_groups;
+		pmu->id = ida_simple_get(&db_ida, 0, 0, GFP_KERNEL);
+		name = devm_kasprintf(&pdev->dev, GFP_KERNEL, DB_PERF_DEV_NAME "%d", pmu->id);
+
+		pmu->clk_ipg = devm_clk_get(&pdev->dev, "ipg");
+		if (IS_ERR(pmu->clk_ipg)) {
+			dev_err(&pdev->dev, "no ipg clock defined\n");
+			return PTR_ERR(pmu->clk_ipg);
+		}
+
+		pmu->clk_cnt = devm_clk_get(&pdev->dev, "cnt");
+		if (IS_ERR(pmu->clk_cnt)) {
+			dev_err(&pdev->dev, "no cnt clock defined\n");
+			return PTR_ERR(pmu->clk_cnt);
+		}
 
-	name = devm_kasprintf(&pdev->dev, GFP_KERNEL, DDR_PERF_DEV_NAME "%d",
-			      num);
+		ret = ddr_perf_clks_enable(pmu);
+		if (ret)
+			return ret;
+	} else
+		return -EINVAL;
 	if (!name) {
 		ret = -ENOMEM;
 		goto cpuhp_state_err;
 	}
 
-	pmu->devtype_data = of_device_get_match_data(&pdev->dev);
-
 	pmu->cpu = raw_smp_processor_id();
 	ret = cpuhp_setup_state_multi(CPUHP_AP_ONLINE_DYN,
 				      DDR_CPUHP_CB_NAME,
@@ -686,7 +883,13 @@ static int ddr_perf_probe(struct platform_device *pdev)
 cpuhp_instance_err:
 	cpuhp_remove_multi_state(pmu->cpuhp_state);
 cpuhp_state_err:
-	ida_simple_remove(&ddr_ida, pmu->id);
+	if (pmu->devtype_data->type & DDR_PERF_TYPE)
+		ida_simple_remove(&ddr_ida, pmu->id);
+	else {
+		ddr_perf_clks_disable(pmu);
+		ida_simple_remove(&db_ida, pmu->id);
+	}
+
 	dev_warn(&pdev->dev, "i.MX8 DDR Perf PMU failed (%d), disabled\n", ret);
 	return ret;
 }
@@ -701,7 +904,13 @@ static int ddr_perf_remove(struct platform_device *pdev)
 
 	perf_pmu_unregister(&pmu->pmu);
 
-	ida_simple_remove(&ddr_ida, pmu->id);
+	if (pmu->devtype_data->type & DDR_PERF_TYPE)
+		ida_simple_remove(&ddr_ida, pmu->id);
+	else {
+		ddr_perf_clks_disable(pmu);
+		ida_simple_remove(&db_ida, pmu->id);
+	}
+
 	return 0;
 }
 
diff --git a/drivers/phy/freescale/Kconfig b/drivers/phy/freescale/Kconfig
index 320630ffe..754b35ae6 100644
--- a/drivers/phy/freescale/Kconfig
+++ b/drivers/phy/freescale/Kconfig
@@ -14,3 +14,12 @@ config PHY_MIXEL_MIPI_DPHY
 	help
 	  Enable this to add support for the Mixel DSI PHY as found
 	  on NXP's i.MX8 family of SOCs.
+
+config PHY_FSL_IMX_PCIE
+	tristate "Freescale i.MX PCIE PHY"
+	depends on OF && HAS_IOMEM
+	select GENERIC_PHY
+	default ARCH_MXC
+	help
+	  Enable this to add support for the PCIE PHY as found on i.MX
+	  family of SOCs.
diff --git a/drivers/phy/freescale/Makefile b/drivers/phy/freescale/Makefile
index 1d02e3869..b4b8ae285 100644
--- a/drivers/phy/freescale/Makefile
+++ b/drivers/phy/freescale/Makefile
@@ -1,3 +1,4 @@
 # SPDX-License-Identifier: GPL-2.0-only
 obj-$(CONFIG_PHY_FSL_IMX8MQ_USB)	+= phy-fsl-imx8mq-usb.o
 obj-$(CONFIG_PHY_MIXEL_MIPI_DPHY)	+= phy-fsl-imx8-mipi-dphy.o
+obj-$(CONFIG_PHY_FSL_IMX_PCIE)		+= phy-fsl-imx8-pcie.o
diff --git a/drivers/phy/freescale/phy-fsl-imx8-mipi-dphy.c b/drivers/phy/freescale/phy-fsl-imx8-mipi-dphy.c
index 9f2c1da14..5ac3398ff 100644
--- a/drivers/phy/freescale/phy-fsl-imx8-mipi-dphy.c
+++ b/drivers/phy/freescale/phy-fsl-imx8-mipi-dphy.c
@@ -1,6 +1,6 @@
 // SPDX-License-Identifier: GPL-2.0+
 /*
- * Copyright 2017,2018 NXP
+ * Copyright 2017,2018,2021 NXP
  * Copyright 2019 Purism SPC
  */
 
@@ -24,13 +24,6 @@
 #define DPHY_MC_PRG_HS_ZERO		0x10
 #define DPHY_M_PRG_HS_TRAIL		0x14
 #define DPHY_MC_PRG_HS_TRAIL		0x18
-#define DPHY_PD_PLL			0x1c
-#define DPHY_TST			0x20
-#define DPHY_CN				0x24
-#define DPHY_CM				0x28
-#define DPHY_CO				0x2c
-#define DPHY_LOCK			0x30
-#define DPHY_LOCK_BYP			0x34
 #define DPHY_REG_BYPASS_PLL		0x4C
 
 #define MBPS(x) ((x) * 1000000)
@@ -55,11 +48,26 @@
 #define PWR_ON	0
 #define PWR_OFF	1
 
+/* not available register */
+#define REG_NA	0xff
+
 enum mixel_dphy_devtype {
 	MIXEL_IMX8MQ,
+	MIXEL_IMX8QM,
+	MIXEL_IMX8QX,
+	MIXEL_IMX8ULP,
 };
 
 struct mixel_dphy_devdata {
+	u8 reg_mc_prg_rxhs_settle;
+	u8 reg_m_prg_rxhs_settle;
+	u8 reg_pd_pll;
+	u8 reg_tst;
+	u8 reg_cn;
+	u8 reg_cm;
+	u8 reg_co;
+	u8 reg_lock;
+	u8 reg_lock_byp;
 	u8 reg_tx_rcal;
 	u8 reg_auto_pd_en;
 	u8 reg_rxlprp;
@@ -69,12 +77,69 @@ struct mixel_dphy_devdata {
 
 static const struct mixel_dphy_devdata mixel_dphy_devdata[] = {
 	[MIXEL_IMX8MQ] = {
+		.reg_mc_prg_rxhs_settle = REG_NA,
+		.reg_m_prg_rxhs_settle = REG_NA,
+		.reg_pd_pll = 0x1c,
+		.reg_tst = 0x20,
+		.reg_cn = 0x24,
+		.reg_cm = 0x28,
+		.reg_co = 0x2c,
+		.reg_lock = 0x30,
+		.reg_lock_byp = 0x34,
 		.reg_tx_rcal = 0x38,
 		.reg_auto_pd_en = 0x3c,
 		.reg_rxlprp = 0x40,
 		.reg_rxcdrp = 0x44,
 		.reg_rxhs_settle = 0x48,
 	},
+	[MIXEL_IMX8QM] = {
+		.reg_mc_prg_rxhs_settle = REG_NA,
+		.reg_m_prg_rxhs_settle = REG_NA,
+		.reg_pd_pll = 0x1c,
+		.reg_tst = 0x20,
+		.reg_cn = 0x24,
+		.reg_cm = 0x28,
+		.reg_co = 0x2c,
+		.reg_lock = 0x30,
+		.reg_lock_byp = 0x34,
+		.reg_tx_rcal = 0x00,
+		.reg_auto_pd_en = 0x38,
+		.reg_rxlprp = 0x3c,
+		.reg_rxcdrp = 0x40,
+		.reg_rxhs_settle = 0x44,
+	},
+	[MIXEL_IMX8QX] = {
+		.reg_mc_prg_rxhs_settle = REG_NA,
+		.reg_m_prg_rxhs_settle = REG_NA,
+		.reg_pd_pll = 0x1c,
+		.reg_tst = 0x20,
+		.reg_cn = 0x24,
+		.reg_cm = 0x28,
+		.reg_co = 0x2c,
+		.reg_lock = 0x30,
+		.reg_lock_byp = 0x34,
+		.reg_tx_rcal = 0x00,
+		.reg_auto_pd_en = 0x38,
+		.reg_rxlprp = 0x3c,
+		.reg_rxcdrp = 0x40,
+		.reg_rxhs_settle = 0x44,
+	},
+	[MIXEL_IMX8ULP] = {
+		.reg_mc_prg_rxhs_settle = 0x1c,
+		.reg_m_prg_rxhs_settle = 0x20,
+		.reg_pd_pll = 0x24,
+		.reg_tst = 0x28,
+		.reg_cn = 0x2c,
+		.reg_cm = 0x30,
+		.reg_co = 0x34,
+		.reg_lock = 0x38,
+		.reg_lock_byp = 0x3c,
+		.reg_tx_rcal = 0x00,
+		.reg_auto_pd_en = 0x40,
+		.reg_rxlprp = 0x44,
+		.reg_rxcdrp = 0x48,
+		.reg_rxhs_settle = REG_NA,
+	},
 };
 
 struct mixel_dphy_cfg {
@@ -261,20 +326,31 @@ static int mixel_dphy_config_from_opts(struct phy *phy,
 	cfg->mc_prg_hs_trail = n;
 
 	/* rxhs_settle: formula from NXP BSP */
-	if (dphy_opts->hs_clk_rate < MBPS(80))
-		cfg->rxhs_settle = 0x0d;
-	else if (dphy_opts->hs_clk_rate < MBPS(90))
-		cfg->rxhs_settle = 0x0c;
-	else if (dphy_opts->hs_clk_rate < MBPS(125))
-		cfg->rxhs_settle = 0x0b;
-	else if (dphy_opts->hs_clk_rate < MBPS(150))
-		cfg->rxhs_settle = 0x0a;
-	else if (dphy_opts->hs_clk_rate < MBPS(225))
-		cfg->rxhs_settle = 0x09;
-	else if (dphy_opts->hs_clk_rate < MBPS(500))
-		cfg->rxhs_settle = 0x08;
-	else
-		cfg->rxhs_settle = 0x07;
+	if (priv->devdata->reg_rxhs_settle != REG_NA) {
+		if (dphy_opts->hs_clk_rate < MBPS(80))
+			cfg->rxhs_settle = 0x0d;
+		else if (dphy_opts->hs_clk_rate < MBPS(90))
+			cfg->rxhs_settle = 0x0c;
+		else if (dphy_opts->hs_clk_rate < MBPS(125))
+			cfg->rxhs_settle = 0x0b;
+		else if (dphy_opts->hs_clk_rate < MBPS(150))
+			cfg->rxhs_settle = 0x0a;
+		else if (dphy_opts->hs_clk_rate < MBPS(225))
+			cfg->rxhs_settle = 0x09;
+		else if (dphy_opts->hs_clk_rate < MBPS(500))
+			cfg->rxhs_settle = 0x08;
+		else
+			cfg->rxhs_settle = 0x07;
+	} else if (priv->devdata->reg_m_prg_rxhs_settle != REG_NA) {
+		if (dphy_opts->hs_clk_rate < MBPS(80))
+			cfg->rxhs_settle = 0x01;
+		else if (dphy_opts->hs_clk_rate < MBPS(250))
+			cfg->rxhs_settle = 0x06;
+		else if (dphy_opts->hs_clk_rate < MBPS(500))
+			cfg->rxhs_settle = 0x08;
+		else
+			cfg->rxhs_settle = 0x0a;
+	}
 
 	dev_dbg(&phy->dev, "phy_config: %u %u %u %u %u %u %u\n",
 		cfg->m_prg_hs_prepare, cfg->mc_prg_hs_prepare,
@@ -295,7 +371,15 @@ static void mixel_phy_set_hs_timings(struct phy *phy)
 	phy_write(phy, priv->cfg.mc_prg_hs_zero, DPHY_MC_PRG_HS_ZERO);
 	phy_write(phy, priv->cfg.m_prg_hs_trail, DPHY_M_PRG_HS_TRAIL);
 	phy_write(phy, priv->cfg.mc_prg_hs_trail, DPHY_MC_PRG_HS_TRAIL);
-	phy_write(phy, priv->cfg.rxhs_settle, priv->devdata->reg_rxhs_settle);
+	if (priv->devdata->reg_rxhs_settle != REG_NA)
+		phy_write(phy, priv->cfg.rxhs_settle,
+			  priv->devdata->reg_rxhs_settle);
+	else if (priv->devdata->reg_m_prg_rxhs_settle != REG_NA)
+		phy_write(phy, priv->cfg.rxhs_settle,
+			  priv->devdata->reg_m_prg_rxhs_settle);
+
+	if (priv->devdata->reg_mc_prg_rxhs_settle != REG_NA)
+		phy_write(phy, 0x10, priv->devdata->reg_mc_prg_rxhs_settle);
 }
 
 static int mixel_dphy_set_pll_params(struct phy *phy)
@@ -311,9 +395,9 @@ static int mixel_dphy_set_pll_params(struct phy *phy)
 	}
 	dev_dbg(&phy->dev, "Using CM:%u CN:%u CO:%u\n",
 		priv->cfg.cm, priv->cfg.cn, priv->cfg.co);
-	phy_write(phy, CM(priv->cfg.cm), DPHY_CM);
-	phy_write(phy, CN(priv->cfg.cn), DPHY_CN);
-	phy_write(phy, CO(priv->cfg.co), DPHY_CO);
+	phy_write(phy, CM(priv->cfg.cm), priv->devdata->reg_cm);
+	phy_write(phy, CN(priv->cfg.cn), priv->devdata->reg_cn);
+	phy_write(phy, CO(priv->cfg.co), priv->devdata->reg_co);
 	return 0;
 }
 
@@ -330,12 +414,12 @@ static int mixel_dphy_configure(struct phy *phy, union phy_configure_opts *opts)
 	/* Update the configuration */
 	memcpy(&priv->cfg, &cfg, sizeof(struct mixel_dphy_cfg));
 
-	phy_write(phy, 0x00, DPHY_LOCK_BYP);
+	phy_write(phy, 0x00, priv->devdata->reg_lock_byp);
 	phy_write(phy, 0x01, priv->devdata->reg_tx_rcal);
 	phy_write(phy, 0x00, priv->devdata->reg_auto_pd_en);
 	phy_write(phy, 0x02, priv->devdata->reg_rxlprp);
 	phy_write(phy, 0x02, priv->devdata->reg_rxcdrp);
-	phy_write(phy, 0x25, DPHY_TST);
+	phy_write(phy, 0x25, priv->devdata->reg_tst);
 
 	mixel_phy_set_hs_timings(phy);
 	ret = mixel_dphy_set_pll_params(phy);
@@ -358,7 +442,9 @@ static int mixel_dphy_validate(struct phy *phy, enum phy_mode mode, int submode,
 
 static int mixel_dphy_init(struct phy *phy)
 {
-	phy_write(phy, PWR_OFF, DPHY_PD_PLL);
+	struct mixel_dphy_priv *priv = phy_get_drvdata(phy);
+
+	phy_write(phy, PWR_OFF, priv->devdata->reg_pd_pll);
 	phy_write(phy, PWR_OFF, DPHY_PD_DPHY);
 
 	return 0;
@@ -366,9 +452,11 @@ static int mixel_dphy_init(struct phy *phy)
 
 static int mixel_dphy_exit(struct phy *phy)
 {
-	phy_write(phy, 0, DPHY_CM);
-	phy_write(phy, 0, DPHY_CN);
-	phy_write(phy, 0, DPHY_CO);
+	struct mixel_dphy_priv *priv = phy_get_drvdata(phy);
+
+	phy_write(phy, 0, priv->devdata->reg_cm);
+	phy_write(phy, 0, priv->devdata->reg_cn);
+	phy_write(phy, 0, priv->devdata->reg_co);
 
 	return 0;
 }
@@ -383,9 +471,9 @@ static int mixel_dphy_power_on(struct phy *phy)
 	if (ret < 0)
 		return ret;
 
-	phy_write(phy, PWR_ON, DPHY_PD_PLL);
-	ret = regmap_read_poll_timeout(priv->regmap, DPHY_LOCK, locked,
-				       locked, PLL_LOCK_SLEEP,
+	phy_write(phy, PWR_ON, priv->devdata->reg_pd_pll);
+	ret = regmap_read_poll_timeout(priv->regmap, priv->devdata->reg_lock,
+				       locked, locked, PLL_LOCK_SLEEP,
 				       PLL_LOCK_TIMEOUT);
 	if (ret < 0) {
 		dev_err(&phy->dev, "Could not get DPHY lock (%d)!\n", ret);
@@ -403,7 +491,7 @@ static int mixel_dphy_power_off(struct phy *phy)
 {
 	struct mixel_dphy_priv *priv = phy_get_drvdata(phy);
 
-	phy_write(phy, PWR_OFF, DPHY_PD_PLL);
+	phy_write(phy, PWR_OFF, priv->devdata->reg_pd_pll);
 	phy_write(phy, PWR_OFF, DPHY_PD_DPHY);
 
 	clk_disable_unprepare(priv->phy_ref_clk);
@@ -424,6 +512,12 @@ static const struct phy_ops mixel_dphy_phy_ops = {
 static const struct of_device_id mixel_dphy_of_match[] = {
 	{ .compatible = "fsl,imx8mq-mipi-dphy",
 	  .data = &mixel_dphy_devdata[MIXEL_IMX8MQ] },
+	{ .compatible = "fsl,imx8qm-mipi-dphy",
+	  .data = &mixel_dphy_devdata[MIXEL_IMX8QM] },
+	{ .compatible = "fsl,imx8qx-mipi-dphy",
+	  .data = &mixel_dphy_devdata[MIXEL_IMX8QX] },
+	{ .compatible = "fsl,imx8ulp-mipi-dphy",
+	  .data = &mixel_dphy_devdata[MIXEL_IMX8ULP] },
 	{ /* sentinel */ },
 };
 MODULE_DEVICE_TABLE(of, mixel_dphy_of_match);
diff --git a/drivers/phy/freescale/phy-fsl-imx8-pcie.c b/drivers/phy/freescale/phy-fsl-imx8-pcie.c
new file mode 100644
index 000000000..2b2e8ec53
--- /dev/null
+++ b/drivers/phy/freescale/phy-fsl-imx8-pcie.c
@@ -0,0 +1,280 @@
+// SPDX-License-Identifier: GPL-2.0+
+/*
+ * Copyright 2020 NXP
+ */
+
+#include <linux/clk.h>
+#include <linux/io.h>
+#include <linux/module.h>
+#include <linux/delay.h>
+#include <linux/phy/phy.h>
+#include <linux/platform_device.h>
+
+#define PHY_PLL_LOCK_WAIT_MAX_RETRIES	2000
+#define IMX8MP_PCIE_PHY_FLAG_EXT_OSC	BIT(0)
+
+#define IMX8MP_PCIE_PHY_CMN_REG020	0x80
+#define  PLL_ANA_LPF_R_SEL_FINE_0_4	0x04
+#define IMX8MP_PCIE_PHY_CMN_REG061	0x184
+#define  ANA_PLL_CLK_OUT_TO_EXT_IO_EN	BIT(0)
+#define IMX8MP_PCIE_PHY_CMN_REG062	0x188
+#define  ANA_PLL_CLK_OUT_TO_EXT_IO_SEL	BIT(3)
+#define IMX8MP_PCIE_PHY_CMN_REG063	0x18C
+#define  AUX_PLL_REFCLK_SEL_SYS_PLL	GENMASK(7, 6)
+#define IMX8MP_PCIE_PHY_CMN_REG064	0x190
+#define  ANA_AUX_RX_TX_SEL_TX		BIT(7)
+#define  ANA_AUX_RX_TERM_GND_EN		BIT(3)
+#define  ANA_AUX_TX_TERM		BIT(2)
+#define IMX8MP_PCIE_PHY_CMN_REG065	0x194
+#define  ANA_AUX_RX_TERM		(BIT(7) | BIT(4))
+#define  ANA_AUX_TX_LVL			GENMASK(3, 0)
+#define IMX8MP_PCIE_PHY_CMN_REG076	0x200
+#define  LANE_RESET_MUX_SEL		0x00
+#define IMX8MP_PCIE_PHY_CMN_REG078	0x208
+#define  LANE_TX_DATA_CLK_MUX_SEL	0x00
+
+#define IMX8MP_PCIE_PHY_TRSV_REG001	0x404
+#define  LN0_OVRD_TX_DRV_LVL		0x3F
+#define IMX8MP_PCIE_PHY_TRSV_REG005	0x414
+#define  LN0_OVRD_TX_DRV_PST_LVL_G1	0x2B
+#define IMX8MP_PCIE_PHY_TRSV_REG006	0x418
+#define  LN0_OVRD_TX_DRV_PST_LVL_G2	0x3
+#define IMX8MP_PCIE_PHY_TRSV_REG007	0x41C
+#define  LN0_OVRD_TX_DRV_PST_LVL_G3	0xA
+#define IMX8MP_PCIE_PHY_TRSV_REG009	0x424
+#define  LN0_OVRD_TX_DRV_PRE_LVL_G1	0x10
+#define IMX8MP_PCIE_PHY_TRSV_REG059	0x4EC
+#define  LN0_OVRD_RX_CTLE_RS1_G1	0x13
+#define IMX8MP_PCIE_PHY_TRSV_REG060	0x4F0
+#define  LN0_OVRD_RX_CTLE_RS1_G2_G3	0x25
+#define IMX8MP_PCIE_PHY_TRSV_REG069	0x514
+#define  LN0_ANA_RX_CTLE_IBLEED		0x7
+#define IMX8MP_PCIE_PHY_TRSV_REG107	0x5AC
+#define  LN0_OVRD_RX_RTERM_VCM_EN	0xB8
+#define IMX8MP_PCIE_PHY_TRSV_REG109	0x5B4
+#define  LN0_ANA_OVRD_RX_SQHS_DIFN_OC	0xD4
+#define IMX8MP_PCIE_PHY_TRSV_REG110	0x5B8
+#define  LN0_ANA_OVRD_RX_SQHS_DIFP_OC	0x6A
+#define IMX8MP_PCIE_PHY_TRSV_REG158	0x678
+#define  LN0_RX_CDR_FBB_FINE_G1_G2	0x55
+#define IMX8MP_PCIE_PHY_TRSV_REG159	0x67C
+#define  LN0_RX_CDR_FBB_FINE_G3_G4	0x53
+#define IMX8MP_PCIE_PHY_TRSV_REG206	0x738
+#define  LN0_TG_RX_SIGVAL_LBF_DELAY	0x4
+
+static int imx8_pcie_phy_tuned;
+struct imx8_pcie_phy {
+	struct phy *phy;
+	struct clk *clk;
+	void __iomem *base;
+	u32 flags;
+};
+
+static int imx8_pcie_phy_init(struct phy *phy)
+{
+	u32 value, retries = 0;
+	struct imx8_pcie_phy *imx8_phy = phy_get_drvdata(phy);
+
+	/*
+	 * SW workaround for ERR050442 of the iMX865 PCIe.
+	 * Description:
+	 * PCIE PHY can't support GEN3. GEN 1/2 are supported. Some
+	 * buffer structures within the digital implementation in the
+	 * PHY required for GEN3 operation are incorrect. This logic can
+	 * be bypassed (optionally) in GEN 1/2 operation. This same
+	 * implementation bug prevents SW form reading some status bits
+	 * in all PCIe modes.
+	 *
+	 * Workaround:
+	 * SW driver doesn't need to read the PHY status bits for proper
+	 * PCIe operation. The buffer structure can be bypassed to
+	 * completely support GEN1/2 operation. With some SW driver
+	 * workarounds to read status from the PCIe PCS instead of the
+	 * PHY, proper operation can be achieved for GEN1/2. Proper
+	 * operation for GEN3 cannot be achieved with the SW workaround
+	 * since the buffer structure cannot be bypassed in GEN3 mode.
+	 */
+
+	/* wait for pipe0_clk locked by checking status from PCS. */
+	for (retries = 0; retries < PHY_PLL_LOCK_WAIT_MAX_RETRIES;
+	     retries++) {
+		value = readl(imx8_phy->base + 0x8188);
+		if (value == BIT(1))
+			break;
+		udelay(10);
+	}
+
+	if (retries >= PHY_PLL_LOCK_WAIT_MAX_RETRIES) {
+		pr_info("pcie phy pipe clk is not ready\n");
+		return -ETIMEDOUT;
+	}
+
+	return 0;
+}
+
+static int imx8_pcie_phy_cal(struct phy *phy)
+{
+	u32 value;
+	struct imx8_pcie_phy *imx8_phy = phy_get_drvdata(phy);
+
+	/* export clock to ep when internal clock is used as PHY REF clock */
+	if ((imx8_phy->flags & IMX8MP_PCIE_PHY_FLAG_EXT_OSC) == 0) {
+		writel(ANA_PLL_CLK_OUT_TO_EXT_IO_EN,
+		       imx8_phy->base + IMX8MP_PCIE_PHY_CMN_REG061);
+		writel(ANA_PLL_CLK_OUT_TO_EXT_IO_SEL,
+		       imx8_phy->base + IMX8MP_PCIE_PHY_CMN_REG062);
+		writel(AUX_PLL_REFCLK_SEL_SYS_PLL,
+		       imx8_phy->base + IMX8MP_PCIE_PHY_CMN_REG063);
+		value = ANA_AUX_RX_TX_SEL_TX | ANA_AUX_TX_TERM;
+		writel(value | ANA_AUX_RX_TERM_GND_EN,
+		       imx8_phy->base + IMX8MP_PCIE_PHY_CMN_REG064);
+		writel(ANA_AUX_RX_TERM | ANA_AUX_TX_LVL,
+		       imx8_phy->base + IMX8MP_PCIE_PHY_CMN_REG065);
+	}
+
+	/*
+	 * Fine tune the parameters of the PHY, let PCIe link up to GEN3
+	 * between two EVK boards in the EP/RC validation system.
+	 */
+	if (imx8_pcie_phy_tuned) {
+		writel(LN0_OVRD_TX_DRV_LVL,
+		       imx8_phy->base + IMX8MP_PCIE_PHY_TRSV_REG001);
+		writel(LN0_OVRD_TX_DRV_PST_LVL_G1,
+		       imx8_phy->base + IMX8MP_PCIE_PHY_TRSV_REG005);
+		writel(LN0_OVRD_TX_DRV_PST_LVL_G2,
+		       imx8_phy->base + IMX8MP_PCIE_PHY_TRSV_REG006);
+		writel(LN0_OVRD_TX_DRV_PST_LVL_G3,
+		       imx8_phy->base + IMX8MP_PCIE_PHY_TRSV_REG007);
+		writel(LN0_OVRD_TX_DRV_PRE_LVL_G1,
+		       imx8_phy->base + IMX8MP_PCIE_PHY_TRSV_REG009);
+		writel(LN0_OVRD_RX_CTLE_RS1_G1,
+		       imx8_phy->base + IMX8MP_PCIE_PHY_TRSV_REG059);
+		writel(LN0_OVRD_RX_CTLE_RS1_G2_G3,
+		       imx8_phy->base + IMX8MP_PCIE_PHY_TRSV_REG060);
+		writel(LN0_ANA_RX_CTLE_IBLEED,
+		       imx8_phy->base + IMX8MP_PCIE_PHY_TRSV_REG069);
+		writel(LN0_OVRD_RX_RTERM_VCM_EN,
+		       imx8_phy->base + IMX8MP_PCIE_PHY_TRSV_REG107);
+		writel(LN0_ANA_OVRD_RX_SQHS_DIFN_OC,
+		       imx8_phy->base + IMX8MP_PCIE_PHY_TRSV_REG109);
+		writel(LN0_ANA_OVRD_RX_SQHS_DIFP_OC,
+		       imx8_phy->base + IMX8MP_PCIE_PHY_TRSV_REG110);
+		writel(LN0_RX_CDR_FBB_FINE_G1_G2,
+		       imx8_phy->base + IMX8MP_PCIE_PHY_TRSV_REG158);
+		writel(LN0_RX_CDR_FBB_FINE_G3_G4,
+		       imx8_phy->base + IMX8MP_PCIE_PHY_TRSV_REG159);
+		writel(LN0_TG_RX_SIGVAL_LBF_DELAY,
+		       imx8_phy->base + IMX8MP_PCIE_PHY_TRSV_REG206);
+	}
+
+	writel(PLL_ANA_LPF_R_SEL_FINE_0_4,
+	       imx8_phy->base + IMX8MP_PCIE_PHY_CMN_REG020);
+	writel(LANE_RESET_MUX_SEL,
+	       imx8_phy->base + IMX8MP_PCIE_PHY_CMN_REG076);
+	writel(LANE_TX_DATA_CLK_MUX_SEL,
+	       imx8_phy->base + IMX8MP_PCIE_PHY_CMN_REG078);
+
+	return 0;
+}
+
+static int imx8_pcie_phy_power_on(struct phy *phy)
+{
+	struct imx8_pcie_phy *imx8_phy = phy_get_drvdata(phy);
+
+	return clk_prepare_enable(imx8_phy->clk);
+}
+
+static int imx8_pcie_phy_power_off(struct phy *phy)
+{
+	struct imx8_pcie_phy *imx8_phy = phy_get_drvdata(phy);
+
+	clk_disable_unprepare(imx8_phy->clk);
+
+	return 0;
+}
+
+static struct phy_ops imx8_pcie_phy_ops = {
+	.init		= imx8_pcie_phy_init,
+	.calibrate	= imx8_pcie_phy_cal,
+	.power_on	= imx8_pcie_phy_power_on,
+	.power_off	= imx8_pcie_phy_power_off,
+	.owner		= THIS_MODULE,
+};
+
+static int __init imx8_pcie_phy_fine_tune(char *str)
+{
+	if (!strcmp(str, "yes")) {
+		pr_info("i.MX PCIe PHY is fine tuned in EP/RC SYS.\n");
+		imx8_pcie_phy_tuned = 1;
+	}
+	return 1;
+}
+
+__setup("pcie_phy_tuned=", imx8_pcie_phy_fine_tune);
+
+static int imx8_pcie_phy_probe(struct platform_device *pdev)
+{
+	u32 val = 0;
+	struct phy_provider *phy_provider;
+	struct device *dev = &pdev->dev;
+	struct device_node *np = dev->of_node;
+	struct imx8_pcie_phy *imx8_phy;
+	struct resource *res;
+
+	imx8_phy = devm_kzalloc(dev, sizeof(*imx8_phy), GFP_KERNEL);
+	if (!imx8_phy)
+		return -ENOMEM;
+
+	imx8_phy->flags &= ~IMX8MP_PCIE_PHY_FLAG_EXT_OSC;
+	if (of_property_read_u32(np, "ext_osc", &val) < 0)
+		/*
+		 * Not specify ext_osc, use the external OSC as default
+		 * CLK mode.
+		 */
+		imx8_phy->flags |= IMX8MP_PCIE_PHY_FLAG_EXT_OSC;
+	if (val == 0)
+		imx8_phy->flags &= ~IMX8MP_PCIE_PHY_FLAG_EXT_OSC;
+	else if (val == 1)
+		imx8_phy->flags |= IMX8MP_PCIE_PHY_FLAG_EXT_OSC;
+	else
+		dev_info(dev, "invalid clk mode %d.\n", val);
+
+	imx8_phy->clk = devm_clk_get(dev, "phy");
+	if (IS_ERR(imx8_phy->clk)) {
+		dev_err(dev, "failed to get imx pcie phy clock\n");
+		return PTR_ERR(imx8_phy->clk);
+	}
+
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	imx8_phy->base = devm_ioremap_resource(dev, res);
+	if (IS_ERR(imx8_phy->base))
+		return PTR_ERR(imx8_phy->base);
+
+	imx8_phy->phy = devm_phy_create(dev, NULL, &imx8_pcie_phy_ops);
+	if (IS_ERR(imx8_phy->phy))
+		return PTR_ERR(imx8_phy->phy);
+
+	phy_set_drvdata(imx8_phy->phy, imx8_phy);
+
+	phy_provider = devm_of_phy_provider_register(dev, of_phy_simple_xlate);
+
+	return PTR_ERR_OR_ZERO(phy_provider);
+}
+
+static const struct of_device_id imx8_pcie_phy_of_match[] = {
+	{.compatible = "fsl,imx8mp-pcie-phy",},
+	{ },
+};
+MODULE_DEVICE_TABLE(of, imx8_pcie_phy_of_match);
+
+static struct platform_driver imx8_pcie_phy_driver = {
+	.probe	= imx8_pcie_phy_probe,
+	.driver = {
+		.name	= "imx8-pcie-phy",
+		.of_match_table	= imx8_pcie_phy_of_match,
+	}
+};
+module_platform_driver(imx8_pcie_phy_driver);
+
+MODULE_DESCRIPTION("FSL IMX8 PCIE PHY driver");
+MODULE_LICENSE("GPL");
diff --git a/drivers/phy/freescale/phy-fsl-imx8mq-usb.c b/drivers/phy/freescale/phy-fsl-imx8mq-usb.c
index 62d6d6849..c438dfce9 100644
--- a/drivers/phy/freescale/phy-fsl-imx8mq-usb.c
+++ b/drivers/phy/freescale/phy-fsl-imx8mq-usb.c
@@ -3,23 +3,30 @@
 
 #include <linux/bitfield.h>
 #include <linux/clk.h>
+#include <linux/debugfs.h>
 #include <linux/delay.h>
 #include <linux/io.h>
 #include <linux/module.h>
 #include <linux/of_platform.h>
 #include <linux/phy/phy.h>
 #include <linux/platform_device.h>
+#include <linux/power_supply.h>
 #include <linux/regulator/consumer.h>
 
 #define PHY_CTRL0			0x0
 #define PHY_CTRL0_REF_SSP_EN		BIT(2)
 #define PHY_CTRL0_FSEL_MASK		GENMASK(10, 5)
 #define PHY_CTRL0_FSEL_24M		0x2a
+#define PHY_CTRL0_FSEL_100M		0x27
+#define PHY_CTRL0_SSC_RANGE_MASK	GENMASK(23, 21)
+#define PHY_CTRL0_SSC_RANGE_4003PPM	(0x2 << 21)
 
 #define PHY_CTRL1			0x4
 #define PHY_CTRL1_RESET			BIT(0)
 #define PHY_CTRL1_COMMONONN		BIT(1)
 #define PHY_CTRL1_ATERESET		BIT(3)
+#define PHY_CTRL1_DCDENB		BIT(17)
+#define PHY_CTRL1_CHRGSEL		BIT(18)
 #define PHY_CTRL1_VDATSRCENB0		BIT(19)
 #define PHY_CTRL1_VDATDETENB0		BIT(20)
 
@@ -27,17 +34,371 @@
 #define PHY_CTRL2_TXENABLEN0		BIT(8)
 #define PHY_CTRL2_OTG_DISABLE		BIT(9)
 
+#define PHY_CTRL3			0xc
+#define PHY_CTRL3_COMPDISTUNE_MASK	GENMASK(2, 0)
+#define PHY_CTRL3_TXPREEMP_TUNE_MASK	GENMASK(16, 15)
+#define PHY_CTRL3_TXPREEMP_TUNE_SHIFT	15
+#define PHY_CTRL3_TXRISE_TUNE_MASK	GENMASK(21, 20)
+#define PHY_CTRL3_TXRISE_TUNE_SHIFT	20
+/* 1111: +24% ... 0000: -6% step: 2% */
+#define PHY_CTRL3_TXVREF_TUNE_MASK	GENMASK(25, 22)
+#define PHY_CTRL3_TXVREF_TUNE_SHIFT	22
+#define PHY_CTRL3_TX_VBOOST_LEVEL_MASK	GENMASK(31, 29)
+#define PHY_CTRL3_TX_VBOOST_LEVEL_SHIFT	29
+
+#define PHY_CTRL4			0x10
+#define PHY_CTRL4_PCS_TX_DEEMPH_3P5DB_MASK	GENMASK(20, 15)
+#define PHY_CTRL4_PCS_TX_DEEMPH_3P5DB_SHIFT	15
+
+#define PHY_CTRL5			0x14
+#define PHY_CTRL5_DMPWD_OVERRIDE_SEL	BIT(23)
+#define PHY_CTRL5_DMPWD_OVERRIDE	BIT(22)
+#define PHY_CTRL5_DPPWD_OVERRIDE_SEL	BIT(21)
+#define PHY_CTRL5_DPPWD_OVERRIDE	BIT(20)
+#define PHY_CTRL5_PCS_TX_SWING_FULL_MASK	GENMASK(6, 0)
+
 #define PHY_CTRL6			0x18
+#define PHY_CTRL6_RXTERM_OVERRIDE_SEL	BIT(29)
 #define PHY_CTRL6_ALT_CLK_EN		BIT(1)
 #define PHY_CTRL6_ALT_CLK_SEL		BIT(0)
 
+/* PHY control register access */
+#define PHY_CTRL_REG_COUNT_MAX		0x42
+#define PHY_CTRL_REG_OFFSET_MAX		0x201f
+
+#define PHY_CRCTL                      0x30
+#define PHY_CRCTL_DATA_IN_MASK         GENMASK(15, 0)
+#define PHY_CRCTL_CAP_ADDR             BIT(16)
+#define PHY_CRCTL_CAP_DATA             BIT(17)
+#define PHY_CRCTL_CR_WRITE             BIT(18)
+#define PHY_CRCTL_CR_READ              BIT(19)
+
+#define PHY_CRSR			0x34
+#define PHY_CRSR_DATA_OUT_MASK		GENMASK(15, 0)
+#define PHY_CRSR_CR_ACK			BIT(16)
+
+#define PHY_STS0			0x40
+#define PHY_STS0_OTGSESSVLD		BIT(7)
+#define PHY_STS0_CHGDET			BIT(4)
+#define PHY_STS0_FSVPLUS		BIT(3)
+#define PHY_STS0_FSVMINUS		BIT(2)
+
+#define PHY_TUNE_DEFAULT		0xffffffff
+
 struct imx8mq_usb_phy {
 	struct phy *phy;
 	struct clk *clk;
 	void __iomem *base;
 	struct regulator *vbus;
+	struct notifier_block chg_det_nb;
+	struct power_supply *vbus_power_supply;
+	enum power_supply_usb_type chg_type;
+	struct dentry *debugfs;
+	u16	cr_access_base;
+	u16	cr_read_count;
+	u32	pcs_tx_swing_full;
+	u32	pcs_tx_deemph_3p5db;
+	u32	tx_vref_tune;
+	u32	tx_rise_tune;
+	u32	tx_preemp_amp_tune;
+	u32	tx_vboost_level;
+	u32	comp_dis_tune;
+};
+
+#define IMX8M_PHY_DEBUG_PORT_LOOP_TIMEOUT 500000
+static int imx8mq_phy_ctrl_reg_addr(struct imx8mq_usb_phy *imx_phy, u16 offset)
+{
+	void __iomem	*cr_ctrl = imx_phy->base + PHY_CRCTL;
+	void __iomem	*cr_sr = imx_phy->base + PHY_CRSR;
+	struct device	*dev = &imx_phy->phy->dev;
+	int i;
+
+	/* Address Phrase */
+	writel(offset, cr_ctrl);
+	writel(readl(cr_ctrl) | PHY_CRCTL_CAP_ADDR, cr_ctrl);
+
+	/* Wait CRSR[16] == 1 */
+	i = IMX8M_PHY_DEBUG_PORT_LOOP_TIMEOUT;
+	while (!(readl(cr_sr) & PHY_CRSR_CR_ACK) && i > 0)
+		i--;
+	if (i == 0)
+		goto cr_addr_err;
+
+	writel(readl(cr_ctrl) & (~PHY_CRCTL_CAP_ADDR), cr_ctrl);
+
+	/* Wait CRSR[16] == 0 */
+	i = IMX8M_PHY_DEBUG_PORT_LOOP_TIMEOUT;
+	while ((readl(cr_sr) & PHY_CRSR_CR_ACK) && i > 0)
+		i--;
+	if (i == 0)
+		goto cr_addr_err;
+
+	return 0;
+
+cr_addr_err:
+	dev_err(dev, "Failed to address reg 0x%x.\n", offset);
+	return -EIO;
+}
+
+static int imx8mq_phy_ctrl_reg_read(struct imx8mq_usb_phy *imx_phy, u16 offset)
+{
+	void __iomem	*cr_ctrl = imx_phy->base + PHY_CRCTL;
+	void __iomem	*cr_sr = imx_phy->base + PHY_CRSR;
+	struct device	*dev = &imx_phy->phy->dev;
+	int val, i;
+
+	/* Address Phrase */
+	val = imx8mq_phy_ctrl_reg_addr(imx_phy, offset);
+	if (val)
+		return val;
+
+	/* Read Phrase */
+	writel(readl(cr_ctrl) | PHY_CRCTL_CR_READ, cr_ctrl);
+
+	/* Wait CRSR[16] == 1 */
+	i = IMX8M_PHY_DEBUG_PORT_LOOP_TIMEOUT;
+	while (!(readl(cr_sr) & PHY_CRSR_CR_ACK) && i > 0)
+		i--;
+	if (i == 0)
+		goto cr_read_err;
+
+	val = readl(cr_sr);
+	writel(val & ~PHY_CRCTL_CR_READ, cr_ctrl);
+
+	/* Wait CRSR[16] == 0 */
+	i = IMX8M_PHY_DEBUG_PORT_LOOP_TIMEOUT;
+	while (!(readl(cr_sr) & PHY_CRSR_CR_ACK) && i > 0)
+		i--;
+	if (i == 0)
+		goto cr_read_err;
+
+	return val;
+
+cr_read_err:
+	dev_err(dev, "Failed to read reg 0x%x.\n", offset);
+	return -EIO;
+}
+
+static int imx8mq_phy_ctrl_reg_write(struct imx8mq_usb_phy *imx_phy,
+				u16 offset, u16 val)
+{
+	void __iomem	*cr_ctrl = imx_phy->base + PHY_CRCTL;
+	void __iomem	*cr_sr = imx_phy->base + PHY_CRSR;
+	struct device	*dev = &imx_phy->phy->dev;
+	int i, ret;
+
+	/* Address Phrase */
+	ret = imx8mq_phy_ctrl_reg_addr(imx_phy, offset);
+	if (ret)
+		return ret;
+
+	writel(val, cr_ctrl);
+
+	/* Set cr_cap_data to be 1'b1 */
+	writel(readl(cr_ctrl) | PHY_CRCTL_CAP_DATA, cr_ctrl);
+	/* Wait CRSR[16] == 1 */
+	i = IMX8M_PHY_DEBUG_PORT_LOOP_TIMEOUT;
+	while (!(readl(cr_sr) & PHY_CRSR_CR_ACK) && i > 0)
+		i--;
+	if (i == 0)
+		goto cr_write_err;
+
+	/* Clear cr_cap_data to be 1'br0 */
+	writel(readl(cr_ctrl) & ~PHY_CRCTL_CAP_DATA, cr_ctrl);
+	/* Wait CRSR[16] == 0 */
+	i = IMX8M_PHY_DEBUG_PORT_LOOP_TIMEOUT;
+	while ((readl(cr_sr) & PHY_CRSR_CR_ACK) && i > 0)
+		i--;
+	if (i == 0)
+		goto cr_write_err;
+
+	/* Set cr_write to be 1'b1 */
+	writel(readl(cr_ctrl) | PHY_CRCTL_CR_WRITE, cr_ctrl);
+	/* Wait CRSR[16] == 1 */
+	i = IMX8M_PHY_DEBUG_PORT_LOOP_TIMEOUT;
+	while (!(readl(cr_sr) & PHY_CRSR_CR_ACK) && i > 0)
+		i--;
+	if (i == 0)
+		goto cr_write_err;
+
+	/* Clear cr_write to be 1'br0 */
+	writel(readl(cr_ctrl) & ~PHY_CRCTL_CR_WRITE, cr_ctrl);
+	/* Wait CRSR[16] == 0 */
+	i = IMX8M_PHY_DEBUG_PORT_LOOP_TIMEOUT;
+	while ((readl(cr_sr) & PHY_CRSR_CR_ACK) && i > 0)
+		i--;
+	if (i == 0)
+		goto cr_write_err;
+
+	return 0;
+
+cr_write_err:
+	dev_err(dev, "Failed to write reg 0x%x.\n", offset);
+
+	return -EIO;
+
+}
+
+static int ctrl_reg_value_show(struct seq_file *s, void *unused)
+{
+	struct imx8mq_usb_phy	*imx_phy = s->private;
+	u16			i, val, base = imx_phy->cr_access_base;
+
+	for (i = 0; i < imx_phy->cr_read_count; i++) {
+		val = imx8mq_phy_ctrl_reg_read(imx_phy, base + i);
+		seq_printf(s, "Control Register 0x%x value is 0x%4x\n",
+			   base + i, val);
+	}
+
+	return 0;
+}
+
+static int ctrl_reg_value_open(struct inode *inode, struct file *file)
+{
+	return single_open(file, ctrl_reg_value_show, inode->i_private);
+}
+
+static ssize_t ctrl_reg_value_write(struct file *file, const char __user *ubuf,
+			       size_t count, loff_t *ppos)
+{
+	struct seq_file		*s = file->private_data;
+	struct imx8mq_usb_phy	*imx_phy = s->private;
+	u16			cr_value;
+	int			ret;
+
+	ret = kstrtou16_from_user(ubuf, count, 16, &cr_value);
+	if (ret)
+		return ret;
+
+	imx8mq_phy_ctrl_reg_write(imx_phy, imx_phy->cr_access_base, cr_value);
+
+	return count;
+}
+
+static const struct file_operations ctrl_reg_value_fops = {
+	.open		= ctrl_reg_value_open,
+	.write		= ctrl_reg_value_write,
+	.read		= seq_read,
+	.llseek		= seq_lseek,
+	.release	= single_release,
 };
 
+static void debug_create_files(struct imx8mq_usb_phy *imx_phy)
+{
+	struct device *dev = &imx_phy->phy->dev;
+
+	imx_phy->debugfs = debugfs_create_dir(dev_name(dev),
+					      phy_debugfs_root);
+
+	debugfs_create_x16("ctrl_reg_base", 0600, imx_phy->debugfs,
+			   &imx_phy->cr_access_base);
+	debugfs_create_x16("ctrl_reg_count", 0600, imx_phy->debugfs,
+			   &imx_phy->cr_read_count);
+	debugfs_create_file("ctrl_reg_value", 0600, imx_phy->debugfs,
+			    imx_phy, &ctrl_reg_value_fops);
+
+	imx_phy->cr_access_base = 0;
+	imx_phy->cr_read_count = 1;
+}
+
+static void debug_remove_files(struct imx8mq_usb_phy *imx_phy)
+{
+	debugfs_remove_recursive(imx_phy->debugfs);
+}
+
+static void imx8m_get_phy_tuning_data(struct imx8mq_usb_phy *imx_phy)
+{
+	struct device *dev = imx_phy->phy->dev.parent;
+
+	if (device_property_read_u32(dev, "fsl,phy-tx-vref-tune",
+				     &imx_phy->tx_vref_tune))
+		imx_phy->tx_vref_tune = PHY_TUNE_DEFAULT;
+
+	if (device_property_read_u32(dev, "fsl,phy-tx-rise-tune",
+				     &imx_phy->tx_rise_tune))
+		imx_phy->tx_rise_tune = PHY_TUNE_DEFAULT;
+
+	if (device_property_read_u32(dev, "fsl,phy-tx-preemp-amp-tune",
+				     &imx_phy->tx_preemp_amp_tune))
+		imx_phy->tx_preemp_amp_tune = PHY_TUNE_DEFAULT;
+
+	if (device_property_read_u32(dev, "fsl,phy-tx-vboost-level",
+				     &imx_phy->tx_vboost_level))
+		imx_phy->tx_vboost_level = PHY_TUNE_DEFAULT;
+
+	if (device_property_read_u32(dev, "fsl,phy-comp-dis-tune",
+				     &imx_phy->comp_dis_tune))
+		imx_phy->comp_dis_tune = PHY_TUNE_DEFAULT;
+
+	if (device_property_read_u32(dev, "fsl,pcs-tx-deemph-3p5db",
+				     &imx_phy->pcs_tx_deemph_3p5db))
+		imx_phy->pcs_tx_deemph_3p5db = PHY_TUNE_DEFAULT;
+
+	if (device_property_read_u32(dev, "fsl,phy-pcs-tx-swing-full",
+				     &imx_phy->pcs_tx_swing_full))
+		imx_phy->pcs_tx_swing_full = PHY_TUNE_DEFAULT;
+}
+
+static void imx8m_phy_tune(struct imx8mq_usb_phy *imx_phy)
+{
+	u32 value;
+
+	/* PHY tuning */
+	if (imx_phy->pcs_tx_deemph_3p5db != PHY_TUNE_DEFAULT) {
+		value = readl(imx_phy->base + PHY_CTRL4);
+		value &= ~PHY_CTRL4_PCS_TX_DEEMPH_3P5DB_MASK;
+		value |= imx_phy->pcs_tx_deemph_3p5db <<
+			 PHY_CTRL4_PCS_TX_DEEMPH_3P5DB_SHIFT;
+		writel(value, imx_phy->base + PHY_CTRL4);
+	}
+
+	if (imx_phy->pcs_tx_swing_full != PHY_TUNE_DEFAULT) {
+		value = readl(imx_phy->base + PHY_CTRL5);
+		value &= ~PHY_CTRL5_PCS_TX_SWING_FULL_MASK;
+		value |= imx_phy->pcs_tx_swing_full;
+		writel(value, imx_phy->base + PHY_CTRL5);
+	}
+
+	if ((imx_phy->tx_vref_tune & imx_phy->tx_rise_tune &
+	     imx_phy->tx_preemp_amp_tune & imx_phy->comp_dis_tune &
+	     imx_phy->tx_vboost_level) == PHY_TUNE_DEFAULT)
+		/* If all are the default values, no need update. */
+		return;
+
+	value = readl(imx_phy->base + PHY_CTRL3);
+	if (imx_phy->tx_vref_tune == PHY_TUNE_DEFAULT)
+		imx_phy->tx_vref_tune = (value & PHY_CTRL3_TXVREF_TUNE_MASK) >>
+					PHY_CTRL3_TXVREF_TUNE_SHIFT;
+
+	if (imx_phy->tx_rise_tune == PHY_TUNE_DEFAULT)
+		imx_phy->tx_rise_tune = (value & PHY_CTRL3_TXRISE_TUNE_MASK) >>
+					PHY_CTRL3_TXRISE_TUNE_SHIFT;
+
+	if (imx_phy->tx_preemp_amp_tune == PHY_TUNE_DEFAULT)
+		imx_phy->tx_preemp_amp_tune = (value & PHY_CTRL3_TXPREEMP_TUNE_MASK) >>
+					      PHY_CTRL3_TXPREEMP_TUNE_SHIFT;
+
+	if (imx_phy->comp_dis_tune == PHY_TUNE_DEFAULT)
+		imx_phy->comp_dis_tune = value & PHY_CTRL3_COMPDISTUNE_MASK;
+
+	if (imx_phy->tx_vboost_level == PHY_TUNE_DEFAULT)
+		imx_phy->tx_vboost_level = (value & PHY_CTRL3_TX_VBOOST_LEVEL_MASK) >>
+					   PHY_CTRL3_TX_VBOOST_LEVEL_SHIFT;
+
+	value &= ~(PHY_CTRL3_TXVREF_TUNE_MASK |
+		   PHY_CTRL3_TXRISE_TUNE_MASK |
+		   PHY_CTRL3_TXPREEMP_TUNE_MASK |
+		   PHY_CTRL3_COMPDISTUNE_MASK |
+		   PHY_CTRL3_TX_VBOOST_LEVEL_MASK);
+	value |= imx_phy->tx_vref_tune << PHY_CTRL3_TXVREF_TUNE_SHIFT |
+		 imx_phy->tx_rise_tune << PHY_CTRL3_TXRISE_TUNE_SHIFT |
+		 imx_phy->tx_preemp_amp_tune << PHY_CTRL3_TXPREEMP_TUNE_SHIFT |
+		 imx_phy->tx_vboost_level << PHY_CTRL3_TX_VBOOST_LEVEL_SHIFT |
+		 imx_phy->comp_dis_tune;
+
+	writel(value, imx_phy->base + PHY_CTRL3);
+}
+
 static int imx8mq_usb_phy_init(struct phy *phy)
 {
 	struct imx8mq_usb_phy *imx_phy = phy_get_drvdata(phy);
@@ -51,6 +412,8 @@ static int imx8mq_usb_phy_init(struct phy *phy)
 
 	value = readl(imx_phy->base + PHY_CTRL0);
 	value |= PHY_CTRL0_REF_SSP_EN;
+	value &= ~PHY_CTRL0_SSC_RANGE_MASK;
+	value |= PHY_CTRL0_SSC_RANGE_4003PPM;
 	writel(value, imx_phy->base + PHY_CTRL0);
 
 	value = readl(imx_phy->base + PHY_CTRL2);
@@ -99,24 +462,42 @@ static int imx8mp_usb_phy_init(struct phy *phy)
 	value &= ~(PHY_CTRL1_RESET | PHY_CTRL1_ATERESET);
 	writel(value, imx_phy->base + PHY_CTRL1);
 
+	imx8m_phy_tune(imx_phy);
+
 	return 0;
 }
 
 static int imx8mq_phy_power_on(struct phy *phy)
 {
 	struct imx8mq_usb_phy *imx_phy = phy_get_drvdata(phy);
+	u32 value;
 	int ret;
 
 	ret = regulator_enable(imx_phy->vbus);
 	if (ret)
 		return ret;
 
-	return clk_prepare_enable(imx_phy->clk);
+	ret = clk_prepare_enable(imx_phy->clk);
+	if (ret)
+		return ret;
+
+	/* Disable rx term override */
+	value = readl(imx_phy->base + PHY_CTRL6);
+	value &= ~PHY_CTRL6_RXTERM_OVERRIDE_SEL;
+	writel(value, imx_phy->base + PHY_CTRL6);
+
+	return 0;
 }
 
 static int imx8mq_phy_power_off(struct phy *phy)
 {
 	struct imx8mq_usb_phy *imx_phy = phy_get_drvdata(phy);
+	u32 value;
+
+	/* Override rx term to be 0 */
+	value = readl(imx_phy->base + PHY_CTRL6);
+	value |= PHY_CTRL6_RXTERM_OVERRIDE_SEL;
+	writel(value, imx_phy->base + PHY_CTRL6);
 
 	clk_disable_unprepare(imx_phy->clk);
 	regulator_disable(imx_phy->vbus);
@@ -124,10 +505,245 @@ static int imx8mq_phy_power_off(struct phy *phy)
 	return 0;
 }
 
+static int imx8mq_chg_data_contact_det(struct imx8mq_usb_phy *imx_phy)
+{
+	int i, data_pin_contact_count = 0;
+	u32 val;
+
+	/* Set DMPULLDOWN<#> = 1'b1 (to enable RDM_DWN) */
+	val = readl(imx_phy->base + PHY_CTRL5);
+	val |= PHY_CTRL5_DMPWD_OVERRIDE_SEL | PHY_CTRL5_DMPWD_OVERRIDE;
+	writel(val, imx_phy->base + PHY_CTRL5);
+
+	/* Set DPPULLDOWN<#> = 1'b0 */
+	val = readl(imx_phy->base + PHY_CTRL5);
+	val |= PHY_CTRL5_DMPWD_OVERRIDE_SEL | PHY_CTRL5_DMPWD_OVERRIDE;
+	writel(val, imx_phy->base + PHY_CTRL5);
+
+	/* Enable Data Contact Detect (DCD) per the USB BC 1.2 */
+	val = readl(imx_phy->base + PHY_CTRL1);
+	writel(val | PHY_CTRL1_DCDENB, imx_phy->base + PHY_CTRL1);
+
+	for (i = 0; i < 100; i = i + 1) {
+		val = readl(imx_phy->base + PHY_STS0);
+		/* DP is low */
+		if (!(val & PHY_STS0_FSVPLUS)) {
+			if (data_pin_contact_count++ > 5)
+				/* Data pin makes contact */
+				break;
+			usleep_range(5000, 10000);
+		} else {
+			data_pin_contact_count = 0;
+			usleep_range(5000, 6000);
+		}
+	}
+
+	/* Disable DCD after finished data contact check */
+	val = readl(imx_phy->base + PHY_CTRL1);
+	val &= ~PHY_CTRL1_DCDENB;
+	writel(val, imx_phy->base + PHY_CTRL1);
+
+	if (i == 100) {
+		dev_err(&imx_phy->phy->dev,
+			"VBUS is coming from a dedicated power supply.\n");
+
+		/* disable override before finish */
+		val = readl(imx_phy->base + PHY_CTRL5);
+		val &= ~(PHY_CTRL5_DMPWD_OVERRIDE | PHY_CTRL5_DPPWD_OVERRIDE);
+		writel(val, imx_phy->base + PHY_CTRL5);
+
+		return -ENXIO;
+	}
+
+	/* Set DMPULLDOWN<#> to 1'b0 when DCD is completed */
+	val = readl(imx_phy->base + PHY_CTRL5);
+	val &= ~PHY_CTRL5_DMPWD_OVERRIDE_SEL;
+	val |= PHY_CTRL5_DMPWD_OVERRIDE;
+	writel(val, imx_phy->base + PHY_CTRL5);
+
+	return 0;
+}
+
+static int imx8mq_chg_primary_detect(struct imx8mq_usb_phy *imx_phy)
+{
+	u32 val;
+
+	/* VDP_SRC is connected to D+ and IDM_SINK is connected to D- */
+	val = readl(imx_phy->base + PHY_CTRL1);
+	val &= ~PHY_CTRL1_CHRGSEL;
+	val |= PHY_CTRL1_VDATSRCENB0 | PHY_CTRL1_VDATDETENB0;
+	writel(val, imx_phy->base + PHY_CTRL1);
+
+	usleep_range(1000, 2000);
+
+	/* Check if D- is less than VDAT_REF to determine an SDP per BC 1.2 */
+	val = readl(imx_phy->base + PHY_STS0);
+	if (!(val & PHY_STS0_CHGDET)) {
+		dev_dbg(&imx_phy->phy->dev, "It is a SDP.\n");
+		imx_phy->chg_type = POWER_SUPPLY_USB_TYPE_SDP;
+	}
+
+	return 0;
+}
+
+static int imx8mq_phy_chg_secondary_det(struct imx8mq_usb_phy *imx_phy)
+{
+	u32 val;
+
+	/* VDM_SRC is connected to D- and IDP_SINK is connected to D+ */
+	val = readl(imx_phy->base + PHY_CTRL1);
+	writel(val | PHY_CTRL1_VDATSRCENB0 | PHY_CTRL1_VDATDETENB0 |
+		PHY_CTRL1_CHRGSEL, imx_phy->base + PHY_CTRL1);
+
+	usleep_range(1000, 2000);
+
+	/*
+	 * Per BC 1.2, check voltage of D+:
+	 * DCP: if greater than VDAT_REF;
+	 * CDP: if less than VDAT0_REF.
+	 */
+	val = readl(imx_phy->base + PHY_STS0);
+	if (val & PHY_STS0_CHGDET) {
+		dev_dbg(&imx_phy->phy->dev, "It is a DCP.\n");
+		imx_phy->chg_type = POWER_SUPPLY_USB_TYPE_DCP;
+	} else {
+		dev_dbg(&imx_phy->phy->dev, "It is a CDP.\n");
+		imx_phy->chg_type = POWER_SUPPLY_USB_TYPE_CDP;
+	}
+
+	return 0;
+}
+
+static void imx8mq_phy_disable_chg_det(struct imx8mq_usb_phy *imx_phy)
+{
+	u32 val;
+
+	val = readl(imx_phy->base + PHY_CTRL5);
+	val &= ~(PHY_CTRL5_DMPWD_OVERRIDE | PHY_CTRL5_DPPWD_OVERRIDE);
+	writel(val, imx_phy->base + PHY_CTRL5);
+
+	val = readl(imx_phy->base + PHY_CTRL1);
+	val &= ~(PHY_CTRL1_DCDENB | PHY_CTRL1_VDATSRCENB0 |
+		 PHY_CTRL1_VDATDETENB0 | PHY_CTRL1_CHRGSEL);
+	writel(val, imx_phy->base + PHY_CTRL1);
+}
+
+static int imx8mq_phy_charger_detect(struct imx8mq_usb_phy *imx_phy)
+{
+	struct device *dev = &imx_phy->phy->dev;
+	struct device_node *np = dev->parent->of_node;
+	union power_supply_propval propval;
+	u32 value;
+	int ret = 0;
+
+	if (!np)
+		return 0;
+
+	imx_phy->vbus_power_supply = power_supply_get_by_phandle(np,
+						"vbus-power-supply");
+	if (IS_ERR_OR_NULL(imx_phy->vbus_power_supply))
+		return 0;
+
+	if (imx_phy->chg_type != POWER_SUPPLY_USB_TYPE_UNKNOWN)
+		goto put_psy;
+
+	ret = power_supply_get_property(imx_phy->vbus_power_supply,
+					POWER_SUPPLY_PROP_ONLINE,
+					&propval);
+	if (ret || propval.intval == 0) {
+		dev_err(dev, "failed to get psy online infor\n");
+		ret = -EINVAL;
+		goto put_psy;
+	}
+
+	/* Check if vbus is valid */
+	value = readl(imx_phy->base + PHY_STS0);
+	if (!(value & PHY_STS0_OTGSESSVLD)) {
+		dev_err(&imx_phy->phy->dev, "vbus is error\n");
+		ret = -EINVAL;
+		goto put_psy;
+	}
+
+	imx_phy->chg_type = POWER_SUPPLY_USB_TYPE_UNKNOWN;
+
+	ret = imx8mq_chg_data_contact_det(imx_phy);
+	if (ret)
+		goto put_psy;
+
+	ret = imx8mq_chg_primary_detect(imx_phy);
+	if (!ret && imx_phy->chg_type != POWER_SUPPLY_USB_TYPE_SDP)
+		ret = imx8mq_phy_chg_secondary_det(imx_phy);
+
+	imx8mq_phy_disable_chg_det(imx_phy);
+
+	if (!ret) {
+		propval.intval = imx_phy->chg_type;
+		power_supply_set_property(imx_phy->vbus_power_supply,
+					  POWER_SUPPLY_PROP_USB_TYPE,
+					  &propval);
+	}
+
+put_psy:
+	power_supply_put(imx_phy->vbus_power_supply);
+
+	return ret;
+}
+
+static int imx8mq_phy_usb_vbus_notify(struct notifier_block *nb,
+				      unsigned long val, void *v)
+{
+	struct imx8mq_usb_phy *imx_phy = container_of(nb, struct imx8mq_usb_phy,
+						      chg_det_nb);
+	struct device *dev = &imx_phy->phy->dev;
+	struct device_node *np = dev->parent->of_node;
+	union power_supply_propval propval;
+	struct power_supply *psy = v;
+	int ret;
+
+	if (!np)
+		return NOTIFY_DONE;
+
+	imx_phy->vbus_power_supply = power_supply_get_by_phandle(np,
+						"vbus-power-supply");
+	if (IS_ERR_OR_NULL(imx_phy->vbus_power_supply)) {
+		dev_err(dev, "failed to get power supply\n");
+		return NOTIFY_DONE;
+	}
+
+	if (val == PSY_EVENT_PROP_CHANGED && psy == imx_phy->vbus_power_supply) {
+		ret = power_supply_get_property(imx_phy->vbus_power_supply,
+						POWER_SUPPLY_PROP_ONLINE,
+						&propval);
+		if (ret) {
+			power_supply_put(imx_phy->vbus_power_supply);
+			dev_err(dev, "failed to get psy online info\n");
+			return NOTIFY_DONE;
+		}
+
+		if (propval.intval == 0)
+			imx_phy->chg_type = POWER_SUPPLY_USB_TYPE_UNKNOWN;
+	}
+	power_supply_put(imx_phy->vbus_power_supply);
+
+	return NOTIFY_OK;
+}
+
+static int imx8mq_phy_set_mode(struct phy *phy, enum phy_mode mode,
+			       int submode)
+{
+	struct imx8mq_usb_phy *imx_phy = phy_get_drvdata(phy);
+
+	if (mode == PHY_MODE_USB_DEVICE)
+		return imx8mq_phy_charger_detect(imx_phy);
+
+	return 0;
+}
+
 static const struct phy_ops imx8mq_usb_phy_ops = {
 	.init		= imx8mq_usb_phy_init,
 	.power_on	= imx8mq_phy_power_on,
 	.power_off	= imx8mq_phy_power_off,
+	.set_mode	= imx8mq_phy_set_mode,
 	.owner		= THIS_MODULE,
 };
 
@@ -135,6 +751,7 @@ static struct phy_ops imx8mp_usb_phy_ops = {
 	.init		= imx8mp_usb_phy_init,
 	.power_on	= imx8mq_phy_power_on,
 	.power_off	= imx8mq_phy_power_off,
+	.set_mode	= imx8mq_phy_set_mode,
 	.owner		= THIS_MODULE,
 };
 
@@ -183,14 +800,37 @@ static int imx8mq_usb_phy_probe(struct platform_device *pdev)
 		return PTR_ERR(imx_phy->vbus);
 
 	phy_set_drvdata(imx_phy->phy, imx_phy);
+	platform_set_drvdata(pdev, imx_phy);
+
+	if (device_property_present(dev, "vbus-power-supply")) {
+		imx_phy->chg_det_nb.notifier_call = imx8mq_phy_usb_vbus_notify;
+		power_supply_reg_notifier(&imx_phy->chg_det_nb);
+	}
+
+	imx8m_get_phy_tuning_data(imx_phy);
+
+	debug_create_files(imx_phy);
 
 	phy_provider = devm_of_phy_provider_register(dev, of_phy_simple_xlate);
 
 	return PTR_ERR_OR_ZERO(phy_provider);
 }
 
+static int imx8mq_usb_phy_remove(struct platform_device *pdev)
+{
+	struct imx8mq_usb_phy *imx_phy = platform_get_drvdata(pdev);
+
+	if (device_property_present(&pdev->dev, "vbus-power-supply"))
+		power_supply_unreg_notifier(&imx_phy->chg_det_nb);
+
+	debug_remove_files(imx_phy);
+
+	return 0;
+}
+
 static struct platform_driver imx8mq_usb_phy_driver = {
 	.probe	= imx8mq_usb_phy_probe,
+	.remove = imx8mq_usb_phy_remove,
 	.driver = {
 		.name	= "imx8mq-usb-phy",
 		.of_match_table	= imx8mq_usb_phy_of_match,
diff --git a/drivers/phy/phy-core.c b/drivers/phy/phy-core.c
index 71cb10826..3fb7b34f9 100644
--- a/drivers/phy/phy-core.c
+++ b/drivers/phy/phy-core.c
@@ -11,6 +11,7 @@
 #include <linux/export.h>
 #include <linux/module.h>
 #include <linux/err.h>
+#include <linux/debugfs.h>
 #include <linux/device.h>
 #include <linux/slab.h>
 #include <linux/of.h>
@@ -24,6 +25,8 @@ static DEFINE_MUTEX(phy_provider_mutex);
 static LIST_HEAD(phy_provider_list);
 static LIST_HEAD(phys);
 static DEFINE_IDA(phy_ida);
+struct dentry *phy_debugfs_root;
+EXPORT_SYMBOL_GPL(phy_debugfs_root);
 
 static void devm_phy_release(struct device *dev, void *res)
 {
@@ -1163,6 +1166,8 @@ static int __init phy_core_init(void)
 
 	phy_class->dev_release = phy_release;
 
+	phy_debugfs_root = debugfs_create_dir("phy", NULL);
+
 	return 0;
 }
 device_initcall(phy_core_init);
diff --git a/drivers/pinctrl/devicetree.c b/drivers/pinctrl/devicetree.c
index 3fb238714..4ccc583d6 100644
--- a/drivers/pinctrl/devicetree.c
+++ b/drivers/pinctrl/devicetree.c
@@ -7,6 +7,7 @@
 
 #include <linux/device.h>
 #include <linux/of.h>
+#include <linux/of_gpio.h>
 #include <linux/pinctrl/pinctrl.h>
 #include <linux/slab.h>
 
@@ -193,6 +194,46 @@ static int dt_remember_dummy_state(struct pinctrl *p, const char *statename)
 	return dt_remember_or_free_map(p, statename, NULL, map, 1);
 }
 
+static int dt_gpio_assert_pinctrl(struct pinctrl *p)
+{
+	struct device_node *np = p->dev->of_node;
+	enum of_gpio_flags flags;
+	int gpio;
+	int index = 0;
+	int ret;
+
+	if (!of_find_property(np, "pinctrl-assert-gpios", NULL))
+		return 0; /* Missing the property, so nothing to be done */
+
+	for (;; index++) {
+		gpio = of_get_named_gpio_flags(np, "pinctrl-assert-gpios",
+					       index, &flags);
+		if (gpio < 0) {
+			if (gpio == -EPROBE_DEFER)
+				return gpio;
+			break; /* End of the phandle list */
+		}
+
+		if (!gpio_is_valid(gpio))
+			return -EINVAL;
+
+		ret = devm_gpio_request_one(p->dev, gpio, GPIOF_OUT_INIT_LOW,
+					    NULL);
+		if (ret < 0)
+			return ret;
+
+		if (flags & OF_GPIO_ACTIVE_LOW)
+			continue;
+
+		if (gpio_cansleep(gpio))
+			gpio_set_value_cansleep(gpio, 1);
+		else
+			gpio_set_value(gpio, 1);
+	}
+
+	return 0;
+}
+
 int pinctrl_dt_to_map(struct pinctrl *p, struct pinctrl_dev *pctldev)
 {
 	struct device_node *np = p->dev->of_node;
@@ -213,6 +254,12 @@ int pinctrl_dt_to_map(struct pinctrl *p, struct pinctrl_dev *pctldev)
 		return 0;
 	}
 
+	ret = dt_gpio_assert_pinctrl(p);
+	if (ret) {
+		dev_dbg(p->dev, "failed to assert pinctrl setting: %d\n", ret);
+		return ret;
+	}
+
 	/* We may store pointers to property names within the node */
 	of_node_get(np);
 
diff --git a/drivers/pinctrl/freescale/Kconfig b/drivers/pinctrl/freescale/Kconfig
index a1fbb3b9a..c1be1c845 100644
--- a/drivers/pinctrl/freescale/Kconfig
+++ b/drivers/pinctrl/freescale/Kconfig
@@ -192,3 +192,16 @@ config PINCTRL_IMX23
 config PINCTRL_IMX28
 	bool
 	select PINCTRL_MXS
+
+config PINCTRL_S32V_CORE
+	bool "Core driver for the S32V pin controller"
+	help
+	  Say Y here to enable the S32V pin controller
+
+config PINCTRL_S32V234
+	bool "Freescale S32V234 pinctrl driver"
+	depends on SOC_S32V234
+	select PINCTRL_IMX
+	select PINCTRL_S32V_CORE
+	help
+	  Say Y here to enable the Freescale S32V234 pinctrl driver
diff --git a/drivers/pinctrl/freescale/Makefile b/drivers/pinctrl/freescale/Makefile
index c61722565..98fe9f528 100644
--- a/drivers/pinctrl/freescale/Makefile
+++ b/drivers/pinctrl/freescale/Makefile
@@ -30,3 +30,5 @@ obj-$(CONFIG_PINCTRL_MXS)	+= pinctrl-mxs.o
 obj-$(CONFIG_PINCTRL_IMX23)	+= pinctrl-imx23.o
 obj-$(CONFIG_PINCTRL_IMX25)	+= pinctrl-imx25.o
 obj-$(CONFIG_PINCTRL_IMX28)	+= pinctrl-imx28.o
+obj-$(CONFIG_PINCTRL_S32V234)	+= pinctrl-s32v234.o
+obj-$(CONFIG_PINCTRL_S32V_CORE)	+= pinctrl-s32v-core.o
diff --git a/drivers/pinctrl/freescale/pinctrl-s32v-core.c b/drivers/pinctrl/freescale/pinctrl-s32v-core.c
new file mode 100644
index 000000000..75d0adc2b
--- /dev/null
+++ b/drivers/pinctrl/freescale/pinctrl-s32v-core.c
@@ -0,0 +1,526 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
+/*
+ * Core driver for the S32V pin controller
+ *
+ * Copyright (C) 2015-2016 Freescale Semiconductor, Inc.
+ * Copyright (C) 2017 NXP
+ *
+ * Based on pinctrl-imx.c:
+ *	Author: Dong Aisheng <dong.aisheng@linaro.org>
+ *	Copyright (C) 2012 Freescale Semiconductor, Inc.
+ *	Copyright (C) 2012 Linaro Ltd.
+ */
+
+#include <linux/err.h>
+#include <linux/init.h>
+#include <linux/io.h>
+#include <linux/module.h>
+#include <linux/of.h>
+#include <linux/of_device.h>
+#include <linux/pinctrl/machine.h>
+#include <linux/pinctrl/pinconf.h>
+#include <linux/pinctrl/pinctrl.h>
+#include <linux/pinctrl/pinmux.h>
+#include <linux/slab.h>
+
+#include "../core.h"
+#include "pinctrl-s32v.h"
+
+/**
+ * @dev: a pointer back to containing device
+ * @base: the offset to the controller in virtual memory
+ */
+struct s32v_pinctrl {
+	struct device *dev;
+	struct pinctrl_dev *pctl;
+	void __iomem *base;
+	const struct s32v_pinctrl_soc_info *info;
+};
+
+static const char *pin_get_name_from_info(struct s32v_pinctrl_soc_info *info,
+					  const unsigned int pin_id)
+{
+	int i;
+
+	for (i = 0; i < info->npins; i++) {
+		if (info->pins[i].number == pin_id)
+			return info->pins[i].name;
+	}
+
+	return NULL;
+}
+
+static inline const struct s32v_pin_group *s32v_pinctrl_find_group_by_name(
+				const struct s32v_pinctrl_soc_info *info,
+				const char *name)
+{
+	const struct s32v_pin_group *grp = NULL;
+	unsigned int i;
+
+	for (i = 0; i < info->ngroups; i++) {
+		if (!strcmp(info->groups[i].name, name)) {
+			grp = &info->groups[i];
+			break;
+		}
+	}
+
+	return grp;
+}
+
+static int s32v_get_groups_count(struct pinctrl_dev *pctldev)
+{
+	struct s32v_pinctrl *ipctl = pinctrl_dev_get_drvdata(pctldev);
+	const struct s32v_pinctrl_soc_info *info = ipctl->info;
+
+	return info->ngroups;
+}
+
+static const char *s32v_get_group_name(struct pinctrl_dev *pctldev,
+				       unsigned int selector)
+{
+	struct s32v_pinctrl *ipctl = pinctrl_dev_get_drvdata(pctldev);
+	const struct s32v_pinctrl_soc_info *info = ipctl->info;
+
+	return info->groups[selector].name;
+}
+
+static int s32v_get_group_pins(struct pinctrl_dev *pctldev,
+			       unsigned int selector, const unsigned int **pins,
+			       unsigned int *npins)
+{
+	struct s32v_pinctrl *ipctl = pinctrl_dev_get_drvdata(pctldev);
+	const struct s32v_pinctrl_soc_info *info = ipctl->info;
+
+	if (selector >= info->ngroups)
+		return -EINVAL;
+
+	*pins = info->groups[selector].pin_ids;
+	*npins = info->groups[selector].npins;
+
+	return 0;
+}
+
+static void s32v_pin_dbg_show(struct pinctrl_dev *pctldev, struct seq_file *s,
+			      unsigned int offset)
+{
+	seq_printf(s, "%s", dev_name(pctldev->dev));
+}
+
+static int s32v_dt_node_to_map(struct pinctrl_dev *pctldev,
+			       struct device_node *np,
+			       struct pinctrl_map **map, unsigned int *num_maps)
+{
+	struct s32v_pinctrl *ipctl = pinctrl_dev_get_drvdata(pctldev);
+	const struct s32v_pinctrl_soc_info *info = ipctl->info;
+	const struct s32v_pin_group *grp;
+	struct pinctrl_map *new_map;
+	struct device_node *parent;
+	int map_num = 1;
+	int i, j;
+
+	/*
+	 * first find the group of this node and check if we need create
+	 * config maps for pins
+	 */
+	grp = s32v_pinctrl_find_group_by_name(info, np->name);
+	if (!grp) {
+		dev_err(info->dev, "unable to find group for node %s\n",
+			np->name);
+		return -EINVAL;
+	}
+
+	for (i = 0; i < grp->npins; i++)
+		map_num++;
+
+	new_map = kmalloc_array(map_num, sizeof(struct pinctrl_map),
+				GFP_KERNEL);
+	if (!new_map)
+		return -ENOMEM;
+
+	*map = new_map;
+	*num_maps = map_num;
+
+	/* create mux map */
+	parent = of_get_parent(np);
+	if (!parent) {
+		kfree(new_map);
+		return -EINVAL;
+	}
+	new_map[0].type = PIN_MAP_TYPE_MUX_GROUP;
+	new_map[0].data.mux.function = parent->name;
+	new_map[0].data.mux.group = np->name;
+	of_node_put(parent);
+
+	/* create config map */
+	new_map++;
+	for (i = j = 0; i < grp->npins; i++) {
+		new_map[j].type = PIN_MAP_TYPE_CONFIGS_PIN;
+		new_map[j].data.configs.group_or_pin =
+			pin_get_name(pctldev, grp->pins[i].pin_id);
+		new_map[j].data.configs.configs = &grp->pins[i].config;
+		new_map[j].data.configs.num_configs = 1;
+		j++;
+	}
+
+	dev_dbg(pctldev->dev, "maps: function %s group %s num %d\n",
+		(*map)->data.mux.function, (*map)->data.mux.group, map_num);
+
+	return 0;
+}
+
+static void s32v_dt_free_map(struct pinctrl_dev *pctldev,
+			     struct pinctrl_map *map, unsigned int num_maps)
+{
+	kfree(map);
+}
+
+static const struct pinctrl_ops s32v_pctrl_ops = {
+	.get_groups_count = s32v_get_groups_count,
+	.get_group_name = s32v_get_group_name,
+	.get_group_pins = s32v_get_group_pins,
+	.pin_dbg_show = s32v_pin_dbg_show,
+	.dt_node_to_map = s32v_dt_node_to_map,
+	.dt_free_map = s32v_dt_free_map,
+
+};
+
+static int s32v_pmx_set(struct pinctrl_dev *pctldev, unsigned int selector,
+			unsigned int group)
+{
+	struct s32v_pinctrl *ipctl = pinctrl_dev_get_drvdata(pctldev);
+	const struct s32v_pinctrl_soc_info *info = ipctl->info;
+	unsigned int npins, pin_id;
+	int i;
+	struct s32v_pin_group *grp;
+
+	/*
+	 * Configure the mux mode for each pin in the group for a specific
+	 * function.
+	 */
+	grp = &info->groups[group];
+	npins = grp->npins;
+
+	dev_dbg(ipctl->dev, "enable function %s group %s\n",
+		info->functions[selector].name, grp->name);
+
+	for (i = 0; i < npins; i++) {
+		struct s32v_pin *pin = &grp->pins[i];
+
+		pin_id = pin->pin_id;
+
+		writel(pin->config, ipctl->base + S32V_PAD_CONFIG(pin_id));
+		dev_dbg(ipctl->dev, "write: offset 0x%x val %lu\n",
+			S32V_PAD_CONFIG(pin_id), pin->config);
+	}
+
+	return 0;
+}
+
+static int s32v_pmx_get_funcs_count(struct pinctrl_dev *pctldev)
+{
+	struct s32v_pinctrl *ipctl = pinctrl_dev_get_drvdata(pctldev);
+	const struct s32v_pinctrl_soc_info *info = ipctl->info;
+
+	return info->nfunctions;
+}
+
+static const char *s32v_pmx_get_func_name(struct pinctrl_dev *pctldev,
+					  unsigned int selector)
+{
+	struct s32v_pinctrl *ipctl = pinctrl_dev_get_drvdata(pctldev);
+	const struct s32v_pinctrl_soc_info *info = ipctl->info;
+
+	return info->functions[selector].name;
+}
+
+static int s32v_pmx_get_groups(struct pinctrl_dev *pctldev,
+			       unsigned int selector,
+			       const char * const **groups,
+			       unsigned int * const num_groups)
+{
+	struct s32v_pinctrl *ipctl = pinctrl_dev_get_drvdata(pctldev);
+	const struct s32v_pinctrl_soc_info *info = ipctl->info;
+
+	*groups = info->functions[selector].groups;
+	*num_groups = info->functions[selector].num_groups;
+
+	return 0;
+}
+
+static const struct pinmux_ops s32v_pmx_ops = {
+	.get_functions_count = s32v_pmx_get_funcs_count,
+	.get_function_name = s32v_pmx_get_func_name,
+	.get_function_groups = s32v_pmx_get_groups,
+	.set_mux = s32v_pmx_set,
+};
+
+static int s32v_pinconf_get(struct pinctrl_dev *pctldev,
+			    unsigned int pin_id, unsigned long *config)
+{
+	struct s32v_pinctrl *ipctl = pinctrl_dev_get_drvdata(pctldev);
+
+	*config = readl(ipctl->base + S32V_PAD_CONFIG(pin_id));
+
+	return 0;
+}
+
+static int s32v_pinconf_set(struct pinctrl_dev *pctldev,
+			    unsigned int pin_id, unsigned long *configs,
+			    unsigned int num_configs)
+{
+	struct s32v_pinctrl *ipctl = pinctrl_dev_get_drvdata(pctldev);
+	int i;
+
+	dev_dbg(ipctl->dev, "pinconf set pin %s\n",
+		pin_get_name(pctldev, pin_id));
+
+	for (i = 0; i < num_configs; i++) {
+		writel(configs[i], ipctl->base + S32V_PAD_CONFIG(pin_id));
+		dev_dbg(ipctl->dev, "write: offset 0x%x val 0x%lx\n",
+			S32V_PAD_CONFIG(pin_id), configs[i]);
+	} /* for each config */
+
+	return 0;
+}
+
+static void s32v_pinconf_dbg_show(struct pinctrl_dev *pctldev,
+				  struct seq_file *s, unsigned int pin_id)
+{
+	struct s32v_pinctrl *ipctl = pinctrl_dev_get_drvdata(pctldev);
+	unsigned long config;
+
+	config = readl(ipctl->base + S32V_PAD_CONFIG(pin_id));
+	seq_printf(s, "0x%lx", config);
+}
+
+static void s32v_pinconf_group_dbg_show(struct pinctrl_dev *pctldev,
+					struct seq_file *s, unsigned int group)
+{
+	struct s32v_pinctrl *ipctl = pinctrl_dev_get_drvdata(pctldev);
+	const struct s32v_pinctrl_soc_info *info = ipctl->info;
+	struct s32v_pin_group *grp;
+	unsigned long config;
+	const char *name;
+	int i, ret;
+
+	if (group > info->ngroups)
+		return;
+
+	seq_puts(s, "\n");
+	grp = &info->groups[group];
+	for (i = 0; i < grp->npins; i++) {
+		struct s32v_pin *pin = &grp->pins[i];
+
+		name = pin_get_name(pctldev, pin->pin_id);
+		ret = s32v_pinconf_get(pctldev, pin->pin_id, &config);
+		if (ret)
+			return;
+		seq_printf(s, "%s: 0x%lx", name, config);
+	}
+}
+
+static const struct pinconf_ops s32v_pinconf_ops = {
+	.pin_config_get = s32v_pinconf_get,
+	.pin_config_set = s32v_pinconf_set,
+	.pin_config_dbg_show = s32v_pinconf_dbg_show,
+	.pin_config_group_dbg_show = s32v_pinconf_group_dbg_show,
+};
+
+static struct pinctrl_desc s32v_pinctrl_desc = {
+	.pctlops = &s32v_pctrl_ops,
+	.pmxops = &s32v_pmx_ops,
+	.confops = &s32v_pinconf_ops,
+	.owner = THIS_MODULE,
+};
+
+/*
+ * Each pin represented in fsl,pins consists of 5 u32 PIN_FUNC_ID and
+ * 1 u32 CONFIG, so 24 types in total for each pin.
+ */
+#define FSL_PIN_SIZE 24
+#define SHARE_FSL_PIN_SIZE 20
+
+static int s32v_pinctrl_parse_groups(struct device_node *np,
+				     struct s32v_pin_group *grp,
+				     struct s32v_pinctrl_soc_info *info,
+				     u32 index)
+{
+	int size, i;
+	const __be32 *list;
+
+	dev_dbg(info->dev, "group(%d): %s\n", index, np->name);
+
+	/* Initialise group */
+	grp->name = np->name;
+
+	/*
+	 * the binding format is fsl,pins = <PIN CONFIG>,
+	 * do sanity check and calculate pins number
+	 */
+	list = of_get_property(np, "fsl,pins", &size);
+	if (!list) {
+		dev_err(info->dev, "no fsl,pins property in node %s\n",
+			np->full_name);
+		return -EINVAL;
+	}
+
+	/* we do not check return since it's safe node passed down */
+	if (!size || size % S32V_PIN_SIZE) {
+		dev_err(info->dev, "Invalid fsl,pins property in node %s\n",
+			np->full_name);
+		return -EINVAL;
+	}
+
+	grp->npins = size / S32V_PIN_SIZE;
+	grp->pins = devm_kzalloc(info->dev,
+				 grp->npins * sizeof(struct s32v_pin),
+				 GFP_KERNEL);
+	grp->pin_ids = devm_kzalloc(info->dev,
+				    grp->npins * sizeof(unsigned int),
+				    GFP_KERNEL);
+	if (!grp->pins || !grp->pin_ids)
+		return -ENOMEM;
+
+	for (i = 0; i < grp->npins; i++) {
+		struct s32v_pin *pin = &grp->pins[i];
+
+		pin->pin_id = be32_to_cpu(*list++);
+		pin->config = be32_to_cpu(*list++);
+		grp->pin_ids[i] = grp->pins[i].pin_id;
+
+		dev_dbg(info->dev, "%s: 0x%08lx",
+			pin_get_name_from_info(info, pin->pin_id), pin->config);
+	}
+
+	return 0;
+}
+
+static int s32v_pinctrl_parse_functions(struct device_node *np,
+					struct s32v_pinctrl_soc_info *info,
+					u32 index)
+{
+	struct device_node *child;
+	struct s32v_pmx_func *func;
+	struct s32v_pin_group *grp;
+	static u32 grp_index;
+	u32 i = 0;
+
+	dev_dbg(info->dev, "parse function(%d): %s\n", index, np->name);
+
+	func = &info->functions[index];
+
+	/* Initialise function */
+	func->name = np->name;
+	func->num_groups = of_get_child_count(np);
+	if (func->num_groups == 0) {
+		dev_err(info->dev, "no groups defined in %s\n", np->full_name);
+		return -EINVAL;
+	}
+	func->groups = devm_kzalloc(info->dev,
+				    func->num_groups * sizeof(char *),
+				    GFP_KERNEL);
+
+	for_each_child_of_node(np, child) {
+		func->groups[i] = child->name;
+		grp = &info->groups[grp_index++];
+		s32v_pinctrl_parse_groups(child, grp, info, i++);
+	}
+
+	return 0;
+}
+
+static int s32v_pinctrl_probe_dt(struct platform_device *pdev,
+				 struct s32v_pinctrl_soc_info *info)
+{
+	struct device_node *np = pdev->dev.of_node;
+	struct device_node *child;
+	u32 nfuncs = 0;
+	u32 i = 0;
+
+	if (!np)
+		return -ENODEV;
+
+	nfuncs = of_get_child_count(np);
+	if (nfuncs <= 0) {
+		dev_err(&pdev->dev, "no functions defined\n");
+		return -EINVAL;
+	}
+
+	info->nfunctions = nfuncs;
+	info->functions = devm_kzalloc(&pdev->dev,
+				       nfuncs * sizeof(struct s32v_pmx_func),
+				       GFP_KERNEL);
+	if (!info->functions)
+		return -ENOMEM;
+
+	info->ngroups = 0;
+	for_each_child_of_node(np, child)
+		info->ngroups += of_get_child_count(child);
+	info->groups = devm_kzalloc(&pdev->dev, info->ngroups *
+						sizeof(struct s32v_pin_group),
+				    GFP_KERNEL);
+	if (!info->groups)
+		return -ENOMEM;
+
+	for_each_child_of_node(np, child)
+		s32v_pinctrl_parse_functions(child, info, i++);
+
+	return 0;
+}
+
+int s32v_pinctrl_probe(struct platform_device *pdev,
+		       struct s32v_pinctrl_soc_info *info)
+{
+	struct s32v_pinctrl *ipctl;
+	struct resource *res;
+	int ret;
+
+	if (!info || !info->pins || !info->npins) {
+		dev_err(&pdev->dev, "wrong pinctrl info\n");
+		return -EINVAL;
+	}
+	info->dev = &pdev->dev;
+
+	/* Create state holders etc for this driver */
+	ipctl = devm_kzalloc(&pdev->dev, sizeof(*ipctl), GFP_KERNEL);
+	if (!ipctl)
+		return -ENOMEM;
+
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	ipctl->base = devm_ioremap_resource(&pdev->dev, res);
+
+	if (IS_ERR(ipctl->base))
+		return PTR_ERR(ipctl->base);
+
+	s32v_pinctrl_desc.name = dev_name(&pdev->dev);
+	s32v_pinctrl_desc.pins = info->pins;
+	s32v_pinctrl_desc.npins = info->npins;
+
+	ret = s32v_pinctrl_probe_dt(pdev, info);
+	if (ret) {
+		dev_err(&pdev->dev, "fail to probe dt properties\n");
+		return ret;
+	}
+
+	ipctl->info = info;
+	ipctl->dev = info->dev;
+	platform_set_drvdata(pdev, ipctl);
+	ipctl->pctl = pinctrl_register(&s32v_pinctrl_desc, &pdev->dev, ipctl);
+	if (!ipctl->pctl) {
+		dev_err(&pdev->dev, "could not register s32 pinctrl driver\n");
+		return -EINVAL;
+	}
+
+	dev_info(&pdev->dev, "initialized s32 pinctrl driver\n");
+
+	return 0;
+}
+
+int s32v_pinctrl_remove(struct platform_device *pdev)
+{
+	struct s32v_pinctrl *ipctl = platform_get_drvdata(pdev);
+
+	pinctrl_unregister(ipctl->pctl);
+
+	return 0;
+}
diff --git a/drivers/pinctrl/freescale/pinctrl-s32v.h b/drivers/pinctrl/freescale/pinctrl-s32v.h
new file mode 100644
index 000000000..f231607bb
--- /dev/null
+++ b/drivers/pinctrl/freescale/pinctrl-s32v.h
@@ -0,0 +1,72 @@
+/* SPDX-License-Identifier: GPL-2.0-or-later */
+/*
+ * S32V pinmux core definitions
+ *
+ * Copyright (C) 2017 NXP
+ * Copyright (C) 2015-2016 Freescale Semiconductor, Inc.
+ * Copyright (C) 2012 Linaro Ltd.
+ *
+ * Based on pinctrl-imx.h, by Dong Aisheng <dong.aisheng@linaro.org>
+ */
+
+#ifndef __DRIVERS_PINCTRL_S32V_H
+#define __DRIVERS_PINCTRL_S32V_H
+
+struct platform_device;
+
+/**
+ * struct s32v_pin - describes a single S32V pin
+ * @pin_id: the pin_id of this pin
+ * @config: the config for this pin.
+ */
+struct s32v_pin {
+	unsigned int pin_id;
+	unsigned long config;
+};
+
+/**
+ * struct s32v_pin_group - describes an S32V pin group
+ * @name: the name of this specific pin group
+ * @npins: the number of pins in this group array, i.e. the number of
+ *	elements in .pins so we can iterate over that array
+ * @pin_ids: array of pin_ids. pinctrl forces us to maintain such an array
+ * @pins: array of pins
+ */
+struct s32v_pin_group {
+	const char *name;
+	unsigned int npins;
+	unsigned int *pin_ids;
+	struct s32v_pin *pins;
+};
+
+/**
+ * struct s32v_pmx_func - describes S32V pinmux functions
+ * @name: the name of this specific function
+ * @groups: corresponding pin groups
+ * @num_groups: the number of groups
+ */
+struct s32v_pmx_func {
+	const char *name;
+	const char **groups;
+	unsigned int num_groups;
+};
+
+struct s32v_pinctrl_soc_info {
+	struct device *dev;
+	const struct pinctrl_pin_desc *pins;
+	unsigned int npins;
+	struct s32v_pin_group *groups;
+	unsigned int ngroups;
+	struct s32v_pmx_func *functions;
+	unsigned int nfunctions;
+	unsigned int flags;
+};
+
+#define S32V_PINCTRL_PIN(pin)	PINCTRL_PIN(pin, #pin)
+#define S32V_PAD_CONFIG(idx)	(0x240 + (idx) * 4)
+#define S32V_PIN_SIZE		(8)
+
+int s32v_pinctrl_probe(struct platform_device *pdev,
+		       struct s32v_pinctrl_soc_info *info);
+int s32v_pinctrl_remove(struct platform_device *pdev);
+#endif /* __DRIVERS_PINCTRL_S32V_H */
diff --git a/drivers/pinctrl/freescale/pinctrl-s32v234.c b/drivers/pinctrl/freescale/pinctrl-s32v234.c
new file mode 100644
index 000000000..6c64f4cdc
--- /dev/null
+++ b/drivers/pinctrl/freescale/pinctrl-s32v234.c
@@ -0,0 +1,251 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
+/*
+ * s32v234 pinctrl driver based on imx pinmux and pinconf core
+ *
+ * Copyright 2015-2016 Freescale Semiconductor, Inc.
+ * Copyright 2017, 2019 NXP
+ */
+
+#include <linux/err.h>
+#include <linux/init.h>
+#include <linux/io.h>
+#include <linux/module.h>
+#include <linux/of.h>
+#include <linux/of_device.h>
+#include <linux/pinctrl/pinctrl.h>
+#include <dt-bindings/pinctrl/s32v234-pinctrl.h>
+
+#include "pinctrl-s32v.h"
+
+/* Pad names for the pinmux subsystem */
+static const struct pinctrl_pin_desc s32v234_pinctrl_pads[] = {
+	S32V_PINCTRL_PIN(S32V234_MSCR_PA0),
+	S32V_PINCTRL_PIN(S32V234_MSCR_PA1),
+	S32V_PINCTRL_PIN(S32V234_MSCR_PA2),
+	S32V_PINCTRL_PIN(S32V234_MSCR_PA3),
+	S32V_PINCTRL_PIN(S32V234_MSCR_PA4),
+	S32V_PINCTRL_PIN(S32V234_MSCR_PA5),
+	S32V_PINCTRL_PIN(S32V234_MSCR_PA6),
+	S32V_PINCTRL_PIN(S32V234_MSCR_PA7),
+	S32V_PINCTRL_PIN(S32V234_MSCR_PA8),
+	S32V_PINCTRL_PIN(S32V234_MSCR_PA9),
+	S32V_PINCTRL_PIN(S32V234_MSCR_PA10),
+	S32V_PINCTRL_PIN(S32V234_MSCR_PA11),
+	S32V_PINCTRL_PIN(S32V234_MSCR_PA12),
+	S32V_PINCTRL_PIN(S32V234_MSCR_PA13),
+	S32V_PINCTRL_PIN(S32V234_MSCR_PA14),
+	S32V_PINCTRL_PIN(S32V234_MSCR_PA15),
+	S32V_PINCTRL_PIN(S32V234_MSCR_PB0),
+	S32V_PINCTRL_PIN(S32V234_MSCR_PB1),
+	S32V_PINCTRL_PIN(S32V234_MSCR_PB2),
+	S32V_PINCTRL_PIN(S32V234_MSCR_PB3),
+	S32V_PINCTRL_PIN(S32V234_MSCR_PB4),
+	S32V_PINCTRL_PIN(S32V234_MSCR_PB5),
+	S32V_PINCTRL_PIN(S32V234_MSCR_PB6),
+	S32V_PINCTRL_PIN(S32V234_MSCR_PB7),
+	S32V_PINCTRL_PIN(S32V234_MSCR_PB8),
+	S32V_PINCTRL_PIN(S32V234_MSCR_PB9),
+	S32V_PINCTRL_PIN(S32V234_MSCR_PB10),
+	S32V_PINCTRL_PIN(S32V234_MSCR_PB11),
+	S32V_PINCTRL_PIN(S32V234_MSCR_PB12),
+	S32V_PINCTRL_PIN(S32V234_MSCR_PB13),
+	S32V_PINCTRL_PIN(S32V234_MSCR_PB14),
+	S32V_PINCTRL_PIN(S32V234_MSCR_PB15),
+	S32V_PINCTRL_PIN(S32V234_MSCR_PC0),
+	S32V_PINCTRL_PIN(S32V234_MSCR_PC1),
+	S32V_PINCTRL_PIN(S32V234_MSCR_PC2),
+	S32V_PINCTRL_PIN(S32V234_MSCR_PC3),
+	S32V_PINCTRL_PIN(S32V234_MSCR_PC4),
+	S32V_PINCTRL_PIN(S32V234_MSCR_PC5),
+	S32V_PINCTRL_PIN(S32V234_MSCR_PC6),
+	S32V_PINCTRL_PIN(S32V234_MSCR_PC7),
+	S32V_PINCTRL_PIN(S32V234_MSCR_PC8),
+	S32V_PINCTRL_PIN(S32V234_MSCR_PC9),
+	S32V_PINCTRL_PIN(S32V234_MSCR_PC10),
+	S32V_PINCTRL_PIN(S32V234_MSCR_PC11),
+	S32V_PINCTRL_PIN(S32V234_MSCR_PC12),
+	S32V_PINCTRL_PIN(S32V234_MSCR_PC13),
+	S32V_PINCTRL_PIN(S32V234_MSCR_PC14),
+	S32V_PINCTRL_PIN(S32V234_MSCR_PC15),
+	S32V_PINCTRL_PIN(S32V234_MSCR_PD0),
+	S32V_PINCTRL_PIN(S32V234_MSCR_PD1),
+	S32V_PINCTRL_PIN(S32V234_MSCR_PD2),
+	S32V_PINCTRL_PIN(S32V234_MSCR_PD3),
+	S32V_PINCTRL_PIN(S32V234_MSCR_PD4),
+	S32V_PINCTRL_PIN(S32V234_MSCR_PD5),
+	S32V_PINCTRL_PIN(S32V234_MSCR_PD6),
+	S32V_PINCTRL_PIN(S32V234_MSCR_PD7),
+	S32V_PINCTRL_PIN(S32V234_MSCR_PD8),
+	S32V_PINCTRL_PIN(S32V234_MSCR_PD9),
+	S32V_PINCTRL_PIN(S32V234_MSCR_PD10),
+	S32V_PINCTRL_PIN(S32V234_MSCR_PD11),
+	S32V_PINCTRL_PIN(S32V234_MSCR_PD12),
+	S32V_PINCTRL_PIN(S32V234_MSCR_PD13),
+	S32V_PINCTRL_PIN(S32V234_MSCR_PD14),
+	S32V_PINCTRL_PIN(S32V234_MSCR_PD15),
+	S32V_PINCTRL_PIN(S32V234_MSCR_PE0),
+	S32V_PINCTRL_PIN(S32V234_MSCR_PE1),
+	S32V_PINCTRL_PIN(S32V234_MSCR_PE2),
+	S32V_PINCTRL_PIN(S32V234_MSCR_PE3),
+	S32V_PINCTRL_PIN(S32V234_MSCR_PE4),
+	S32V_PINCTRL_PIN(S32V234_MSCR_PE5),
+	S32V_PINCTRL_PIN(S32V234_MSCR_PE6),
+	S32V_PINCTRL_PIN(S32V234_MSCR_PE7),
+	S32V_PINCTRL_PIN(S32V234_MSCR_PE8),
+	S32V_PINCTRL_PIN(S32V234_MSCR_PE9),
+	S32V_PINCTRL_PIN(S32V234_MSCR_PE10),
+	S32V_PINCTRL_PIN(S32V234_MSCR_PE11),
+	S32V_PINCTRL_PIN(S32V234_MSCR_PE12),
+	S32V_PINCTRL_PIN(S32V234_MSCR_PE13),
+	S32V_PINCTRL_PIN(S32V234_MSCR_PE14),
+	S32V_PINCTRL_PIN(S32V234_MSCR_PE15),
+	S32V_PINCTRL_PIN(S32V234_MSCR_PF0),
+	S32V_PINCTRL_PIN(S32V234_MSCR_PF1),
+	S32V_PINCTRL_PIN(S32V234_MSCR_PF2),
+	S32V_PINCTRL_PIN(S32V234_MSCR_PF3),
+	S32V_PINCTRL_PIN(S32V234_MSCR_PF4),
+	S32V_PINCTRL_PIN(S32V234_MSCR_PF5),
+	S32V_PINCTRL_PIN(S32V234_MSCR_PF6),
+	S32V_PINCTRL_PIN(S32V234_MSCR_PF7),
+	S32V_PINCTRL_PIN(S32V234_MSCR_PF8),
+	S32V_PINCTRL_PIN(S32V234_MSCR_PF9),
+	S32V_PINCTRL_PIN(S32V234_MSCR_PF10),
+	S32V_PINCTRL_PIN(S32V234_MSCR_PF11),
+	S32V_PINCTRL_PIN(S32V234_MSCR_PF12),
+	S32V_PINCTRL_PIN(S32V234_MSCR_PF13),
+	S32V_PINCTRL_PIN(S32V234_MSCR_PF14),
+	S32V_PINCTRL_PIN(S32V234_MSCR_PF15),
+	S32V_PINCTRL_PIN(S32V234_MSCR_PG0),
+	S32V_PINCTRL_PIN(S32V234_MSCR_PG1),
+	S32V_PINCTRL_PIN(S32V234_MSCR_PG2),
+	S32V_PINCTRL_PIN(S32V234_MSCR_PG3),
+	S32V_PINCTRL_PIN(S32V234_MSCR_PG4),
+	S32V_PINCTRL_PIN(S32V234_MSCR_PG5),
+	S32V_PINCTRL_PIN(S32V234_MSCR_PG6),
+	S32V_PINCTRL_PIN(S32V234_MSCR_PG7),
+	S32V_PINCTRL_PIN(S32V234_MSCR_PG8),
+	S32V_PINCTRL_PIN(S32V234_MSCR_PG9),
+	S32V_PINCTRL_PIN(S32V234_MSCR_PG10),
+	S32V_PINCTRL_PIN(S32V234_MSCR_PG11),
+	S32V_PINCTRL_PIN(S32V234_MSCR_PG12),
+	S32V_PINCTRL_PIN(S32V234_MSCR_PG13),
+	S32V_PINCTRL_PIN(S32V234_MSCR_PG14),
+	S32V_PINCTRL_PIN(S32V234_MSCR_PG15),
+	S32V_PINCTRL_PIN(S32V234_MSCR_PH0),
+	S32V_PINCTRL_PIN(S32V234_MSCR_PH1),
+	S32V_PINCTRL_PIN(S32V234_MSCR_PH2),
+	S32V_PINCTRL_PIN(S32V234_MSCR_PH3),
+	S32V_PINCTRL_PIN(S32V234_MSCR_PH4),
+	S32V_PINCTRL_PIN(S32V234_MSCR_PH5),
+	S32V_PINCTRL_PIN(S32V234_MSCR_PH6),
+	S32V_PINCTRL_PIN(S32V234_MSCR_PH7),
+	S32V_PINCTRL_PIN(S32V234_MSCR_PH8),
+	S32V_PINCTRL_PIN(S32V234_MSCR_PH9),
+	S32V_PINCTRL_PIN(S32V234_MSCR_PH10),
+	S32V_PINCTRL_PIN(S32V234_MSCR_PH11),
+	S32V_PINCTRL_PIN(S32V234_MSCR_PH12),
+	S32V_PINCTRL_PIN(S32V234_MSCR_PH13),
+	S32V_PINCTRL_PIN(S32V234_MSCR_PH14),
+	S32V_PINCTRL_PIN(S32V234_MSCR_PH15),
+	S32V_PINCTRL_PIN(S32V234_MSCR_PJ0),
+	S32V_PINCTRL_PIN(S32V234_MSCR_PJ1),
+	S32V_PINCTRL_PIN(S32V234_MSCR_PJ2),
+	S32V_PINCTRL_PIN(S32V234_MSCR_PJ3),
+	S32V_PINCTRL_PIN(S32V234_MSCR_PJ4),
+	S32V_PINCTRL_PIN(S32V234_MSCR_PJ5),
+	S32V_PINCTRL_PIN(S32V234_MSCR_PJ6),
+	S32V_PINCTRL_PIN(S32V234_MSCR_PJ7),
+	S32V_PINCTRL_PIN(S32V234_MSCR_PJ8),
+	S32V_PINCTRL_PIN(S32V234_MSCR_PJ9),
+	S32V_PINCTRL_PIN(S32V234_MSCR_PJ10),
+	S32V_PINCTRL_PIN(S32V234_MSCR_PJ11),
+	S32V_PINCTRL_PIN(S32V234_MSCR_PJ12),
+	S32V_PINCTRL_PIN(S32V234_MSCR_PJ13),
+	S32V_PINCTRL_PIN(S32V234_MSCR_PJ14),
+	S32V_PINCTRL_PIN(S32V234_MSCR_PJ15),
+	S32V_PINCTRL_PIN(S32V234_MSCR_PK0),
+	S32V_PINCTRL_PIN(S32V234_MSCR_PK1),
+	S32V_PINCTRL_PIN(S32V234_MSCR_PK2),
+	S32V_PINCTRL_PIN(S32V234_MSCR_PK3),
+	S32V_PINCTRL_PIN(S32V234_MSCR_PK4),
+	S32V_PINCTRL_PIN(S32V234_MSCR_PK5),
+	S32V_PINCTRL_PIN(S32V234_MSCR_PK6),
+	S32V_PINCTRL_PIN(S32V234_MSCR_PK7),
+	S32V_PINCTRL_PIN(S32V234_MSCR_PK8),
+	S32V_PINCTRL_PIN(S32V234_MSCR_PK9),
+	S32V_PINCTRL_PIN(S32V234_MSCR_PK10),
+	S32V_PINCTRL_PIN(S32V234_MSCR_PK11),
+	S32V_PINCTRL_PIN(S32V234_MSCR_PK12),
+	S32V_PINCTRL_PIN(S32V234_MSCR_PK13),
+	S32V_PINCTRL_PIN(S32V234_MSCR_PK14),
+	S32V_PINCTRL_PIN(S32V234_MSCR_PK15),
+	S32V_PINCTRL_PIN(S32V234_MSCR_PL0),
+	S32V_PINCTRL_PIN(S32V234_MSCR_PL1),
+	S32V_PINCTRL_PIN(S32V234_MSCR_PL2),
+	S32V_PINCTRL_PIN(S32V234_MSCR_PL3),
+	S32V_PINCTRL_PIN(S32V234_MSCR_PL4),
+	S32V_PINCTRL_PIN(S32V234_MSCR_PL5),
+	S32V_PINCTRL_PIN(S32V234_MSCR_PL8),
+
+	S32V_PINCTRL_PIN(S32V234_IMCR_USDHC_CLK),
+	S32V_PINCTRL_PIN(S32V234_IMCR_USDHC_CMD),
+	S32V_PINCTRL_PIN(S32V234_IMCR_USDHC_DAT0),
+	S32V_PINCTRL_PIN(S32V234_IMCR_USDHC_DAT1),
+	S32V_PINCTRL_PIN(S32V234_IMCR_USDHC_DAT2),
+	S32V_PINCTRL_PIN(S32V234_IMCR_USDHC_DAT3),
+	S32V_PINCTRL_PIN(S32V234_IMCR_USDHC_DAT4),
+	S32V_PINCTRL_PIN(S32V234_IMCR_USDHC_DAT5),
+	S32V_PINCTRL_PIN(S32V234_IMCR_USDHC_DAT6),
+	S32V_PINCTRL_PIN(S32V234_IMCR_USDHC_DAT7),
+	S32V_PINCTRL_PIN(S32V234_IMCR_CAN_FD0_RXD),
+	S32V_PINCTRL_PIN(S32V234_IMCR_CAN_FD1_RXD),
+	S32V_PINCTRL_PIN(S32V234_IMCR_UART0_RXD),
+	S32V_PINCTRL_PIN(S32V234_IMCR_UART1_RXD),
+	S32V_PINCTRL_PIN(S32V234_IMCR_USDHC_WP),
+
+	S32V_PINCTRL_PIN(S32V234_IMCR_Ethernet_RX_ER),
+	S32V_PINCTRL_PIN(S32V234_IMCR_Ethernet_COL),
+	S32V_PINCTRL_PIN(S32V234_IMCR_Ethernet_CRS),
+	S32V_PINCTRL_PIN(S32V234_IMCR_Ethernet_RX_DV),
+	S32V_PINCTRL_PIN(S32V234_IMCR_Ethernet_RX_D0),
+	S32V_PINCTRL_PIN(S32V234_IMCR_Ethernet_RX_D1),
+	S32V_PINCTRL_PIN(S32V234_IMCR_Ethernet_RX_D2),
+	S32V_PINCTRL_PIN(S32V234_IMCR_Ethernet_RX_D3),
+	S32V_PINCTRL_PIN(S32V234_IMCR_Ethernet_TX_CLK),
+	S32V_PINCTRL_PIN(S32V234_IMCR_Ethernet_RX_CLK),
+	S32V_PINCTRL_PIN(S32V234_IMCR_Ethernet_MDIO),
+	S32V_PINCTRL_PIN(S32V234_IMCR_Ethernet_TIMER0),
+	S32V_PINCTRL_PIN(S32V234_IMCR_Ethernet_TIMER1),
+	S32V_PINCTRL_PIN(S32V234_IMCR_Ethernet_TIMER2),
+};
+
+static struct s32v_pinctrl_soc_info s32v234_pinctrl_info = {
+	.pins = s32v234_pinctrl_pads,
+	.npins = ARRAY_SIZE(s32v234_pinctrl_pads),
+};
+
+static const struct of_device_id s32v234_pinctrl_of_match[] = {
+	{ .compatible = "fsl,s32v234-siul2", },
+	{ /* sentinel */ }
+};
+MODULE_DEVICE_TABLE(of, s32v234_pinctrl_of_match);
+
+static int s32v234_pinctrl_probe(struct platform_device *pdev)
+{
+	return s32v_pinctrl_probe(pdev, &s32v234_pinctrl_info);
+}
+
+static struct platform_driver s32v234_pinctrl_driver = {
+	.driver = {
+		.name = "s32v234-siul2",
+		.owner = THIS_MODULE,
+		.of_match_table = s32v234_pinctrl_of_match,
+	},
+	.probe = s32v234_pinctrl_probe,
+	.remove = s32v_pinctrl_remove,
+};
+
+module_platform_driver(s32v234_pinctrl_driver);
+
+MODULE_DESCRIPTION("Freescale S32V234 pinctrl driver");
+MODULE_LICENSE("GPL v2");
diff --git a/drivers/ptp/Kconfig b/drivers/ptp/Kconfig
index 3e377f3c6..d5be332cf 100644
--- a/drivers/ptp/Kconfig
+++ b/drivers/ptp/Kconfig
@@ -44,7 +44,7 @@ config PTP_1588_CLOCK_DTE
 
 config PTP_1588_CLOCK_QORIQ
 	tristate "Freescale QorIQ 1588 timer as PTP clock"
-	depends on GIANFAR || FSL_DPAA_ETH || FSL_DPAA2_ETH || FSL_ENETC || FSL_ENETC_VF || COMPILE_TEST
+	depends on !FSL_SDK_FMAN_RTC_API && (GIANFAR || FSL_DPAA_ETH || FSL_SDK_DPAA_ETH || FSL_DPAA2_ETH || FSL_ENETC || FSL_ENETC_VF) || COMPILE_TEST
 	depends on PTP_1588_CLOCK
 	default y
 	help
diff --git a/drivers/pwm/pwm-imx27.c b/drivers/pwm/pwm-imx27.c
index 86bcafd23..7615ac75e 100644
--- a/drivers/pwm/pwm-imx27.c
+++ b/drivers/pwm/pwm-imx27.c
@@ -82,6 +82,7 @@
 struct pwm_imx27_chip {
 	struct clk	*clk_ipg;
 	struct clk	*clk_per;
+	struct clk	*clk_32k;
 	void __iomem	*mmio_base;
 	struct pwm_chip	chip;
 
@@ -99,23 +100,36 @@ static int pwm_imx27_clk_prepare_enable(struct pwm_imx27_chip *imx)
 {
 	int ret;
 
+	if (imx->clk_32k) {
+		ret = clk_prepare_enable(imx->clk_32k);
+		if (ret)
+			goto err1;
+	}
+
 	ret = clk_prepare_enable(imx->clk_ipg);
 	if (ret)
-		return ret;
+		goto err2;
 
 	ret = clk_prepare_enable(imx->clk_per);
-	if (ret) {
-		clk_disable_unprepare(imx->clk_ipg);
-		return ret;
-	}
+	if (ret)
+		goto err3;
 
 	return 0;
+err3:
+	clk_disable_unprepare(imx->clk_ipg);
+err2:
+	if (imx->clk_32k)
+		clk_disable_unprepare(imx->clk_32k);
+err1:
+	return ret;
 }
 
 static void pwm_imx27_clk_disable_unprepare(struct pwm_imx27_chip *imx)
 {
 	clk_disable_unprepare(imx->clk_per);
 	clk_disable_unprepare(imx->clk_ipg);
+	if (imx->clk_32k)
+		clk_disable_unprepare(imx->clk_32k);
 }
 
 static void pwm_imx27_get_state(struct pwm_chip *chip,
@@ -338,6 +352,13 @@ static int pwm_imx27_probe(struct platform_device *pdev)
 		return ret;
 	}
 
+	imx->clk_32k = devm_clk_get_optional(&pdev->dev, "32k");
+	if (IS_ERR(imx->clk_32k)) {
+		dev_err(&pdev->dev, "getting 32k clock failed with %ld\n",
+				PTR_ERR(imx->clk_32k));
+		return PTR_ERR(imx->clk_32k);
+	}
+
 	imx->chip.ops = &pwm_imx27_ops;
 	imx->chip.dev = &pdev->dev;
 	imx->chip.base = -1;
