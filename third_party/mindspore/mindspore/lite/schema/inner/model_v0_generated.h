// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_MODELV0_MINDSPORE_SCHEMA_V0_H_
#define FLATBUFFERS_GENERATED_MODELV0_MINDSPORE_SCHEMA_V0_H_

#include "flatbuffers/flatbuffers.h"

#include "ops_v0_generated.h"

namespace mindspore {
namespace schema {
namespace v0 {

struct QuantParam;
struct QuantParamBuilder;
struct QuantParamT;

struct Tensor;
struct TensorBuilder;
struct TensorT;

struct Primitive;
struct PrimitiveBuilder;
struct PrimitiveT;

struct CNode;
struct CNodeBuilder;
struct CNodeT;

struct SubGraph;
struct SubGraphBuilder;
struct SubGraphT;

struct MetaGraph;
struct MetaGraphBuilder;
struct MetaGraphT;

inline const flatbuffers::TypeTable *QuantParamTypeTable();

inline const flatbuffers::TypeTable *TensorTypeTable();

inline const flatbuffers::TypeTable *PrimitiveTypeTable();

inline const flatbuffers::TypeTable *CNodeTypeTable();

inline const flatbuffers::TypeTable *SubGraphTypeTable();

inline const flatbuffers::TypeTable *MetaGraphTypeTable();

enum NodeType : int32_t {
  NodeType_ValueNode = 0,
  NodeType_Parameter = 1,
  NodeType_CNode = 2,
  NodeType_MIN = NodeType_ValueNode,
  NodeType_MAX = NodeType_CNode
};

inline const NodeType (&EnumValuesNodeType())[3] {
  static const NodeType values[] = {
    NodeType_ValueNode,
    NodeType_Parameter,
    NodeType_CNode
  };
  return values;
}

inline const char * const *EnumNamesNodeType() {
  static const char * const names[4] = {
    "ValueNode",
    "Parameter",
    "CNode",
    nullptr
  };
  return names;
}

inline const char *EnumNameNodeType(NodeType e) {
  if (flatbuffers::IsOutRange(e, NodeType_ValueNode, NodeType_CNode)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesNodeType()[index];
}

enum PrimitiveType : uint8_t {
  PrimitiveType_NONE = 0,
  PrimitiveType_Concat = 1,
  PrimitiveType_SoftMax = 2,
  PrimitiveType_Activation = 3,
  PrimitiveType_Conv2D = 4,
  PrimitiveType_FusedBatchNorm = 5,
  PrimitiveType_BatchNorm = 6,
  PrimitiveType_BiasAdd = 7,
  PrimitiveType_Pooling = 8,
  PrimitiveType_ROIPooling = 9,
  PrimitiveType_DepthwiseConv2D = 10,
  PrimitiveType_DeDepthwiseConv2D = 11,
  PrimitiveType_Resize = 12,
  PrimitiveType_DetectionPostProcess = 13,
  PrimitiveType_FullConnection = 14,
  PrimitiveType_Mean = 15,
  PrimitiveType_DeConv2D = 16,
  PrimitiveType_Scale = 17,
  PrimitiveType_Reshape = 18,
  PrimitiveType_Eltwise = 19,
  PrimitiveType_NetOutput = 20,
  PrimitiveType_Add = 21,
  PrimitiveType_Sub = 22,
  PrimitiveType_MatMul = 23,
  PrimitiveType_StridedSlice = 24,
  PrimitiveType_Power = 25,
  PrimitiveType_Slice = 26,
  PrimitiveType_Stack = 27,
  PrimitiveType_Mul = 28,
  PrimitiveType_RealDiv = 29,
  PrimitiveType_Pad = 30,
  PrimitiveType_Maximum = 31,
  PrimitiveType_Minimum = 32,
  PrimitiveType_PReLU = 33,
  PrimitiveType_LeakyReLU = 34,
  PrimitiveType_ArgMax = 35,
  PrimitiveType_ArgMin = 36,
  PrimitiveType_Exp = 37,
  PrimitiveType_Crop = 38,
  PrimitiveType_Range = 39,
  PrimitiveType_Rsqrt = 40,
  PrimitiveType_ExpandDims = 41,
  PrimitiveType_Tile = 42,
  PrimitiveType_Cast = 43,
  PrimitiveType_Shape = 44,
  PrimitiveType_Nchw2Nhwc = 45,
  PrimitiveType_Nhwc2Nchw = 46,
  PrimitiveType_QuantDTypeCast = 47,
  PrimitiveType_Split = 48,
  PrimitiveType_Permute = 49,
  PrimitiveType_FakeQuantWithMinMaxVars = 50,
  PrimitiveType_Equal = 51,
  PrimitiveType_Less = 52,
  PrimitiveType_Greater = 53,
  PrimitiveType_NotEqual = 54,
  PrimitiveType_LessEqual = 55,
  PrimitiveType_GreaterEqual = 56,
  PrimitiveType_Min = 57,
  PrimitiveType_Floor = 58,
  PrimitiveType_Abs = 59,
  PrimitiveType_Neg = 60,
  PrimitiveType_Cos = 61,
  PrimitiveType_Sin = 62,
  PrimitiveType_Sqrt = 63,
  PrimitiveType_Square = 64,
  PrimitiveType_Constant = 65,
  PrimitiveType_Log = 66,
  PrimitiveType_Tan = 67,
  PrimitiveType_Atan = 68,
  PrimitiveType_Asin = 69,
  PrimitiveType_Clip = 70,
  PrimitiveType_Transpose = 71,
  PrimitiveType_Squeeze = 72,
  PrimitiveType_Unsqueeze = 73,
  PrimitiveType_Upsample = 74,
  PrimitiveType_Dropout = 75,
  PrimitiveType_Broadcast = 76,
  PrimitiveType_BroadcastTo = 77,
  PrimitiveType_Lrn = 78,
  PrimitiveType_ZerosLike = 79,
  PrimitiveType_TopK = 80,
  PrimitiveType_SpaceToDepth = 81,
  PrimitiveType_SpaceToBatch = 82,
  PrimitiveType_SparseToDense = 83,
  PrimitiveType_ReverseSequence = 84,
  PrimitiveType_Rank = 85,
  PrimitiveType_Gather = 86,
  PrimitiveType_GatherNd = 87,
  PrimitiveType_Fill = 88,
  PrimitiveType_Elu = 89,
  PrimitiveType_DepthToSpace = 90,
  PrimitiveType_BatchToSpace = 91,
  PrimitiveType_AddN = 92,
  PrimitiveType_Ceil = 93,
  PrimitiveType_EmbeddingLookup = 94,
  PrimitiveType_EmbeddingLookupSparse = 95,
  PrimitiveType_FloorDiv = 96,
  PrimitiveType_FloorMod = 97,
  PrimitiveType_L2Norm = 98,
  PrimitiveType_LocalResponseNormalization = 99,
  PrimitiveType_MatrixDiag = 100,
  PrimitiveType_Reduce = 101,
  PrimitiveType_Reverse = 102,
  PrimitiveType_Round = 103,
  PrimitiveType_Select = 104,
  PrimitiveType_Scatter = 105,
  PrimitiveType_ScatterND = 106,
  PrimitiveType_ConstantOfShape = 107,
  PrimitiveType_Unique = 108,
  PrimitiveType_Unstack = 109,
  PrimitiveType_LogicalAnd = 110,
  PrimitiveType_LogicalOr = 111,
  PrimitiveType_LogicalXor = 112,
  PrimitiveType_LogicalNot = 113,
  PrimitiveType_OnnxInt8Quantize = 114,
  PrimitiveType_OnnxInt8Dequantize = 115,
  PrimitiveType_FakeQuantWithMinMax = 116,
  PrimitiveType_FakeQuantWithMinMaxPerChannel = 117,
  PrimitiveType_BatchNormFold = 118,
  PrimitiveType_MulFold = 119,
  PrimitiveType_AddFold = 120,
  PrimitiveType_SquaredDifference = 121,
  PrimitiveType_Flatten = 122,
  PrimitiveType_FlattenGrad = 123,
  PrimitiveType_TupleGetItem = 124,
  PrimitiveType_Div = 125,
  PrimitiveType_Where = 126,
  PrimitiveType_OneHot = 127,
  PrimitiveType_Lstm = 128,
  PrimitiveType_Conv2DGradFilter = 129,
  PrimitiveType_Conv2DGradInput = 130,
  PrimitiveType_PoolingGrad = 131,
  PrimitiveType_BNGrad = 132,
  PrimitiveType_Assign = 133,
  PrimitiveType_ApplyMomentum = 134,
  PrimitiveType_BiasGrad = 135,
  PrimitiveType_SoftmaxCrossEntropy = 136,
  PrimitiveType_AddGrad = 137,
  PrimitiveType_SubGrad = 138,
  PrimitiveType_MulGrad = 139,
  PrimitiveType_DivGrad = 140,
  PrimitiveType_PowerGrad = 141,
  PrimitiveType_ActivationGrad = 142,
  PrimitiveType_PriorBox = 143,
  PrimitiveType_SpaceToBatchND = 144,
  PrimitiveType_Depend = 145,
  PrimitiveType_Return = 146,
  PrimitiveType_MakeTuple = 147,
  PrimitiveType_ToFormat = 148,
  PrimitiveType_Proposal = 149,
  PrimitiveType_Custom = 150,
  PrimitiveType_BlackBox = 151,
  PrimitiveType_NegGrad = 152,
  PrimitiveType_LogGrad = 153,
  PrimitiveType_BatchToSpaceND = 154,
  PrimitiveType_LshProjection = 155,
  PrimitiveType_HashtableLookup = 156,
  PrimitiveType_SkipGram = 157,
  PrimitiveType_DeConv2DGradFilter = 158,
  PrimitiveType_CustomPredict = 159,
  PrimitiveType_CustomNormalize = 160,
  PrimitiveType_CustomExtractFeatures = 161,
  PrimitiveType_AudioSpectrogram = 162,
  PrimitiveType_Mfcc = 163,
  PrimitiveType_Rfft = 164,
  PrimitiveType_FftReal = 165,
  PrimitiveType_FftImag = 166,
  PrimitiveType_Sgd = 167,
  PrimitiveType_Adam = 168,
  PrimitiveType_GroupConv2DGradInput = 169,
  PrimitiveType_Loop = 170,
  PrimitiveType_NonMaxSuppression = 171,
  PrimitiveType_InstanceNorm = 172,
  PrimitiveType_Identity = 173,
  PrimitiveType_LayerNorm = 174,
  PrimitiveType_While = 175,
  PrimitiveType_ControlDepend = 176,
  PrimitiveType_UnsortedSegmentSum = 177,
  PrimitiveType_AssignAdd = 178,
  PrimitiveType_OnesLike = 179,
  PrimitiveType_BinaryCrossEntropyGrad = 180,
  PrimitiveType_BinaryCrossEntropy = 181,
  PrimitiveType_LpNormalization = 182,
  PrimitiveType_DropoutGrad = 183,
  PrimitiveType_MaximumGrad = 184,
  PrimitiveType_MinimumGrad = 185,
  PrimitiveType_Switch = 186,
  PrimitiveType_Partial = 187,
  PrimitiveType_TensorListFromTensor = 188,
  PrimitiveType_TensorListStack = 189,
  PrimitiveType_TensorListGetItem = 190,
  PrimitiveType_TensorListSetItem = 191,
  PrimitiveType_TensorListReserve = 192,
  PrimitiveType_All = 193,
  PrimitiveType_Assert = 194,
  PrimitiveType_Adder = 195,
  PrimitiveType_SparseSoftmaxCrossEntropy = 196,
  PrimitiveType_SmoothL1Loss = 197,
  PrimitiveType_SmoothL1LossGrad = 198,
  PrimitiveType_SigmoidCrossEntropyWithLogits = 199,
  PrimitiveType_SigmoidCrossEntropyWithLogitsGrad = 200,
  PrimitiveType_Reciprocal = 201,
  PrimitiveType_Merge = 202,
  PrimitiveType_Mod = 203,
  PrimitiveType_GeLU = 204,
  PrimitiveType_MIN = PrimitiveType_NONE,
  PrimitiveType_MAX = PrimitiveType_GeLU
};

inline const PrimitiveType (&EnumValuesPrimitiveType())[205] {
  static const PrimitiveType values[] = {
    PrimitiveType_NONE,
    PrimitiveType_Concat,
    PrimitiveType_SoftMax,
    PrimitiveType_Activation,
    PrimitiveType_Conv2D,
    PrimitiveType_FusedBatchNorm,
    PrimitiveType_BatchNorm,
    PrimitiveType_BiasAdd,
    PrimitiveType_Pooling,
    PrimitiveType_ROIPooling,
    PrimitiveType_DepthwiseConv2D,
    PrimitiveType_DeDepthwiseConv2D,
    PrimitiveType_Resize,
    PrimitiveType_DetectionPostProcess,
    PrimitiveType_FullConnection,
    PrimitiveType_Mean,
    PrimitiveType_DeConv2D,
    PrimitiveType_Scale,
    PrimitiveType_Reshape,
    PrimitiveType_Eltwise,
    PrimitiveType_NetOutput,
    PrimitiveType_Add,
    PrimitiveType_Sub,
    PrimitiveType_MatMul,
    PrimitiveType_StridedSlice,
    PrimitiveType_Power,
    PrimitiveType_Slice,
    PrimitiveType_Stack,
    PrimitiveType_Mul,
    PrimitiveType_RealDiv,
    PrimitiveType_Pad,
    PrimitiveType_Maximum,
    PrimitiveType_Minimum,
    PrimitiveType_PReLU,
    PrimitiveType_LeakyReLU,
    PrimitiveType_ArgMax,
    PrimitiveType_ArgMin,
    PrimitiveType_Exp,
    PrimitiveType_Crop,
    PrimitiveType_Range,
    PrimitiveType_Rsqrt,
    PrimitiveType_ExpandDims,
    PrimitiveType_Tile,
    PrimitiveType_Cast,
    PrimitiveType_Shape,
    PrimitiveType_Nchw2Nhwc,
    PrimitiveType_Nhwc2Nchw,
    PrimitiveType_QuantDTypeCast,
    PrimitiveType_Split,
    PrimitiveType_Permute,
    PrimitiveType_FakeQuantWithMinMaxVars,
    PrimitiveType_Equal,
    PrimitiveType_Less,
    PrimitiveType_Greater,
    PrimitiveType_NotEqual,
    PrimitiveType_LessEqual,
    PrimitiveType_GreaterEqual,
    PrimitiveType_Min,
    PrimitiveType_Floor,
    PrimitiveType_Abs,
    PrimitiveType_Neg,
    PrimitiveType_Cos,
    PrimitiveType_Sin,
    PrimitiveType_Sqrt,
    PrimitiveType_Square,
    PrimitiveType_Constant,
    PrimitiveType_Log,
    PrimitiveType_Tan,
    PrimitiveType_Atan,
    PrimitiveType_Asin,
    PrimitiveType_Clip,
    PrimitiveType_Transpose,
    PrimitiveType_Squeeze,
    PrimitiveType_Unsqueeze,
    PrimitiveType_Upsample,
    PrimitiveType_Dropout,
    PrimitiveType_Broadcast,
    PrimitiveType_BroadcastTo,
    PrimitiveType_Lrn,
    PrimitiveType_ZerosLike,
    PrimitiveType_TopK,
    PrimitiveType_SpaceToDepth,
    PrimitiveType_SpaceToBatch,
    PrimitiveType_SparseToDense,
    PrimitiveType_ReverseSequence,
    PrimitiveType_Rank,
    PrimitiveType_Gather,
    PrimitiveType_GatherNd,
    PrimitiveType_Fill,
    PrimitiveType_Elu,
    PrimitiveType_DepthToSpace,
    PrimitiveType_BatchToSpace,
    PrimitiveType_AddN,
    PrimitiveType_Ceil,
    PrimitiveType_EmbeddingLookup,
    PrimitiveType_EmbeddingLookupSparse,
    PrimitiveType_FloorDiv,
    PrimitiveType_FloorMod,
    PrimitiveType_L2Norm,
    PrimitiveType_LocalResponseNormalization,
    PrimitiveType_MatrixDiag,
    PrimitiveType_Reduce,
    PrimitiveType_Reverse,
    PrimitiveType_Round,
    PrimitiveType_Select,
    PrimitiveType_Scatter,
    PrimitiveType_ScatterND,
    PrimitiveType_ConstantOfShape,
    PrimitiveType_Unique,
    PrimitiveType_Unstack,
    PrimitiveType_LogicalAnd,
    PrimitiveType_LogicalOr,
    PrimitiveType_LogicalXor,
    PrimitiveType_LogicalNot,
    PrimitiveType_OnnxInt8Quantize,
    PrimitiveType_OnnxInt8Dequantize,
    PrimitiveType_FakeQuantWithMinMax,
    PrimitiveType_FakeQuantWithMinMaxPerChannel,
    PrimitiveType_BatchNormFold,
    PrimitiveType_MulFold,
    PrimitiveType_AddFold,
    PrimitiveType_SquaredDifference,
    PrimitiveType_Flatten,
    PrimitiveType_FlattenGrad,
    PrimitiveType_TupleGetItem,
    PrimitiveType_Div,
    PrimitiveType_Where,
    PrimitiveType_OneHot,
    PrimitiveType_Lstm,
    PrimitiveType_Conv2DGradFilter,
    PrimitiveType_Conv2DGradInput,
    PrimitiveType_PoolingGrad,
    PrimitiveType_BNGrad,
    PrimitiveType_Assign,
    PrimitiveType_ApplyMomentum,
    PrimitiveType_BiasGrad,
    PrimitiveType_SoftmaxCrossEntropy,
    PrimitiveType_AddGrad,
    PrimitiveType_SubGrad,
    PrimitiveType_MulGrad,
    PrimitiveType_DivGrad,
    PrimitiveType_PowerGrad,
    PrimitiveType_ActivationGrad,
    PrimitiveType_PriorBox,
    PrimitiveType_SpaceToBatchND,
    PrimitiveType_Depend,
    PrimitiveType_Return,
    PrimitiveType_MakeTuple,
    PrimitiveType_ToFormat,
    PrimitiveType_Proposal,
    PrimitiveType_Custom,
    PrimitiveType_BlackBox,
    PrimitiveType_NegGrad,
    PrimitiveType_LogGrad,
    PrimitiveType_BatchToSpaceND,
    PrimitiveType_LshProjection,
    PrimitiveType_HashtableLookup,
    PrimitiveType_SkipGram,
    PrimitiveType_DeConv2DGradFilter,
    PrimitiveType_CustomPredict,
    PrimitiveType_CustomNormalize,
    PrimitiveType_CustomExtractFeatures,
    PrimitiveType_AudioSpectrogram,
    PrimitiveType_Mfcc,
    PrimitiveType_Rfft,
    PrimitiveType_FftReal,
    PrimitiveType_FftImag,
    PrimitiveType_Sgd,
    PrimitiveType_Adam,
    PrimitiveType_GroupConv2DGradInput,
    PrimitiveType_Loop,
    PrimitiveType_NonMaxSuppression,
    PrimitiveType_InstanceNorm,
    PrimitiveType_Identity,
    PrimitiveType_LayerNorm,
    PrimitiveType_While,
    PrimitiveType_ControlDepend,
    PrimitiveType_UnsortedSegmentSum,
    PrimitiveType_AssignAdd,
    PrimitiveType_OnesLike,
    PrimitiveType_BinaryCrossEntropyGrad,
    PrimitiveType_BinaryCrossEntropy,
    PrimitiveType_LpNormalization,
    PrimitiveType_DropoutGrad,
    PrimitiveType_MaximumGrad,
    PrimitiveType_MinimumGrad,
    PrimitiveType_Switch,
    PrimitiveType_Partial,
    PrimitiveType_TensorListFromTensor,
    PrimitiveType_TensorListStack,
    PrimitiveType_TensorListGetItem,
    PrimitiveType_TensorListSetItem,
    PrimitiveType_TensorListReserve,
    PrimitiveType_All,
    PrimitiveType_Assert,
    PrimitiveType_Adder,
    PrimitiveType_SparseSoftmaxCrossEntropy,
    PrimitiveType_SmoothL1Loss,
    PrimitiveType_SmoothL1LossGrad,
    PrimitiveType_SigmoidCrossEntropyWithLogits,
    PrimitiveType_SigmoidCrossEntropyWithLogitsGrad,
    PrimitiveType_Reciprocal,
    PrimitiveType_Merge,
    PrimitiveType_Mod,
    PrimitiveType_GeLU
  };
  return values;
}

inline const char * const *EnumNamesPrimitiveType() {
  static const char * const names[206] = {
    "NONE",
    "Concat",
    "SoftMax",
    "Activation",
    "Conv2D",
    "FusedBatchNorm",
    "BatchNorm",
    "BiasAdd",
    "Pooling",
    "ROIPooling",
    "DepthwiseConv2D",
    "DeDepthwiseConv2D",
    "Resize",
    "DetectionPostProcess",
    "FullConnection",
    "Mean",
    "DeConv2D",
    "Scale",
    "Reshape",
    "Eltwise",
    "NetOutput",
    "Add",
    "Sub",
    "MatMul",
    "StridedSlice",
    "Power",
    "Slice",
    "Stack",
    "Mul",
    "RealDiv",
    "Pad",
    "Maximum",
    "Minimum",
    "PReLU",
    "LeakyReLU",
    "ArgMax",
    "ArgMin",
    "Exp",
    "Crop",
    "Range",
    "Rsqrt",
    "ExpandDims",
    "Tile",
    "Cast",
    "Shape",
    "Nchw2Nhwc",
    "Nhwc2Nchw",
    "QuantDTypeCast",
    "Split",
    "Permute",
    "FakeQuantWithMinMaxVars",
    "Equal",
    "Less",
    "Greater",
    "NotEqual",
    "LessEqual",
    "GreaterEqual",
    "Min",
    "Floor",
    "Abs",
    "Neg",
    "Cos",
    "Sin",
    "Sqrt",
    "Square",
    "Constant",
    "Log",
    "Tan",
    "Atan",
    "Asin",
    "Clip",
    "Transpose",
    "Squeeze",
    "Unsqueeze",
    "Upsample",
    "Dropout",
    "Broadcast",
    "BroadcastTo",
    "Lrn",
    "ZerosLike",
    "TopK",
    "SpaceToDepth",
    "SpaceToBatch",
    "SparseToDense",
    "ReverseSequence",
    "Rank",
    "Gather",
    "GatherNd",
    "Fill",
    "Elu",
    "DepthToSpace",
    "BatchToSpace",
    "AddN",
    "Ceil",
    "EmbeddingLookup",
    "EmbeddingLookupSparse",
    "FloorDiv",
    "FloorMod",
    "L2Norm",
    "LocalResponseNormalization",
    "MatrixDiag",
    "Reduce",
    "Reverse",
    "Round",
    "Select",
    "Scatter",
    "ScatterND",
    "ConstantOfShape",
    "Unique",
    "Unstack",
    "LogicalAnd",
    "LogicalOr",
    "LogicalXor",
    "LogicalNot",
    "OnnxInt8Quantize",
    "OnnxInt8Dequantize",
    "FakeQuantWithMinMax",
    "FakeQuantWithMinMaxPerChannel",
    "BatchNormFold",
    "MulFold",
    "AddFold",
    "SquaredDifference",
    "Flatten",
    "FlattenGrad",
    "TupleGetItem",
    "Div",
    "Where",
    "OneHot",
    "Lstm",
    "Conv2DGradFilter",
    "Conv2DGradInput",
    "PoolingGrad",
    "BNGrad",
    "Assign",
    "ApplyMomentum",
    "BiasGrad",
    "SoftmaxCrossEntropy",
    "AddGrad",
    "SubGrad",
    "MulGrad",
    "DivGrad",
    "PowerGrad",
    "ActivationGrad",
    "PriorBox",
    "SpaceToBatchND",
    "Depend",
    "Return",
    "MakeTuple",
    "ToFormat",
    "Proposal",
    "Custom",
    "BlackBox",
    "NegGrad",
    "LogGrad",
    "BatchToSpaceND",
    "LshProjection",
    "HashtableLookup",
    "SkipGram",
    "DeConv2DGradFilter",
    "CustomPredict",
    "CustomNormalize",
    "CustomExtractFeatures",
    "AudioSpectrogram",
    "Mfcc",
    "Rfft",
    "FftReal",
    "FftImag",
    "Sgd",
    "Adam",
    "GroupConv2DGradInput",
    "Loop",
    "NonMaxSuppression",
    "InstanceNorm",
    "Identity",
    "LayerNorm",
    "While",
    "ControlDepend",
    "UnsortedSegmentSum",
    "AssignAdd",
    "OnesLike",
    "BinaryCrossEntropyGrad",
    "BinaryCrossEntropy",
    "LpNormalization",
    "DropoutGrad",
    "MaximumGrad",
    "MinimumGrad",
    "Switch",
    "Partial",
    "TensorListFromTensor",
    "TensorListStack",
    "TensorListGetItem",
    "TensorListSetItem",
    "TensorListReserve",
    "All",
    "Assert",
    "Adder",
    "SparseSoftmaxCrossEntropy",
    "SmoothL1Loss",
    "SmoothL1LossGrad",
    "SigmoidCrossEntropyWithLogits",
    "SigmoidCrossEntropyWithLogitsGrad",
    "Reciprocal",
    "Merge",
    "Mod",
    "GeLU",
    nullptr
  };
  return names;
}

inline const char *EnumNamePrimitiveType(PrimitiveType e) {
  if (flatbuffers::IsOutRange(e, PrimitiveType_NONE, PrimitiveType_GeLU)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesPrimitiveType()[index];
}

template<typename T> struct PrimitiveTypeTraits {
  static const PrimitiveType enum_value = PrimitiveType_NONE;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::v0::Concat> {
  static const PrimitiveType enum_value = PrimitiveType_Concat;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::v0::SoftMax> {
  static const PrimitiveType enum_value = PrimitiveType_SoftMax;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::v0::Activation> {
  static const PrimitiveType enum_value = PrimitiveType_Activation;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::v0::Conv2D> {
  static const PrimitiveType enum_value = PrimitiveType_Conv2D;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::v0::FusedBatchNorm> {
  static const PrimitiveType enum_value = PrimitiveType_FusedBatchNorm;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::v0::BatchNorm> {
  static const PrimitiveType enum_value = PrimitiveType_BatchNorm;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::v0::BiasAdd> {
  static const PrimitiveType enum_value = PrimitiveType_BiasAdd;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::v0::Pooling> {
  static const PrimitiveType enum_value = PrimitiveType_Pooling;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::v0::ROIPooling> {
  static const PrimitiveType enum_value = PrimitiveType_ROIPooling;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::v0::DepthwiseConv2D> {
  static const PrimitiveType enum_value = PrimitiveType_DepthwiseConv2D;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::v0::DeDepthwiseConv2D> {
  static const PrimitiveType enum_value = PrimitiveType_DeDepthwiseConv2D;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::v0::Resize> {
  static const PrimitiveType enum_value = PrimitiveType_Resize;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::v0::DetectionPostProcess> {
  static const PrimitiveType enum_value = PrimitiveType_DetectionPostProcess;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::v0::FullConnection> {
  static const PrimitiveType enum_value = PrimitiveType_FullConnection;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::v0::Mean> {
  static const PrimitiveType enum_value = PrimitiveType_Mean;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::v0::DeConv2D> {
  static const PrimitiveType enum_value = PrimitiveType_DeConv2D;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::v0::Scale> {
  static const PrimitiveType enum_value = PrimitiveType_Scale;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::v0::Reshape> {
  static const PrimitiveType enum_value = PrimitiveType_Reshape;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::v0::Eltwise> {
  static const PrimitiveType enum_value = PrimitiveType_Eltwise;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::v0::NetOutput> {
  static const PrimitiveType enum_value = PrimitiveType_NetOutput;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::v0::Add> {
  static const PrimitiveType enum_value = PrimitiveType_Add;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::v0::Sub> {
  static const PrimitiveType enum_value = PrimitiveType_Sub;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::v0::MatMul> {
  static const PrimitiveType enum_value = PrimitiveType_MatMul;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::v0::StridedSlice> {
  static const PrimitiveType enum_value = PrimitiveType_StridedSlice;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::v0::Power> {
  static const PrimitiveType enum_value = PrimitiveType_Power;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::v0::Slice> {
  static const PrimitiveType enum_value = PrimitiveType_Slice;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::v0::Stack> {
  static const PrimitiveType enum_value = PrimitiveType_Stack;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::v0::Mul> {
  static const PrimitiveType enum_value = PrimitiveType_Mul;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::v0::RealDiv> {
  static const PrimitiveType enum_value = PrimitiveType_RealDiv;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::v0::Pad> {
  static const PrimitiveType enum_value = PrimitiveType_Pad;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::v0::Maximum> {
  static const PrimitiveType enum_value = PrimitiveType_Maximum;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::v0::Minimum> {
  static const PrimitiveType enum_value = PrimitiveType_Minimum;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::v0::PReLU> {
  static const PrimitiveType enum_value = PrimitiveType_PReLU;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::v0::LeakyReLU> {
  static const PrimitiveType enum_value = PrimitiveType_LeakyReLU;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::v0::ArgMax> {
  static const PrimitiveType enum_value = PrimitiveType_ArgMax;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::v0::ArgMin> {
  static const PrimitiveType enum_value = PrimitiveType_ArgMin;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::v0::Exp> {
  static const PrimitiveType enum_value = PrimitiveType_Exp;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::v0::Crop> {
  static const PrimitiveType enum_value = PrimitiveType_Crop;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::v0::Range> {
  static const PrimitiveType enum_value = PrimitiveType_Range;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::v0::Rsqrt> {
  static const PrimitiveType enum_value = PrimitiveType_Rsqrt;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::v0::ExpandDims> {
  static const PrimitiveType enum_value = PrimitiveType_ExpandDims;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::v0::Tile> {
  static const PrimitiveType enum_value = PrimitiveType_Tile;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::v0::Cast> {
  static const PrimitiveType enum_value = PrimitiveType_Cast;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::v0::Shape> {
  static const PrimitiveType enum_value = PrimitiveType_Shape;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::v0::Nchw2Nhwc> {
  static const PrimitiveType enum_value = PrimitiveType_Nchw2Nhwc;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::v0::Nhwc2Nchw> {
  static const PrimitiveType enum_value = PrimitiveType_Nhwc2Nchw;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::v0::QuantDTypeCast> {
  static const PrimitiveType enum_value = PrimitiveType_QuantDTypeCast;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::v0::Split> {
  static const PrimitiveType enum_value = PrimitiveType_Split;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::v0::Permute> {
  static const PrimitiveType enum_value = PrimitiveType_Permute;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::v0::FakeQuantWithMinMaxVars> {
  static const PrimitiveType enum_value = PrimitiveType_FakeQuantWithMinMaxVars;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::v0::Equal> {
  static const PrimitiveType enum_value = PrimitiveType_Equal;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::v0::Less> {
  static const PrimitiveType enum_value = PrimitiveType_Less;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::v0::Greater> {
  static const PrimitiveType enum_value = PrimitiveType_Greater;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::v0::NotEqual> {
  static const PrimitiveType enum_value = PrimitiveType_NotEqual;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::v0::LessEqual> {
  static const PrimitiveType enum_value = PrimitiveType_LessEqual;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::v0::GreaterEqual> {
  static const PrimitiveType enum_value = PrimitiveType_GreaterEqual;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::v0::Min> {
  static const PrimitiveType enum_value = PrimitiveType_Min;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::v0::Floor> {
  static const PrimitiveType enum_value = PrimitiveType_Floor;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::v0::Abs> {
  static const PrimitiveType enum_value = PrimitiveType_Abs;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::v0::Neg> {
  static const PrimitiveType enum_value = PrimitiveType_Neg;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::v0::Cos> {
  static const PrimitiveType enum_value = PrimitiveType_Cos;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::v0::Sin> {
  static const PrimitiveType enum_value = PrimitiveType_Sin;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::v0::Sqrt> {
  static const PrimitiveType enum_value = PrimitiveType_Sqrt;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::v0::Square> {
  static const PrimitiveType enum_value = PrimitiveType_Square;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::v0::Constant> {
  static const PrimitiveType enum_value = PrimitiveType_Constant;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::v0::Log> {
  static const PrimitiveType enum_value = PrimitiveType_Log;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::v0::Tan> {
  static const PrimitiveType enum_value = PrimitiveType_Tan;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::v0::Atan> {
  static const PrimitiveType enum_value = PrimitiveType_Atan;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::v0::Asin> {
  static const PrimitiveType enum_value = PrimitiveType_Asin;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::v0::Clip> {
  static const PrimitiveType enum_value = PrimitiveType_Clip;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::v0::Transpose> {
  static const PrimitiveType enum_value = PrimitiveType_Transpose;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::v0::Squeeze> {
  static const PrimitiveType enum_value = PrimitiveType_Squeeze;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::v0::Unsqueeze> {
  static const PrimitiveType enum_value = PrimitiveType_Unsqueeze;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::v0::Upsample> {
  static const PrimitiveType enum_value = PrimitiveType_Upsample;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::v0::Dropout> {
  static const PrimitiveType enum_value = PrimitiveType_Dropout;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::v0::Broadcast> {
  static const PrimitiveType enum_value = PrimitiveType_Broadcast;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::v0::BroadcastTo> {
  static const PrimitiveType enum_value = PrimitiveType_BroadcastTo;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::v0::Lrn> {
  static const PrimitiveType enum_value = PrimitiveType_Lrn;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::v0::ZerosLike> {
  static const PrimitiveType enum_value = PrimitiveType_ZerosLike;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::v0::TopK> {
  static const PrimitiveType enum_value = PrimitiveType_TopK;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::v0::SpaceToDepth> {
  static const PrimitiveType enum_value = PrimitiveType_SpaceToDepth;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::v0::SpaceToBatch> {
  static const PrimitiveType enum_value = PrimitiveType_SpaceToBatch;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::v0::SparseToDense> {
  static const PrimitiveType enum_value = PrimitiveType_SparseToDense;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::v0::ReverseSequence> {
  static const PrimitiveType enum_value = PrimitiveType_ReverseSequence;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::v0::Rank> {
  static const PrimitiveType enum_value = PrimitiveType_Rank;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::v0::Gather> {
  static const PrimitiveType enum_value = PrimitiveType_Gather;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::v0::GatherNd> {
  static const PrimitiveType enum_value = PrimitiveType_GatherNd;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::v0::Fill> {
  static const PrimitiveType enum_value = PrimitiveType_Fill;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::v0::Elu> {
  static const PrimitiveType enum_value = PrimitiveType_Elu;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::v0::DepthToSpace> {
  static const PrimitiveType enum_value = PrimitiveType_DepthToSpace;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::v0::BatchToSpace> {
  static const PrimitiveType enum_value = PrimitiveType_BatchToSpace;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::v0::AddN> {
  static const PrimitiveType enum_value = PrimitiveType_AddN;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::v0::Ceil> {
  static const PrimitiveType enum_value = PrimitiveType_Ceil;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::v0::EmbeddingLookup> {
  static const PrimitiveType enum_value = PrimitiveType_EmbeddingLookup;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::v0::EmbeddingLookupSparse> {
  static const PrimitiveType enum_value = PrimitiveType_EmbeddingLookupSparse;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::v0::FloorDiv> {
  static const PrimitiveType enum_value = PrimitiveType_FloorDiv;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::v0::FloorMod> {
  static const PrimitiveType enum_value = PrimitiveType_FloorMod;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::v0::L2Norm> {
  static const PrimitiveType enum_value = PrimitiveType_L2Norm;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::v0::LocalResponseNormalization> {
  static const PrimitiveType enum_value = PrimitiveType_LocalResponseNormalization;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::v0::MatrixDiag> {
  static const PrimitiveType enum_value = PrimitiveType_MatrixDiag;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::v0::Reduce> {
  static const PrimitiveType enum_value = PrimitiveType_Reduce;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::v0::Reverse> {
  static const PrimitiveType enum_value = PrimitiveType_Reverse;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::v0::Round> {
  static const PrimitiveType enum_value = PrimitiveType_Round;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::v0::Select> {
  static const PrimitiveType enum_value = PrimitiveType_Select;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::v0::Scatter> {
  static const PrimitiveType enum_value = PrimitiveType_Scatter;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::v0::ScatterND> {
  static const PrimitiveType enum_value = PrimitiveType_ScatterND;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::v0::ConstantOfShape> {
  static const PrimitiveType enum_value = PrimitiveType_ConstantOfShape;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::v0::Unique> {
  static const PrimitiveType enum_value = PrimitiveType_Unique;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::v0::Unstack> {
  static const PrimitiveType enum_value = PrimitiveType_Unstack;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::v0::LogicalAnd> {
  static const PrimitiveType enum_value = PrimitiveType_LogicalAnd;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::v0::LogicalOr> {
  static const PrimitiveType enum_value = PrimitiveType_LogicalOr;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::v0::LogicalXor> {
  static const PrimitiveType enum_value = PrimitiveType_LogicalXor;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::v0::LogicalNot> {
  static const PrimitiveType enum_value = PrimitiveType_LogicalNot;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::v0::OnnxInt8Quantize> {
  static const PrimitiveType enum_value = PrimitiveType_OnnxInt8Quantize;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::v0::OnnxInt8Dequantize> {
  static const PrimitiveType enum_value = PrimitiveType_OnnxInt8Dequantize;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::v0::FakeQuantWithMinMax> {
  static const PrimitiveType enum_value = PrimitiveType_FakeQuantWithMinMax;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::v0::FakeQuantWithMinMaxPerChannel> {
  static const PrimitiveType enum_value = PrimitiveType_FakeQuantWithMinMaxPerChannel;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::v0::BatchNormFold> {
  static const PrimitiveType enum_value = PrimitiveType_BatchNormFold;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::v0::MulFold> {
  static const PrimitiveType enum_value = PrimitiveType_MulFold;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::v0::AddFold> {
  static const PrimitiveType enum_value = PrimitiveType_AddFold;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::v0::SquaredDifference> {
  static const PrimitiveType enum_value = PrimitiveType_SquaredDifference;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::v0::Flatten> {
  static const PrimitiveType enum_value = PrimitiveType_Flatten;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::v0::FlattenGrad> {
  static const PrimitiveType enum_value = PrimitiveType_FlattenGrad;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::v0::TupleGetItem> {
  static const PrimitiveType enum_value = PrimitiveType_TupleGetItem;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::v0::Div> {
  static const PrimitiveType enum_value = PrimitiveType_Div;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::v0::Where> {
  static const PrimitiveType enum_value = PrimitiveType_Where;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::v0::OneHot> {
  static const PrimitiveType enum_value = PrimitiveType_OneHot;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::v0::Lstm> {
  static const PrimitiveType enum_value = PrimitiveType_Lstm;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::v0::Conv2DGradFilter> {
  static const PrimitiveType enum_value = PrimitiveType_Conv2DGradFilter;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::v0::Conv2DGradInput> {
  static const PrimitiveType enum_value = PrimitiveType_Conv2DGradInput;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::v0::PoolingGrad> {
  static const PrimitiveType enum_value = PrimitiveType_PoolingGrad;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::v0::BNGrad> {
  static const PrimitiveType enum_value = PrimitiveType_BNGrad;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::v0::Assign> {
  static const PrimitiveType enum_value = PrimitiveType_Assign;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::v0::ApplyMomentum> {
  static const PrimitiveType enum_value = PrimitiveType_ApplyMomentum;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::v0::BiasGrad> {
  static const PrimitiveType enum_value = PrimitiveType_BiasGrad;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::v0::SoftmaxCrossEntropy> {
  static const PrimitiveType enum_value = PrimitiveType_SoftmaxCrossEntropy;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::v0::AddGrad> {
  static const PrimitiveType enum_value = PrimitiveType_AddGrad;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::v0::SubGrad> {
  static const PrimitiveType enum_value = PrimitiveType_SubGrad;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::v0::MulGrad> {
  static const PrimitiveType enum_value = PrimitiveType_MulGrad;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::v0::DivGrad> {
  static const PrimitiveType enum_value = PrimitiveType_DivGrad;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::v0::PowerGrad> {
  static const PrimitiveType enum_value = PrimitiveType_PowerGrad;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::v0::ActivationGrad> {
  static const PrimitiveType enum_value = PrimitiveType_ActivationGrad;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::v0::PriorBox> {
  static const PrimitiveType enum_value = PrimitiveType_PriorBox;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::v0::SpaceToBatchND> {
  static const PrimitiveType enum_value = PrimitiveType_SpaceToBatchND;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::v0::Depend> {
  static const PrimitiveType enum_value = PrimitiveType_Depend;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::v0::Return> {
  static const PrimitiveType enum_value = PrimitiveType_Return;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::v0::MakeTuple> {
  static const PrimitiveType enum_value = PrimitiveType_MakeTuple;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::v0::ToFormat> {
  static const PrimitiveType enum_value = PrimitiveType_ToFormat;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::v0::Proposal> {
  static const PrimitiveType enum_value = PrimitiveType_Proposal;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::v0::Custom> {
  static const PrimitiveType enum_value = PrimitiveType_Custom;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::v0::BlackBox> {
  static const PrimitiveType enum_value = PrimitiveType_BlackBox;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::v0::NegGrad> {
  static const PrimitiveType enum_value = PrimitiveType_NegGrad;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::v0::LogGrad> {
  static const PrimitiveType enum_value = PrimitiveType_LogGrad;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::v0::BatchToSpaceND> {
  static const PrimitiveType enum_value = PrimitiveType_BatchToSpaceND;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::v0::LshProjection> {
  static const PrimitiveType enum_value = PrimitiveType_LshProjection;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::v0::HashtableLookup> {
  static const PrimitiveType enum_value = PrimitiveType_HashtableLookup;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::v0::SkipGram> {
  static const PrimitiveType enum_value = PrimitiveType_SkipGram;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::v0::DeConv2DGradFilter> {
  static const PrimitiveType enum_value = PrimitiveType_DeConv2DGradFilter;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::v0::CustomPredict> {
  static const PrimitiveType enum_value = PrimitiveType_CustomPredict;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::v0::CustomNormalize> {
  static const PrimitiveType enum_value = PrimitiveType_CustomNormalize;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::v0::CustomExtractFeatures> {
  static const PrimitiveType enum_value = PrimitiveType_CustomExtractFeatures;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::v0::AudioSpectrogram> {
  static const PrimitiveType enum_value = PrimitiveType_AudioSpectrogram;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::v0::Mfcc> {
  static const PrimitiveType enum_value = PrimitiveType_Mfcc;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::v0::Rfft> {
  static const PrimitiveType enum_value = PrimitiveType_Rfft;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::v0::FftReal> {
  static const PrimitiveType enum_value = PrimitiveType_FftReal;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::v0::FftImag> {
  static const PrimitiveType enum_value = PrimitiveType_FftImag;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::v0::Sgd> {
  static const PrimitiveType enum_value = PrimitiveType_Sgd;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::v0::Adam> {
  static const PrimitiveType enum_value = PrimitiveType_Adam;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::v0::GroupConv2DGradInput> {
  static const PrimitiveType enum_value = PrimitiveType_GroupConv2DGradInput;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::v0::Loop> {
  static const PrimitiveType enum_value = PrimitiveType_Loop;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::v0::NonMaxSuppression> {
  static const PrimitiveType enum_value = PrimitiveType_NonMaxSuppression;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::v0::InstanceNorm> {
  static const PrimitiveType enum_value = PrimitiveType_InstanceNorm;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::v0::Identity> {
  static const PrimitiveType enum_value = PrimitiveType_Identity;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::v0::LayerNorm> {
  static const PrimitiveType enum_value = PrimitiveType_LayerNorm;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::v0::While> {
  static const PrimitiveType enum_value = PrimitiveType_While;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::v0::ControlDepend> {
  static const PrimitiveType enum_value = PrimitiveType_ControlDepend;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::v0::UnsortedSegmentSum> {
  static const PrimitiveType enum_value = PrimitiveType_UnsortedSegmentSum;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::v0::AssignAdd> {
  static const PrimitiveType enum_value = PrimitiveType_AssignAdd;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::v0::OnesLike> {
  static const PrimitiveType enum_value = PrimitiveType_OnesLike;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::v0::BinaryCrossEntropyGrad> {
  static const PrimitiveType enum_value = PrimitiveType_BinaryCrossEntropyGrad;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::v0::BinaryCrossEntropy> {
  static const PrimitiveType enum_value = PrimitiveType_BinaryCrossEntropy;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::v0::LpNormalization> {
  static const PrimitiveType enum_value = PrimitiveType_LpNormalization;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::v0::DropoutGrad> {
  static const PrimitiveType enum_value = PrimitiveType_DropoutGrad;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::v0::MaximumGrad> {
  static const PrimitiveType enum_value = PrimitiveType_MaximumGrad;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::v0::MinimumGrad> {
  static const PrimitiveType enum_value = PrimitiveType_MinimumGrad;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::v0::Switch> {
  static const PrimitiveType enum_value = PrimitiveType_Switch;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::v0::Partial> {
  static const PrimitiveType enum_value = PrimitiveType_Partial;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::v0::TensorListFromTensor> {
  static const PrimitiveType enum_value = PrimitiveType_TensorListFromTensor;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::v0::TensorListStack> {
  static const PrimitiveType enum_value = PrimitiveType_TensorListStack;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::v0::TensorListGetItem> {
  static const PrimitiveType enum_value = PrimitiveType_TensorListGetItem;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::v0::TensorListSetItem> {
  static const PrimitiveType enum_value = PrimitiveType_TensorListSetItem;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::v0::TensorListReserve> {
  static const PrimitiveType enum_value = PrimitiveType_TensorListReserve;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::v0::All> {
  static const PrimitiveType enum_value = PrimitiveType_All;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::v0::Assert> {
  static const PrimitiveType enum_value = PrimitiveType_Assert;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::v0::Adder> {
  static const PrimitiveType enum_value = PrimitiveType_Adder;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::v0::SparseSoftmaxCrossEntropy> {
  static const PrimitiveType enum_value = PrimitiveType_SparseSoftmaxCrossEntropy;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::v0::SmoothL1Loss> {
  static const PrimitiveType enum_value = PrimitiveType_SmoothL1Loss;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::v0::SmoothL1LossGrad> {
  static const PrimitiveType enum_value = PrimitiveType_SmoothL1LossGrad;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::v0::SigmoidCrossEntropyWithLogits> {
  static const PrimitiveType enum_value = PrimitiveType_SigmoidCrossEntropyWithLogits;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::v0::SigmoidCrossEntropyWithLogitsGrad> {
  static const PrimitiveType enum_value = PrimitiveType_SigmoidCrossEntropyWithLogitsGrad;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::v0::Reciprocal> {
  static const PrimitiveType enum_value = PrimitiveType_Reciprocal;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::v0::Merge> {
  static const PrimitiveType enum_value = PrimitiveType_Merge;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::v0::Mod> {
  static const PrimitiveType enum_value = PrimitiveType_Mod;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::v0::GeLU> {
  static const PrimitiveType enum_value = PrimitiveType_GeLU;
};

struct PrimitiveTypeUnion {
  PrimitiveType type;
  void *value;

  PrimitiveTypeUnion() : type(PrimitiveType_NONE), value(nullptr) {}
  PrimitiveTypeUnion(PrimitiveTypeUnion&& u) FLATBUFFERS_NOEXCEPT :
    type(PrimitiveType_NONE), value(nullptr)
    { std::swap(type, u.type); std::swap(value, u.value); }
  PrimitiveTypeUnion(const PrimitiveTypeUnion &);
  PrimitiveTypeUnion &operator=(const PrimitiveTypeUnion &u)
    { PrimitiveTypeUnion t(u); std::swap(type, t.type); std::swap(value, t.value); return *this; }
  PrimitiveTypeUnion &operator=(PrimitiveTypeUnion &&u) FLATBUFFERS_NOEXCEPT
    { std::swap(type, u.type); std::swap(value, u.value); return *this; }
  ~PrimitiveTypeUnion() { Reset(); }

  void Reset();

#ifndef FLATBUFFERS_CPP98_STL
  template <typename T>
  void Set(T&& val) {
    using RT = typename std::remove_reference<T>::type;
    Reset();
    type = PrimitiveTypeTraits<typename RT::TableType>::enum_value;
    if (type != PrimitiveType_NONE) {
      value = new RT(std::forward<T>(val));
    }
  }
#endif  // FLATBUFFERS_CPP98_STL

  static void *UnPack(const void *obj, PrimitiveType type, const flatbuffers::resolver_function_t *resolver);
  flatbuffers::Offset<void> Pack(flatbuffers::FlatBufferBuilder &_fbb, const flatbuffers::rehasher_function_t *_rehasher = nullptr) const;

  mindspore::schema::v0::ConcatT *AsConcat() {
    return type == PrimitiveType_Concat ?
      reinterpret_cast<mindspore::schema::v0::ConcatT *>(value) : nullptr;
  }
  const mindspore::schema::v0::ConcatT *AsConcat() const {
    return type == PrimitiveType_Concat ?
      reinterpret_cast<const mindspore::schema::v0::ConcatT *>(value) : nullptr;
  }
  mindspore::schema::v0::SoftMaxT *AsSoftMax() {
    return type == PrimitiveType_SoftMax ?
      reinterpret_cast<mindspore::schema::v0::SoftMaxT *>(value) : nullptr;
  }
  const mindspore::schema::v0::SoftMaxT *AsSoftMax() const {
    return type == PrimitiveType_SoftMax ?
      reinterpret_cast<const mindspore::schema::v0::SoftMaxT *>(value) : nullptr;
  }
  mindspore::schema::v0::ActivationT *AsActivation() {
    return type == PrimitiveType_Activation ?
      reinterpret_cast<mindspore::schema::v0::ActivationT *>(value) : nullptr;
  }
  const mindspore::schema::v0::ActivationT *AsActivation() const {
    return type == PrimitiveType_Activation ?
      reinterpret_cast<const mindspore::schema::v0::ActivationT *>(value) : nullptr;
  }
  mindspore::schema::v0::Conv2DT *AsConv2D() {
    return type == PrimitiveType_Conv2D ?
      reinterpret_cast<mindspore::schema::v0::Conv2DT *>(value) : nullptr;
  }
  const mindspore::schema::v0::Conv2DT *AsConv2D() const {
    return type == PrimitiveType_Conv2D ?
      reinterpret_cast<const mindspore::schema::v0::Conv2DT *>(value) : nullptr;
  }
  mindspore::schema::v0::FusedBatchNormT *AsFusedBatchNorm() {
    return type == PrimitiveType_FusedBatchNorm ?
      reinterpret_cast<mindspore::schema::v0::FusedBatchNormT *>(value) : nullptr;
  }
  const mindspore::schema::v0::FusedBatchNormT *AsFusedBatchNorm() const {
    return type == PrimitiveType_FusedBatchNorm ?
      reinterpret_cast<const mindspore::schema::v0::FusedBatchNormT *>(value) : nullptr;
  }
  mindspore::schema::v0::BatchNormT *AsBatchNorm() {
    return type == PrimitiveType_BatchNorm ?
      reinterpret_cast<mindspore::schema::v0::BatchNormT *>(value) : nullptr;
  }
  const mindspore::schema::v0::BatchNormT *AsBatchNorm() const {
    return type == PrimitiveType_BatchNorm ?
      reinterpret_cast<const mindspore::schema::v0::BatchNormT *>(value) : nullptr;
  }
  mindspore::schema::v0::BiasAddT *AsBiasAdd() {
    return type == PrimitiveType_BiasAdd ?
      reinterpret_cast<mindspore::schema::v0::BiasAddT *>(value) : nullptr;
  }
  const mindspore::schema::v0::BiasAddT *AsBiasAdd() const {
    return type == PrimitiveType_BiasAdd ?
      reinterpret_cast<const mindspore::schema::v0::BiasAddT *>(value) : nullptr;
  }
  mindspore::schema::v0::PoolingT *AsPooling() {
    return type == PrimitiveType_Pooling ?
      reinterpret_cast<mindspore::schema::v0::PoolingT *>(value) : nullptr;
  }
  const mindspore::schema::v0::PoolingT *AsPooling() const {
    return type == PrimitiveType_Pooling ?
      reinterpret_cast<const mindspore::schema::v0::PoolingT *>(value) : nullptr;
  }
  mindspore::schema::v0::ROIPoolingT *AsROIPooling() {
    return type == PrimitiveType_ROIPooling ?
      reinterpret_cast<mindspore::schema::v0::ROIPoolingT *>(value) : nullptr;
  }
  const mindspore::schema::v0::ROIPoolingT *AsROIPooling() const {
    return type == PrimitiveType_ROIPooling ?
      reinterpret_cast<const mindspore::schema::v0::ROIPoolingT *>(value) : nullptr;
  }
  mindspore::schema::v0::DepthwiseConv2DT *AsDepthwiseConv2D() {
    return type == PrimitiveType_DepthwiseConv2D ?
      reinterpret_cast<mindspore::schema::v0::DepthwiseConv2DT *>(value) : nullptr;
  }
  const mindspore::schema::v0::DepthwiseConv2DT *AsDepthwiseConv2D() const {
    return type == PrimitiveType_DepthwiseConv2D ?
      reinterpret_cast<const mindspore::schema::v0::DepthwiseConv2DT *>(value) : nullptr;
  }
  mindspore::schema::v0::DeDepthwiseConv2DT *AsDeDepthwiseConv2D() {
    return type == PrimitiveType_DeDepthwiseConv2D ?
      reinterpret_cast<mindspore::schema::v0::DeDepthwiseConv2DT *>(value) : nullptr;
  }
  const mindspore::schema::v0::DeDepthwiseConv2DT *AsDeDepthwiseConv2D() const {
    return type == PrimitiveType_DeDepthwiseConv2D ?
      reinterpret_cast<const mindspore::schema::v0::DeDepthwiseConv2DT *>(value) : nullptr;
  }
  mindspore::schema::v0::ResizeT *AsResize() {
    return type == PrimitiveType_Resize ?
      reinterpret_cast<mindspore::schema::v0::ResizeT *>(value) : nullptr;
  }
  const mindspore::schema::v0::ResizeT *AsResize() const {
    return type == PrimitiveType_Resize ?
      reinterpret_cast<const mindspore::schema::v0::ResizeT *>(value) : nullptr;
  }
  mindspore::schema::v0::DetectionPostProcessT *AsDetectionPostProcess() {
    return type == PrimitiveType_DetectionPostProcess ?
      reinterpret_cast<mindspore::schema::v0::DetectionPostProcessT *>(value) : nullptr;
  }
  const mindspore::schema::v0::DetectionPostProcessT *AsDetectionPostProcess() const {
    return type == PrimitiveType_DetectionPostProcess ?
      reinterpret_cast<const mindspore::schema::v0::DetectionPostProcessT *>(value) : nullptr;
  }
  mindspore::schema::v0::FullConnectionT *AsFullConnection() {
    return type == PrimitiveType_FullConnection ?
      reinterpret_cast<mindspore::schema::v0::FullConnectionT *>(value) : nullptr;
  }
  const mindspore::schema::v0::FullConnectionT *AsFullConnection() const {
    return type == PrimitiveType_FullConnection ?
      reinterpret_cast<const mindspore::schema::v0::FullConnectionT *>(value) : nullptr;
  }
  mindspore::schema::v0::MeanT *AsMean() {
    return type == PrimitiveType_Mean ?
      reinterpret_cast<mindspore::schema::v0::MeanT *>(value) : nullptr;
  }
  const mindspore::schema::v0::MeanT *AsMean() const {
    return type == PrimitiveType_Mean ?
      reinterpret_cast<const mindspore::schema::v0::MeanT *>(value) : nullptr;
  }
  mindspore::schema::v0::DeConv2DT *AsDeConv2D() {
    return type == PrimitiveType_DeConv2D ?
      reinterpret_cast<mindspore::schema::v0::DeConv2DT *>(value) : nullptr;
  }
  const mindspore::schema::v0::DeConv2DT *AsDeConv2D() const {
    return type == PrimitiveType_DeConv2D ?
      reinterpret_cast<const mindspore::schema::v0::DeConv2DT *>(value) : nullptr;
  }
  mindspore::schema::v0::ScaleT *AsScale() {
    return type == PrimitiveType_Scale ?
      reinterpret_cast<mindspore::schema::v0::ScaleT *>(value) : nullptr;
  }
  const mindspore::schema::v0::ScaleT *AsScale() const {
    return type == PrimitiveType_Scale ?
      reinterpret_cast<const mindspore::schema::v0::ScaleT *>(value) : nullptr;
  }
  mindspore::schema::v0::ReshapeT *AsReshape() {
    return type == PrimitiveType_Reshape ?
      reinterpret_cast<mindspore::schema::v0::ReshapeT *>(value) : nullptr;
  }
  const mindspore::schema::v0::ReshapeT *AsReshape() const {
    return type == PrimitiveType_Reshape ?
      reinterpret_cast<const mindspore::schema::v0::ReshapeT *>(value) : nullptr;
  }
  mindspore::schema::v0::EltwiseT *AsEltwise() {
    return type == PrimitiveType_Eltwise ?
      reinterpret_cast<mindspore::schema::v0::EltwiseT *>(value) : nullptr;
  }
  const mindspore::schema::v0::EltwiseT *AsEltwise() const {
    return type == PrimitiveType_Eltwise ?
      reinterpret_cast<const mindspore::schema::v0::EltwiseT *>(value) : nullptr;
  }
  mindspore::schema::v0::NetOutputT *AsNetOutput() {
    return type == PrimitiveType_NetOutput ?
      reinterpret_cast<mindspore::schema::v0::NetOutputT *>(value) : nullptr;
  }
  const mindspore::schema::v0::NetOutputT *AsNetOutput() const {
    return type == PrimitiveType_NetOutput ?
      reinterpret_cast<const mindspore::schema::v0::NetOutputT *>(value) : nullptr;
  }
  mindspore::schema::v0::AddT *AsAdd() {
    return type == PrimitiveType_Add ?
      reinterpret_cast<mindspore::schema::v0::AddT *>(value) : nullptr;
  }
  const mindspore::schema::v0::AddT *AsAdd() const {
    return type == PrimitiveType_Add ?
      reinterpret_cast<const mindspore::schema::v0::AddT *>(value) : nullptr;
  }
  mindspore::schema::v0::SubT *AsSub() {
    return type == PrimitiveType_Sub ?
      reinterpret_cast<mindspore::schema::v0::SubT *>(value) : nullptr;
  }
  const mindspore::schema::v0::SubT *AsSub() const {
    return type == PrimitiveType_Sub ?
      reinterpret_cast<const mindspore::schema::v0::SubT *>(value) : nullptr;
  }
  mindspore::schema::v0::MatMulT *AsMatMul() {
    return type == PrimitiveType_MatMul ?
      reinterpret_cast<mindspore::schema::v0::MatMulT *>(value) : nullptr;
  }
  const mindspore::schema::v0::MatMulT *AsMatMul() const {
    return type == PrimitiveType_MatMul ?
      reinterpret_cast<const mindspore::schema::v0::MatMulT *>(value) : nullptr;
  }
  mindspore::schema::v0::StridedSliceT *AsStridedSlice() {
    return type == PrimitiveType_StridedSlice ?
      reinterpret_cast<mindspore::schema::v0::StridedSliceT *>(value) : nullptr;
  }
  const mindspore::schema::v0::StridedSliceT *AsStridedSlice() const {
    return type == PrimitiveType_StridedSlice ?
      reinterpret_cast<const mindspore::schema::v0::StridedSliceT *>(value) : nullptr;
  }
  mindspore::schema::v0::PowerT *AsPower() {
    return type == PrimitiveType_Power ?
      reinterpret_cast<mindspore::schema::v0::PowerT *>(value) : nullptr;
  }
  const mindspore::schema::v0::PowerT *AsPower() const {
    return type == PrimitiveType_Power ?
      reinterpret_cast<const mindspore::schema::v0::PowerT *>(value) : nullptr;
  }
  mindspore::schema::v0::SliceT *AsSlice() {
    return type == PrimitiveType_Slice ?
      reinterpret_cast<mindspore::schema::v0::SliceT *>(value) : nullptr;
  }
  const mindspore::schema::v0::SliceT *AsSlice() const {
    return type == PrimitiveType_Slice ?
      reinterpret_cast<const mindspore::schema::v0::SliceT *>(value) : nullptr;
  }
  mindspore::schema::v0::StackT *AsStack() {
    return type == PrimitiveType_Stack ?
      reinterpret_cast<mindspore::schema::v0::StackT *>(value) : nullptr;
  }
  const mindspore::schema::v0::StackT *AsStack() const {
    return type == PrimitiveType_Stack ?
      reinterpret_cast<const mindspore::schema::v0::StackT *>(value) : nullptr;
  }
  mindspore::schema::v0::MulT *AsMul() {
    return type == PrimitiveType_Mul ?
      reinterpret_cast<mindspore::schema::v0::MulT *>(value) : nullptr;
  }
  const mindspore::schema::v0::MulT *AsMul() const {
    return type == PrimitiveType_Mul ?
      reinterpret_cast<const mindspore::schema::v0::MulT *>(value) : nullptr;
  }
  mindspore::schema::v0::RealDivT *AsRealDiv() {
    return type == PrimitiveType_RealDiv ?
      reinterpret_cast<mindspore::schema::v0::RealDivT *>(value) : nullptr;
  }
  const mindspore::schema::v0::RealDivT *AsRealDiv() const {
    return type == PrimitiveType_RealDiv ?
      reinterpret_cast<const mindspore::schema::v0::RealDivT *>(value) : nullptr;
  }
  mindspore::schema::v0::PadT *AsPad() {
    return type == PrimitiveType_Pad ?
      reinterpret_cast<mindspore::schema::v0::PadT *>(value) : nullptr;
  }
  const mindspore::schema::v0::PadT *AsPad() const {
    return type == PrimitiveType_Pad ?
      reinterpret_cast<const mindspore::schema::v0::PadT *>(value) : nullptr;
  }
  mindspore::schema::v0::MaximumT *AsMaximum() {
    return type == PrimitiveType_Maximum ?
      reinterpret_cast<mindspore::schema::v0::MaximumT *>(value) : nullptr;
  }
  const mindspore::schema::v0::MaximumT *AsMaximum() const {
    return type == PrimitiveType_Maximum ?
      reinterpret_cast<const mindspore::schema::v0::MaximumT *>(value) : nullptr;
  }
  mindspore::schema::v0::MinimumT *AsMinimum() {
    return type == PrimitiveType_Minimum ?
      reinterpret_cast<mindspore::schema::v0::MinimumT *>(value) : nullptr;
  }
  const mindspore::schema::v0::MinimumT *AsMinimum() const {
    return type == PrimitiveType_Minimum ?
      reinterpret_cast<const mindspore::schema::v0::MinimumT *>(value) : nullptr;
  }
  mindspore::schema::v0::PReLUT *AsPReLU() {
    return type == PrimitiveType_PReLU ?
      reinterpret_cast<mindspore::schema::v0::PReLUT *>(value) : nullptr;
  }
  const mindspore::schema::v0::PReLUT *AsPReLU() const {
    return type == PrimitiveType_PReLU ?
      reinterpret_cast<const mindspore::schema::v0::PReLUT *>(value) : nullptr;
  }
  mindspore::schema::v0::LeakyReLUT *AsLeakyReLU() {
    return type == PrimitiveType_LeakyReLU ?
      reinterpret_cast<mindspore::schema::v0::LeakyReLUT *>(value) : nullptr;
  }
  const mindspore::schema::v0::LeakyReLUT *AsLeakyReLU() const {
    return type == PrimitiveType_LeakyReLU ?
      reinterpret_cast<const mindspore::schema::v0::LeakyReLUT *>(value) : nullptr;
  }
  mindspore::schema::v0::ArgMaxT *AsArgMax() {
    return type == PrimitiveType_ArgMax ?
      reinterpret_cast<mindspore::schema::v0::ArgMaxT *>(value) : nullptr;
  }
  const mindspore::schema::v0::ArgMaxT *AsArgMax() const {
    return type == PrimitiveType_ArgMax ?
      reinterpret_cast<const mindspore::schema::v0::ArgMaxT *>(value) : nullptr;
  }
  mindspore::schema::v0::ArgMinT *AsArgMin() {
    return type == PrimitiveType_ArgMin ?
      reinterpret_cast<mindspore::schema::v0::ArgMinT *>(value) : nullptr;
  }
  const mindspore::schema::v0::ArgMinT *AsArgMin() const {
    return type == PrimitiveType_ArgMin ?
      reinterpret_cast<const mindspore::schema::v0::ArgMinT *>(value) : nullptr;
  }
  mindspore::schema::v0::ExpT *AsExp() {
    return type == PrimitiveType_Exp ?
      reinterpret_cast<mindspore::schema::v0::ExpT *>(value) : nullptr;
  }
  const mindspore::schema::v0::ExpT *AsExp() const {
    return type == PrimitiveType_Exp ?
      reinterpret_cast<const mindspore::schema::v0::ExpT *>(value) : nullptr;
  }
  mindspore::schema::v0::CropT *AsCrop() {
    return type == PrimitiveType_Crop ?
      reinterpret_cast<mindspore::schema::v0::CropT *>(value) : nullptr;
  }
  const mindspore::schema::v0::CropT *AsCrop() const {
    return type == PrimitiveType_Crop ?
      reinterpret_cast<const mindspore::schema::v0::CropT *>(value) : nullptr;
  }
  mindspore::schema::v0::RangeT *AsRange() {
    return type == PrimitiveType_Range ?
      reinterpret_cast<mindspore::schema::v0::RangeT *>(value) : nullptr;
  }
  const mindspore::schema::v0::RangeT *AsRange() const {
    return type == PrimitiveType_Range ?
      reinterpret_cast<const mindspore::schema::v0::RangeT *>(value) : nullptr;
  }
  mindspore::schema::v0::RsqrtT *AsRsqrt() {
    return type == PrimitiveType_Rsqrt ?
      reinterpret_cast<mindspore::schema::v0::RsqrtT *>(value) : nullptr;
  }
  const mindspore::schema::v0::RsqrtT *AsRsqrt() const {
    return type == PrimitiveType_Rsqrt ?
      reinterpret_cast<const mindspore::schema::v0::RsqrtT *>(value) : nullptr;
  }
  mindspore::schema::v0::ExpandDimsT *AsExpandDims() {
    return type == PrimitiveType_ExpandDims ?
      reinterpret_cast<mindspore::schema::v0::ExpandDimsT *>(value) : nullptr;
  }
  const mindspore::schema::v0::ExpandDimsT *AsExpandDims() const {
    return type == PrimitiveType_ExpandDims ?
      reinterpret_cast<const mindspore::schema::v0::ExpandDimsT *>(value) : nullptr;
  }
  mindspore::schema::v0::TileT *AsTile() {
    return type == PrimitiveType_Tile ?
      reinterpret_cast<mindspore::schema::v0::TileT *>(value) : nullptr;
  }
  const mindspore::schema::v0::TileT *AsTile() const {
    return type == PrimitiveType_Tile ?
      reinterpret_cast<const mindspore::schema::v0::TileT *>(value) : nullptr;
  }
  mindspore::schema::v0::CastT *AsCast() {
    return type == PrimitiveType_Cast ?
      reinterpret_cast<mindspore::schema::v0::CastT *>(value) : nullptr;
  }
  const mindspore::schema::v0::CastT *AsCast() const {
    return type == PrimitiveType_Cast ?
      reinterpret_cast<const mindspore::schema::v0::CastT *>(value) : nullptr;
  }
  mindspore::schema::v0::ShapeT *AsShape() {
    return type == PrimitiveType_Shape ?
      reinterpret_cast<mindspore::schema::v0::ShapeT *>(value) : nullptr;
  }
  const mindspore::schema::v0::ShapeT *AsShape() const {
    return type == PrimitiveType_Shape ?
      reinterpret_cast<const mindspore::schema::v0::ShapeT *>(value) : nullptr;
  }
  mindspore::schema::v0::Nchw2NhwcT *AsNchw2Nhwc() {
    return type == PrimitiveType_Nchw2Nhwc ?
      reinterpret_cast<mindspore::schema::v0::Nchw2NhwcT *>(value) : nullptr;
  }
  const mindspore::schema::v0::Nchw2NhwcT *AsNchw2Nhwc() const {
    return type == PrimitiveType_Nchw2Nhwc ?
      reinterpret_cast<const mindspore::schema::v0::Nchw2NhwcT *>(value) : nullptr;
  }
  mindspore::schema::v0::Nhwc2NchwT *AsNhwc2Nchw() {
    return type == PrimitiveType_Nhwc2Nchw ?
      reinterpret_cast<mindspore::schema::v0::Nhwc2NchwT *>(value) : nullptr;
  }
  const mindspore::schema::v0::Nhwc2NchwT *AsNhwc2Nchw() const {
    return type == PrimitiveType_Nhwc2Nchw ?
      reinterpret_cast<const mindspore::schema::v0::Nhwc2NchwT *>(value) : nullptr;
  }
  mindspore::schema::v0::QuantDTypeCastT *AsQuantDTypeCast() {
    return type == PrimitiveType_QuantDTypeCast ?
      reinterpret_cast<mindspore::schema::v0::QuantDTypeCastT *>(value) : nullptr;
  }
  const mindspore::schema::v0::QuantDTypeCastT *AsQuantDTypeCast() const {
    return type == PrimitiveType_QuantDTypeCast ?
      reinterpret_cast<const mindspore::schema::v0::QuantDTypeCastT *>(value) : nullptr;
  }
  mindspore::schema::v0::SplitT *AsSplit() {
    return type == PrimitiveType_Split ?
      reinterpret_cast<mindspore::schema::v0::SplitT *>(value) : nullptr;
  }
  const mindspore::schema::v0::SplitT *AsSplit() const {
    return type == PrimitiveType_Split ?
      reinterpret_cast<const mindspore::schema::v0::SplitT *>(value) : nullptr;
  }
  mindspore::schema::v0::PermuteT *AsPermute() {
    return type == PrimitiveType_Permute ?
      reinterpret_cast<mindspore::schema::v0::PermuteT *>(value) : nullptr;
  }
  const mindspore::schema::v0::PermuteT *AsPermute() const {
    return type == PrimitiveType_Permute ?
      reinterpret_cast<const mindspore::schema::v0::PermuteT *>(value) : nullptr;
  }
  mindspore::schema::v0::FakeQuantWithMinMaxVarsT *AsFakeQuantWithMinMaxVars() {
    return type == PrimitiveType_FakeQuantWithMinMaxVars ?
      reinterpret_cast<mindspore::schema::v0::FakeQuantWithMinMaxVarsT *>(value) : nullptr;
  }
  const mindspore::schema::v0::FakeQuantWithMinMaxVarsT *AsFakeQuantWithMinMaxVars() const {
    return type == PrimitiveType_FakeQuantWithMinMaxVars ?
      reinterpret_cast<const mindspore::schema::v0::FakeQuantWithMinMaxVarsT *>(value) : nullptr;
  }
  mindspore::schema::v0::EqualT *AsEqual() {
    return type == PrimitiveType_Equal ?
      reinterpret_cast<mindspore::schema::v0::EqualT *>(value) : nullptr;
  }
  const mindspore::schema::v0::EqualT *AsEqual() const {
    return type == PrimitiveType_Equal ?
      reinterpret_cast<const mindspore::schema::v0::EqualT *>(value) : nullptr;
  }
  mindspore::schema::v0::LessT *AsLess() {
    return type == PrimitiveType_Less ?
      reinterpret_cast<mindspore::schema::v0::LessT *>(value) : nullptr;
  }
  const mindspore::schema::v0::LessT *AsLess() const {
    return type == PrimitiveType_Less ?
      reinterpret_cast<const mindspore::schema::v0::LessT *>(value) : nullptr;
  }
  mindspore::schema::v0::GreaterT *AsGreater() {
    return type == PrimitiveType_Greater ?
      reinterpret_cast<mindspore::schema::v0::GreaterT *>(value) : nullptr;
  }
  const mindspore::schema::v0::GreaterT *AsGreater() const {
    return type == PrimitiveType_Greater ?
      reinterpret_cast<const mindspore::schema::v0::GreaterT *>(value) : nullptr;
  }
  mindspore::schema::v0::NotEqualT *AsNotEqual() {
    return type == PrimitiveType_NotEqual ?
      reinterpret_cast<mindspore::schema::v0::NotEqualT *>(value) : nullptr;
  }
  const mindspore::schema::v0::NotEqualT *AsNotEqual() const {
    return type == PrimitiveType_NotEqual ?
      reinterpret_cast<const mindspore::schema::v0::NotEqualT *>(value) : nullptr;
  }
  mindspore::schema::v0::LessEqualT *AsLessEqual() {
    return type == PrimitiveType_LessEqual ?
      reinterpret_cast<mindspore::schema::v0::LessEqualT *>(value) : nullptr;
  }
  const mindspore::schema::v0::LessEqualT *AsLessEqual() const {
    return type == PrimitiveType_LessEqual ?
      reinterpret_cast<const mindspore::schema::v0::LessEqualT *>(value) : nullptr;
  }
  mindspore::schema::v0::GreaterEqualT *AsGreaterEqual() {
    return type == PrimitiveType_GreaterEqual ?
      reinterpret_cast<mindspore::schema::v0::GreaterEqualT *>(value) : nullptr;
  }
  const mindspore::schema::v0::GreaterEqualT *AsGreaterEqual() const {
    return type == PrimitiveType_GreaterEqual ?
      reinterpret_cast<const mindspore::schema::v0::GreaterEqualT *>(value) : nullptr;
  }
  mindspore::schema::v0::MinT *AsMin() {
    return type == PrimitiveType_Min ?
      reinterpret_cast<mindspore::schema::v0::MinT *>(value) : nullptr;
  }
  const mindspore::schema::v0::MinT *AsMin() const {
    return type == PrimitiveType_Min ?
      reinterpret_cast<const mindspore::schema::v0::MinT *>(value) : nullptr;
  }
  mindspore::schema::v0::FloorT *AsFloor() {
    return type == PrimitiveType_Floor ?
      reinterpret_cast<mindspore::schema::v0::FloorT *>(value) : nullptr;
  }
  const mindspore::schema::v0::FloorT *AsFloor() const {
    return type == PrimitiveType_Floor ?
      reinterpret_cast<const mindspore::schema::v0::FloorT *>(value) : nullptr;
  }
  mindspore::schema::v0::AbsT *AsAbs() {
    return type == PrimitiveType_Abs ?
      reinterpret_cast<mindspore::schema::v0::AbsT *>(value) : nullptr;
  }
  const mindspore::schema::v0::AbsT *AsAbs() const {
    return type == PrimitiveType_Abs ?
      reinterpret_cast<const mindspore::schema::v0::AbsT *>(value) : nullptr;
  }
  mindspore::schema::v0::NegT *AsNeg() {
    return type == PrimitiveType_Neg ?
      reinterpret_cast<mindspore::schema::v0::NegT *>(value) : nullptr;
  }
  const mindspore::schema::v0::NegT *AsNeg() const {
    return type == PrimitiveType_Neg ?
      reinterpret_cast<const mindspore::schema::v0::NegT *>(value) : nullptr;
  }
  mindspore::schema::v0::CosT *AsCos() {
    return type == PrimitiveType_Cos ?
      reinterpret_cast<mindspore::schema::v0::CosT *>(value) : nullptr;
  }
  const mindspore::schema::v0::CosT *AsCos() const {
    return type == PrimitiveType_Cos ?
      reinterpret_cast<const mindspore::schema::v0::CosT *>(value) : nullptr;
  }
  mindspore::schema::v0::SinT *AsSin() {
    return type == PrimitiveType_Sin ?
      reinterpret_cast<mindspore::schema::v0::SinT *>(value) : nullptr;
  }
  const mindspore::schema::v0::SinT *AsSin() const {
    return type == PrimitiveType_Sin ?
      reinterpret_cast<const mindspore::schema::v0::SinT *>(value) : nullptr;
  }
  mindspore::schema::v0::SqrtT *AsSqrt() {
    return type == PrimitiveType_Sqrt ?
      reinterpret_cast<mindspore::schema::v0::SqrtT *>(value) : nullptr;
  }
  const mindspore::schema::v0::SqrtT *AsSqrt() const {
    return type == PrimitiveType_Sqrt ?
      reinterpret_cast<const mindspore::schema::v0::SqrtT *>(value) : nullptr;
  }
  mindspore::schema::v0::SquareT *AsSquare() {
    return type == PrimitiveType_Square ?
      reinterpret_cast<mindspore::schema::v0::SquareT *>(value) : nullptr;
  }
  const mindspore::schema::v0::SquareT *AsSquare() const {
    return type == PrimitiveType_Square ?
      reinterpret_cast<const mindspore::schema::v0::SquareT *>(value) : nullptr;
  }
  mindspore::schema::v0::ConstantT *AsConstant() {
    return type == PrimitiveType_Constant ?
      reinterpret_cast<mindspore::schema::v0::ConstantT *>(value) : nullptr;
  }
  const mindspore::schema::v0::ConstantT *AsConstant() const {
    return type == PrimitiveType_Constant ?
      reinterpret_cast<const mindspore::schema::v0::ConstantT *>(value) : nullptr;
  }
  mindspore::schema::v0::LogT *AsLog() {
    return type == PrimitiveType_Log ?
      reinterpret_cast<mindspore::schema::v0::LogT *>(value) : nullptr;
  }
  const mindspore::schema::v0::LogT *AsLog() const {
    return type == PrimitiveType_Log ?
      reinterpret_cast<const mindspore::schema::v0::LogT *>(value) : nullptr;
  }
  mindspore::schema::v0::TanT *AsTan() {
    return type == PrimitiveType_Tan ?
      reinterpret_cast<mindspore::schema::v0::TanT *>(value) : nullptr;
  }
  const mindspore::schema::v0::TanT *AsTan() const {
    return type == PrimitiveType_Tan ?
      reinterpret_cast<const mindspore::schema::v0::TanT *>(value) : nullptr;
  }
  mindspore::schema::v0::AtanT *AsAtan() {
    return type == PrimitiveType_Atan ?
      reinterpret_cast<mindspore::schema::v0::AtanT *>(value) : nullptr;
  }
  const mindspore::schema::v0::AtanT *AsAtan() const {
    return type == PrimitiveType_Atan ?
      reinterpret_cast<const mindspore::schema::v0::AtanT *>(value) : nullptr;
  }
  mindspore::schema::v0::AsinT *AsAsin() {
    return type == PrimitiveType_Asin ?
      reinterpret_cast<mindspore::schema::v0::AsinT *>(value) : nullptr;
  }
  const mindspore::schema::v0::AsinT *AsAsin() const {
    return type == PrimitiveType_Asin ?
      reinterpret_cast<const mindspore::schema::v0::AsinT *>(value) : nullptr;
  }
  mindspore::schema::v0::ClipT *AsClip() {
    return type == PrimitiveType_Clip ?
      reinterpret_cast<mindspore::schema::v0::ClipT *>(value) : nullptr;
  }
  const mindspore::schema::v0::ClipT *AsClip() const {
    return type == PrimitiveType_Clip ?
      reinterpret_cast<const mindspore::schema::v0::ClipT *>(value) : nullptr;
  }
  mindspore::schema::v0::TransposeT *AsTranspose() {
    return type == PrimitiveType_Transpose ?
      reinterpret_cast<mindspore::schema::v0::TransposeT *>(value) : nullptr;
  }
  const mindspore::schema::v0::TransposeT *AsTranspose() const {
    return type == PrimitiveType_Transpose ?
      reinterpret_cast<const mindspore::schema::v0::TransposeT *>(value) : nullptr;
  }
  mindspore::schema::v0::SqueezeT *AsSqueeze() {
    return type == PrimitiveType_Squeeze ?
      reinterpret_cast<mindspore::schema::v0::SqueezeT *>(value) : nullptr;
  }
  const mindspore::schema::v0::SqueezeT *AsSqueeze() const {
    return type == PrimitiveType_Squeeze ?
      reinterpret_cast<const mindspore::schema::v0::SqueezeT *>(value) : nullptr;
  }
  mindspore::schema::v0::UnsqueezeT *AsUnsqueeze() {
    return type == PrimitiveType_Unsqueeze ?
      reinterpret_cast<mindspore::schema::v0::UnsqueezeT *>(value) : nullptr;
  }
  const mindspore::schema::v0::UnsqueezeT *AsUnsqueeze() const {
    return type == PrimitiveType_Unsqueeze ?
      reinterpret_cast<const mindspore::schema::v0::UnsqueezeT *>(value) : nullptr;
  }
  mindspore::schema::v0::UpsampleT *AsUpsample() {
    return type == PrimitiveType_Upsample ?
      reinterpret_cast<mindspore::schema::v0::UpsampleT *>(value) : nullptr;
  }
  const mindspore::schema::v0::UpsampleT *AsUpsample() const {
    return type == PrimitiveType_Upsample ?
      reinterpret_cast<const mindspore::schema::v0::UpsampleT *>(value) : nullptr;
  }
  mindspore::schema::v0::DropoutT *AsDropout() {
    return type == PrimitiveType_Dropout ?
      reinterpret_cast<mindspore::schema::v0::DropoutT *>(value) : nullptr;
  }
  const mindspore::schema::v0::DropoutT *AsDropout() const {
    return type == PrimitiveType_Dropout ?
      reinterpret_cast<const mindspore::schema::v0::DropoutT *>(value) : nullptr;
  }
  mindspore::schema::v0::BroadcastT *AsBroadcast() {
    return type == PrimitiveType_Broadcast ?
      reinterpret_cast<mindspore::schema::v0::BroadcastT *>(value) : nullptr;
  }
  const mindspore::schema::v0::BroadcastT *AsBroadcast() const {
    return type == PrimitiveType_Broadcast ?
      reinterpret_cast<const mindspore::schema::v0::BroadcastT *>(value) : nullptr;
  }
  mindspore::schema::v0::BroadcastToT *AsBroadcastTo() {
    return type == PrimitiveType_BroadcastTo ?
      reinterpret_cast<mindspore::schema::v0::BroadcastToT *>(value) : nullptr;
  }
  const mindspore::schema::v0::BroadcastToT *AsBroadcastTo() const {
    return type == PrimitiveType_BroadcastTo ?
      reinterpret_cast<const mindspore::schema::v0::BroadcastToT *>(value) : nullptr;
  }
  mindspore::schema::v0::LrnT *AsLrn() {
    return type == PrimitiveType_Lrn ?
      reinterpret_cast<mindspore::schema::v0::LrnT *>(value) : nullptr;
  }
  const mindspore::schema::v0::LrnT *AsLrn() const {
    return type == PrimitiveType_Lrn ?
      reinterpret_cast<const mindspore::schema::v0::LrnT *>(value) : nullptr;
  }
  mindspore::schema::v0::ZerosLikeT *AsZerosLike() {
    return type == PrimitiveType_ZerosLike ?
      reinterpret_cast<mindspore::schema::v0::ZerosLikeT *>(value) : nullptr;
  }
  const mindspore::schema::v0::ZerosLikeT *AsZerosLike() const {
    return type == PrimitiveType_ZerosLike ?
      reinterpret_cast<const mindspore::schema::v0::ZerosLikeT *>(value) : nullptr;
  }
  mindspore::schema::v0::TopKT *AsTopK() {
    return type == PrimitiveType_TopK ?
      reinterpret_cast<mindspore::schema::v0::TopKT *>(value) : nullptr;
  }
  const mindspore::schema::v0::TopKT *AsTopK() const {
    return type == PrimitiveType_TopK ?
      reinterpret_cast<const mindspore::schema::v0::TopKT *>(value) : nullptr;
  }
  mindspore::schema::v0::SpaceToDepthT *AsSpaceToDepth() {
    return type == PrimitiveType_SpaceToDepth ?
      reinterpret_cast<mindspore::schema::v0::SpaceToDepthT *>(value) : nullptr;
  }
  const mindspore::schema::v0::SpaceToDepthT *AsSpaceToDepth() const {
    return type == PrimitiveType_SpaceToDepth ?
      reinterpret_cast<const mindspore::schema::v0::SpaceToDepthT *>(value) : nullptr;
  }
  mindspore::schema::v0::SpaceToBatchT *AsSpaceToBatch() {
    return type == PrimitiveType_SpaceToBatch ?
      reinterpret_cast<mindspore::schema::v0::SpaceToBatchT *>(value) : nullptr;
  }
  const mindspore::schema::v0::SpaceToBatchT *AsSpaceToBatch() const {
    return type == PrimitiveType_SpaceToBatch ?
      reinterpret_cast<const mindspore::schema::v0::SpaceToBatchT *>(value) : nullptr;
  }
  mindspore::schema::v0::SparseToDenseT *AsSparseToDense() {
    return type == PrimitiveType_SparseToDense ?
      reinterpret_cast<mindspore::schema::v0::SparseToDenseT *>(value) : nullptr;
  }
  const mindspore::schema::v0::SparseToDenseT *AsSparseToDense() const {
    return type == PrimitiveType_SparseToDense ?
      reinterpret_cast<const mindspore::schema::v0::SparseToDenseT *>(value) : nullptr;
  }
  mindspore::schema::v0::ReverseSequenceT *AsReverseSequence() {
    return type == PrimitiveType_ReverseSequence ?
      reinterpret_cast<mindspore::schema::v0::ReverseSequenceT *>(value) : nullptr;
  }
  const mindspore::schema::v0::ReverseSequenceT *AsReverseSequence() const {
    return type == PrimitiveType_ReverseSequence ?
      reinterpret_cast<const mindspore::schema::v0::ReverseSequenceT *>(value) : nullptr;
  }
  mindspore::schema::v0::RankT *AsRank() {
    return type == PrimitiveType_Rank ?
      reinterpret_cast<mindspore::schema::v0::RankT *>(value) : nullptr;
  }
  const mindspore::schema::v0::RankT *AsRank() const {
    return type == PrimitiveType_Rank ?
      reinterpret_cast<const mindspore::schema::v0::RankT *>(value) : nullptr;
  }
  mindspore::schema::v0::GatherT *AsGather() {
    return type == PrimitiveType_Gather ?
      reinterpret_cast<mindspore::schema::v0::GatherT *>(value) : nullptr;
  }
  const mindspore::schema::v0::GatherT *AsGather() const {
    return type == PrimitiveType_Gather ?
      reinterpret_cast<const mindspore::schema::v0::GatherT *>(value) : nullptr;
  }
  mindspore::schema::v0::GatherNdT *AsGatherNd() {
    return type == PrimitiveType_GatherNd ?
      reinterpret_cast<mindspore::schema::v0::GatherNdT *>(value) : nullptr;
  }
  const mindspore::schema::v0::GatherNdT *AsGatherNd() const {
    return type == PrimitiveType_GatherNd ?
      reinterpret_cast<const mindspore::schema::v0::GatherNdT *>(value) : nullptr;
  }
  mindspore::schema::v0::FillT *AsFill() {
    return type == PrimitiveType_Fill ?
      reinterpret_cast<mindspore::schema::v0::FillT *>(value) : nullptr;
  }
  const mindspore::schema::v0::FillT *AsFill() const {
    return type == PrimitiveType_Fill ?
      reinterpret_cast<const mindspore::schema::v0::FillT *>(value) : nullptr;
  }
  mindspore::schema::v0::EluT *AsElu() {
    return type == PrimitiveType_Elu ?
      reinterpret_cast<mindspore::schema::v0::EluT *>(value) : nullptr;
  }
  const mindspore::schema::v0::EluT *AsElu() const {
    return type == PrimitiveType_Elu ?
      reinterpret_cast<const mindspore::schema::v0::EluT *>(value) : nullptr;
  }
  mindspore::schema::v0::DepthToSpaceT *AsDepthToSpace() {
    return type == PrimitiveType_DepthToSpace ?
      reinterpret_cast<mindspore::schema::v0::DepthToSpaceT *>(value) : nullptr;
  }
  const mindspore::schema::v0::DepthToSpaceT *AsDepthToSpace() const {
    return type == PrimitiveType_DepthToSpace ?
      reinterpret_cast<const mindspore::schema::v0::DepthToSpaceT *>(value) : nullptr;
  }
  mindspore::schema::v0::BatchToSpaceT *AsBatchToSpace() {
    return type == PrimitiveType_BatchToSpace ?
      reinterpret_cast<mindspore::schema::v0::BatchToSpaceT *>(value) : nullptr;
  }
  const mindspore::schema::v0::BatchToSpaceT *AsBatchToSpace() const {
    return type == PrimitiveType_BatchToSpace ?
      reinterpret_cast<const mindspore::schema::v0::BatchToSpaceT *>(value) : nullptr;
  }
  mindspore::schema::v0::AddNT *AsAddN() {
    return type == PrimitiveType_AddN ?
      reinterpret_cast<mindspore::schema::v0::AddNT *>(value) : nullptr;
  }
  const mindspore::schema::v0::AddNT *AsAddN() const {
    return type == PrimitiveType_AddN ?
      reinterpret_cast<const mindspore::schema::v0::AddNT *>(value) : nullptr;
  }
  mindspore::schema::v0::CeilT *AsCeil() {
    return type == PrimitiveType_Ceil ?
      reinterpret_cast<mindspore::schema::v0::CeilT *>(value) : nullptr;
  }
  const mindspore::schema::v0::CeilT *AsCeil() const {
    return type == PrimitiveType_Ceil ?
      reinterpret_cast<const mindspore::schema::v0::CeilT *>(value) : nullptr;
  }
  mindspore::schema::v0::EmbeddingLookupT *AsEmbeddingLookup() {
    return type == PrimitiveType_EmbeddingLookup ?
      reinterpret_cast<mindspore::schema::v0::EmbeddingLookupT *>(value) : nullptr;
  }
  const mindspore::schema::v0::EmbeddingLookupT *AsEmbeddingLookup() const {
    return type == PrimitiveType_EmbeddingLookup ?
      reinterpret_cast<const mindspore::schema::v0::EmbeddingLookupT *>(value) : nullptr;
  }
  mindspore::schema::v0::EmbeddingLookupSparseT *AsEmbeddingLookupSparse() {
    return type == PrimitiveType_EmbeddingLookupSparse ?
      reinterpret_cast<mindspore::schema::v0::EmbeddingLookupSparseT *>(value) : nullptr;
  }
  const mindspore::schema::v0::EmbeddingLookupSparseT *AsEmbeddingLookupSparse() const {
    return type == PrimitiveType_EmbeddingLookupSparse ?
      reinterpret_cast<const mindspore::schema::v0::EmbeddingLookupSparseT *>(value) : nullptr;
  }
  mindspore::schema::v0::FloorDivT *AsFloorDiv() {
    return type == PrimitiveType_FloorDiv ?
      reinterpret_cast<mindspore::schema::v0::FloorDivT *>(value) : nullptr;
  }
  const mindspore::schema::v0::FloorDivT *AsFloorDiv() const {
    return type == PrimitiveType_FloorDiv ?
      reinterpret_cast<const mindspore::schema::v0::FloorDivT *>(value) : nullptr;
  }
  mindspore::schema::v0::FloorModT *AsFloorMod() {
    return type == PrimitiveType_FloorMod ?
      reinterpret_cast<mindspore::schema::v0::FloorModT *>(value) : nullptr;
  }
  const mindspore::schema::v0::FloorModT *AsFloorMod() const {
    return type == PrimitiveType_FloorMod ?
      reinterpret_cast<const mindspore::schema::v0::FloorModT *>(value) : nullptr;
  }
  mindspore::schema::v0::L2NormT *AsL2Norm() {
    return type == PrimitiveType_L2Norm ?
      reinterpret_cast<mindspore::schema::v0::L2NormT *>(value) : nullptr;
  }
  const mindspore::schema::v0::L2NormT *AsL2Norm() const {
    return type == PrimitiveType_L2Norm ?
      reinterpret_cast<const mindspore::schema::v0::L2NormT *>(value) : nullptr;
  }
  mindspore::schema::v0::LocalResponseNormalizationT *AsLocalResponseNormalization() {
    return type == PrimitiveType_LocalResponseNormalization ?
      reinterpret_cast<mindspore::schema::v0::LocalResponseNormalizationT *>(value) : nullptr;
  }
  const mindspore::schema::v0::LocalResponseNormalizationT *AsLocalResponseNormalization() const {
    return type == PrimitiveType_LocalResponseNormalization ?
      reinterpret_cast<const mindspore::schema::v0::LocalResponseNormalizationT *>(value) : nullptr;
  }
  mindspore::schema::v0::MatrixDiagT *AsMatrixDiag() {
    return type == PrimitiveType_MatrixDiag ?
      reinterpret_cast<mindspore::schema::v0::MatrixDiagT *>(value) : nullptr;
  }
  const mindspore::schema::v0::MatrixDiagT *AsMatrixDiag() const {
    return type == PrimitiveType_MatrixDiag ?
      reinterpret_cast<const mindspore::schema::v0::MatrixDiagT *>(value) : nullptr;
  }
  mindspore::schema::v0::ReduceT *AsReduce() {
    return type == PrimitiveType_Reduce ?
      reinterpret_cast<mindspore::schema::v0::ReduceT *>(value) : nullptr;
  }
  const mindspore::schema::v0::ReduceT *AsReduce() const {
    return type == PrimitiveType_Reduce ?
      reinterpret_cast<const mindspore::schema::v0::ReduceT *>(value) : nullptr;
  }
  mindspore::schema::v0::ReverseT *AsReverse() {
    return type == PrimitiveType_Reverse ?
      reinterpret_cast<mindspore::schema::v0::ReverseT *>(value) : nullptr;
  }
  const mindspore::schema::v0::ReverseT *AsReverse() const {
    return type == PrimitiveType_Reverse ?
      reinterpret_cast<const mindspore::schema::v0::ReverseT *>(value) : nullptr;
  }
  mindspore::schema::v0::RoundT *AsRound() {
    return type == PrimitiveType_Round ?
      reinterpret_cast<mindspore::schema::v0::RoundT *>(value) : nullptr;
  }
  const mindspore::schema::v0::RoundT *AsRound() const {
    return type == PrimitiveType_Round ?
      reinterpret_cast<const mindspore::schema::v0::RoundT *>(value) : nullptr;
  }
  mindspore::schema::v0::SelectT *AsSelect() {
    return type == PrimitiveType_Select ?
      reinterpret_cast<mindspore::schema::v0::SelectT *>(value) : nullptr;
  }
  const mindspore::schema::v0::SelectT *AsSelect() const {
    return type == PrimitiveType_Select ?
      reinterpret_cast<const mindspore::schema::v0::SelectT *>(value) : nullptr;
  }
  mindspore::schema::v0::ScatterT *AsScatter() {
    return type == PrimitiveType_Scatter ?
      reinterpret_cast<mindspore::schema::v0::ScatterT *>(value) : nullptr;
  }
  const mindspore::schema::v0::ScatterT *AsScatter() const {
    return type == PrimitiveType_Scatter ?
      reinterpret_cast<const mindspore::schema::v0::ScatterT *>(value) : nullptr;
  }
  mindspore::schema::v0::ScatterNDT *AsScatterND() {
    return type == PrimitiveType_ScatterND ?
      reinterpret_cast<mindspore::schema::v0::ScatterNDT *>(value) : nullptr;
  }
  const mindspore::schema::v0::ScatterNDT *AsScatterND() const {
    return type == PrimitiveType_ScatterND ?
      reinterpret_cast<const mindspore::schema::v0::ScatterNDT *>(value) : nullptr;
  }
  mindspore::schema::v0::ConstantOfShapeT *AsConstantOfShape() {
    return type == PrimitiveType_ConstantOfShape ?
      reinterpret_cast<mindspore::schema::v0::ConstantOfShapeT *>(value) : nullptr;
  }
  const mindspore::schema::v0::ConstantOfShapeT *AsConstantOfShape() const {
    return type == PrimitiveType_ConstantOfShape ?
      reinterpret_cast<const mindspore::schema::v0::ConstantOfShapeT *>(value) : nullptr;
  }
  mindspore::schema::v0::UniqueT *AsUnique() {
    return type == PrimitiveType_Unique ?
      reinterpret_cast<mindspore::schema::v0::UniqueT *>(value) : nullptr;
  }
  const mindspore::schema::v0::UniqueT *AsUnique() const {
    return type == PrimitiveType_Unique ?
      reinterpret_cast<const mindspore::schema::v0::UniqueT *>(value) : nullptr;
  }
  mindspore::schema::v0::UnstackT *AsUnstack() {
    return type == PrimitiveType_Unstack ?
      reinterpret_cast<mindspore::schema::v0::UnstackT *>(value) : nullptr;
  }
  const mindspore::schema::v0::UnstackT *AsUnstack() const {
    return type == PrimitiveType_Unstack ?
      reinterpret_cast<const mindspore::schema::v0::UnstackT *>(value) : nullptr;
  }
  mindspore::schema::v0::LogicalAndT *AsLogicalAnd() {
    return type == PrimitiveType_LogicalAnd ?
      reinterpret_cast<mindspore::schema::v0::LogicalAndT *>(value) : nullptr;
  }
  const mindspore::schema::v0::LogicalAndT *AsLogicalAnd() const {
    return type == PrimitiveType_LogicalAnd ?
      reinterpret_cast<const mindspore::schema::v0::LogicalAndT *>(value) : nullptr;
  }
  mindspore::schema::v0::LogicalOrT *AsLogicalOr() {
    return type == PrimitiveType_LogicalOr ?
      reinterpret_cast<mindspore::schema::v0::LogicalOrT *>(value) : nullptr;
  }
  const mindspore::schema::v0::LogicalOrT *AsLogicalOr() const {
    return type == PrimitiveType_LogicalOr ?
      reinterpret_cast<const mindspore::schema::v0::LogicalOrT *>(value) : nullptr;
  }
  mindspore::schema::v0::LogicalXorT *AsLogicalXor() {
    return type == PrimitiveType_LogicalXor ?
      reinterpret_cast<mindspore::schema::v0::LogicalXorT *>(value) : nullptr;
  }
  const mindspore::schema::v0::LogicalXorT *AsLogicalXor() const {
    return type == PrimitiveType_LogicalXor ?
      reinterpret_cast<const mindspore::schema::v0::LogicalXorT *>(value) : nullptr;
  }
  mindspore::schema::v0::LogicalNotT *AsLogicalNot() {
    return type == PrimitiveType_LogicalNot ?
      reinterpret_cast<mindspore::schema::v0::LogicalNotT *>(value) : nullptr;
  }
  const mindspore::schema::v0::LogicalNotT *AsLogicalNot() const {
    return type == PrimitiveType_LogicalNot ?
      reinterpret_cast<const mindspore::schema::v0::LogicalNotT *>(value) : nullptr;
  }
  mindspore::schema::v0::OnnxInt8QuantizeT *AsOnnxInt8Quantize() {
    return type == PrimitiveType_OnnxInt8Quantize ?
      reinterpret_cast<mindspore::schema::v0::OnnxInt8QuantizeT *>(value) : nullptr;
  }
  const mindspore::schema::v0::OnnxInt8QuantizeT *AsOnnxInt8Quantize() const {
    return type == PrimitiveType_OnnxInt8Quantize ?
      reinterpret_cast<const mindspore::schema::v0::OnnxInt8QuantizeT *>(value) : nullptr;
  }
  mindspore::schema::v0::OnnxInt8DequantizeT *AsOnnxInt8Dequantize() {
    return type == PrimitiveType_OnnxInt8Dequantize ?
      reinterpret_cast<mindspore::schema::v0::OnnxInt8DequantizeT *>(value) : nullptr;
  }
  const mindspore::schema::v0::OnnxInt8DequantizeT *AsOnnxInt8Dequantize() const {
    return type == PrimitiveType_OnnxInt8Dequantize ?
      reinterpret_cast<const mindspore::schema::v0::OnnxInt8DequantizeT *>(value) : nullptr;
  }
  mindspore::schema::v0::FakeQuantWithMinMaxT *AsFakeQuantWithMinMax() {
    return type == PrimitiveType_FakeQuantWithMinMax ?
      reinterpret_cast<mindspore::schema::v0::FakeQuantWithMinMaxT *>(value) : nullptr;
  }
  const mindspore::schema::v0::FakeQuantWithMinMaxT *AsFakeQuantWithMinMax() const {
    return type == PrimitiveType_FakeQuantWithMinMax ?
      reinterpret_cast<const mindspore::schema::v0::FakeQuantWithMinMaxT *>(value) : nullptr;
  }
  mindspore::schema::v0::FakeQuantWithMinMaxPerChannelT *AsFakeQuantWithMinMaxPerChannel() {
    return type == PrimitiveType_FakeQuantWithMinMaxPerChannel ?
      reinterpret_cast<mindspore::schema::v0::FakeQuantWithMinMaxPerChannelT *>(value) : nullptr;
  }
  const mindspore::schema::v0::FakeQuantWithMinMaxPerChannelT *AsFakeQuantWithMinMaxPerChannel() const {
    return type == PrimitiveType_FakeQuantWithMinMaxPerChannel ?
      reinterpret_cast<const mindspore::schema::v0::FakeQuantWithMinMaxPerChannelT *>(value) : nullptr;
  }
  mindspore::schema::v0::BatchNormFoldT *AsBatchNormFold() {
    return type == PrimitiveType_BatchNormFold ?
      reinterpret_cast<mindspore::schema::v0::BatchNormFoldT *>(value) : nullptr;
  }
  const mindspore::schema::v0::BatchNormFoldT *AsBatchNormFold() const {
    return type == PrimitiveType_BatchNormFold ?
      reinterpret_cast<const mindspore::schema::v0::BatchNormFoldT *>(value) : nullptr;
  }
  mindspore::schema::v0::MulFoldT *AsMulFold() {
    return type == PrimitiveType_MulFold ?
      reinterpret_cast<mindspore::schema::v0::MulFoldT *>(value) : nullptr;
  }
  const mindspore::schema::v0::MulFoldT *AsMulFold() const {
    return type == PrimitiveType_MulFold ?
      reinterpret_cast<const mindspore::schema::v0::MulFoldT *>(value) : nullptr;
  }
  mindspore::schema::v0::AddFoldT *AsAddFold() {
    return type == PrimitiveType_AddFold ?
      reinterpret_cast<mindspore::schema::v0::AddFoldT *>(value) : nullptr;
  }
  const mindspore::schema::v0::AddFoldT *AsAddFold() const {
    return type == PrimitiveType_AddFold ?
      reinterpret_cast<const mindspore::schema::v0::AddFoldT *>(value) : nullptr;
  }
  mindspore::schema::v0::SquaredDifferenceT *AsSquaredDifference() {
    return type == PrimitiveType_SquaredDifference ?
      reinterpret_cast<mindspore::schema::v0::SquaredDifferenceT *>(value) : nullptr;
  }
  const mindspore::schema::v0::SquaredDifferenceT *AsSquaredDifference() const {
    return type == PrimitiveType_SquaredDifference ?
      reinterpret_cast<const mindspore::schema::v0::SquaredDifferenceT *>(value) : nullptr;
  }
  mindspore::schema::v0::FlattenT *AsFlatten() {
    return type == PrimitiveType_Flatten ?
      reinterpret_cast<mindspore::schema::v0::FlattenT *>(value) : nullptr;
  }
  const mindspore::schema::v0::FlattenT *AsFlatten() const {
    return type == PrimitiveType_Flatten ?
      reinterpret_cast<const mindspore::schema::v0::FlattenT *>(value) : nullptr;
  }
  mindspore::schema::v0::FlattenGradT *AsFlattenGrad() {
    return type == PrimitiveType_FlattenGrad ?
      reinterpret_cast<mindspore::schema::v0::FlattenGradT *>(value) : nullptr;
  }
  const mindspore::schema::v0::FlattenGradT *AsFlattenGrad() const {
    return type == PrimitiveType_FlattenGrad ?
      reinterpret_cast<const mindspore::schema::v0::FlattenGradT *>(value) : nullptr;
  }
  mindspore::schema::v0::TupleGetItemT *AsTupleGetItem() {
    return type == PrimitiveType_TupleGetItem ?
      reinterpret_cast<mindspore::schema::v0::TupleGetItemT *>(value) : nullptr;
  }
  const mindspore::schema::v0::TupleGetItemT *AsTupleGetItem() const {
    return type == PrimitiveType_TupleGetItem ?
      reinterpret_cast<const mindspore::schema::v0::TupleGetItemT *>(value) : nullptr;
  }
  mindspore::schema::v0::DivT *AsDiv() {
    return type == PrimitiveType_Div ?
      reinterpret_cast<mindspore::schema::v0::DivT *>(value) : nullptr;
  }
  const mindspore::schema::v0::DivT *AsDiv() const {
    return type == PrimitiveType_Div ?
      reinterpret_cast<const mindspore::schema::v0::DivT *>(value) : nullptr;
  }
  mindspore::schema::v0::WhereT *AsWhere() {
    return type == PrimitiveType_Where ?
      reinterpret_cast<mindspore::schema::v0::WhereT *>(value) : nullptr;
  }
  const mindspore::schema::v0::WhereT *AsWhere() const {
    return type == PrimitiveType_Where ?
      reinterpret_cast<const mindspore::schema::v0::WhereT *>(value) : nullptr;
  }
  mindspore::schema::v0::OneHotT *AsOneHot() {
    return type == PrimitiveType_OneHot ?
      reinterpret_cast<mindspore::schema::v0::OneHotT *>(value) : nullptr;
  }
  const mindspore::schema::v0::OneHotT *AsOneHot() const {
    return type == PrimitiveType_OneHot ?
      reinterpret_cast<const mindspore::schema::v0::OneHotT *>(value) : nullptr;
  }
  mindspore::schema::v0::LstmT *AsLstm() {
    return type == PrimitiveType_Lstm ?
      reinterpret_cast<mindspore::schema::v0::LstmT *>(value) : nullptr;
  }
  const mindspore::schema::v0::LstmT *AsLstm() const {
    return type == PrimitiveType_Lstm ?
      reinterpret_cast<const mindspore::schema::v0::LstmT *>(value) : nullptr;
  }
  mindspore::schema::v0::Conv2DGradFilterT *AsConv2DGradFilter() {
    return type == PrimitiveType_Conv2DGradFilter ?
      reinterpret_cast<mindspore::schema::v0::Conv2DGradFilterT *>(value) : nullptr;
  }
  const mindspore::schema::v0::Conv2DGradFilterT *AsConv2DGradFilter() const {
    return type == PrimitiveType_Conv2DGradFilter ?
      reinterpret_cast<const mindspore::schema::v0::Conv2DGradFilterT *>(value) : nullptr;
  }
  mindspore::schema::v0::Conv2DGradInputT *AsConv2DGradInput() {
    return type == PrimitiveType_Conv2DGradInput ?
      reinterpret_cast<mindspore::schema::v0::Conv2DGradInputT *>(value) : nullptr;
  }
  const mindspore::schema::v0::Conv2DGradInputT *AsConv2DGradInput() const {
    return type == PrimitiveType_Conv2DGradInput ?
      reinterpret_cast<const mindspore::schema::v0::Conv2DGradInputT *>(value) : nullptr;
  }
  mindspore::schema::v0::PoolingGradT *AsPoolingGrad() {
    return type == PrimitiveType_PoolingGrad ?
      reinterpret_cast<mindspore::schema::v0::PoolingGradT *>(value) : nullptr;
  }
  const mindspore::schema::v0::PoolingGradT *AsPoolingGrad() const {
    return type == PrimitiveType_PoolingGrad ?
      reinterpret_cast<const mindspore::schema::v0::PoolingGradT *>(value) : nullptr;
  }
  mindspore::schema::v0::BNGradT *AsBNGrad() {
    return type == PrimitiveType_BNGrad ?
      reinterpret_cast<mindspore::schema::v0::BNGradT *>(value) : nullptr;
  }
  const mindspore::schema::v0::BNGradT *AsBNGrad() const {
    return type == PrimitiveType_BNGrad ?
      reinterpret_cast<const mindspore::schema::v0::BNGradT *>(value) : nullptr;
  }
  mindspore::schema::v0::AssignT *AsAssign() {
    return type == PrimitiveType_Assign ?
      reinterpret_cast<mindspore::schema::v0::AssignT *>(value) : nullptr;
  }
  const mindspore::schema::v0::AssignT *AsAssign() const {
    return type == PrimitiveType_Assign ?
      reinterpret_cast<const mindspore::schema::v0::AssignT *>(value) : nullptr;
  }
  mindspore::schema::v0::ApplyMomentumT *AsApplyMomentum() {
    return type == PrimitiveType_ApplyMomentum ?
      reinterpret_cast<mindspore::schema::v0::ApplyMomentumT *>(value) : nullptr;
  }
  const mindspore::schema::v0::ApplyMomentumT *AsApplyMomentum() const {
    return type == PrimitiveType_ApplyMomentum ?
      reinterpret_cast<const mindspore::schema::v0::ApplyMomentumT *>(value) : nullptr;
  }
  mindspore::schema::v0::BiasGradT *AsBiasGrad() {
    return type == PrimitiveType_BiasGrad ?
      reinterpret_cast<mindspore::schema::v0::BiasGradT *>(value) : nullptr;
  }
  const mindspore::schema::v0::BiasGradT *AsBiasGrad() const {
    return type == PrimitiveType_BiasGrad ?
      reinterpret_cast<const mindspore::schema::v0::BiasGradT *>(value) : nullptr;
  }
  mindspore::schema::v0::SoftmaxCrossEntropyT *AsSoftmaxCrossEntropy() {
    return type == PrimitiveType_SoftmaxCrossEntropy ?
      reinterpret_cast<mindspore::schema::v0::SoftmaxCrossEntropyT *>(value) : nullptr;
  }
  const mindspore::schema::v0::SoftmaxCrossEntropyT *AsSoftmaxCrossEntropy() const {
    return type == PrimitiveType_SoftmaxCrossEntropy ?
      reinterpret_cast<const mindspore::schema::v0::SoftmaxCrossEntropyT *>(value) : nullptr;
  }
  mindspore::schema::v0::AddGradT *AsAddGrad() {
    return type == PrimitiveType_AddGrad ?
      reinterpret_cast<mindspore::schema::v0::AddGradT *>(value) : nullptr;
  }
  const mindspore::schema::v0::AddGradT *AsAddGrad() const {
    return type == PrimitiveType_AddGrad ?
      reinterpret_cast<const mindspore::schema::v0::AddGradT *>(value) : nullptr;
  }
  mindspore::schema::v0::SubGradT *AsSubGrad() {
    return type == PrimitiveType_SubGrad ?
      reinterpret_cast<mindspore::schema::v0::SubGradT *>(value) : nullptr;
  }
  const mindspore::schema::v0::SubGradT *AsSubGrad() const {
    return type == PrimitiveType_SubGrad ?
      reinterpret_cast<const mindspore::schema::v0::SubGradT *>(value) : nullptr;
  }
  mindspore::schema::v0::MulGradT *AsMulGrad() {
    return type == PrimitiveType_MulGrad ?
      reinterpret_cast<mindspore::schema::v0::MulGradT *>(value) : nullptr;
  }
  const mindspore::schema::v0::MulGradT *AsMulGrad() const {
    return type == PrimitiveType_MulGrad ?
      reinterpret_cast<const mindspore::schema::v0::MulGradT *>(value) : nullptr;
  }
  mindspore::schema::v0::DivGradT *AsDivGrad() {
    return type == PrimitiveType_DivGrad ?
      reinterpret_cast<mindspore::schema::v0::DivGradT *>(value) : nullptr;
  }
  const mindspore::schema::v0::DivGradT *AsDivGrad() const {
    return type == PrimitiveType_DivGrad ?
      reinterpret_cast<const mindspore::schema::v0::DivGradT *>(value) : nullptr;
  }
  mindspore::schema::v0::PowerGradT *AsPowerGrad() {
    return type == PrimitiveType_PowerGrad ?
      reinterpret_cast<mindspore::schema::v0::PowerGradT *>(value) : nullptr;
  }
  const mindspore::schema::v0::PowerGradT *AsPowerGrad() const {
    return type == PrimitiveType_PowerGrad ?
      reinterpret_cast<const mindspore::schema::v0::PowerGradT *>(value) : nullptr;
  }
  mindspore::schema::v0::ActivationGradT *AsActivationGrad() {
    return type == PrimitiveType_ActivationGrad ?
      reinterpret_cast<mindspore::schema::v0::ActivationGradT *>(value) : nullptr;
  }
  const mindspore::schema::v0::ActivationGradT *AsActivationGrad() const {
    return type == PrimitiveType_ActivationGrad ?
      reinterpret_cast<const mindspore::schema::v0::ActivationGradT *>(value) : nullptr;
  }
  mindspore::schema::v0::PriorBoxT *AsPriorBox() {
    return type == PrimitiveType_PriorBox ?
      reinterpret_cast<mindspore::schema::v0::PriorBoxT *>(value) : nullptr;
  }
  const mindspore::schema::v0::PriorBoxT *AsPriorBox() const {
    return type == PrimitiveType_PriorBox ?
      reinterpret_cast<const mindspore::schema::v0::PriorBoxT *>(value) : nullptr;
  }
  mindspore::schema::v0::SpaceToBatchNDT *AsSpaceToBatchND() {
    return type == PrimitiveType_SpaceToBatchND ?
      reinterpret_cast<mindspore::schema::v0::SpaceToBatchNDT *>(value) : nullptr;
  }
  const mindspore::schema::v0::SpaceToBatchNDT *AsSpaceToBatchND() const {
    return type == PrimitiveType_SpaceToBatchND ?
      reinterpret_cast<const mindspore::schema::v0::SpaceToBatchNDT *>(value) : nullptr;
  }
  mindspore::schema::v0::DependT *AsDepend() {
    return type == PrimitiveType_Depend ?
      reinterpret_cast<mindspore::schema::v0::DependT *>(value) : nullptr;
  }
  const mindspore::schema::v0::DependT *AsDepend() const {
    return type == PrimitiveType_Depend ?
      reinterpret_cast<const mindspore::schema::v0::DependT *>(value) : nullptr;
  }
  mindspore::schema::v0::ReturnT *AsReturn() {
    return type == PrimitiveType_Return ?
      reinterpret_cast<mindspore::schema::v0::ReturnT *>(value) : nullptr;
  }
  const mindspore::schema::v0::ReturnT *AsReturn() const {
    return type == PrimitiveType_Return ?
      reinterpret_cast<const mindspore::schema::v0::ReturnT *>(value) : nullptr;
  }
  mindspore::schema::v0::MakeTupleT *AsMakeTuple() {
    return type == PrimitiveType_MakeTuple ?
      reinterpret_cast<mindspore::schema::v0::MakeTupleT *>(value) : nullptr;
  }
  const mindspore::schema::v0::MakeTupleT *AsMakeTuple() const {
    return type == PrimitiveType_MakeTuple ?
      reinterpret_cast<const mindspore::schema::v0::MakeTupleT *>(value) : nullptr;
  }
  mindspore::schema::v0::ToFormatT *AsToFormat() {
    return type == PrimitiveType_ToFormat ?
      reinterpret_cast<mindspore::schema::v0::ToFormatT *>(value) : nullptr;
  }
  const mindspore::schema::v0::ToFormatT *AsToFormat() const {
    return type == PrimitiveType_ToFormat ?
      reinterpret_cast<const mindspore::schema::v0::ToFormatT *>(value) : nullptr;
  }
  mindspore::schema::v0::ProposalT *AsProposal() {
    return type == PrimitiveType_Proposal ?
      reinterpret_cast<mindspore::schema::v0::ProposalT *>(value) : nullptr;
  }
  const mindspore::schema::v0::ProposalT *AsProposal() const {
    return type == PrimitiveType_Proposal ?
      reinterpret_cast<const mindspore::schema::v0::ProposalT *>(value) : nullptr;
  }
  mindspore::schema::v0::CustomT *AsCustom() {
    return type == PrimitiveType_Custom ?
      reinterpret_cast<mindspore::schema::v0::CustomT *>(value) : nullptr;
  }
  const mindspore::schema::v0::CustomT *AsCustom() const {
    return type == PrimitiveType_Custom ?
      reinterpret_cast<const mindspore::schema::v0::CustomT *>(value) : nullptr;
  }
  mindspore::schema::v0::BlackBoxT *AsBlackBox() {
    return type == PrimitiveType_BlackBox ?
      reinterpret_cast<mindspore::schema::v0::BlackBoxT *>(value) : nullptr;
  }
  const mindspore::schema::v0::BlackBoxT *AsBlackBox() const {
    return type == PrimitiveType_BlackBox ?
      reinterpret_cast<const mindspore::schema::v0::BlackBoxT *>(value) : nullptr;
  }
  mindspore::schema::v0::NegGradT *AsNegGrad() {
    return type == PrimitiveType_NegGrad ?
      reinterpret_cast<mindspore::schema::v0::NegGradT *>(value) : nullptr;
  }
  const mindspore::schema::v0::NegGradT *AsNegGrad() const {
    return type == PrimitiveType_NegGrad ?
      reinterpret_cast<const mindspore::schema::v0::NegGradT *>(value) : nullptr;
  }
  mindspore::schema::v0::LogGradT *AsLogGrad() {
    return type == PrimitiveType_LogGrad ?
      reinterpret_cast<mindspore::schema::v0::LogGradT *>(value) : nullptr;
  }
  const mindspore::schema::v0::LogGradT *AsLogGrad() const {
    return type == PrimitiveType_LogGrad ?
      reinterpret_cast<const mindspore::schema::v0::LogGradT *>(value) : nullptr;
  }
  mindspore::schema::v0::BatchToSpaceNDT *AsBatchToSpaceND() {
    return type == PrimitiveType_BatchToSpaceND ?
      reinterpret_cast<mindspore::schema::v0::BatchToSpaceNDT *>(value) : nullptr;
  }
  const mindspore::schema::v0::BatchToSpaceNDT *AsBatchToSpaceND() const {
    return type == PrimitiveType_BatchToSpaceND ?
      reinterpret_cast<const mindspore::schema::v0::BatchToSpaceNDT *>(value) : nullptr;
  }
  mindspore::schema::v0::LshProjectionT *AsLshProjection() {
    return type == PrimitiveType_LshProjection ?
      reinterpret_cast<mindspore::schema::v0::LshProjectionT *>(value) : nullptr;
  }
  const mindspore::schema::v0::LshProjectionT *AsLshProjection() const {
    return type == PrimitiveType_LshProjection ?
      reinterpret_cast<const mindspore::schema::v0::LshProjectionT *>(value) : nullptr;
  }
  mindspore::schema::v0::HashtableLookupT *AsHashtableLookup() {
    return type == PrimitiveType_HashtableLookup ?
      reinterpret_cast<mindspore::schema::v0::HashtableLookupT *>(value) : nullptr;
  }
  const mindspore::schema::v0::HashtableLookupT *AsHashtableLookup() const {
    return type == PrimitiveType_HashtableLookup ?
      reinterpret_cast<const mindspore::schema::v0::HashtableLookupT *>(value) : nullptr;
  }
  mindspore::schema::v0::SkipGramT *AsSkipGram() {
    return type == PrimitiveType_SkipGram ?
      reinterpret_cast<mindspore::schema::v0::SkipGramT *>(value) : nullptr;
  }
  const mindspore::schema::v0::SkipGramT *AsSkipGram() const {
    return type == PrimitiveType_SkipGram ?
      reinterpret_cast<const mindspore::schema::v0::SkipGramT *>(value) : nullptr;
  }
  mindspore::schema::v0::DeConv2DGradFilterT *AsDeConv2DGradFilter() {
    return type == PrimitiveType_DeConv2DGradFilter ?
      reinterpret_cast<mindspore::schema::v0::DeConv2DGradFilterT *>(value) : nullptr;
  }
  const mindspore::schema::v0::DeConv2DGradFilterT *AsDeConv2DGradFilter() const {
    return type == PrimitiveType_DeConv2DGradFilter ?
      reinterpret_cast<const mindspore::schema::v0::DeConv2DGradFilterT *>(value) : nullptr;
  }
  mindspore::schema::v0::CustomPredictT *AsCustomPredict() {
    return type == PrimitiveType_CustomPredict ?
      reinterpret_cast<mindspore::schema::v0::CustomPredictT *>(value) : nullptr;
  }
  const mindspore::schema::v0::CustomPredictT *AsCustomPredict() const {
    return type == PrimitiveType_CustomPredict ?
      reinterpret_cast<const mindspore::schema::v0::CustomPredictT *>(value) : nullptr;
  }
  mindspore::schema::v0::CustomNormalizeT *AsCustomNormalize() {
    return type == PrimitiveType_CustomNormalize ?
      reinterpret_cast<mindspore::schema::v0::CustomNormalizeT *>(value) : nullptr;
  }
  const mindspore::schema::v0::CustomNormalizeT *AsCustomNormalize() const {
    return type == PrimitiveType_CustomNormalize ?
      reinterpret_cast<const mindspore::schema::v0::CustomNormalizeT *>(value) : nullptr;
  }
  mindspore::schema::v0::CustomExtractFeaturesT *AsCustomExtractFeatures() {
    return type == PrimitiveType_CustomExtractFeatures ?
      reinterpret_cast<mindspore::schema::v0::CustomExtractFeaturesT *>(value) : nullptr;
  }
  const mindspore::schema::v0::CustomExtractFeaturesT *AsCustomExtractFeatures() const {
    return type == PrimitiveType_CustomExtractFeatures ?
      reinterpret_cast<const mindspore::schema::v0::CustomExtractFeaturesT *>(value) : nullptr;
  }
  mindspore::schema::v0::AudioSpectrogramT *AsAudioSpectrogram() {
    return type == PrimitiveType_AudioSpectrogram ?
      reinterpret_cast<mindspore::schema::v0::AudioSpectrogramT *>(value) : nullptr;
  }
  const mindspore::schema::v0::AudioSpectrogramT *AsAudioSpectrogram() const {
    return type == PrimitiveType_AudioSpectrogram ?
      reinterpret_cast<const mindspore::schema::v0::AudioSpectrogramT *>(value) : nullptr;
  }
  mindspore::schema::v0::MfccT *AsMfcc() {
    return type == PrimitiveType_Mfcc ?
      reinterpret_cast<mindspore::schema::v0::MfccT *>(value) : nullptr;
  }
  const mindspore::schema::v0::MfccT *AsMfcc() const {
    return type == PrimitiveType_Mfcc ?
      reinterpret_cast<const mindspore::schema::v0::MfccT *>(value) : nullptr;
  }
  mindspore::schema::v0::RfftT *AsRfft() {
    return type == PrimitiveType_Rfft ?
      reinterpret_cast<mindspore::schema::v0::RfftT *>(value) : nullptr;
  }
  const mindspore::schema::v0::RfftT *AsRfft() const {
    return type == PrimitiveType_Rfft ?
      reinterpret_cast<const mindspore::schema::v0::RfftT *>(value) : nullptr;
  }
  mindspore::schema::v0::FftRealT *AsFftReal() {
    return type == PrimitiveType_FftReal ?
      reinterpret_cast<mindspore::schema::v0::FftRealT *>(value) : nullptr;
  }
  const mindspore::schema::v0::FftRealT *AsFftReal() const {
    return type == PrimitiveType_FftReal ?
      reinterpret_cast<const mindspore::schema::v0::FftRealT *>(value) : nullptr;
  }
  mindspore::schema::v0::FftImagT *AsFftImag() {
    return type == PrimitiveType_FftImag ?
      reinterpret_cast<mindspore::schema::v0::FftImagT *>(value) : nullptr;
  }
  const mindspore::schema::v0::FftImagT *AsFftImag() const {
    return type == PrimitiveType_FftImag ?
      reinterpret_cast<const mindspore::schema::v0::FftImagT *>(value) : nullptr;
  }
  mindspore::schema::v0::SgdT *AsSgd() {
    return type == PrimitiveType_Sgd ?
      reinterpret_cast<mindspore::schema::v0::SgdT *>(value) : nullptr;
  }
  const mindspore::schema::v0::SgdT *AsSgd() const {
    return type == PrimitiveType_Sgd ?
      reinterpret_cast<const mindspore::schema::v0::SgdT *>(value) : nullptr;
  }
  mindspore::schema::v0::AdamT *AsAdam() {
    return type == PrimitiveType_Adam ?
      reinterpret_cast<mindspore::schema::v0::AdamT *>(value) : nullptr;
  }
  const mindspore::schema::v0::AdamT *AsAdam() const {
    return type == PrimitiveType_Adam ?
      reinterpret_cast<const mindspore::schema::v0::AdamT *>(value) : nullptr;
  }
  mindspore::schema::v0::GroupConv2DGradInputT *AsGroupConv2DGradInput() {
    return type == PrimitiveType_GroupConv2DGradInput ?
      reinterpret_cast<mindspore::schema::v0::GroupConv2DGradInputT *>(value) : nullptr;
  }
  const mindspore::schema::v0::GroupConv2DGradInputT *AsGroupConv2DGradInput() const {
    return type == PrimitiveType_GroupConv2DGradInput ?
      reinterpret_cast<const mindspore::schema::v0::GroupConv2DGradInputT *>(value) : nullptr;
  }
  mindspore::schema::v0::LoopT *AsLoop() {
    return type == PrimitiveType_Loop ?
      reinterpret_cast<mindspore::schema::v0::LoopT *>(value) : nullptr;
  }
  const mindspore::schema::v0::LoopT *AsLoop() const {
    return type == PrimitiveType_Loop ?
      reinterpret_cast<const mindspore::schema::v0::LoopT *>(value) : nullptr;
  }
  mindspore::schema::v0::NonMaxSuppressionT *AsNonMaxSuppression() {
    return type == PrimitiveType_NonMaxSuppression ?
      reinterpret_cast<mindspore::schema::v0::NonMaxSuppressionT *>(value) : nullptr;
  }
  const mindspore::schema::v0::NonMaxSuppressionT *AsNonMaxSuppression() const {
    return type == PrimitiveType_NonMaxSuppression ?
      reinterpret_cast<const mindspore::schema::v0::NonMaxSuppressionT *>(value) : nullptr;
  }
  mindspore::schema::v0::InstanceNormT *AsInstanceNorm() {
    return type == PrimitiveType_InstanceNorm ?
      reinterpret_cast<mindspore::schema::v0::InstanceNormT *>(value) : nullptr;
  }
  const mindspore::schema::v0::InstanceNormT *AsInstanceNorm() const {
    return type == PrimitiveType_InstanceNorm ?
      reinterpret_cast<const mindspore::schema::v0::InstanceNormT *>(value) : nullptr;
  }
  mindspore::schema::v0::IdentityT *AsIdentity() {
    return type == PrimitiveType_Identity ?
      reinterpret_cast<mindspore::schema::v0::IdentityT *>(value) : nullptr;
  }
  const mindspore::schema::v0::IdentityT *AsIdentity() const {
    return type == PrimitiveType_Identity ?
      reinterpret_cast<const mindspore::schema::v0::IdentityT *>(value) : nullptr;
  }
  mindspore::schema::v0::LayerNormT *AsLayerNorm() {
    return type == PrimitiveType_LayerNorm ?
      reinterpret_cast<mindspore::schema::v0::LayerNormT *>(value) : nullptr;
  }
  const mindspore::schema::v0::LayerNormT *AsLayerNorm() const {
    return type == PrimitiveType_LayerNorm ?
      reinterpret_cast<const mindspore::schema::v0::LayerNormT *>(value) : nullptr;
  }
  mindspore::schema::v0::WhileT *AsWhile() {
    return type == PrimitiveType_While ?
      reinterpret_cast<mindspore::schema::v0::WhileT *>(value) : nullptr;
  }
  const mindspore::schema::v0::WhileT *AsWhile() const {
    return type == PrimitiveType_While ?
      reinterpret_cast<const mindspore::schema::v0::WhileT *>(value) : nullptr;
  }
  mindspore::schema::v0::ControlDependT *AsControlDepend() {
    return type == PrimitiveType_ControlDepend ?
      reinterpret_cast<mindspore::schema::v0::ControlDependT *>(value) : nullptr;
  }
  const mindspore::schema::v0::ControlDependT *AsControlDepend() const {
    return type == PrimitiveType_ControlDepend ?
      reinterpret_cast<const mindspore::schema::v0::ControlDependT *>(value) : nullptr;
  }
  mindspore::schema::v0::UnsortedSegmentSumT *AsUnsortedSegmentSum() {
    return type == PrimitiveType_UnsortedSegmentSum ?
      reinterpret_cast<mindspore::schema::v0::UnsortedSegmentSumT *>(value) : nullptr;
  }
  const mindspore::schema::v0::UnsortedSegmentSumT *AsUnsortedSegmentSum() const {
    return type == PrimitiveType_UnsortedSegmentSum ?
      reinterpret_cast<const mindspore::schema::v0::UnsortedSegmentSumT *>(value) : nullptr;
  }
  mindspore::schema::v0::AssignAddT *AsAssignAdd() {
    return type == PrimitiveType_AssignAdd ?
      reinterpret_cast<mindspore::schema::v0::AssignAddT *>(value) : nullptr;
  }
  const mindspore::schema::v0::AssignAddT *AsAssignAdd() const {
    return type == PrimitiveType_AssignAdd ?
      reinterpret_cast<const mindspore::schema::v0::AssignAddT *>(value) : nullptr;
  }
  mindspore::schema::v0::OnesLikeT *AsOnesLike() {
    return type == PrimitiveType_OnesLike ?
      reinterpret_cast<mindspore::schema::v0::OnesLikeT *>(value) : nullptr;
  }
  const mindspore::schema::v0::OnesLikeT *AsOnesLike() const {
    return type == PrimitiveType_OnesLike ?
      reinterpret_cast<const mindspore::schema::v0::OnesLikeT *>(value) : nullptr;
  }
  mindspore::schema::v0::BinaryCrossEntropyGradT *AsBinaryCrossEntropyGrad() {
    return type == PrimitiveType_BinaryCrossEntropyGrad ?
      reinterpret_cast<mindspore::schema::v0::BinaryCrossEntropyGradT *>(value) : nullptr;
  }
  const mindspore::schema::v0::BinaryCrossEntropyGradT *AsBinaryCrossEntropyGrad() const {
    return type == PrimitiveType_BinaryCrossEntropyGrad ?
      reinterpret_cast<const mindspore::schema::v0::BinaryCrossEntropyGradT *>(value) : nullptr;
  }
  mindspore::schema::v0::BinaryCrossEntropyT *AsBinaryCrossEntropy() {
    return type == PrimitiveType_BinaryCrossEntropy ?
      reinterpret_cast<mindspore::schema::v0::BinaryCrossEntropyT *>(value) : nullptr;
  }
  const mindspore::schema::v0::BinaryCrossEntropyT *AsBinaryCrossEntropy() const {
    return type == PrimitiveType_BinaryCrossEntropy ?
      reinterpret_cast<const mindspore::schema::v0::BinaryCrossEntropyT *>(value) : nullptr;
  }
  mindspore::schema::v0::LpNormalizationT *AsLpNormalization() {
    return type == PrimitiveType_LpNormalization ?
      reinterpret_cast<mindspore::schema::v0::LpNormalizationT *>(value) : nullptr;
  }
  const mindspore::schema::v0::LpNormalizationT *AsLpNormalization() const {
    return type == PrimitiveType_LpNormalization ?
      reinterpret_cast<const mindspore::schema::v0::LpNormalizationT *>(value) : nullptr;
  }
  mindspore::schema::v0::DropoutGradT *AsDropoutGrad() {
    return type == PrimitiveType_DropoutGrad ?
      reinterpret_cast<mindspore::schema::v0::DropoutGradT *>(value) : nullptr;
  }
  const mindspore::schema::v0::DropoutGradT *AsDropoutGrad() const {
    return type == PrimitiveType_DropoutGrad ?
      reinterpret_cast<const mindspore::schema::v0::DropoutGradT *>(value) : nullptr;
  }
  mindspore::schema::v0::MaximumGradT *AsMaximumGrad() {
    return type == PrimitiveType_MaximumGrad ?
      reinterpret_cast<mindspore::schema::v0::MaximumGradT *>(value) : nullptr;
  }
  const mindspore::schema::v0::MaximumGradT *AsMaximumGrad() const {
    return type == PrimitiveType_MaximumGrad ?
      reinterpret_cast<const mindspore::schema::v0::MaximumGradT *>(value) : nullptr;
  }
  mindspore::schema::v0::MinimumGradT *AsMinimumGrad() {
    return type == PrimitiveType_MinimumGrad ?
      reinterpret_cast<mindspore::schema::v0::MinimumGradT *>(value) : nullptr;
  }
  const mindspore::schema::v0::MinimumGradT *AsMinimumGrad() const {
    return type == PrimitiveType_MinimumGrad ?
      reinterpret_cast<const mindspore::schema::v0::MinimumGradT *>(value) : nullptr;
  }
  mindspore::schema::v0::SwitchT *AsSwitch() {
    return type == PrimitiveType_Switch ?
      reinterpret_cast<mindspore::schema::v0::SwitchT *>(value) : nullptr;
  }
  const mindspore::schema::v0::SwitchT *AsSwitch() const {
    return type == PrimitiveType_Switch ?
      reinterpret_cast<const mindspore::schema::v0::SwitchT *>(value) : nullptr;
  }
  mindspore::schema::v0::PartialT *AsPartial() {
    return type == PrimitiveType_Partial ?
      reinterpret_cast<mindspore::schema::v0::PartialT *>(value) : nullptr;
  }
  const mindspore::schema::v0::PartialT *AsPartial() const {
    return type == PrimitiveType_Partial ?
      reinterpret_cast<const mindspore::schema::v0::PartialT *>(value) : nullptr;
  }
  mindspore::schema::v0::TensorListFromTensorT *AsTensorListFromTensor() {
    return type == PrimitiveType_TensorListFromTensor ?
      reinterpret_cast<mindspore::schema::v0::TensorListFromTensorT *>(value) : nullptr;
  }
  const mindspore::schema::v0::TensorListFromTensorT *AsTensorListFromTensor() const {
    return type == PrimitiveType_TensorListFromTensor ?
      reinterpret_cast<const mindspore::schema::v0::TensorListFromTensorT *>(value) : nullptr;
  }
  mindspore::schema::v0::TensorListStackT *AsTensorListStack() {
    return type == PrimitiveType_TensorListStack ?
      reinterpret_cast<mindspore::schema::v0::TensorListStackT *>(value) : nullptr;
  }
  const mindspore::schema::v0::TensorListStackT *AsTensorListStack() const {
    return type == PrimitiveType_TensorListStack ?
      reinterpret_cast<const mindspore::schema::v0::TensorListStackT *>(value) : nullptr;
  }
  mindspore::schema::v0::TensorListGetItemT *AsTensorListGetItem() {
    return type == PrimitiveType_TensorListGetItem ?
      reinterpret_cast<mindspore::schema::v0::TensorListGetItemT *>(value) : nullptr;
  }
  const mindspore::schema::v0::TensorListGetItemT *AsTensorListGetItem() const {
    return type == PrimitiveType_TensorListGetItem ?
      reinterpret_cast<const mindspore::schema::v0::TensorListGetItemT *>(value) : nullptr;
  }
  mindspore::schema::v0::TensorListSetItemT *AsTensorListSetItem() {
    return type == PrimitiveType_TensorListSetItem ?
      reinterpret_cast<mindspore::schema::v0::TensorListSetItemT *>(value) : nullptr;
  }
  const mindspore::schema::v0::TensorListSetItemT *AsTensorListSetItem() const {
    return type == PrimitiveType_TensorListSetItem ?
      reinterpret_cast<const mindspore::schema::v0::TensorListSetItemT *>(value) : nullptr;
  }
  mindspore::schema::v0::TensorListReserveT *AsTensorListReserve() {
    return type == PrimitiveType_TensorListReserve ?
      reinterpret_cast<mindspore::schema::v0::TensorListReserveT *>(value) : nullptr;
  }
  const mindspore::schema::v0::TensorListReserveT *AsTensorListReserve() const {
    return type == PrimitiveType_TensorListReserve ?
      reinterpret_cast<const mindspore::schema::v0::TensorListReserveT *>(value) : nullptr;
  }
  mindspore::schema::v0::AllT *AsAll() {
    return type == PrimitiveType_All ?
      reinterpret_cast<mindspore::schema::v0::AllT *>(value) : nullptr;
  }
  const mindspore::schema::v0::AllT *AsAll() const {
    return type == PrimitiveType_All ?
      reinterpret_cast<const mindspore::schema::v0::AllT *>(value) : nullptr;
  }
  mindspore::schema::v0::AssertT *AsAssert() {
    return type == PrimitiveType_Assert ?
      reinterpret_cast<mindspore::schema::v0::AssertT *>(value) : nullptr;
  }
  const mindspore::schema::v0::AssertT *AsAssert() const {
    return type == PrimitiveType_Assert ?
      reinterpret_cast<const mindspore::schema::v0::AssertT *>(value) : nullptr;
  }
  mindspore::schema::v0::AdderT *AsAdder() {
    return type == PrimitiveType_Adder ?
      reinterpret_cast<mindspore::schema::v0::AdderT *>(value) : nullptr;
  }
  const mindspore::schema::v0::AdderT *AsAdder() const {
    return type == PrimitiveType_Adder ?
      reinterpret_cast<const mindspore::schema::v0::AdderT *>(value) : nullptr;
  }
  mindspore::schema::v0::SparseSoftmaxCrossEntropyT *AsSparseSoftmaxCrossEntropy() {
    return type == PrimitiveType_SparseSoftmaxCrossEntropy ?
      reinterpret_cast<mindspore::schema::v0::SparseSoftmaxCrossEntropyT *>(value) : nullptr;
  }
  const mindspore::schema::v0::SparseSoftmaxCrossEntropyT *AsSparseSoftmaxCrossEntropy() const {
    return type == PrimitiveType_SparseSoftmaxCrossEntropy ?
      reinterpret_cast<const mindspore::schema::v0::SparseSoftmaxCrossEntropyT *>(value) : nullptr;
  }
  mindspore::schema::v0::SmoothL1LossT *AsSmoothL1Loss() {
    return type == PrimitiveType_SmoothL1Loss ?
      reinterpret_cast<mindspore::schema::v0::SmoothL1LossT *>(value) : nullptr;
  }
  const mindspore::schema::v0::SmoothL1LossT *AsSmoothL1Loss() const {
    return type == PrimitiveType_SmoothL1Loss ?
      reinterpret_cast<const mindspore::schema::v0::SmoothL1LossT *>(value) : nullptr;
  }
  mindspore::schema::v0::SmoothL1LossGradT *AsSmoothL1LossGrad() {
    return type == PrimitiveType_SmoothL1LossGrad ?
      reinterpret_cast<mindspore::schema::v0::SmoothL1LossGradT *>(value) : nullptr;
  }
  const mindspore::schema::v0::SmoothL1LossGradT *AsSmoothL1LossGrad() const {
    return type == PrimitiveType_SmoothL1LossGrad ?
      reinterpret_cast<const mindspore::schema::v0::SmoothL1LossGradT *>(value) : nullptr;
  }
  mindspore::schema::v0::SigmoidCrossEntropyWithLogitsT *AsSigmoidCrossEntropyWithLogits() {
    return type == PrimitiveType_SigmoidCrossEntropyWithLogits ?
      reinterpret_cast<mindspore::schema::v0::SigmoidCrossEntropyWithLogitsT *>(value) : nullptr;
  }
  const mindspore::schema::v0::SigmoidCrossEntropyWithLogitsT *AsSigmoidCrossEntropyWithLogits() const {
    return type == PrimitiveType_SigmoidCrossEntropyWithLogits ?
      reinterpret_cast<const mindspore::schema::v0::SigmoidCrossEntropyWithLogitsT *>(value) : nullptr;
  }
  mindspore::schema::v0::SigmoidCrossEntropyWithLogitsGradT *AsSigmoidCrossEntropyWithLogitsGrad() {
    return type == PrimitiveType_SigmoidCrossEntropyWithLogitsGrad ?
      reinterpret_cast<mindspore::schema::v0::SigmoidCrossEntropyWithLogitsGradT *>(value) : nullptr;
  }
  const mindspore::schema::v0::SigmoidCrossEntropyWithLogitsGradT *AsSigmoidCrossEntropyWithLogitsGrad() const {
    return type == PrimitiveType_SigmoidCrossEntropyWithLogitsGrad ?
      reinterpret_cast<const mindspore::schema::v0::SigmoidCrossEntropyWithLogitsGradT *>(value) : nullptr;
  }
  mindspore::schema::v0::ReciprocalT *AsReciprocal() {
    return type == PrimitiveType_Reciprocal ?
      reinterpret_cast<mindspore::schema::v0::ReciprocalT *>(value) : nullptr;
  }
  const mindspore::schema::v0::ReciprocalT *AsReciprocal() const {
    return type == PrimitiveType_Reciprocal ?
      reinterpret_cast<const mindspore::schema::v0::ReciprocalT *>(value) : nullptr;
  }
  mindspore::schema::v0::MergeT *AsMerge() {
    return type == PrimitiveType_Merge ?
      reinterpret_cast<mindspore::schema::v0::MergeT *>(value) : nullptr;
  }
  const mindspore::schema::v0::MergeT *AsMerge() const {
    return type == PrimitiveType_Merge ?
      reinterpret_cast<const mindspore::schema::v0::MergeT *>(value) : nullptr;
  }
  mindspore::schema::v0::ModT *AsMod() {
    return type == PrimitiveType_Mod ?
      reinterpret_cast<mindspore::schema::v0::ModT *>(value) : nullptr;
  }
  const mindspore::schema::v0::ModT *AsMod() const {
    return type == PrimitiveType_Mod ?
      reinterpret_cast<const mindspore::schema::v0::ModT *>(value) : nullptr;
  }
  mindspore::schema::v0::GeLUT *AsGeLU() {
    return type == PrimitiveType_GeLU ?
      reinterpret_cast<mindspore::schema::v0::GeLUT *>(value) : nullptr;
  }
  const mindspore::schema::v0::GeLUT *AsGeLU() const {
    return type == PrimitiveType_GeLU ?
      reinterpret_cast<const mindspore::schema::v0::GeLUT *>(value) : nullptr;
  }
};

bool VerifyPrimitiveType(flatbuffers::Verifier &verifier, const void *obj, PrimitiveType type);
bool VerifyPrimitiveTypeVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types);

enum QuantType : int32_t {
  QuantType_QUANT_NONE = 0,
  QuantType_AwareTraining = 1,
  QuantType_WeightQuant = 2,
  QuantType_PostTraining = 3,
  QuantType_MIN = QuantType_QUANT_NONE,
  QuantType_MAX = QuantType_PostTraining
};

inline const QuantType (&EnumValuesQuantType())[4] {
  static const QuantType values[] = {
    QuantType_QUANT_NONE,
    QuantType_AwareTraining,
    QuantType_WeightQuant,
    QuantType_PostTraining
  };
  return values;
}

inline const char * const *EnumNamesQuantType() {
  static const char * const names[5] = {
    "QUANT_NONE",
    "AwareTraining",
    "WeightQuant",
    "PostTraining",
    nullptr
  };
  return names;
}

inline const char *EnumNameQuantType(QuantType e) {
  if (flatbuffers::IsOutRange(e, QuantType_QUANT_NONE, QuantType_PostTraining)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesQuantType()[index];
}

struct QuantParamT : public flatbuffers::NativeTable {
  typedef QuantParam TableType;
  double scale = 0.0;
  int32_t zeroPoint = 0;
  double min = 0.0;
  double max = 0.0;
  bool narrowRange = true;
  int32_t numBits = 8;
  bool inited = false;
  float varCorr = 1.0f;
  float meanCorr = 0.0f;
  int32_t dstDtype = 32;
  int32_t roundType = 1;
  int32_t multiplier = 1;
};

struct QuantParam FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef QuantParamT NativeTableType;
  typedef QuantParamBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return QuantParamTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SCALE = 4,
    VT_ZEROPOINT = 6,
    VT_MIN = 8,
    VT_MAX = 10,
    VT_NARROWRANGE = 12,
    VT_NUMBITS = 14,
    VT_INITED = 16,
    VT_VARCORR = 18,
    VT_MEANCORR = 20,
    VT_DSTDTYPE = 22,
    VT_ROUNDTYPE = 24,
    VT_MULTIPLIER = 26
  };
  double scale() const {
    return GetField<double>(VT_SCALE, 0.0);
  }
  bool mutate_scale(double _scale) {
    return SetField<double>(VT_SCALE, _scale, 0.0);
  }
  int32_t zeroPoint() const {
    return GetField<int32_t>(VT_ZEROPOINT, 0);
  }
  bool mutate_zeroPoint(int32_t _zeroPoint) {
    return SetField<int32_t>(VT_ZEROPOINT, _zeroPoint, 0);
  }
  double min() const {
    return GetField<double>(VT_MIN, 0.0);
  }
  bool mutate_min(double _min) {
    return SetField<double>(VT_MIN, _min, 0.0);
  }
  double max() const {
    return GetField<double>(VT_MAX, 0.0);
  }
  bool mutate_max(double _max) {
    return SetField<double>(VT_MAX, _max, 0.0);
  }
  bool narrowRange() const {
    return GetField<uint8_t>(VT_NARROWRANGE, 1) != 0;
  }
  bool mutate_narrowRange(bool _narrowRange) {
    return SetField<uint8_t>(VT_NARROWRANGE, static_cast<uint8_t>(_narrowRange), 1);
  }
  int32_t numBits() const {
    return GetField<int32_t>(VT_NUMBITS, 8);
  }
  bool mutate_numBits(int32_t _numBits) {
    return SetField<int32_t>(VT_NUMBITS, _numBits, 8);
  }
  bool inited() const {
    return GetField<uint8_t>(VT_INITED, 0) != 0;
  }
  bool mutate_inited(bool _inited) {
    return SetField<uint8_t>(VT_INITED, static_cast<uint8_t>(_inited), 0);
  }
  float varCorr() const {
    return GetField<float>(VT_VARCORR, 1.0f);
  }
  bool mutate_varCorr(float _varCorr) {
    return SetField<float>(VT_VARCORR, _varCorr, 1.0f);
  }
  float meanCorr() const {
    return GetField<float>(VT_MEANCORR, 0.0f);
  }
  bool mutate_meanCorr(float _meanCorr) {
    return SetField<float>(VT_MEANCORR, _meanCorr, 0.0f);
  }
  int32_t dstDtype() const {
    return GetField<int32_t>(VT_DSTDTYPE, 32);
  }
  bool mutate_dstDtype(int32_t _dstDtype) {
    return SetField<int32_t>(VT_DSTDTYPE, _dstDtype, 32);
  }
  int32_t roundType() const {
    return GetField<int32_t>(VT_ROUNDTYPE, 1);
  }
  bool mutate_roundType(int32_t _roundType) {
    return SetField<int32_t>(VT_ROUNDTYPE, _roundType, 1);
  }
  int32_t multiplier() const {
    return GetField<int32_t>(VT_MULTIPLIER, 1);
  }
  bool mutate_multiplier(int32_t _multiplier) {
    return SetField<int32_t>(VT_MULTIPLIER, _multiplier, 1);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<double>(verifier, VT_SCALE) &&
           VerifyField<int32_t>(verifier, VT_ZEROPOINT) &&
           VerifyField<double>(verifier, VT_MIN) &&
           VerifyField<double>(verifier, VT_MAX) &&
           VerifyField<uint8_t>(verifier, VT_NARROWRANGE) &&
           VerifyField<int32_t>(verifier, VT_NUMBITS) &&
           VerifyField<uint8_t>(verifier, VT_INITED) &&
           VerifyField<float>(verifier, VT_VARCORR) &&
           VerifyField<float>(verifier, VT_MEANCORR) &&
           VerifyField<int32_t>(verifier, VT_DSTDTYPE) &&
           VerifyField<int32_t>(verifier, VT_ROUNDTYPE) &&
           VerifyField<int32_t>(verifier, VT_MULTIPLIER) &&
           verifier.EndTable();
  }
  QuantParamT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(QuantParamT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<QuantParam> Pack(flatbuffers::FlatBufferBuilder &_fbb, const QuantParamT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct QuantParamBuilder {
  typedef QuantParam Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_scale(double scale) {
    fbb_.AddElement<double>(QuantParam::VT_SCALE, scale, 0.0);
  }
  void add_zeroPoint(int32_t zeroPoint) {
    fbb_.AddElement<int32_t>(QuantParam::VT_ZEROPOINT, zeroPoint, 0);
  }
  void add_min(double min) {
    fbb_.AddElement<double>(QuantParam::VT_MIN, min, 0.0);
  }
  void add_max(double max) {
    fbb_.AddElement<double>(QuantParam::VT_MAX, max, 0.0);
  }
  void add_narrowRange(bool narrowRange) {
    fbb_.AddElement<uint8_t>(QuantParam::VT_NARROWRANGE, static_cast<uint8_t>(narrowRange), 1);
  }
  void add_numBits(int32_t numBits) {
    fbb_.AddElement<int32_t>(QuantParam::VT_NUMBITS, numBits, 8);
  }
  void add_inited(bool inited) {
    fbb_.AddElement<uint8_t>(QuantParam::VT_INITED, static_cast<uint8_t>(inited), 0);
  }
  void add_varCorr(float varCorr) {
    fbb_.AddElement<float>(QuantParam::VT_VARCORR, varCorr, 1.0f);
  }
  void add_meanCorr(float meanCorr) {
    fbb_.AddElement<float>(QuantParam::VT_MEANCORR, meanCorr, 0.0f);
  }
  void add_dstDtype(int32_t dstDtype) {
    fbb_.AddElement<int32_t>(QuantParam::VT_DSTDTYPE, dstDtype, 32);
  }
  void add_roundType(int32_t roundType) {
    fbb_.AddElement<int32_t>(QuantParam::VT_ROUNDTYPE, roundType, 1);
  }
  void add_multiplier(int32_t multiplier) {
    fbb_.AddElement<int32_t>(QuantParam::VT_MULTIPLIER, multiplier, 1);
  }
  explicit QuantParamBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<QuantParam> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<QuantParam>(end);
    return o;
  }
};

inline flatbuffers::Offset<QuantParam> CreateQuantParam(
    flatbuffers::FlatBufferBuilder &_fbb,
    double scale = 0.0,
    int32_t zeroPoint = 0,
    double min = 0.0,
    double max = 0.0,
    bool narrowRange = true,
    int32_t numBits = 8,
    bool inited = false,
    float varCorr = 1.0f,
    float meanCorr = 0.0f,
    int32_t dstDtype = 32,
    int32_t roundType = 1,
    int32_t multiplier = 1) {
  QuantParamBuilder builder_(_fbb);
  builder_.add_max(max);
  builder_.add_min(min);
  builder_.add_scale(scale);
  builder_.add_multiplier(multiplier);
  builder_.add_roundType(roundType);
  builder_.add_dstDtype(dstDtype);
  builder_.add_meanCorr(meanCorr);
  builder_.add_varCorr(varCorr);
  builder_.add_numBits(numBits);
  builder_.add_zeroPoint(zeroPoint);
  builder_.add_inited(inited);
  builder_.add_narrowRange(narrowRange);
  return builder_.Finish();
}

flatbuffers::Offset<QuantParam> CreateQuantParam(flatbuffers::FlatBufferBuilder &_fbb, const QuantParamT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct TensorT : public flatbuffers::NativeTable {
  typedef Tensor TableType;
  mindspore::schema::v0::NodeType nodeType = mindspore::schema::v0::NodeType_ValueNode;
  int32_t dataType = 0;
  std::vector<int32_t> dims{};
  mindspore::schema::v0::Format format = mindspore::schema::v0::Format_NCHW;
  int32_t refCount = 0;
  int32_t offset = 0;
  std::vector<uint8_t> data{};
  std::vector<std::unique_ptr<mindspore::schema::v0::QuantParamT>> quantParams{};
  std::vector<float> quantClusters{};
  std::string name{};
};

struct Tensor FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef TensorT NativeTableType;
  typedef TensorBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return TensorTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NODETYPE = 4,
    VT_DATATYPE = 6,
    VT_DIMS = 8,
    VT_FORMAT = 10,
    VT_REFCOUNT = 12,
    VT_OFFSET = 14,
    VT_DATA = 16,
    VT_QUANTPARAMS = 18,
    VT_QUANTCLUSTERS = 20,
    VT_NAME = 22
  };
  mindspore::schema::v0::NodeType nodeType() const {
    return static_cast<mindspore::schema::v0::NodeType>(GetField<int32_t>(VT_NODETYPE, 0));
  }
  bool mutate_nodeType(mindspore::schema::v0::NodeType _nodeType) {
    return SetField<int32_t>(VT_NODETYPE, static_cast<int32_t>(_nodeType), 0);
  }
  int32_t dataType() const {
    return GetField<int32_t>(VT_DATATYPE, 0);
  }
  bool mutate_dataType(int32_t _dataType) {
    return SetField<int32_t>(VT_DATATYPE, _dataType, 0);
  }
  const flatbuffers::Vector<int32_t> *dims() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_DIMS);
  }
  flatbuffers::Vector<int32_t> *mutable_dims() {
    return GetPointer<flatbuffers::Vector<int32_t> *>(VT_DIMS);
  }
  mindspore::schema::v0::Format format() const {
    return static_cast<mindspore::schema::v0::Format>(GetField<int32_t>(VT_FORMAT, 0));
  }
  bool mutate_format(mindspore::schema::v0::Format _format) {
    return SetField<int32_t>(VT_FORMAT, static_cast<int32_t>(_format), 0);
  }
  int32_t refCount() const {
    return GetField<int32_t>(VT_REFCOUNT, 0);
  }
  bool mutate_refCount(int32_t _refCount) {
    return SetField<int32_t>(VT_REFCOUNT, _refCount, 0);
  }
  int32_t offset() const {
    return GetField<int32_t>(VT_OFFSET, 0);
  }
  bool mutate_offset(int32_t _offset) {
    return SetField<int32_t>(VT_OFFSET, _offset, 0);
  }
  const flatbuffers::Vector<uint8_t> *data() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_DATA);
  }
  flatbuffers::Vector<uint8_t> *mutable_data() {
    return GetPointer<flatbuffers::Vector<uint8_t> *>(VT_DATA);
  }
  const flatbuffers::Vector<flatbuffers::Offset<mindspore::schema::v0::QuantParam>> *quantParams() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<mindspore::schema::v0::QuantParam>> *>(VT_QUANTPARAMS);
  }
  flatbuffers::Vector<flatbuffers::Offset<mindspore::schema::v0::QuantParam>> *mutable_quantParams() {
    return GetPointer<flatbuffers::Vector<flatbuffers::Offset<mindspore::schema::v0::QuantParam>> *>(VT_QUANTPARAMS);
  }
  const flatbuffers::Vector<float> *quantClusters() const {
    return GetPointer<const flatbuffers::Vector<float> *>(VT_QUANTCLUSTERS);
  }
  flatbuffers::Vector<float> *mutable_quantClusters() {
    return GetPointer<flatbuffers::Vector<float> *>(VT_QUANTCLUSTERS);
  }
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  flatbuffers::String *mutable_name() {
    return GetPointer<flatbuffers::String *>(VT_NAME);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_NODETYPE) &&
           VerifyField<int32_t>(verifier, VT_DATATYPE) &&
           VerifyOffset(verifier, VT_DIMS) &&
           verifier.VerifyVector(dims()) &&
           VerifyField<int32_t>(verifier, VT_FORMAT) &&
           VerifyField<int32_t>(verifier, VT_REFCOUNT) &&
           VerifyField<int32_t>(verifier, VT_OFFSET) &&
           VerifyOffset(verifier, VT_DATA) &&
           verifier.VerifyVector(data()) &&
           VerifyOffset(verifier, VT_QUANTPARAMS) &&
           verifier.VerifyVector(quantParams()) &&
           verifier.VerifyVectorOfTables(quantParams()) &&
           VerifyOffset(verifier, VT_QUANTCLUSTERS) &&
           verifier.VerifyVector(quantClusters()) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           verifier.EndTable();
  }
  TensorT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(TensorT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Tensor> Pack(flatbuffers::FlatBufferBuilder &_fbb, const TensorT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct TensorBuilder {
  typedef Tensor Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_nodeType(mindspore::schema::v0::NodeType nodeType) {
    fbb_.AddElement<int32_t>(Tensor::VT_NODETYPE, static_cast<int32_t>(nodeType), 0);
  }
  void add_dataType(int32_t dataType) {
    fbb_.AddElement<int32_t>(Tensor::VT_DATATYPE, dataType, 0);
  }
  void add_dims(flatbuffers::Offset<flatbuffers::Vector<int32_t>> dims) {
    fbb_.AddOffset(Tensor::VT_DIMS, dims);
  }
  void add_format(mindspore::schema::v0::Format format) {
    fbb_.AddElement<int32_t>(Tensor::VT_FORMAT, static_cast<int32_t>(format), 0);
  }
  void add_refCount(int32_t refCount) {
    fbb_.AddElement<int32_t>(Tensor::VT_REFCOUNT, refCount, 0);
  }
  void add_offset(int32_t offset) {
    fbb_.AddElement<int32_t>(Tensor::VT_OFFSET, offset, 0);
  }
  void add_data(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> data) {
    fbb_.AddOffset(Tensor::VT_DATA, data);
  }
  void add_quantParams(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<mindspore::schema::v0::QuantParam>>> quantParams) {
    fbb_.AddOffset(Tensor::VT_QUANTPARAMS, quantParams);
  }
  void add_quantClusters(flatbuffers::Offset<flatbuffers::Vector<float>> quantClusters) {
    fbb_.AddOffset(Tensor::VT_QUANTCLUSTERS, quantClusters);
  }
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(Tensor::VT_NAME, name);
  }
  explicit TensorBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Tensor> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Tensor>(end);
    return o;
  }
};

inline flatbuffers::Offset<Tensor> CreateTensor(
    flatbuffers::FlatBufferBuilder &_fbb,
    mindspore::schema::v0::NodeType nodeType = mindspore::schema::v0::NodeType_ValueNode,
    int32_t dataType = 0,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> dims = 0,
    mindspore::schema::v0::Format format = mindspore::schema::v0::Format_NCHW,
    int32_t refCount = 0,
    int32_t offset = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> data = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<mindspore::schema::v0::QuantParam>>> quantParams = 0,
    flatbuffers::Offset<flatbuffers::Vector<float>> quantClusters = 0,
    flatbuffers::Offset<flatbuffers::String> name = 0) {
  TensorBuilder builder_(_fbb);
  builder_.add_name(name);
  builder_.add_quantClusters(quantClusters);
  builder_.add_quantParams(quantParams);
  builder_.add_data(data);
  builder_.add_offset(offset);
  builder_.add_refCount(refCount);
  builder_.add_format(format);
  builder_.add_dims(dims);
  builder_.add_dataType(dataType);
  builder_.add_nodeType(nodeType);
  return builder_.Finish();
}

inline flatbuffers::Offset<Tensor> CreateTensorDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    mindspore::schema::v0::NodeType nodeType = mindspore::schema::v0::NodeType_ValueNode,
    int32_t dataType = 0,
    const std::vector<int32_t> *dims = nullptr,
    mindspore::schema::v0::Format format = mindspore::schema::v0::Format_NCHW,
    int32_t refCount = 0,
    int32_t offset = 0,
    const std::vector<uint8_t> *data = nullptr,
    const std::vector<flatbuffers::Offset<mindspore::schema::v0::QuantParam>> *quantParams = nullptr,
    const std::vector<float> *quantClusters = nullptr,
    const char *name = nullptr) {
  auto dims__ = dims ? _fbb.CreateVector<int32_t>(*dims) : 0;
  auto data__ = data ? _fbb.CreateVector<uint8_t>(*data) : 0;
  auto quantParams__ = quantParams ? _fbb.CreateVector<flatbuffers::Offset<mindspore::schema::v0::QuantParam>>(*quantParams) : 0;
  auto quantClusters__ = quantClusters ? _fbb.CreateVector<float>(*quantClusters) : 0;
  auto name__ = name ? _fbb.CreateString(name) : 0;
  return mindspore::schema::v0::CreateTensor(
      _fbb,
      nodeType,
      dataType,
      dims__,
      format,
      refCount,
      offset,
      data__,
      quantParams__,
      quantClusters__,
      name__);
}

flatbuffers::Offset<Tensor> CreateTensor(flatbuffers::FlatBufferBuilder &_fbb, const TensorT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct PrimitiveT : public flatbuffers::NativeTable {
  typedef Primitive TableType;
  mindspore::schema::v0::PrimitiveTypeUnion value{};
};

struct Primitive FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef PrimitiveT NativeTableType;
  typedef PrimitiveBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return PrimitiveTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VALUE_TYPE = 4,
    VT_VALUE = 6
  };
  mindspore::schema::v0::PrimitiveType value_type() const {
    return static_cast<mindspore::schema::v0::PrimitiveType>(GetField<uint8_t>(VT_VALUE_TYPE, 0));
  }
  const void *value() const {
    return GetPointer<const void *>(VT_VALUE);
  }
  template<typename T> const T *value_as() const;
  const mindspore::schema::v0::Concat *value_as_Concat() const {
    return value_type() == mindspore::schema::v0::PrimitiveType_Concat ? static_cast<const mindspore::schema::v0::Concat *>(value()) : nullptr;
  }
  const mindspore::schema::v0::SoftMax *value_as_SoftMax() const {
    return value_type() == mindspore::schema::v0::PrimitiveType_SoftMax ? static_cast<const mindspore::schema::v0::SoftMax *>(value()) : nullptr;
  }
  const mindspore::schema::v0::Activation *value_as_Activation() const {
    return value_type() == mindspore::schema::v0::PrimitiveType_Activation ? static_cast<const mindspore::schema::v0::Activation *>(value()) : nullptr;
  }
  const mindspore::schema::v0::Conv2D *value_as_Conv2D() const {
    return value_type() == mindspore::schema::v0::PrimitiveType_Conv2D ? static_cast<const mindspore::schema::v0::Conv2D *>(value()) : nullptr;
  }
  const mindspore::schema::v0::FusedBatchNorm *value_as_FusedBatchNorm() const {
    return value_type() == mindspore::schema::v0::PrimitiveType_FusedBatchNorm ? static_cast<const mindspore::schema::v0::FusedBatchNorm *>(value()) : nullptr;
  }
  const mindspore::schema::v0::BatchNorm *value_as_BatchNorm() const {
    return value_type() == mindspore::schema::v0::PrimitiveType_BatchNorm ? static_cast<const mindspore::schema::v0::BatchNorm *>(value()) : nullptr;
  }
  const mindspore::schema::v0::BiasAdd *value_as_BiasAdd() const {
    return value_type() == mindspore::schema::v0::PrimitiveType_BiasAdd ? static_cast<const mindspore::schema::v0::BiasAdd *>(value()) : nullptr;
  }
  const mindspore::schema::v0::Pooling *value_as_Pooling() const {
    return value_type() == mindspore::schema::v0::PrimitiveType_Pooling ? static_cast<const mindspore::schema::v0::Pooling *>(value()) : nullptr;
  }
  const mindspore::schema::v0::ROIPooling *value_as_ROIPooling() const {
    return value_type() == mindspore::schema::v0::PrimitiveType_ROIPooling ? static_cast<const mindspore::schema::v0::ROIPooling *>(value()) : nullptr;
  }
  const mindspore::schema::v0::DepthwiseConv2D *value_as_DepthwiseConv2D() const {
    return value_type() == mindspore::schema::v0::PrimitiveType_DepthwiseConv2D ? static_cast<const mindspore::schema::v0::DepthwiseConv2D *>(value()) : nullptr;
  }
  const mindspore::schema::v0::DeDepthwiseConv2D *value_as_DeDepthwiseConv2D() const {
    return value_type() == mindspore::schema::v0::PrimitiveType_DeDepthwiseConv2D ? static_cast<const mindspore::schema::v0::DeDepthwiseConv2D *>(value()) : nullptr;
  }
  const mindspore::schema::v0::Resize *value_as_Resize() const {
    return value_type() == mindspore::schema::v0::PrimitiveType_Resize ? static_cast<const mindspore::schema::v0::Resize *>(value()) : nullptr;
  }
  const mindspore::schema::v0::DetectionPostProcess *value_as_DetectionPostProcess() const {
    return value_type() == mindspore::schema::v0::PrimitiveType_DetectionPostProcess ? static_cast<const mindspore::schema::v0::DetectionPostProcess *>(value()) : nullptr;
  }
  const mindspore::schema::v0::FullConnection *value_as_FullConnection() const {
    return value_type() == mindspore::schema::v0::PrimitiveType_FullConnection ? static_cast<const mindspore::schema::v0::FullConnection *>(value()) : nullptr;
  }
  const mindspore::schema::v0::Mean *value_as_Mean() const {
    return value_type() == mindspore::schema::v0::PrimitiveType_Mean ? static_cast<const mindspore::schema::v0::Mean *>(value()) : nullptr;
  }
  const mindspore::schema::v0::DeConv2D *value_as_DeConv2D() const {
    return value_type() == mindspore::schema::v0::PrimitiveType_DeConv2D ? static_cast<const mindspore::schema::v0::DeConv2D *>(value()) : nullptr;
  }
  const mindspore::schema::v0::Scale *value_as_Scale() const {
    return value_type() == mindspore::schema::v0::PrimitiveType_Scale ? static_cast<const mindspore::schema::v0::Scale *>(value()) : nullptr;
  }
  const mindspore::schema::v0::Reshape *value_as_Reshape() const {
    return value_type() == mindspore::schema::v0::PrimitiveType_Reshape ? static_cast<const mindspore::schema::v0::Reshape *>(value()) : nullptr;
  }
  const mindspore::schema::v0::Eltwise *value_as_Eltwise() const {
    return value_type() == mindspore::schema::v0::PrimitiveType_Eltwise ? static_cast<const mindspore::schema::v0::Eltwise *>(value()) : nullptr;
  }
  const mindspore::schema::v0::NetOutput *value_as_NetOutput() const {
    return value_type() == mindspore::schema::v0::PrimitiveType_NetOutput ? static_cast<const mindspore::schema::v0::NetOutput *>(value()) : nullptr;
  }
  const mindspore::schema::v0::Add *value_as_Add() const {
    return value_type() == mindspore::schema::v0::PrimitiveType_Add ? static_cast<const mindspore::schema::v0::Add *>(value()) : nullptr;
  }
  const mindspore::schema::v0::Sub *value_as_Sub() const {
    return value_type() == mindspore::schema::v0::PrimitiveType_Sub ? static_cast<const mindspore::schema::v0::Sub *>(value()) : nullptr;
  }
  const mindspore::schema::v0::MatMul *value_as_MatMul() const {
    return value_type() == mindspore::schema::v0::PrimitiveType_MatMul ? static_cast<const mindspore::schema::v0::MatMul *>(value()) : nullptr;
  }
  const mindspore::schema::v0::StridedSlice *value_as_StridedSlice() const {
    return value_type() == mindspore::schema::v0::PrimitiveType_StridedSlice ? static_cast<const mindspore::schema::v0::StridedSlice *>(value()) : nullptr;
  }
  const mindspore::schema::v0::Power *value_as_Power() const {
    return value_type() == mindspore::schema::v0::PrimitiveType_Power ? static_cast<const mindspore::schema::v0::Power *>(value()) : nullptr;
  }
  const mindspore::schema::v0::Slice *value_as_Slice() const {
    return value_type() == mindspore::schema::v0::PrimitiveType_Slice ? static_cast<const mindspore::schema::v0::Slice *>(value()) : nullptr;
  }
  const mindspore::schema::v0::Stack *value_as_Stack() const {
    return value_type() == mindspore::schema::v0::PrimitiveType_Stack ? static_cast<const mindspore::schema::v0::Stack *>(value()) : nullptr;
  }
  const mindspore::schema::v0::Mul *value_as_Mul() const {
    return value_type() == mindspore::schema::v0::PrimitiveType_Mul ? static_cast<const mindspore::schema::v0::Mul *>(value()) : nullptr;
  }
  const mindspore::schema::v0::RealDiv *value_as_RealDiv() const {
    return value_type() == mindspore::schema::v0::PrimitiveType_RealDiv ? static_cast<const mindspore::schema::v0::RealDiv *>(value()) : nullptr;
  }
  const mindspore::schema::v0::Pad *value_as_Pad() const {
    return value_type() == mindspore::schema::v0::PrimitiveType_Pad ? static_cast<const mindspore::schema::v0::Pad *>(value()) : nullptr;
  }
  const mindspore::schema::v0::Maximum *value_as_Maximum() const {
    return value_type() == mindspore::schema::v0::PrimitiveType_Maximum ? static_cast<const mindspore::schema::v0::Maximum *>(value()) : nullptr;
  }
  const mindspore::schema::v0::Minimum *value_as_Minimum() const {
    return value_type() == mindspore::schema::v0::PrimitiveType_Minimum ? static_cast<const mindspore::schema::v0::Minimum *>(value()) : nullptr;
  }
  const mindspore::schema::v0::PReLU *value_as_PReLU() const {
    return value_type() == mindspore::schema::v0::PrimitiveType_PReLU ? static_cast<const mindspore::schema::v0::PReLU *>(value()) : nullptr;
  }
  const mindspore::schema::v0::LeakyReLU *value_as_LeakyReLU() const {
    return value_type() == mindspore::schema::v0::PrimitiveType_LeakyReLU ? static_cast<const mindspore::schema::v0::LeakyReLU *>(value()) : nullptr;
  }
  const mindspore::schema::v0::ArgMax *value_as_ArgMax() const {
    return value_type() == mindspore::schema::v0::PrimitiveType_ArgMax ? static_cast<const mindspore::schema::v0::ArgMax *>(value()) : nullptr;
  }
  const mindspore::schema::v0::ArgMin *value_as_ArgMin() const {
    return value_type() == mindspore::schema::v0::PrimitiveType_ArgMin ? static_cast<const mindspore::schema::v0::ArgMin *>(value()) : nullptr;
  }
  const mindspore::schema::v0::Exp *value_as_Exp() const {
    return value_type() == mindspore::schema::v0::PrimitiveType_Exp ? static_cast<const mindspore::schema::v0::Exp *>(value()) : nullptr;
  }
  const mindspore::schema::v0::Crop *value_as_Crop() const {
    return value_type() == mindspore::schema::v0::PrimitiveType_Crop ? static_cast<const mindspore::schema::v0::Crop *>(value()) : nullptr;
  }
  const mindspore::schema::v0::Range *value_as_Range() const {
    return value_type() == mindspore::schema::v0::PrimitiveType_Range ? static_cast<const mindspore::schema::v0::Range *>(value()) : nullptr;
  }
  const mindspore::schema::v0::Rsqrt *value_as_Rsqrt() const {
    return value_type() == mindspore::schema::v0::PrimitiveType_Rsqrt ? static_cast<const mindspore::schema::v0::Rsqrt *>(value()) : nullptr;
  }
  const mindspore::schema::v0::ExpandDims *value_as_ExpandDims() const {
    return value_type() == mindspore::schema::v0::PrimitiveType_ExpandDims ? static_cast<const mindspore::schema::v0::ExpandDims *>(value()) : nullptr;
  }
  const mindspore::schema::v0::Tile *value_as_Tile() const {
    return value_type() == mindspore::schema::v0::PrimitiveType_Tile ? static_cast<const mindspore::schema::v0::Tile *>(value()) : nullptr;
  }
  const mindspore::schema::v0::Cast *value_as_Cast() const {
    return value_type() == mindspore::schema::v0::PrimitiveType_Cast ? static_cast<const mindspore::schema::v0::Cast *>(value()) : nullptr;
  }
  const mindspore::schema::v0::Shape *value_as_Shape() const {
    return value_type() == mindspore::schema::v0::PrimitiveType_Shape ? static_cast<const mindspore::schema::v0::Shape *>(value()) : nullptr;
  }
  const mindspore::schema::v0::Nchw2Nhwc *value_as_Nchw2Nhwc() const {
    return value_type() == mindspore::schema::v0::PrimitiveType_Nchw2Nhwc ? static_cast<const mindspore::schema::v0::Nchw2Nhwc *>(value()) : nullptr;
  }
  const mindspore::schema::v0::Nhwc2Nchw *value_as_Nhwc2Nchw() const {
    return value_type() == mindspore::schema::v0::PrimitiveType_Nhwc2Nchw ? static_cast<const mindspore::schema::v0::Nhwc2Nchw *>(value()) : nullptr;
  }
  const mindspore::schema::v0::QuantDTypeCast *value_as_QuantDTypeCast() const {
    return value_type() == mindspore::schema::v0::PrimitiveType_QuantDTypeCast ? static_cast<const mindspore::schema::v0::QuantDTypeCast *>(value()) : nullptr;
  }
  const mindspore::schema::v0::Split *value_as_Split() const {
    return value_type() == mindspore::schema::v0::PrimitiveType_Split ? static_cast<const mindspore::schema::v0::Split *>(value()) : nullptr;
  }
  const mindspore::schema::v0::Permute *value_as_Permute() const {
    return value_type() == mindspore::schema::v0::PrimitiveType_Permute ? static_cast<const mindspore::schema::v0::Permute *>(value()) : nullptr;
  }
  const mindspore::schema::v0::FakeQuantWithMinMaxVars *value_as_FakeQuantWithMinMaxVars() const {
    return value_type() == mindspore::schema::v0::PrimitiveType_FakeQuantWithMinMaxVars ? static_cast<const mindspore::schema::v0::FakeQuantWithMinMaxVars *>(value()) : nullptr;
  }
  const mindspore::schema::v0::Equal *value_as_Equal() const {
    return value_type() == mindspore::schema::v0::PrimitiveType_Equal ? static_cast<const mindspore::schema::v0::Equal *>(value()) : nullptr;
  }
  const mindspore::schema::v0::Less *value_as_Less() const {
    return value_type() == mindspore::schema::v0::PrimitiveType_Less ? static_cast<const mindspore::schema::v0::Less *>(value()) : nullptr;
  }
  const mindspore::schema::v0::Greater *value_as_Greater() const {
    return value_type() == mindspore::schema::v0::PrimitiveType_Greater ? static_cast<const mindspore::schema::v0::Greater *>(value()) : nullptr;
  }
  const mindspore::schema::v0::NotEqual *value_as_NotEqual() const {
    return value_type() == mindspore::schema::v0::PrimitiveType_NotEqual ? static_cast<const mindspore::schema::v0::NotEqual *>(value()) : nullptr;
  }
  const mindspore::schema::v0::LessEqual *value_as_LessEqual() const {
    return value_type() == mindspore::schema::v0::PrimitiveType_LessEqual ? static_cast<const mindspore::schema::v0::LessEqual *>(value()) : nullptr;
  }
  const mindspore::schema::v0::GreaterEqual *value_as_GreaterEqual() const {
    return value_type() == mindspore::schema::v0::PrimitiveType_GreaterEqual ? static_cast<const mindspore::schema::v0::GreaterEqual *>(value()) : nullptr;
  }
  const mindspore::schema::v0::Min *value_as_Min() const {
    return value_type() == mindspore::schema::v0::PrimitiveType_Min ? static_cast<const mindspore::schema::v0::Min *>(value()) : nullptr;
  }
  const mindspore::schema::v0::Floor *value_as_Floor() const {
    return value_type() == mindspore::schema::v0::PrimitiveType_Floor ? static_cast<const mindspore::schema::v0::Floor *>(value()) : nullptr;
  }
  const mindspore::schema::v0::Abs *value_as_Abs() const {
    return value_type() == mindspore::schema::v0::PrimitiveType_Abs ? static_cast<const mindspore::schema::v0::Abs *>(value()) : nullptr;
  }
  const mindspore::schema::v0::Neg *value_as_Neg() const {
    return value_type() == mindspore::schema::v0::PrimitiveType_Neg ? static_cast<const mindspore::schema::v0::Neg *>(value()) : nullptr;
  }
  const mindspore::schema::v0::Cos *value_as_Cos() const {
    return value_type() == mindspore::schema::v0::PrimitiveType_Cos ? static_cast<const mindspore::schema::v0::Cos *>(value()) : nullptr;
  }
  const mindspore::schema::v0::Sin *value_as_Sin() const {
    return value_type() == mindspore::schema::v0::PrimitiveType_Sin ? static_cast<const mindspore::schema::v0::Sin *>(value()) : nullptr;
  }
  const mindspore::schema::v0::Sqrt *value_as_Sqrt() const {
    return value_type() == mindspore::schema::v0::PrimitiveType_Sqrt ? static_cast<const mindspore::schema::v0::Sqrt *>(value()) : nullptr;
  }
  const mindspore::schema::v0::Square *value_as_Square() const {
    return value_type() == mindspore::schema::v0::PrimitiveType_Square ? static_cast<const mindspore::schema::v0::Square *>(value()) : nullptr;
  }
  const mindspore::schema::v0::Constant *value_as_Constant() const {
    return value_type() == mindspore::schema::v0::PrimitiveType_Constant ? static_cast<const mindspore::schema::v0::Constant *>(value()) : nullptr;
  }
  const mindspore::schema::v0::Log *value_as_Log() const {
    return value_type() == mindspore::schema::v0::PrimitiveType_Log ? static_cast<const mindspore::schema::v0::Log *>(value()) : nullptr;
  }
  const mindspore::schema::v0::Tan *value_as_Tan() const {
    return value_type() == mindspore::schema::v0::PrimitiveType_Tan ? static_cast<const mindspore::schema::v0::Tan *>(value()) : nullptr;
  }
  const mindspore::schema::v0::Atan *value_as_Atan() const {
    return value_type() == mindspore::schema::v0::PrimitiveType_Atan ? static_cast<const mindspore::schema::v0::Atan *>(value()) : nullptr;
  }
  const mindspore::schema::v0::Asin *value_as_Asin() const {
    return value_type() == mindspore::schema::v0::PrimitiveType_Asin ? static_cast<const mindspore::schema::v0::Asin *>(value()) : nullptr;
  }
  const mindspore::schema::v0::Clip *value_as_Clip() const {
    return value_type() == mindspore::schema::v0::PrimitiveType_Clip ? static_cast<const mindspore::schema::v0::Clip *>(value()) : nullptr;
  }
  const mindspore::schema::v0::Transpose *value_as_Transpose() const {
    return value_type() == mindspore::schema::v0::PrimitiveType_Transpose ? static_cast<const mindspore::schema::v0::Transpose *>(value()) : nullptr;
  }
  const mindspore::schema::v0::Squeeze *value_as_Squeeze() const {
    return value_type() == mindspore::schema::v0::PrimitiveType_Squeeze ? static_cast<const mindspore::schema::v0::Squeeze *>(value()) : nullptr;
  }
  const mindspore::schema::v0::Unsqueeze *value_as_Unsqueeze() const {
    return value_type() == mindspore::schema::v0::PrimitiveType_Unsqueeze ? static_cast<const mindspore::schema::v0::Unsqueeze *>(value()) : nullptr;
  }
  const mindspore::schema::v0::Upsample *value_as_Upsample() const {
    return value_type() == mindspore::schema::v0::PrimitiveType_Upsample ? static_cast<const mindspore::schema::v0::Upsample *>(value()) : nullptr;
  }
  const mindspore::schema::v0::Dropout *value_as_Dropout() const {
    return value_type() == mindspore::schema::v0::PrimitiveType_Dropout ? static_cast<const mindspore::schema::v0::Dropout *>(value()) : nullptr;
  }
  const mindspore::schema::v0::Broadcast *value_as_Broadcast() const {
    return value_type() == mindspore::schema::v0::PrimitiveType_Broadcast ? static_cast<const mindspore::schema::v0::Broadcast *>(value()) : nullptr;
  }
  const mindspore::schema::v0::BroadcastTo *value_as_BroadcastTo() const {
    return value_type() == mindspore::schema::v0::PrimitiveType_BroadcastTo ? static_cast<const mindspore::schema::v0::BroadcastTo *>(value()) : nullptr;
  }
  const mindspore::schema::v0::Lrn *value_as_Lrn() const {
    return value_type() == mindspore::schema::v0::PrimitiveType_Lrn ? static_cast<const mindspore::schema::v0::Lrn *>(value()) : nullptr;
  }
  const mindspore::schema::v0::ZerosLike *value_as_ZerosLike() const {
    return value_type() == mindspore::schema::v0::PrimitiveType_ZerosLike ? static_cast<const mindspore::schema::v0::ZerosLike *>(value()) : nullptr;
  }
  const mindspore::schema::v0::TopK *value_as_TopK() const {
    return value_type() == mindspore::schema::v0::PrimitiveType_TopK ? static_cast<const mindspore::schema::v0::TopK *>(value()) : nullptr;
  }
  const mindspore::schema::v0::SpaceToDepth *value_as_SpaceToDepth() const {
    return value_type() == mindspore::schema::v0::PrimitiveType_SpaceToDepth ? static_cast<const mindspore::schema::v0::SpaceToDepth *>(value()) : nullptr;
  }
  const mindspore::schema::v0::SpaceToBatch *value_as_SpaceToBatch() const {
    return value_type() == mindspore::schema::v0::PrimitiveType_SpaceToBatch ? static_cast<const mindspore::schema::v0::SpaceToBatch *>(value()) : nullptr;
  }
  const mindspore::schema::v0::SparseToDense *value_as_SparseToDense() const {
    return value_type() == mindspore::schema::v0::PrimitiveType_SparseToDense ? static_cast<const mindspore::schema::v0::SparseToDense *>(value()) : nullptr;
  }
  const mindspore::schema::v0::ReverseSequence *value_as_ReverseSequence() const {
    return value_type() == mindspore::schema::v0::PrimitiveType_ReverseSequence ? static_cast<const mindspore::schema::v0::ReverseSequence *>(value()) : nullptr;
  }
  const mindspore::schema::v0::Rank *value_as_Rank() const {
    return value_type() == mindspore::schema::v0::PrimitiveType_Rank ? static_cast<const mindspore::schema::v0::Rank *>(value()) : nullptr;
  }
  const mindspore::schema::v0::Gather *value_as_Gather() const {
    return value_type() == mindspore::schema::v0::PrimitiveType_Gather ? static_cast<const mindspore::schema::v0::Gather *>(value()) : nullptr;
  }
  const mindspore::schema::v0::GatherNd *value_as_GatherNd() const {
    return value_type() == mindspore::schema::v0::PrimitiveType_GatherNd ? static_cast<const mindspore::schema::v0::GatherNd *>(value()) : nullptr;
  }
  const mindspore::schema::v0::Fill *value_as_Fill() const {
    return value_type() == mindspore::schema::v0::PrimitiveType_Fill ? static_cast<const mindspore::schema::v0::Fill *>(value()) : nullptr;
  }
  const mindspore::schema::v0::Elu *value_as_Elu() const {
    return value_type() == mindspore::schema::v0::PrimitiveType_Elu ? static_cast<const mindspore::schema::v0::Elu *>(value()) : nullptr;
  }
  const mindspore::schema::v0::DepthToSpace *value_as_DepthToSpace() const {
    return value_type() == mindspore::schema::v0::PrimitiveType_DepthToSpace ? static_cast<const mindspore::schema::v0::DepthToSpace *>(value()) : nullptr;
  }
  const mindspore::schema::v0::BatchToSpace *value_as_BatchToSpace() const {
    return value_type() == mindspore::schema::v0::PrimitiveType_BatchToSpace ? static_cast<const mindspore::schema::v0::BatchToSpace *>(value()) : nullptr;
  }
  const mindspore::schema::v0::AddN *value_as_AddN() const {
    return value_type() == mindspore::schema::v0::PrimitiveType_AddN ? static_cast<const mindspore::schema::v0::AddN *>(value()) : nullptr;
  }
  const mindspore::schema::v0::Ceil *value_as_Ceil() const {
    return value_type() == mindspore::schema::v0::PrimitiveType_Ceil ? static_cast<const mindspore::schema::v0::Ceil *>(value()) : nullptr;
  }
  const mindspore::schema::v0::EmbeddingLookup *value_as_EmbeddingLookup() const {
    return value_type() == mindspore::schema::v0::PrimitiveType_EmbeddingLookup ? static_cast<const mindspore::schema::v0::EmbeddingLookup *>(value()) : nullptr;
  }
  const mindspore::schema::v0::EmbeddingLookupSparse *value_as_EmbeddingLookupSparse() const {
    return value_type() == mindspore::schema::v0::PrimitiveType_EmbeddingLookupSparse ? static_cast<const mindspore::schema::v0::EmbeddingLookupSparse *>(value()) : nullptr;
  }
  const mindspore::schema::v0::FloorDiv *value_as_FloorDiv() const {
    return value_type() == mindspore::schema::v0::PrimitiveType_FloorDiv ? static_cast<const mindspore::schema::v0::FloorDiv *>(value()) : nullptr;
  }
  const mindspore::schema::v0::FloorMod *value_as_FloorMod() const {
    return value_type() == mindspore::schema::v0::PrimitiveType_FloorMod ? static_cast<const mindspore::schema::v0::FloorMod *>(value()) : nullptr;
  }
  const mindspore::schema::v0::L2Norm *value_as_L2Norm() const {
    return value_type() == mindspore::schema::v0::PrimitiveType_L2Norm ? static_cast<const mindspore::schema::v0::L2Norm *>(value()) : nullptr;
  }
  const mindspore::schema::v0::LocalResponseNormalization *value_as_LocalResponseNormalization() const {
    return value_type() == mindspore::schema::v0::PrimitiveType_LocalResponseNormalization ? static_cast<const mindspore::schema::v0::LocalResponseNormalization *>(value()) : nullptr;
  }
  const mindspore::schema::v0::MatrixDiag *value_as_MatrixDiag() const {
    return value_type() == mindspore::schema::v0::PrimitiveType_MatrixDiag ? static_cast<const mindspore::schema::v0::MatrixDiag *>(value()) : nullptr;
  }
  const mindspore::schema::v0::Reduce *value_as_Reduce() const {
    return value_type() == mindspore::schema::v0::PrimitiveType_Reduce ? static_cast<const mindspore::schema::v0::Reduce *>(value()) : nullptr;
  }
  const mindspore::schema::v0::Reverse *value_as_Reverse() const {
    return value_type() == mindspore::schema::v0::PrimitiveType_Reverse ? static_cast<const mindspore::schema::v0::Reverse *>(value()) : nullptr;
  }
  const mindspore::schema::v0::Round *value_as_Round() const {
    return value_type() == mindspore::schema::v0::PrimitiveType_Round ? static_cast<const mindspore::schema::v0::Round *>(value()) : nullptr;
  }
  const mindspore::schema::v0::Select *value_as_Select() const {
    return value_type() == mindspore::schema::v0::PrimitiveType_Select ? static_cast<const mindspore::schema::v0::Select *>(value()) : nullptr;
  }
  const mindspore::schema::v0::Scatter *value_as_Scatter() const {
    return value_type() == mindspore::schema::v0::PrimitiveType_Scatter ? static_cast<const mindspore::schema::v0::Scatter *>(value()) : nullptr;
  }
  const mindspore::schema::v0::ScatterND *value_as_ScatterND() const {
    return value_type() == mindspore::schema::v0::PrimitiveType_ScatterND ? static_cast<const mindspore::schema::v0::ScatterND *>(value()) : nullptr;
  }
  const mindspore::schema::v0::ConstantOfShape *value_as_ConstantOfShape() const {
    return value_type() == mindspore::schema::v0::PrimitiveType_ConstantOfShape ? static_cast<const mindspore::schema::v0::ConstantOfShape *>(value()) : nullptr;
  }
  const mindspore::schema::v0::Unique *value_as_Unique() const {
    return value_type() == mindspore::schema::v0::PrimitiveType_Unique ? static_cast<const mindspore::schema::v0::Unique *>(value()) : nullptr;
  }
  const mindspore::schema::v0::Unstack *value_as_Unstack() const {
    return value_type() == mindspore::schema::v0::PrimitiveType_Unstack ? static_cast<const mindspore::schema::v0::Unstack *>(value()) : nullptr;
  }
  const mindspore::schema::v0::LogicalAnd *value_as_LogicalAnd() const {
    return value_type() == mindspore::schema::v0::PrimitiveType_LogicalAnd ? static_cast<const mindspore::schema::v0::LogicalAnd *>(value()) : nullptr;
  }
  const mindspore::schema::v0::LogicalOr *value_as_LogicalOr() const {
    return value_type() == mindspore::schema::v0::PrimitiveType_LogicalOr ? static_cast<const mindspore::schema::v0::LogicalOr *>(value()) : nullptr;
  }
  const mindspore::schema::v0::LogicalXor *value_as_LogicalXor() const {
    return value_type() == mindspore::schema::v0::PrimitiveType_LogicalXor ? static_cast<const mindspore::schema::v0::LogicalXor *>(value()) : nullptr;
  }
  const mindspore::schema::v0::LogicalNot *value_as_LogicalNot() const {
    return value_type() == mindspore::schema::v0::PrimitiveType_LogicalNot ? static_cast<const mindspore::schema::v0::LogicalNot *>(value()) : nullptr;
  }
  const mindspore::schema::v0::OnnxInt8Quantize *value_as_OnnxInt8Quantize() const {
    return value_type() == mindspore::schema::v0::PrimitiveType_OnnxInt8Quantize ? static_cast<const mindspore::schema::v0::OnnxInt8Quantize *>(value()) : nullptr;
  }
  const mindspore::schema::v0::OnnxInt8Dequantize *value_as_OnnxInt8Dequantize() const {
    return value_type() == mindspore::schema::v0::PrimitiveType_OnnxInt8Dequantize ? static_cast<const mindspore::schema::v0::OnnxInt8Dequantize *>(value()) : nullptr;
  }
  const mindspore::schema::v0::FakeQuantWithMinMax *value_as_FakeQuantWithMinMax() const {
    return value_type() == mindspore::schema::v0::PrimitiveType_FakeQuantWithMinMax ? static_cast<const mindspore::schema::v0::FakeQuantWithMinMax *>(value()) : nullptr;
  }
  const mindspore::schema::v0::FakeQuantWithMinMaxPerChannel *value_as_FakeQuantWithMinMaxPerChannel() const {
    return value_type() == mindspore::schema::v0::PrimitiveType_FakeQuantWithMinMaxPerChannel ? static_cast<const mindspore::schema::v0::FakeQuantWithMinMaxPerChannel *>(value()) : nullptr;
  }
  const mindspore::schema::v0::BatchNormFold *value_as_BatchNormFold() const {
    return value_type() == mindspore::schema::v0::PrimitiveType_BatchNormFold ? static_cast<const mindspore::schema::v0::BatchNormFold *>(value()) : nullptr;
  }
  const mindspore::schema::v0::MulFold *value_as_MulFold() const {
    return value_type() == mindspore::schema::v0::PrimitiveType_MulFold ? static_cast<const mindspore::schema::v0::MulFold *>(value()) : nullptr;
  }
  const mindspore::schema::v0::AddFold *value_as_AddFold() const {
    return value_type() == mindspore::schema::v0::PrimitiveType_AddFold ? static_cast<const mindspore::schema::v0::AddFold *>(value()) : nullptr;
  }
  const mindspore::schema::v0::SquaredDifference *value_as_SquaredDifference() const {
    return value_type() == mindspore::schema::v0::PrimitiveType_SquaredDifference ? static_cast<const mindspore::schema::v0::SquaredDifference *>(value()) : nullptr;
  }
  const mindspore::schema::v0::Flatten *value_as_Flatten() const {
    return value_type() == mindspore::schema::v0::PrimitiveType_Flatten ? static_cast<const mindspore::schema::v0::Flatten *>(value()) : nullptr;
  }
  const mindspore::schema::v0::FlattenGrad *value_as_FlattenGrad() const {
    return value_type() == mindspore::schema::v0::PrimitiveType_FlattenGrad ? static_cast<const mindspore::schema::v0::FlattenGrad *>(value()) : nullptr;
  }
  const mindspore::schema::v0::TupleGetItem *value_as_TupleGetItem() const {
    return value_type() == mindspore::schema::v0::PrimitiveType_TupleGetItem ? static_cast<const mindspore::schema::v0::TupleGetItem *>(value()) : nullptr;
  }
  const mindspore::schema::v0::Div *value_as_Div() const {
    return value_type() == mindspore::schema::v0::PrimitiveType_Div ? static_cast<const mindspore::schema::v0::Div *>(value()) : nullptr;
  }
  const mindspore::schema::v0::Where *value_as_Where() const {
    return value_type() == mindspore::schema::v0::PrimitiveType_Where ? static_cast<const mindspore::schema::v0::Where *>(value()) : nullptr;
  }
  const mindspore::schema::v0::OneHot *value_as_OneHot() const {
    return value_type() == mindspore::schema::v0::PrimitiveType_OneHot ? static_cast<const mindspore::schema::v0::OneHot *>(value()) : nullptr;
  }
  const mindspore::schema::v0::Lstm *value_as_Lstm() const {
    return value_type() == mindspore::schema::v0::PrimitiveType_Lstm ? static_cast<const mindspore::schema::v0::Lstm *>(value()) : nullptr;
  }
  const mindspore::schema::v0::Conv2DGradFilter *value_as_Conv2DGradFilter() const {
    return value_type() == mindspore::schema::v0::PrimitiveType_Conv2DGradFilter ? static_cast<const mindspore::schema::v0::Conv2DGradFilter *>(value()) : nullptr;
  }
  const mindspore::schema::v0::Conv2DGradInput *value_as_Conv2DGradInput() const {
    return value_type() == mindspore::schema::v0::PrimitiveType_Conv2DGradInput ? static_cast<const mindspore::schema::v0::Conv2DGradInput *>(value()) : nullptr;
  }
  const mindspore::schema::v0::PoolingGrad *value_as_PoolingGrad() const {
    return value_type() == mindspore::schema::v0::PrimitiveType_PoolingGrad ? static_cast<const mindspore::schema::v0::PoolingGrad *>(value()) : nullptr;
  }
  const mindspore::schema::v0::BNGrad *value_as_BNGrad() const {
    return value_type() == mindspore::schema::v0::PrimitiveType_BNGrad ? static_cast<const mindspore::schema::v0::BNGrad *>(value()) : nullptr;
  }
  const mindspore::schema::v0::Assign *value_as_Assign() const {
    return value_type() == mindspore::schema::v0::PrimitiveType_Assign ? static_cast<const mindspore::schema::v0::Assign *>(value()) : nullptr;
  }
  const mindspore::schema::v0::ApplyMomentum *value_as_ApplyMomentum() const {
    return value_type() == mindspore::schema::v0::PrimitiveType_ApplyMomentum ? static_cast<const mindspore::schema::v0::ApplyMomentum *>(value()) : nullptr;
  }
  const mindspore::schema::v0::BiasGrad *value_as_BiasGrad() const {
    return value_type() == mindspore::schema::v0::PrimitiveType_BiasGrad ? static_cast<const mindspore::schema::v0::BiasGrad *>(value()) : nullptr;
  }
  const mindspore::schema::v0::SoftmaxCrossEntropy *value_as_SoftmaxCrossEntropy() const {
    return value_type() == mindspore::schema::v0::PrimitiveType_SoftmaxCrossEntropy ? static_cast<const mindspore::schema::v0::SoftmaxCrossEntropy *>(value()) : nullptr;
  }
  const mindspore::schema::v0::AddGrad *value_as_AddGrad() const {
    return value_type() == mindspore::schema::v0::PrimitiveType_AddGrad ? static_cast<const mindspore::schema::v0::AddGrad *>(value()) : nullptr;
  }
  const mindspore::schema::v0::SubGrad *value_as_SubGrad() const {
    return value_type() == mindspore::schema::v0::PrimitiveType_SubGrad ? static_cast<const mindspore::schema::v0::SubGrad *>(value()) : nullptr;
  }
  const mindspore::schema::v0::MulGrad *value_as_MulGrad() const {
    return value_type() == mindspore::schema::v0::PrimitiveType_MulGrad ? static_cast<const mindspore::schema::v0::MulGrad *>(value()) : nullptr;
  }
  const mindspore::schema::v0::DivGrad *value_as_DivGrad() const {
    return value_type() == mindspore::schema::v0::PrimitiveType_DivGrad ? static_cast<const mindspore::schema::v0::DivGrad *>(value()) : nullptr;
  }
  const mindspore::schema::v0::PowerGrad *value_as_PowerGrad() const {
    return value_type() == mindspore::schema::v0::PrimitiveType_PowerGrad ? static_cast<const mindspore::schema::v0::PowerGrad *>(value()) : nullptr;
  }
  const mindspore::schema::v0::ActivationGrad *value_as_ActivationGrad() const {
    return value_type() == mindspore::schema::v0::PrimitiveType_ActivationGrad ? static_cast<const mindspore::schema::v0::ActivationGrad *>(value()) : nullptr;
  }
  const mindspore::schema::v0::PriorBox *value_as_PriorBox() const {
    return value_type() == mindspore::schema::v0::PrimitiveType_PriorBox ? static_cast<const mindspore::schema::v0::PriorBox *>(value()) : nullptr;
  }
  const mindspore::schema::v0::SpaceToBatchND *value_as_SpaceToBatchND() const {
    return value_type() == mindspore::schema::v0::PrimitiveType_SpaceToBatchND ? static_cast<const mindspore::schema::v0::SpaceToBatchND *>(value()) : nullptr;
  }
  const mindspore::schema::v0::Depend *value_as_Depend() const {
    return value_type() == mindspore::schema::v0::PrimitiveType_Depend ? static_cast<const mindspore::schema::v0::Depend *>(value()) : nullptr;
  }
  const mindspore::schema::v0::Return *value_as_Return() const {
    return value_type() == mindspore::schema::v0::PrimitiveType_Return ? static_cast<const mindspore::schema::v0::Return *>(value()) : nullptr;
  }
  const mindspore::schema::v0::MakeTuple *value_as_MakeTuple() const {
    return value_type() == mindspore::schema::v0::PrimitiveType_MakeTuple ? static_cast<const mindspore::schema::v0::MakeTuple *>(value()) : nullptr;
  }
  const mindspore::schema::v0::ToFormat *value_as_ToFormat() const {
    return value_type() == mindspore::schema::v0::PrimitiveType_ToFormat ? static_cast<const mindspore::schema::v0::ToFormat *>(value()) : nullptr;
  }
  const mindspore::schema::v0::Proposal *value_as_Proposal() const {
    return value_type() == mindspore::schema::v0::PrimitiveType_Proposal ? static_cast<const mindspore::schema::v0::Proposal *>(value()) : nullptr;
  }
  const mindspore::schema::v0::Custom *value_as_Custom() const {
    return value_type() == mindspore::schema::v0::PrimitiveType_Custom ? static_cast<const mindspore::schema::v0::Custom *>(value()) : nullptr;
  }
  const mindspore::schema::v0::BlackBox *value_as_BlackBox() const {
    return value_type() == mindspore::schema::v0::PrimitiveType_BlackBox ? static_cast<const mindspore::schema::v0::BlackBox *>(value()) : nullptr;
  }
  const mindspore::schema::v0::NegGrad *value_as_NegGrad() const {
    return value_type() == mindspore::schema::v0::PrimitiveType_NegGrad ? static_cast<const mindspore::schema::v0::NegGrad *>(value()) : nullptr;
  }
  const mindspore::schema::v0::LogGrad *value_as_LogGrad() const {
    return value_type() == mindspore::schema::v0::PrimitiveType_LogGrad ? static_cast<const mindspore::schema::v0::LogGrad *>(value()) : nullptr;
  }
  const mindspore::schema::v0::BatchToSpaceND *value_as_BatchToSpaceND() const {
    return value_type() == mindspore::schema::v0::PrimitiveType_BatchToSpaceND ? static_cast<const mindspore::schema::v0::BatchToSpaceND *>(value()) : nullptr;
  }
  const mindspore::schema::v0::LshProjection *value_as_LshProjection() const {
    return value_type() == mindspore::schema::v0::PrimitiveType_LshProjection ? static_cast<const mindspore::schema::v0::LshProjection *>(value()) : nullptr;
  }
  const mindspore::schema::v0::HashtableLookup *value_as_HashtableLookup() const {
    return value_type() == mindspore::schema::v0::PrimitiveType_HashtableLookup ? static_cast<const mindspore::schema::v0::HashtableLookup *>(value()) : nullptr;
  }
  const mindspore::schema::v0::SkipGram *value_as_SkipGram() const {
    return value_type() == mindspore::schema::v0::PrimitiveType_SkipGram ? static_cast<const mindspore::schema::v0::SkipGram *>(value()) : nullptr;
  }
  const mindspore::schema::v0::DeConv2DGradFilter *value_as_DeConv2DGradFilter() const {
    return value_type() == mindspore::schema::v0::PrimitiveType_DeConv2DGradFilter ? static_cast<const mindspore::schema::v0::DeConv2DGradFilter *>(value()) : nullptr;
  }
  const mindspore::schema::v0::CustomPredict *value_as_CustomPredict() const {
    return value_type() == mindspore::schema::v0::PrimitiveType_CustomPredict ? static_cast<const mindspore::schema::v0::CustomPredict *>(value()) : nullptr;
  }
  const mindspore::schema::v0::CustomNormalize *value_as_CustomNormalize() const {
    return value_type() == mindspore::schema::v0::PrimitiveType_CustomNormalize ? static_cast<const mindspore::schema::v0::CustomNormalize *>(value()) : nullptr;
  }
  const mindspore::schema::v0::CustomExtractFeatures *value_as_CustomExtractFeatures() const {
    return value_type() == mindspore::schema::v0::PrimitiveType_CustomExtractFeatures ? static_cast<const mindspore::schema::v0::CustomExtractFeatures *>(value()) : nullptr;
  }
  const mindspore::schema::v0::AudioSpectrogram *value_as_AudioSpectrogram() const {
    return value_type() == mindspore::schema::v0::PrimitiveType_AudioSpectrogram ? static_cast<const mindspore::schema::v0::AudioSpectrogram *>(value()) : nullptr;
  }
  const mindspore::schema::v0::Mfcc *value_as_Mfcc() const {
    return value_type() == mindspore::schema::v0::PrimitiveType_Mfcc ? static_cast<const mindspore::schema::v0::Mfcc *>(value()) : nullptr;
  }
  const mindspore::schema::v0::Rfft *value_as_Rfft() const {
    return value_type() == mindspore::schema::v0::PrimitiveType_Rfft ? static_cast<const mindspore::schema::v0::Rfft *>(value()) : nullptr;
  }
  const mindspore::schema::v0::FftReal *value_as_FftReal() const {
    return value_type() == mindspore::schema::v0::PrimitiveType_FftReal ? static_cast<const mindspore::schema::v0::FftReal *>(value()) : nullptr;
  }
  const mindspore::schema::v0::FftImag *value_as_FftImag() const {
    return value_type() == mindspore::schema::v0::PrimitiveType_FftImag ? static_cast<const mindspore::schema::v0::FftImag *>(value()) : nullptr;
  }
  const mindspore::schema::v0::Sgd *value_as_Sgd() const {
    return value_type() == mindspore::schema::v0::PrimitiveType_Sgd ? static_cast<const mindspore::schema::v0::Sgd *>(value()) : nullptr;
  }
  const mindspore::schema::v0::Adam *value_as_Adam() const {
    return value_type() == mindspore::schema::v0::PrimitiveType_Adam ? static_cast<const mindspore::schema::v0::Adam *>(value()) : nullptr;
  }
  const mindspore::schema::v0::GroupConv2DGradInput *value_as_GroupConv2DGradInput() const {
    return value_type() == mindspore::schema::v0::PrimitiveType_GroupConv2DGradInput ? static_cast<const mindspore::schema::v0::GroupConv2DGradInput *>(value()) : nullptr;
  }
  const mindspore::schema::v0::Loop *value_as_Loop() const {
    return value_type() == mindspore::schema::v0::PrimitiveType_Loop ? static_cast<const mindspore::schema::v0::Loop *>(value()) : nullptr;
  }
  const mindspore::schema::v0::NonMaxSuppression *value_as_NonMaxSuppression() const {
    return value_type() == mindspore::schema::v0::PrimitiveType_NonMaxSuppression ? static_cast<const mindspore::schema::v0::NonMaxSuppression *>(value()) : nullptr;
  }
  const mindspore::schema::v0::InstanceNorm *value_as_InstanceNorm() const {
    return value_type() == mindspore::schema::v0::PrimitiveType_InstanceNorm ? static_cast<const mindspore::schema::v0::InstanceNorm *>(value()) : nullptr;
  }
  const mindspore::schema::v0::Identity *value_as_Identity() const {
    return value_type() == mindspore::schema::v0::PrimitiveType_Identity ? static_cast<const mindspore::schema::v0::Identity *>(value()) : nullptr;
  }
  const mindspore::schema::v0::LayerNorm *value_as_LayerNorm() const {
    return value_type() == mindspore::schema::v0::PrimitiveType_LayerNorm ? static_cast<const mindspore::schema::v0::LayerNorm *>(value()) : nullptr;
  }
  const mindspore::schema::v0::While *value_as_While() const {
    return value_type() == mindspore::schema::v0::PrimitiveType_While ? static_cast<const mindspore::schema::v0::While *>(value()) : nullptr;
  }
  const mindspore::schema::v0::ControlDepend *value_as_ControlDepend() const {
    return value_type() == mindspore::schema::v0::PrimitiveType_ControlDepend ? static_cast<const mindspore::schema::v0::ControlDepend *>(value()) : nullptr;
  }
  const mindspore::schema::v0::UnsortedSegmentSum *value_as_UnsortedSegmentSum() const {
    return value_type() == mindspore::schema::v0::PrimitiveType_UnsortedSegmentSum ? static_cast<const mindspore::schema::v0::UnsortedSegmentSum *>(value()) : nullptr;
  }
  const mindspore::schema::v0::AssignAdd *value_as_AssignAdd() const {
    return value_type() == mindspore::schema::v0::PrimitiveType_AssignAdd ? static_cast<const mindspore::schema::v0::AssignAdd *>(value()) : nullptr;
  }
  const mindspore::schema::v0::OnesLike *value_as_OnesLike() const {
    return value_type() == mindspore::schema::v0::PrimitiveType_OnesLike ? static_cast<const mindspore::schema::v0::OnesLike *>(value()) : nullptr;
  }
  const mindspore::schema::v0::BinaryCrossEntropyGrad *value_as_BinaryCrossEntropyGrad() const {
    return value_type() == mindspore::schema::v0::PrimitiveType_BinaryCrossEntropyGrad ? static_cast<const mindspore::schema::v0::BinaryCrossEntropyGrad *>(value()) : nullptr;
  }
  const mindspore::schema::v0::BinaryCrossEntropy *value_as_BinaryCrossEntropy() const {
    return value_type() == mindspore::schema::v0::PrimitiveType_BinaryCrossEntropy ? static_cast<const mindspore::schema::v0::BinaryCrossEntropy *>(value()) : nullptr;
  }
  const mindspore::schema::v0::LpNormalization *value_as_LpNormalization() const {
    return value_type() == mindspore::schema::v0::PrimitiveType_LpNormalization ? static_cast<const mindspore::schema::v0::LpNormalization *>(value()) : nullptr;
  }
  const mindspore::schema::v0::DropoutGrad *value_as_DropoutGrad() const {
    return value_type() == mindspore::schema::v0::PrimitiveType_DropoutGrad ? static_cast<const mindspore::schema::v0::DropoutGrad *>(value()) : nullptr;
  }
  const mindspore::schema::v0::MaximumGrad *value_as_MaximumGrad() const {
    return value_type() == mindspore::schema::v0::PrimitiveType_MaximumGrad ? static_cast<const mindspore::schema::v0::MaximumGrad *>(value()) : nullptr;
  }
  const mindspore::schema::v0::MinimumGrad *value_as_MinimumGrad() const {
    return value_type() == mindspore::schema::v0::PrimitiveType_MinimumGrad ? static_cast<const mindspore::schema::v0::MinimumGrad *>(value()) : nullptr;
  }
  const mindspore::schema::v0::Switch *value_as_Switch() const {
    return value_type() == mindspore::schema::v0::PrimitiveType_Switch ? static_cast<const mindspore::schema::v0::Switch *>(value()) : nullptr;
  }
  const mindspore::schema::v0::Partial *value_as_Partial() const {
    return value_type() == mindspore::schema::v0::PrimitiveType_Partial ? static_cast<const mindspore::schema::v0::Partial *>(value()) : nullptr;
  }
  const mindspore::schema::v0::TensorListFromTensor *value_as_TensorListFromTensor() const {
    return value_type() == mindspore::schema::v0::PrimitiveType_TensorListFromTensor ? static_cast<const mindspore::schema::v0::TensorListFromTensor *>(value()) : nullptr;
  }
  const mindspore::schema::v0::TensorListStack *value_as_TensorListStack() const {
    return value_type() == mindspore::schema::v0::PrimitiveType_TensorListStack ? static_cast<const mindspore::schema::v0::TensorListStack *>(value()) : nullptr;
  }
  const mindspore::schema::v0::TensorListGetItem *value_as_TensorListGetItem() const {
    return value_type() == mindspore::schema::v0::PrimitiveType_TensorListGetItem ? static_cast<const mindspore::schema::v0::TensorListGetItem *>(value()) : nullptr;
  }
  const mindspore::schema::v0::TensorListSetItem *value_as_TensorListSetItem() const {
    return value_type() == mindspore::schema::v0::PrimitiveType_TensorListSetItem ? static_cast<const mindspore::schema::v0::TensorListSetItem *>(value()) : nullptr;
  }
  const mindspore::schema::v0::TensorListReserve *value_as_TensorListReserve() const {
    return value_type() == mindspore::schema::v0::PrimitiveType_TensorListReserve ? static_cast<const mindspore::schema::v0::TensorListReserve *>(value()) : nullptr;
  }
  const mindspore::schema::v0::All *value_as_All() const {
    return value_type() == mindspore::schema::v0::PrimitiveType_All ? static_cast<const mindspore::schema::v0::All *>(value()) : nullptr;
  }
  const mindspore::schema::v0::Assert *value_as_Assert() const {
    return value_type() == mindspore::schema::v0::PrimitiveType_Assert ? static_cast<const mindspore::schema::v0::Assert *>(value()) : nullptr;
  }
  const mindspore::schema::v0::Adder *value_as_Adder() const {
    return value_type() == mindspore::schema::v0::PrimitiveType_Adder ? static_cast<const mindspore::schema::v0::Adder *>(value()) : nullptr;
  }
  const mindspore::schema::v0::SparseSoftmaxCrossEntropy *value_as_SparseSoftmaxCrossEntropy() const {
    return value_type() == mindspore::schema::v0::PrimitiveType_SparseSoftmaxCrossEntropy ? static_cast<const mindspore::schema::v0::SparseSoftmaxCrossEntropy *>(value()) : nullptr;
  }
  const mindspore::schema::v0::SmoothL1Loss *value_as_SmoothL1Loss() const {
    return value_type() == mindspore::schema::v0::PrimitiveType_SmoothL1Loss ? static_cast<const mindspore::schema::v0::SmoothL1Loss *>(value()) : nullptr;
  }
  const mindspore::schema::v0::SmoothL1LossGrad *value_as_SmoothL1LossGrad() const {
    return value_type() == mindspore::schema::v0::PrimitiveType_SmoothL1LossGrad ? static_cast<const mindspore::schema::v0::SmoothL1LossGrad *>(value()) : nullptr;
  }
  const mindspore::schema::v0::SigmoidCrossEntropyWithLogits *value_as_SigmoidCrossEntropyWithLogits() const {
    return value_type() == mindspore::schema::v0::PrimitiveType_SigmoidCrossEntropyWithLogits ? static_cast<const mindspore::schema::v0::SigmoidCrossEntropyWithLogits *>(value()) : nullptr;
  }
  const mindspore::schema::v0::SigmoidCrossEntropyWithLogitsGrad *value_as_SigmoidCrossEntropyWithLogitsGrad() const {
    return value_type() == mindspore::schema::v0::PrimitiveType_SigmoidCrossEntropyWithLogitsGrad ? static_cast<const mindspore::schema::v0::SigmoidCrossEntropyWithLogitsGrad *>(value()) : nullptr;
  }
  const mindspore::schema::v0::Reciprocal *value_as_Reciprocal() const {
    return value_type() == mindspore::schema::v0::PrimitiveType_Reciprocal ? static_cast<const mindspore::schema::v0::Reciprocal *>(value()) : nullptr;
  }
  const mindspore::schema::v0::Merge *value_as_Merge() const {
    return value_type() == mindspore::schema::v0::PrimitiveType_Merge ? static_cast<const mindspore::schema::v0::Merge *>(value()) : nullptr;
  }
  const mindspore::schema::v0::Mod *value_as_Mod() const {
    return value_type() == mindspore::schema::v0::PrimitiveType_Mod ? static_cast<const mindspore::schema::v0::Mod *>(value()) : nullptr;
  }
  const mindspore::schema::v0::GeLU *value_as_GeLU() const {
    return value_type() == mindspore::schema::v0::PrimitiveType_GeLU ? static_cast<const mindspore::schema::v0::GeLU *>(value()) : nullptr;
  }
  void *mutable_value() {
    return GetPointer<void *>(VT_VALUE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_VALUE_TYPE) &&
           VerifyOffset(verifier, VT_VALUE) &&
           VerifyPrimitiveType(verifier, value(), value_type()) &&
           verifier.EndTable();
  }
  PrimitiveT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(PrimitiveT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Primitive> Pack(flatbuffers::FlatBufferBuilder &_fbb, const PrimitiveT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

template<> inline const mindspore::schema::v0::Concat *Primitive::value_as<mindspore::schema::v0::Concat>() const {
  return value_as_Concat();
}

template<> inline const mindspore::schema::v0::SoftMax *Primitive::value_as<mindspore::schema::v0::SoftMax>() const {
  return value_as_SoftMax();
}

template<> inline const mindspore::schema::v0::Activation *Primitive::value_as<mindspore::schema::v0::Activation>() const {
  return value_as_Activation();
}

template<> inline const mindspore::schema::v0::Conv2D *Primitive::value_as<mindspore::schema::v0::Conv2D>() const {
  return value_as_Conv2D();
}

template<> inline const mindspore::schema::v0::FusedBatchNorm *Primitive::value_as<mindspore::schema::v0::FusedBatchNorm>() const {
  return value_as_FusedBatchNorm();
}

template<> inline const mindspore::schema::v0::BatchNorm *Primitive::value_as<mindspore::schema::v0::BatchNorm>() const {
  return value_as_BatchNorm();
}

template<> inline const mindspore::schema::v0::BiasAdd *Primitive::value_as<mindspore::schema::v0::BiasAdd>() const {
  return value_as_BiasAdd();
}

template<> inline const mindspore::schema::v0::Pooling *Primitive::value_as<mindspore::schema::v0::Pooling>() const {
  return value_as_Pooling();
}

template<> inline const mindspore::schema::v0::ROIPooling *Primitive::value_as<mindspore::schema::v0::ROIPooling>() const {
  return value_as_ROIPooling();
}

template<> inline const mindspore::schema::v0::DepthwiseConv2D *Primitive::value_as<mindspore::schema::v0::DepthwiseConv2D>() const {
  return value_as_DepthwiseConv2D();
}

template<> inline const mindspore::schema::v0::DeDepthwiseConv2D *Primitive::value_as<mindspore::schema::v0::DeDepthwiseConv2D>() const {
  return value_as_DeDepthwiseConv2D();
}

template<> inline const mindspore::schema::v0::Resize *Primitive::value_as<mindspore::schema::v0::Resize>() const {
  return value_as_Resize();
}

template<> inline const mindspore::schema::v0::DetectionPostProcess *Primitive::value_as<mindspore::schema::v0::DetectionPostProcess>() const {
  return value_as_DetectionPostProcess();
}

template<> inline const mindspore::schema::v0::FullConnection *Primitive::value_as<mindspore::schema::v0::FullConnection>() const {
  return value_as_FullConnection();
}

template<> inline const mindspore::schema::v0::Mean *Primitive::value_as<mindspore::schema::v0::Mean>() const {
  return value_as_Mean();
}

template<> inline const mindspore::schema::v0::DeConv2D *Primitive::value_as<mindspore::schema::v0::DeConv2D>() const {
  return value_as_DeConv2D();
}

template<> inline const mindspore::schema::v0::Scale *Primitive::value_as<mindspore::schema::v0::Scale>() const {
  return value_as_Scale();
}

template<> inline const mindspore::schema::v0::Reshape *Primitive::value_as<mindspore::schema::v0::Reshape>() const {
  return value_as_Reshape();
}

template<> inline const mindspore::schema::v0::Eltwise *Primitive::value_as<mindspore::schema::v0::Eltwise>() const {
  return value_as_Eltwise();
}

template<> inline const mindspore::schema::v0::NetOutput *Primitive::value_as<mindspore::schema::v0::NetOutput>() const {
  return value_as_NetOutput();
}

template<> inline const mindspore::schema::v0::Add *Primitive::value_as<mindspore::schema::v0::Add>() const {
  return value_as_Add();
}

template<> inline const mindspore::schema::v0::Sub *Primitive::value_as<mindspore::schema::v0::Sub>() const {
  return value_as_Sub();
}

template<> inline const mindspore::schema::v0::MatMul *Primitive::value_as<mindspore::schema::v0::MatMul>() const {
  return value_as_MatMul();
}

template<> inline const mindspore::schema::v0::StridedSlice *Primitive::value_as<mindspore::schema::v0::StridedSlice>() const {
  return value_as_StridedSlice();
}

template<> inline const mindspore::schema::v0::Power *Primitive::value_as<mindspore::schema::v0::Power>() const {
  return value_as_Power();
}

template<> inline const mindspore::schema::v0::Slice *Primitive::value_as<mindspore::schema::v0::Slice>() const {
  return value_as_Slice();
}

template<> inline const mindspore::schema::v0::Stack *Primitive::value_as<mindspore::schema::v0::Stack>() const {
  return value_as_Stack();
}

template<> inline const mindspore::schema::v0::Mul *Primitive::value_as<mindspore::schema::v0::Mul>() const {
  return value_as_Mul();
}

template<> inline const mindspore::schema::v0::RealDiv *Primitive::value_as<mindspore::schema::v0::RealDiv>() const {
  return value_as_RealDiv();
}

template<> inline const mindspore::schema::v0::Pad *Primitive::value_as<mindspore::schema::v0::Pad>() const {
  return value_as_Pad();
}

template<> inline const mindspore::schema::v0::Maximum *Primitive::value_as<mindspore::schema::v0::Maximum>() const {
  return value_as_Maximum();
}

template<> inline const mindspore::schema::v0::Minimum *Primitive::value_as<mindspore::schema::v0::Minimum>() const {
  return value_as_Minimum();
}

template<> inline const mindspore::schema::v0::PReLU *Primitive::value_as<mindspore::schema::v0::PReLU>() const {
  return value_as_PReLU();
}

template<> inline const mindspore::schema::v0::LeakyReLU *Primitive::value_as<mindspore::schema::v0::LeakyReLU>() const {
  return value_as_LeakyReLU();
}

template<> inline const mindspore::schema::v0::ArgMax *Primitive::value_as<mindspore::schema::v0::ArgMax>() const {
  return value_as_ArgMax();
}

template<> inline const mindspore::schema::v0::ArgMin *Primitive::value_as<mindspore::schema::v0::ArgMin>() const {
  return value_as_ArgMin();
}

template<> inline const mindspore::schema::v0::Exp *Primitive::value_as<mindspore::schema::v0::Exp>() const {
  return value_as_Exp();
}

template<> inline const mindspore::schema::v0::Crop *Primitive::value_as<mindspore::schema::v0::Crop>() const {
  return value_as_Crop();
}

template<> inline const mindspore::schema::v0::Range *Primitive::value_as<mindspore::schema::v0::Range>() const {
  return value_as_Range();
}

template<> inline const mindspore::schema::v0::Rsqrt *Primitive::value_as<mindspore::schema::v0::Rsqrt>() const {
  return value_as_Rsqrt();
}

template<> inline const mindspore::schema::v0::ExpandDims *Primitive::value_as<mindspore::schema::v0::ExpandDims>() const {
  return value_as_ExpandDims();
}

template<> inline const mindspore::schema::v0::Tile *Primitive::value_as<mindspore::schema::v0::Tile>() const {
  return value_as_Tile();
}

template<> inline const mindspore::schema::v0::Cast *Primitive::value_as<mindspore::schema::v0::Cast>() const {
  return value_as_Cast();
}

template<> inline const mindspore::schema::v0::Shape *Primitive::value_as<mindspore::schema::v0::Shape>() const {
  return value_as_Shape();
}

template<> inline const mindspore::schema::v0::Nchw2Nhwc *Primitive::value_as<mindspore::schema::v0::Nchw2Nhwc>() const {
  return value_as_Nchw2Nhwc();
}

template<> inline const mindspore::schema::v0::Nhwc2Nchw *Primitive::value_as<mindspore::schema::v0::Nhwc2Nchw>() const {
  return value_as_Nhwc2Nchw();
}

template<> inline const mindspore::schema::v0::QuantDTypeCast *Primitive::value_as<mindspore::schema::v0::QuantDTypeCast>() const {
  return value_as_QuantDTypeCast();
}

template<> inline const mindspore::schema::v0::Split *Primitive::value_as<mindspore::schema::v0::Split>() const {
  return value_as_Split();
}

template<> inline const mindspore::schema::v0::Permute *Primitive::value_as<mindspore::schema::v0::Permute>() const {
  return value_as_Permute();
}

template<> inline const mindspore::schema::v0::FakeQuantWithMinMaxVars *Primitive::value_as<mindspore::schema::v0::FakeQuantWithMinMaxVars>() const {
  return value_as_FakeQuantWithMinMaxVars();
}

template<> inline const mindspore::schema::v0::Equal *Primitive::value_as<mindspore::schema::v0::Equal>() const {
  return value_as_Equal();
}

template<> inline const mindspore::schema::v0::Less *Primitive::value_as<mindspore::schema::v0::Less>() const {
  return value_as_Less();
}

template<> inline const mindspore::schema::v0::Greater *Primitive::value_as<mindspore::schema::v0::Greater>() const {
  return value_as_Greater();
}

template<> inline const mindspore::schema::v0::NotEqual *Primitive::value_as<mindspore::schema::v0::NotEqual>() const {
  return value_as_NotEqual();
}

template<> inline const mindspore::schema::v0::LessEqual *Primitive::value_as<mindspore::schema::v0::LessEqual>() const {
  return value_as_LessEqual();
}

template<> inline const mindspore::schema::v0::GreaterEqual *Primitive::value_as<mindspore::schema::v0::GreaterEqual>() const {
  return value_as_GreaterEqual();
}

template<> inline const mindspore::schema::v0::Min *Primitive::value_as<mindspore::schema::v0::Min>() const {
  return value_as_Min();
}

template<> inline const mindspore::schema::v0::Floor *Primitive::value_as<mindspore::schema::v0::Floor>() const {
  return value_as_Floor();
}

template<> inline const mindspore::schema::v0::Abs *Primitive::value_as<mindspore::schema::v0::Abs>() const {
  return value_as_Abs();
}

template<> inline const mindspore::schema::v0::Neg *Primitive::value_as<mindspore::schema::v0::Neg>() const {
  return value_as_Neg();
}

template<> inline const mindspore::schema::v0::Cos *Primitive::value_as<mindspore::schema::v0::Cos>() const {
  return value_as_Cos();
}

template<> inline const mindspore::schema::v0::Sin *Primitive::value_as<mindspore::schema::v0::Sin>() const {
  return value_as_Sin();
}

template<> inline const mindspore::schema::v0::Sqrt *Primitive::value_as<mindspore::schema::v0::Sqrt>() const {
  return value_as_Sqrt();
}

template<> inline const mindspore::schema::v0::Square *Primitive::value_as<mindspore::schema::v0::Square>() const {
  return value_as_Square();
}

template<> inline const mindspore::schema::v0::Constant *Primitive::value_as<mindspore::schema::v0::Constant>() const {
  return value_as_Constant();
}

template<> inline const mindspore::schema::v0::Log *Primitive::value_as<mindspore::schema::v0::Log>() const {
  return value_as_Log();
}

template<> inline const mindspore::schema::v0::Tan *Primitive::value_as<mindspore::schema::v0::Tan>() const {
  return value_as_Tan();
}

template<> inline const mindspore::schema::v0::Atan *Primitive::value_as<mindspore::schema::v0::Atan>() const {
  return value_as_Atan();
}

template<> inline const mindspore::schema::v0::Asin *Primitive::value_as<mindspore::schema::v0::Asin>() const {
  return value_as_Asin();
}

template<> inline const mindspore::schema::v0::Clip *Primitive::value_as<mindspore::schema::v0::Clip>() const {
  return value_as_Clip();
}

template<> inline const mindspore::schema::v0::Transpose *Primitive::value_as<mindspore::schema::v0::Transpose>() const {
  return value_as_Transpose();
}

template<> inline const mindspore::schema::v0::Squeeze *Primitive::value_as<mindspore::schema::v0::Squeeze>() const {
  return value_as_Squeeze();
}

template<> inline const mindspore::schema::v0::Unsqueeze *Primitive::value_as<mindspore::schema::v0::Unsqueeze>() const {
  return value_as_Unsqueeze();
}

template<> inline const mindspore::schema::v0::Upsample *Primitive::value_as<mindspore::schema::v0::Upsample>() const {
  return value_as_Upsample();
}

template<> inline const mindspore::schema::v0::Dropout *Primitive::value_as<mindspore::schema::v0::Dropout>() const {
  return value_as_Dropout();
}

template<> inline const mindspore::schema::v0::Broadcast *Primitive::value_as<mindspore::schema::v0::Broadcast>() const {
  return value_as_Broadcast();
}

template<> inline const mindspore::schema::v0::BroadcastTo *Primitive::value_as<mindspore::schema::v0::BroadcastTo>() const {
  return value_as_BroadcastTo();
}

template<> inline const mindspore::schema::v0::Lrn *Primitive::value_as<mindspore::schema::v0::Lrn>() const {
  return value_as_Lrn();
}

template<> inline const mindspore::schema::v0::ZerosLike *Primitive::value_as<mindspore::schema::v0::ZerosLike>() const {
  return value_as_ZerosLike();
}

template<> inline const mindspore::schema::v0::TopK *Primitive::value_as<mindspore::schema::v0::TopK>() const {
  return value_as_TopK();
}

template<> inline const mindspore::schema::v0::SpaceToDepth *Primitive::value_as<mindspore::schema::v0::SpaceToDepth>() const {
  return value_as_SpaceToDepth();
}

template<> inline const mindspore::schema::v0::SpaceToBatch *Primitive::value_as<mindspore::schema::v0::SpaceToBatch>() const {
  return value_as_SpaceToBatch();
}

template<> inline const mindspore::schema::v0::SparseToDense *Primitive::value_as<mindspore::schema::v0::SparseToDense>() const {
  return value_as_SparseToDense();
}

template<> inline const mindspore::schema::v0::ReverseSequence *Primitive::value_as<mindspore::schema::v0::ReverseSequence>() const {
  return value_as_ReverseSequence();
}

template<> inline const mindspore::schema::v0::Rank *Primitive::value_as<mindspore::schema::v0::Rank>() const {
  return value_as_Rank();
}

template<> inline const mindspore::schema::v0::Gather *Primitive::value_as<mindspore::schema::v0::Gather>() const {
  return value_as_Gather();
}

template<> inline const mindspore::schema::v0::GatherNd *Primitive::value_as<mindspore::schema::v0::GatherNd>() const {
  return value_as_GatherNd();
}

template<> inline const mindspore::schema::v0::Fill *Primitive::value_as<mindspore::schema::v0::Fill>() const {
  return value_as_Fill();
}

template<> inline const mindspore::schema::v0::Elu *Primitive::value_as<mindspore::schema::v0::Elu>() const {
  return value_as_Elu();
}

template<> inline const mindspore::schema::v0::DepthToSpace *Primitive::value_as<mindspore::schema::v0::DepthToSpace>() const {
  return value_as_DepthToSpace();
}

template<> inline const mindspore::schema::v0::BatchToSpace *Primitive::value_as<mindspore::schema::v0::BatchToSpace>() const {
  return value_as_BatchToSpace();
}

template<> inline const mindspore::schema::v0::AddN *Primitive::value_as<mindspore::schema::v0::AddN>() const {
  return value_as_AddN();
}

template<> inline const mindspore::schema::v0::Ceil *Primitive::value_as<mindspore::schema::v0::Ceil>() const {
  return value_as_Ceil();
}

template<> inline const mindspore::schema::v0::EmbeddingLookup *Primitive::value_as<mindspore::schema::v0::EmbeddingLookup>() const {
  return value_as_EmbeddingLookup();
}

template<> inline const mindspore::schema::v0::EmbeddingLookupSparse *Primitive::value_as<mindspore::schema::v0::EmbeddingLookupSparse>() const {
  return value_as_EmbeddingLookupSparse();
}

template<> inline const mindspore::schema::v0::FloorDiv *Primitive::value_as<mindspore::schema::v0::FloorDiv>() const {
  return value_as_FloorDiv();
}

template<> inline const mindspore::schema::v0::FloorMod *Primitive::value_as<mindspore::schema::v0::FloorMod>() const {
  return value_as_FloorMod();
}

template<> inline const mindspore::schema::v0::L2Norm *Primitive::value_as<mindspore::schema::v0::L2Norm>() const {
  return value_as_L2Norm();
}

template<> inline const mindspore::schema::v0::LocalResponseNormalization *Primitive::value_as<mindspore::schema::v0::LocalResponseNormalization>() const {
  return value_as_LocalResponseNormalization();
}

template<> inline const mindspore::schema::v0::MatrixDiag *Primitive::value_as<mindspore::schema::v0::MatrixDiag>() const {
  return value_as_MatrixDiag();
}

template<> inline const mindspore::schema::v0::Reduce *Primitive::value_as<mindspore::schema::v0::Reduce>() const {
  return value_as_Reduce();
}

template<> inline const mindspore::schema::v0::Reverse *Primitive::value_as<mindspore::schema::v0::Reverse>() const {
  return value_as_Reverse();
}

template<> inline const mindspore::schema::v0::Round *Primitive::value_as<mindspore::schema::v0::Round>() const {
  return value_as_Round();
}

template<> inline const mindspore::schema::v0::Select *Primitive::value_as<mindspore::schema::v0::Select>() const {
  return value_as_Select();
}

template<> inline const mindspore::schema::v0::Scatter *Primitive::value_as<mindspore::schema::v0::Scatter>() const {
  return value_as_Scatter();
}

template<> inline const mindspore::schema::v0::ScatterND *Primitive::value_as<mindspore::schema::v0::ScatterND>() const {
  return value_as_ScatterND();
}

template<> inline const mindspore::schema::v0::ConstantOfShape *Primitive::value_as<mindspore::schema::v0::ConstantOfShape>() const {
  return value_as_ConstantOfShape();
}

template<> inline const mindspore::schema::v0::Unique *Primitive::value_as<mindspore::schema::v0::Unique>() const {
  return value_as_Unique();
}

template<> inline const mindspore::schema::v0::Unstack *Primitive::value_as<mindspore::schema::v0::Unstack>() const {
  return value_as_Unstack();
}

template<> inline const mindspore::schema::v0::LogicalAnd *Primitive::value_as<mindspore::schema::v0::LogicalAnd>() const {
  return value_as_LogicalAnd();
}

template<> inline const mindspore::schema::v0::LogicalOr *Primitive::value_as<mindspore::schema::v0::LogicalOr>() const {
  return value_as_LogicalOr();
}

template<> inline const mindspore::schema::v0::LogicalXor *Primitive::value_as<mindspore::schema::v0::LogicalXor>() const {
  return value_as_LogicalXor();
}

template<> inline const mindspore::schema::v0::LogicalNot *Primitive::value_as<mindspore::schema::v0::LogicalNot>() const {
  return value_as_LogicalNot();
}

template<> inline const mindspore::schema::v0::OnnxInt8Quantize *Primitive::value_as<mindspore::schema::v0::OnnxInt8Quantize>() const {
  return value_as_OnnxInt8Quantize();
}

template<> inline const mindspore::schema::v0::OnnxInt8Dequantize *Primitive::value_as<mindspore::schema::v0::OnnxInt8Dequantize>() const {
  return value_as_OnnxInt8Dequantize();
}

template<> inline const mindspore::schema::v0::FakeQuantWithMinMax *Primitive::value_as<mindspore::schema::v0::FakeQuantWithMinMax>() const {
  return value_as_FakeQuantWithMinMax();
}

template<> inline const mindspore::schema::v0::FakeQuantWithMinMaxPerChannel *Primitive::value_as<mindspore::schema::v0::FakeQuantWithMinMaxPerChannel>() const {
  return value_as_FakeQuantWithMinMaxPerChannel();
}

template<> inline const mindspore::schema::v0::BatchNormFold *Primitive::value_as<mindspore::schema::v0::BatchNormFold>() const {
  return value_as_BatchNormFold();
}

template<> inline const mindspore::schema::v0::MulFold *Primitive::value_as<mindspore::schema::v0::MulFold>() const {
  return value_as_MulFold();
}

template<> inline const mindspore::schema::v0::AddFold *Primitive::value_as<mindspore::schema::v0::AddFold>() const {
  return value_as_AddFold();
}

template<> inline const mindspore::schema::v0::SquaredDifference *Primitive::value_as<mindspore::schema::v0::SquaredDifference>() const {
  return value_as_SquaredDifference();
}

template<> inline const mindspore::schema::v0::Flatten *Primitive::value_as<mindspore::schema::v0::Flatten>() const {
  return value_as_Flatten();
}

template<> inline const mindspore::schema::v0::FlattenGrad *Primitive::value_as<mindspore::schema::v0::FlattenGrad>() const {
  return value_as_FlattenGrad();
}

template<> inline const mindspore::schema::v0::TupleGetItem *Primitive::value_as<mindspore::schema::v0::TupleGetItem>() const {
  return value_as_TupleGetItem();
}

template<> inline const mindspore::schema::v0::Div *Primitive::value_as<mindspore::schema::v0::Div>() const {
  return value_as_Div();
}

template<> inline const mindspore::schema::v0::Where *Primitive::value_as<mindspore::schema::v0::Where>() const {
  return value_as_Where();
}

template<> inline const mindspore::schema::v0::OneHot *Primitive::value_as<mindspore::schema::v0::OneHot>() const {
  return value_as_OneHot();
}

template<> inline const mindspore::schema::v0::Lstm *Primitive::value_as<mindspore::schema::v0::Lstm>() const {
  return value_as_Lstm();
}

template<> inline const mindspore::schema::v0::Conv2DGradFilter *Primitive::value_as<mindspore::schema::v0::Conv2DGradFilter>() const {
  return value_as_Conv2DGradFilter();
}

template<> inline const mindspore::schema::v0::Conv2DGradInput *Primitive::value_as<mindspore::schema::v0::Conv2DGradInput>() const {
  return value_as_Conv2DGradInput();
}

template<> inline const mindspore::schema::v0::PoolingGrad *Primitive::value_as<mindspore::schema::v0::PoolingGrad>() const {
  return value_as_PoolingGrad();
}

template<> inline const mindspore::schema::v0::BNGrad *Primitive::value_as<mindspore::schema::v0::BNGrad>() const {
  return value_as_BNGrad();
}

template<> inline const mindspore::schema::v0::Assign *Primitive::value_as<mindspore::schema::v0::Assign>() const {
  return value_as_Assign();
}

template<> inline const mindspore::schema::v0::ApplyMomentum *Primitive::value_as<mindspore::schema::v0::ApplyMomentum>() const {
  return value_as_ApplyMomentum();
}

template<> inline const mindspore::schema::v0::BiasGrad *Primitive::value_as<mindspore::schema::v0::BiasGrad>() const {
  return value_as_BiasGrad();
}

template<> inline const mindspore::schema::v0::SoftmaxCrossEntropy *Primitive::value_as<mindspore::schema::v0::SoftmaxCrossEntropy>() const {
  return value_as_SoftmaxCrossEntropy();
}

template<> inline const mindspore::schema::v0::AddGrad *Primitive::value_as<mindspore::schema::v0::AddGrad>() const {
  return value_as_AddGrad();
}

template<> inline const mindspore::schema::v0::SubGrad *Primitive::value_as<mindspore::schema::v0::SubGrad>() const {
  return value_as_SubGrad();
}

template<> inline const mindspore::schema::v0::MulGrad *Primitive::value_as<mindspore::schema::v0::MulGrad>() const {
  return value_as_MulGrad();
}

template<> inline const mindspore::schema::v0::DivGrad *Primitive::value_as<mindspore::schema::v0::DivGrad>() const {
  return value_as_DivGrad();
}

template<> inline const mindspore::schema::v0::PowerGrad *Primitive::value_as<mindspore::schema::v0::PowerGrad>() const {
  return value_as_PowerGrad();
}

template<> inline const mindspore::schema::v0::ActivationGrad *Primitive::value_as<mindspore::schema::v0::ActivationGrad>() const {
  return value_as_ActivationGrad();
}

template<> inline const mindspore::schema::v0::PriorBox *Primitive::value_as<mindspore::schema::v0::PriorBox>() const {
  return value_as_PriorBox();
}

template<> inline const mindspore::schema::v0::SpaceToBatchND *Primitive::value_as<mindspore::schema::v0::SpaceToBatchND>() const {
  return value_as_SpaceToBatchND();
}

template<> inline const mindspore::schema::v0::Depend *Primitive::value_as<mindspore::schema::v0::Depend>() const {
  return value_as_Depend();
}

template<> inline const mindspore::schema::v0::Return *Primitive::value_as<mindspore::schema::v0::Return>() const {
  return value_as_Return();
}

template<> inline const mindspore::schema::v0::MakeTuple *Primitive::value_as<mindspore::schema::v0::MakeTuple>() const {
  return value_as_MakeTuple();
}

template<> inline const mindspore::schema::v0::ToFormat *Primitive::value_as<mindspore::schema::v0::ToFormat>() const {
  return value_as_ToFormat();
}

template<> inline const mindspore::schema::v0::Proposal *Primitive::value_as<mindspore::schema::v0::Proposal>() const {
  return value_as_Proposal();
}

template<> inline const mindspore::schema::v0::Custom *Primitive::value_as<mindspore::schema::v0::Custom>() const {
  return value_as_Custom();
}

template<> inline const mindspore::schema::v0::BlackBox *Primitive::value_as<mindspore::schema::v0::BlackBox>() const {
  return value_as_BlackBox();
}

template<> inline const mindspore::schema::v0::NegGrad *Primitive::value_as<mindspore::schema::v0::NegGrad>() const {
  return value_as_NegGrad();
}

template<> inline const mindspore::schema::v0::LogGrad *Primitive::value_as<mindspore::schema::v0::LogGrad>() const {
  return value_as_LogGrad();
}

template<> inline const mindspore::schema::v0::BatchToSpaceND *Primitive::value_as<mindspore::schema::v0::BatchToSpaceND>() const {
  return value_as_BatchToSpaceND();
}

template<> inline const mindspore::schema::v0::LshProjection *Primitive::value_as<mindspore::schema::v0::LshProjection>() const {
  return value_as_LshProjection();
}

template<> inline const mindspore::schema::v0::HashtableLookup *Primitive::value_as<mindspore::schema::v0::HashtableLookup>() const {
  return value_as_HashtableLookup();
}

template<> inline const mindspore::schema::v0::SkipGram *Primitive::value_as<mindspore::schema::v0::SkipGram>() const {
  return value_as_SkipGram();
}

template<> inline const mindspore::schema::v0::DeConv2DGradFilter *Primitive::value_as<mindspore::schema::v0::DeConv2DGradFilter>() const {
  return value_as_DeConv2DGradFilter();
}

template<> inline const mindspore::schema::v0::CustomPredict *Primitive::value_as<mindspore::schema::v0::CustomPredict>() const {
  return value_as_CustomPredict();
}

template<> inline const mindspore::schema::v0::CustomNormalize *Primitive::value_as<mindspore::schema::v0::CustomNormalize>() const {
  return value_as_CustomNormalize();
}

template<> inline const mindspore::schema::v0::CustomExtractFeatures *Primitive::value_as<mindspore::schema::v0::CustomExtractFeatures>() const {
  return value_as_CustomExtractFeatures();
}

template<> inline const mindspore::schema::v0::AudioSpectrogram *Primitive::value_as<mindspore::schema::v0::AudioSpectrogram>() const {
  return value_as_AudioSpectrogram();
}

template<> inline const mindspore::schema::v0::Mfcc *Primitive::value_as<mindspore::schema::v0::Mfcc>() const {
  return value_as_Mfcc();
}

template<> inline const mindspore::schema::v0::Rfft *Primitive::value_as<mindspore::schema::v0::Rfft>() const {
  return value_as_Rfft();
}

template<> inline const mindspore::schema::v0::FftReal *Primitive::value_as<mindspore::schema::v0::FftReal>() const {
  return value_as_FftReal();
}

template<> inline const mindspore::schema::v0::FftImag *Primitive::value_as<mindspore::schema::v0::FftImag>() const {
  return value_as_FftImag();
}

template<> inline const mindspore::schema::v0::Sgd *Primitive::value_as<mindspore::schema::v0::Sgd>() const {
  return value_as_Sgd();
}

template<> inline const mindspore::schema::v0::Adam *Primitive::value_as<mindspore::schema::v0::Adam>() const {
  return value_as_Adam();
}

template<> inline const mindspore::schema::v0::GroupConv2DGradInput *Primitive::value_as<mindspore::schema::v0::GroupConv2DGradInput>() const {
  return value_as_GroupConv2DGradInput();
}

template<> inline const mindspore::schema::v0::Loop *Primitive::value_as<mindspore::schema::v0::Loop>() const {
  return value_as_Loop();
}

template<> inline const mindspore::schema::v0::NonMaxSuppression *Primitive::value_as<mindspore::schema::v0::NonMaxSuppression>() const {
  return value_as_NonMaxSuppression();
}

template<> inline const mindspore::schema::v0::InstanceNorm *Primitive::value_as<mindspore::schema::v0::InstanceNorm>() const {
  return value_as_InstanceNorm();
}

template<> inline const mindspore::schema::v0::Identity *Primitive::value_as<mindspore::schema::v0::Identity>() const {
  return value_as_Identity();
}

template<> inline const mindspore::schema::v0::LayerNorm *Primitive::value_as<mindspore::schema::v0::LayerNorm>() const {
  return value_as_LayerNorm();
}

template<> inline const mindspore::schema::v0::While *Primitive::value_as<mindspore::schema::v0::While>() const {
  return value_as_While();
}

template<> inline const mindspore::schema::v0::ControlDepend *Primitive::value_as<mindspore::schema::v0::ControlDepend>() const {
  return value_as_ControlDepend();
}

template<> inline const mindspore::schema::v0::UnsortedSegmentSum *Primitive::value_as<mindspore::schema::v0::UnsortedSegmentSum>() const {
  return value_as_UnsortedSegmentSum();
}

template<> inline const mindspore::schema::v0::AssignAdd *Primitive::value_as<mindspore::schema::v0::AssignAdd>() const {
  return value_as_AssignAdd();
}

template<> inline const mindspore::schema::v0::OnesLike *Primitive::value_as<mindspore::schema::v0::OnesLike>() const {
  return value_as_OnesLike();
}

template<> inline const mindspore::schema::v0::BinaryCrossEntropyGrad *Primitive::value_as<mindspore::schema::v0::BinaryCrossEntropyGrad>() const {
  return value_as_BinaryCrossEntropyGrad();
}

template<> inline const mindspore::schema::v0::BinaryCrossEntropy *Primitive::value_as<mindspore::schema::v0::BinaryCrossEntropy>() const {
  return value_as_BinaryCrossEntropy();
}

template<> inline const mindspore::schema::v0::LpNormalization *Primitive::value_as<mindspore::schema::v0::LpNormalization>() const {
  return value_as_LpNormalization();
}

template<> inline const mindspore::schema::v0::DropoutGrad *Primitive::value_as<mindspore::schema::v0::DropoutGrad>() const {
  return value_as_DropoutGrad();
}

template<> inline const mindspore::schema::v0::MaximumGrad *Primitive::value_as<mindspore::schema::v0::MaximumGrad>() const {
  return value_as_MaximumGrad();
}

template<> inline const mindspore::schema::v0::MinimumGrad *Primitive::value_as<mindspore::schema::v0::MinimumGrad>() const {
  return value_as_MinimumGrad();
}

template<> inline const mindspore::schema::v0::Switch *Primitive::value_as<mindspore::schema::v0::Switch>() const {
  return value_as_Switch();
}

template<> inline const mindspore::schema::v0::Partial *Primitive::value_as<mindspore::schema::v0::Partial>() const {
  return value_as_Partial();
}

template<> inline const mindspore::schema::v0::TensorListFromTensor *Primitive::value_as<mindspore::schema::v0::TensorListFromTensor>() const {
  return value_as_TensorListFromTensor();
}

template<> inline const mindspore::schema::v0::TensorListStack *Primitive::value_as<mindspore::schema::v0::TensorListStack>() const {
  return value_as_TensorListStack();
}

template<> inline const mindspore::schema::v0::TensorListGetItem *Primitive::value_as<mindspore::schema::v0::TensorListGetItem>() const {
  return value_as_TensorListGetItem();
}

template<> inline const mindspore::schema::v0::TensorListSetItem *Primitive::value_as<mindspore::schema::v0::TensorListSetItem>() const {
  return value_as_TensorListSetItem();
}

template<> inline const mindspore::schema::v0::TensorListReserve *Primitive::value_as<mindspore::schema::v0::TensorListReserve>() const {
  return value_as_TensorListReserve();
}

template<> inline const mindspore::schema::v0::All *Primitive::value_as<mindspore::schema::v0::All>() const {
  return value_as_All();
}

template<> inline const mindspore::schema::v0::Assert *Primitive::value_as<mindspore::schema::v0::Assert>() const {
  return value_as_Assert();
}

template<> inline const mindspore::schema::v0::Adder *Primitive::value_as<mindspore::schema::v0::Adder>() const {
  return value_as_Adder();
}

template<> inline const mindspore::schema::v0::SparseSoftmaxCrossEntropy *Primitive::value_as<mindspore::schema::v0::SparseSoftmaxCrossEntropy>() const {
  return value_as_SparseSoftmaxCrossEntropy();
}

template<> inline const mindspore::schema::v0::SmoothL1Loss *Primitive::value_as<mindspore::schema::v0::SmoothL1Loss>() const {
  return value_as_SmoothL1Loss();
}

template<> inline const mindspore::schema::v0::SmoothL1LossGrad *Primitive::value_as<mindspore::schema::v0::SmoothL1LossGrad>() const {
  return value_as_SmoothL1LossGrad();
}

template<> inline const mindspore::schema::v0::SigmoidCrossEntropyWithLogits *Primitive::value_as<mindspore::schema::v0::SigmoidCrossEntropyWithLogits>() const {
  return value_as_SigmoidCrossEntropyWithLogits();
}

template<> inline const mindspore::schema::v0::SigmoidCrossEntropyWithLogitsGrad *Primitive::value_as<mindspore::schema::v0::SigmoidCrossEntropyWithLogitsGrad>() const {
  return value_as_SigmoidCrossEntropyWithLogitsGrad();
}

template<> inline const mindspore::schema::v0::Reciprocal *Primitive::value_as<mindspore::schema::v0::Reciprocal>() const {
  return value_as_Reciprocal();
}

template<> inline const mindspore::schema::v0::Merge *Primitive::value_as<mindspore::schema::v0::Merge>() const {
  return value_as_Merge();
}

template<> inline const mindspore::schema::v0::Mod *Primitive::value_as<mindspore::schema::v0::Mod>() const {
  return value_as_Mod();
}

template<> inline const mindspore::schema::v0::GeLU *Primitive::value_as<mindspore::schema::v0::GeLU>() const {
  return value_as_GeLU();
}

struct PrimitiveBuilder {
  typedef Primitive Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_value_type(mindspore::schema::v0::PrimitiveType value_type) {
    fbb_.AddElement<uint8_t>(Primitive::VT_VALUE_TYPE, static_cast<uint8_t>(value_type), 0);
  }
  void add_value(flatbuffers::Offset<void> value) {
    fbb_.AddOffset(Primitive::VT_VALUE, value);
  }
  explicit PrimitiveBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Primitive> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Primitive>(end);
    return o;
  }
};

inline flatbuffers::Offset<Primitive> CreatePrimitive(
    flatbuffers::FlatBufferBuilder &_fbb,
    mindspore::schema::v0::PrimitiveType value_type = mindspore::schema::v0::PrimitiveType_NONE,
    flatbuffers::Offset<void> value = 0) {
  PrimitiveBuilder builder_(_fbb);
  builder_.add_value(value);
  builder_.add_value_type(value_type);
  return builder_.Finish();
}

flatbuffers::Offset<Primitive> CreatePrimitive(flatbuffers::FlatBufferBuilder &_fbb, const PrimitiveT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct CNodeT : public flatbuffers::NativeTable {
  typedef CNode TableType;
  std::string name{};
  mindspore::schema::v0::NodeType nodeType = mindspore::schema::v0::NodeType_CNode;
  std::unique_ptr<mindspore::schema::v0::PrimitiveT> primitive{};
  std::vector<uint32_t> inputIndex{};
  std::vector<uint32_t> outputIndex{};
  mindspore::schema::v0::QuantType quantType = mindspore::schema::v0::QuantType_QUANT_NONE;
};

struct CNode FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef CNodeT NativeTableType;
  typedef CNodeBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return CNodeTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NAME = 4,
    VT_NODETYPE = 6,
    VT_PRIMITIVE = 8,
    VT_INPUTINDEX = 10,
    VT_OUTPUTINDEX = 12,
    VT_QUANTTYPE = 14
  };
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  flatbuffers::String *mutable_name() {
    return GetPointer<flatbuffers::String *>(VT_NAME);
  }
  mindspore::schema::v0::NodeType nodeType() const {
    return static_cast<mindspore::schema::v0::NodeType>(GetField<int32_t>(VT_NODETYPE, 2));
  }
  bool mutate_nodeType(mindspore::schema::v0::NodeType _nodeType) {
    return SetField<int32_t>(VT_NODETYPE, static_cast<int32_t>(_nodeType), 2);
  }
  const mindspore::schema::v0::Primitive *primitive() const {
    return GetPointer<const mindspore::schema::v0::Primitive *>(VT_PRIMITIVE);
  }
  mindspore::schema::v0::Primitive *mutable_primitive() {
    return GetPointer<mindspore::schema::v0::Primitive *>(VT_PRIMITIVE);
  }
  const flatbuffers::Vector<uint32_t> *inputIndex() const {
    return GetPointer<const flatbuffers::Vector<uint32_t> *>(VT_INPUTINDEX);
  }
  flatbuffers::Vector<uint32_t> *mutable_inputIndex() {
    return GetPointer<flatbuffers::Vector<uint32_t> *>(VT_INPUTINDEX);
  }
  const flatbuffers::Vector<uint32_t> *outputIndex() const {
    return GetPointer<const flatbuffers::Vector<uint32_t> *>(VT_OUTPUTINDEX);
  }
  flatbuffers::Vector<uint32_t> *mutable_outputIndex() {
    return GetPointer<flatbuffers::Vector<uint32_t> *>(VT_OUTPUTINDEX);
  }
  mindspore::schema::v0::QuantType quantType() const {
    return static_cast<mindspore::schema::v0::QuantType>(GetField<int32_t>(VT_QUANTTYPE, 0));
  }
  bool mutate_quantType(mindspore::schema::v0::QuantType _quantType) {
    return SetField<int32_t>(VT_QUANTTYPE, static_cast<int32_t>(_quantType), 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyField<int32_t>(verifier, VT_NODETYPE) &&
           VerifyOffset(verifier, VT_PRIMITIVE) &&
           verifier.VerifyTable(primitive()) &&
           VerifyOffset(verifier, VT_INPUTINDEX) &&
           verifier.VerifyVector(inputIndex()) &&
           VerifyOffset(verifier, VT_OUTPUTINDEX) &&
           verifier.VerifyVector(outputIndex()) &&
           VerifyField<int32_t>(verifier, VT_QUANTTYPE) &&
           verifier.EndTable();
  }
  CNodeT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(CNodeT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<CNode> Pack(flatbuffers::FlatBufferBuilder &_fbb, const CNodeT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct CNodeBuilder {
  typedef CNode Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(CNode::VT_NAME, name);
  }
  void add_nodeType(mindspore::schema::v0::NodeType nodeType) {
    fbb_.AddElement<int32_t>(CNode::VT_NODETYPE, static_cast<int32_t>(nodeType), 2);
  }
  void add_primitive(flatbuffers::Offset<mindspore::schema::v0::Primitive> primitive) {
    fbb_.AddOffset(CNode::VT_PRIMITIVE, primitive);
  }
  void add_inputIndex(flatbuffers::Offset<flatbuffers::Vector<uint32_t>> inputIndex) {
    fbb_.AddOffset(CNode::VT_INPUTINDEX, inputIndex);
  }
  void add_outputIndex(flatbuffers::Offset<flatbuffers::Vector<uint32_t>> outputIndex) {
    fbb_.AddOffset(CNode::VT_OUTPUTINDEX, outputIndex);
  }
  void add_quantType(mindspore::schema::v0::QuantType quantType) {
    fbb_.AddElement<int32_t>(CNode::VT_QUANTTYPE, static_cast<int32_t>(quantType), 0);
  }
  explicit CNodeBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<CNode> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<CNode>(end);
    return o;
  }
};

inline flatbuffers::Offset<CNode> CreateCNode(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    mindspore::schema::v0::NodeType nodeType = mindspore::schema::v0::NodeType_CNode,
    flatbuffers::Offset<mindspore::schema::v0::Primitive> primitive = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint32_t>> inputIndex = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint32_t>> outputIndex = 0,
    mindspore::schema::v0::QuantType quantType = mindspore::schema::v0::QuantType_QUANT_NONE) {
  CNodeBuilder builder_(_fbb);
  builder_.add_quantType(quantType);
  builder_.add_outputIndex(outputIndex);
  builder_.add_inputIndex(inputIndex);
  builder_.add_primitive(primitive);
  builder_.add_nodeType(nodeType);
  builder_.add_name(name);
  return builder_.Finish();
}

inline flatbuffers::Offset<CNode> CreateCNodeDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *name = nullptr,
    mindspore::schema::v0::NodeType nodeType = mindspore::schema::v0::NodeType_CNode,
    flatbuffers::Offset<mindspore::schema::v0::Primitive> primitive = 0,
    const std::vector<uint32_t> *inputIndex = nullptr,
    const std::vector<uint32_t> *outputIndex = nullptr,
    mindspore::schema::v0::QuantType quantType = mindspore::schema::v0::QuantType_QUANT_NONE) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  auto inputIndex__ = inputIndex ? _fbb.CreateVector<uint32_t>(*inputIndex) : 0;
  auto outputIndex__ = outputIndex ? _fbb.CreateVector<uint32_t>(*outputIndex) : 0;
  return mindspore::schema::v0::CreateCNode(
      _fbb,
      name__,
      nodeType,
      primitive,
      inputIndex__,
      outputIndex__,
      quantType);
}

flatbuffers::Offset<CNode> CreateCNode(flatbuffers::FlatBufferBuilder &_fbb, const CNodeT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct SubGraphT : public flatbuffers::NativeTable {
  typedef SubGraph TableType;
  std::string name{};
  std::vector<uint32_t> inputIndices{};
  std::vector<uint32_t> outputIndices{};
  std::vector<uint32_t> nodeIndices{};
  std::vector<uint32_t> tensorIndices{};
};

struct SubGraph FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef SubGraphT NativeTableType;
  typedef SubGraphBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return SubGraphTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NAME = 4,
    VT_INPUTINDICES = 6,
    VT_OUTPUTINDICES = 8,
    VT_NODEINDICES = 10,
    VT_TENSORINDICES = 12
  };
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  flatbuffers::String *mutable_name() {
    return GetPointer<flatbuffers::String *>(VT_NAME);
  }
  const flatbuffers::Vector<uint32_t> *inputIndices() const {
    return GetPointer<const flatbuffers::Vector<uint32_t> *>(VT_INPUTINDICES);
  }
  flatbuffers::Vector<uint32_t> *mutable_inputIndices() {
    return GetPointer<flatbuffers::Vector<uint32_t> *>(VT_INPUTINDICES);
  }
  const flatbuffers::Vector<uint32_t> *outputIndices() const {
    return GetPointer<const flatbuffers::Vector<uint32_t> *>(VT_OUTPUTINDICES);
  }
  flatbuffers::Vector<uint32_t> *mutable_outputIndices() {
    return GetPointer<flatbuffers::Vector<uint32_t> *>(VT_OUTPUTINDICES);
  }
  const flatbuffers::Vector<uint32_t> *nodeIndices() const {
    return GetPointer<const flatbuffers::Vector<uint32_t> *>(VT_NODEINDICES);
  }
  flatbuffers::Vector<uint32_t> *mutable_nodeIndices() {
    return GetPointer<flatbuffers::Vector<uint32_t> *>(VT_NODEINDICES);
  }
  const flatbuffers::Vector<uint32_t> *tensorIndices() const {
    return GetPointer<const flatbuffers::Vector<uint32_t> *>(VT_TENSORINDICES);
  }
  flatbuffers::Vector<uint32_t> *mutable_tensorIndices() {
    return GetPointer<flatbuffers::Vector<uint32_t> *>(VT_TENSORINDICES);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyOffset(verifier, VT_INPUTINDICES) &&
           verifier.VerifyVector(inputIndices()) &&
           VerifyOffset(verifier, VT_OUTPUTINDICES) &&
           verifier.VerifyVector(outputIndices()) &&
           VerifyOffset(verifier, VT_NODEINDICES) &&
           verifier.VerifyVector(nodeIndices()) &&
           VerifyOffset(verifier, VT_TENSORINDICES) &&
           verifier.VerifyVector(tensorIndices()) &&
           verifier.EndTable();
  }
  SubGraphT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(SubGraphT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<SubGraph> Pack(flatbuffers::FlatBufferBuilder &_fbb, const SubGraphT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct SubGraphBuilder {
  typedef SubGraph Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(SubGraph::VT_NAME, name);
  }
  void add_inputIndices(flatbuffers::Offset<flatbuffers::Vector<uint32_t>> inputIndices) {
    fbb_.AddOffset(SubGraph::VT_INPUTINDICES, inputIndices);
  }
  void add_outputIndices(flatbuffers::Offset<flatbuffers::Vector<uint32_t>> outputIndices) {
    fbb_.AddOffset(SubGraph::VT_OUTPUTINDICES, outputIndices);
  }
  void add_nodeIndices(flatbuffers::Offset<flatbuffers::Vector<uint32_t>> nodeIndices) {
    fbb_.AddOffset(SubGraph::VT_NODEINDICES, nodeIndices);
  }
  void add_tensorIndices(flatbuffers::Offset<flatbuffers::Vector<uint32_t>> tensorIndices) {
    fbb_.AddOffset(SubGraph::VT_TENSORINDICES, tensorIndices);
  }
  explicit SubGraphBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<SubGraph> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SubGraph>(end);
    return o;
  }
};

inline flatbuffers::Offset<SubGraph> CreateSubGraph(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint32_t>> inputIndices = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint32_t>> outputIndices = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint32_t>> nodeIndices = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint32_t>> tensorIndices = 0) {
  SubGraphBuilder builder_(_fbb);
  builder_.add_tensorIndices(tensorIndices);
  builder_.add_nodeIndices(nodeIndices);
  builder_.add_outputIndices(outputIndices);
  builder_.add_inputIndices(inputIndices);
  builder_.add_name(name);
  return builder_.Finish();
}

inline flatbuffers::Offset<SubGraph> CreateSubGraphDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *name = nullptr,
    const std::vector<uint32_t> *inputIndices = nullptr,
    const std::vector<uint32_t> *outputIndices = nullptr,
    const std::vector<uint32_t> *nodeIndices = nullptr,
    const std::vector<uint32_t> *tensorIndices = nullptr) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  auto inputIndices__ = inputIndices ? _fbb.CreateVector<uint32_t>(*inputIndices) : 0;
  auto outputIndices__ = outputIndices ? _fbb.CreateVector<uint32_t>(*outputIndices) : 0;
  auto nodeIndices__ = nodeIndices ? _fbb.CreateVector<uint32_t>(*nodeIndices) : 0;
  auto tensorIndices__ = tensorIndices ? _fbb.CreateVector<uint32_t>(*tensorIndices) : 0;
  return mindspore::schema::v0::CreateSubGraph(
      _fbb,
      name__,
      inputIndices__,
      outputIndices__,
      nodeIndices__,
      tensorIndices__);
}

flatbuffers::Offset<SubGraph> CreateSubGraph(flatbuffers::FlatBufferBuilder &_fbb, const SubGraphT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct MetaGraphT : public flatbuffers::NativeTable {
  typedef MetaGraph TableType;
  std::string name{};
  std::string version{};
  int32_t fmkType = 0;
  std::vector<uint32_t> inputIndex{};
  std::vector<uint32_t> outputIndex{};
  uint32_t mempoolSize = 0;
  std::vector<std::unique_ptr<mindspore::schema::v0::CNodeT>> nodes{};
  std::vector<std::unique_ptr<mindspore::schema::v0::TensorT>> allTensors{};
  std::vector<std::unique_ptr<mindspore::schema::v0::SubGraphT>> subGraph{};
};

struct MetaGraph FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef MetaGraphT NativeTableType;
  typedef MetaGraphBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return MetaGraphTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NAME = 4,
    VT_VERSION = 6,
    VT_FMKTYPE = 8,
    VT_INPUTINDEX = 10,
    VT_OUTPUTINDEX = 12,
    VT_MEMPOOLSIZE = 14,
    VT_NODES = 16,
    VT_ALLTENSORS = 18,
    VT_SUBGRAPH = 20
  };
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  flatbuffers::String *mutable_name() {
    return GetPointer<flatbuffers::String *>(VT_NAME);
  }
  const flatbuffers::String *version() const {
    return GetPointer<const flatbuffers::String *>(VT_VERSION);
  }
  flatbuffers::String *mutable_version() {
    return GetPointer<flatbuffers::String *>(VT_VERSION);
  }
  int32_t fmkType() const {
    return GetField<int32_t>(VT_FMKTYPE, 0);
  }
  bool mutate_fmkType(int32_t _fmkType) {
    return SetField<int32_t>(VT_FMKTYPE, _fmkType, 0);
  }
  const flatbuffers::Vector<uint32_t> *inputIndex() const {
    return GetPointer<const flatbuffers::Vector<uint32_t> *>(VT_INPUTINDEX);
  }
  flatbuffers::Vector<uint32_t> *mutable_inputIndex() {
    return GetPointer<flatbuffers::Vector<uint32_t> *>(VT_INPUTINDEX);
  }
  const flatbuffers::Vector<uint32_t> *outputIndex() const {
    return GetPointer<const flatbuffers::Vector<uint32_t> *>(VT_OUTPUTINDEX);
  }
  flatbuffers::Vector<uint32_t> *mutable_outputIndex() {
    return GetPointer<flatbuffers::Vector<uint32_t> *>(VT_OUTPUTINDEX);
  }
  uint32_t mempoolSize() const {
    return GetField<uint32_t>(VT_MEMPOOLSIZE, 0);
  }
  bool mutate_mempoolSize(uint32_t _mempoolSize) {
    return SetField<uint32_t>(VT_MEMPOOLSIZE, _mempoolSize, 0);
  }
  const flatbuffers::Vector<flatbuffers::Offset<mindspore::schema::v0::CNode>> *nodes() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<mindspore::schema::v0::CNode>> *>(VT_NODES);
  }
  flatbuffers::Vector<flatbuffers::Offset<mindspore::schema::v0::CNode>> *mutable_nodes() {
    return GetPointer<flatbuffers::Vector<flatbuffers::Offset<mindspore::schema::v0::CNode>> *>(VT_NODES);
  }
  const flatbuffers::Vector<flatbuffers::Offset<mindspore::schema::v0::Tensor>> *allTensors() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<mindspore::schema::v0::Tensor>> *>(VT_ALLTENSORS);
  }
  flatbuffers::Vector<flatbuffers::Offset<mindspore::schema::v0::Tensor>> *mutable_allTensors() {
    return GetPointer<flatbuffers::Vector<flatbuffers::Offset<mindspore::schema::v0::Tensor>> *>(VT_ALLTENSORS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<mindspore::schema::v0::SubGraph>> *subGraph() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<mindspore::schema::v0::SubGraph>> *>(VT_SUBGRAPH);
  }
  flatbuffers::Vector<flatbuffers::Offset<mindspore::schema::v0::SubGraph>> *mutable_subGraph() {
    return GetPointer<flatbuffers::Vector<flatbuffers::Offset<mindspore::schema::v0::SubGraph>> *>(VT_SUBGRAPH);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyOffset(verifier, VT_VERSION) &&
           verifier.VerifyString(version()) &&
           VerifyField<int32_t>(verifier, VT_FMKTYPE) &&
           VerifyOffset(verifier, VT_INPUTINDEX) &&
           verifier.VerifyVector(inputIndex()) &&
           VerifyOffset(verifier, VT_OUTPUTINDEX) &&
           verifier.VerifyVector(outputIndex()) &&
           VerifyField<uint32_t>(verifier, VT_MEMPOOLSIZE) &&
           VerifyOffset(verifier, VT_NODES) &&
           verifier.VerifyVector(nodes()) &&
           verifier.VerifyVectorOfTables(nodes()) &&
           VerifyOffset(verifier, VT_ALLTENSORS) &&
           verifier.VerifyVector(allTensors()) &&
           verifier.VerifyVectorOfTables(allTensors()) &&
           VerifyOffset(verifier, VT_SUBGRAPH) &&
           verifier.VerifyVector(subGraph()) &&
           verifier.VerifyVectorOfTables(subGraph()) &&
           verifier.EndTable();
  }
  MetaGraphT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(MetaGraphT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<MetaGraph> Pack(flatbuffers::FlatBufferBuilder &_fbb, const MetaGraphT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct MetaGraphBuilder {
  typedef MetaGraph Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(MetaGraph::VT_NAME, name);
  }
  void add_version(flatbuffers::Offset<flatbuffers::String> version) {
    fbb_.AddOffset(MetaGraph::VT_VERSION, version);
  }
  void add_fmkType(int32_t fmkType) {
    fbb_.AddElement<int32_t>(MetaGraph::VT_FMKTYPE, fmkType, 0);
  }
  void add_inputIndex(flatbuffers::Offset<flatbuffers::Vector<uint32_t>> inputIndex) {
    fbb_.AddOffset(MetaGraph::VT_INPUTINDEX, inputIndex);
  }
  void add_outputIndex(flatbuffers::Offset<flatbuffers::Vector<uint32_t>> outputIndex) {
    fbb_.AddOffset(MetaGraph::VT_OUTPUTINDEX, outputIndex);
  }
  void add_mempoolSize(uint32_t mempoolSize) {
    fbb_.AddElement<uint32_t>(MetaGraph::VT_MEMPOOLSIZE, mempoolSize, 0);
  }
  void add_nodes(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<mindspore::schema::v0::CNode>>> nodes) {
    fbb_.AddOffset(MetaGraph::VT_NODES, nodes);
  }
  void add_allTensors(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<mindspore::schema::v0::Tensor>>> allTensors) {
    fbb_.AddOffset(MetaGraph::VT_ALLTENSORS, allTensors);
  }
  void add_subGraph(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<mindspore::schema::v0::SubGraph>>> subGraph) {
    fbb_.AddOffset(MetaGraph::VT_SUBGRAPH, subGraph);
  }
  explicit MetaGraphBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<MetaGraph> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<MetaGraph>(end);
    return o;
  }
};

inline flatbuffers::Offset<MetaGraph> CreateMetaGraph(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    flatbuffers::Offset<flatbuffers::String> version = 0,
    int32_t fmkType = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint32_t>> inputIndex = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint32_t>> outputIndex = 0,
    uint32_t mempoolSize = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<mindspore::schema::v0::CNode>>> nodes = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<mindspore::schema::v0::Tensor>>> allTensors = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<mindspore::schema::v0::SubGraph>>> subGraph = 0) {
  MetaGraphBuilder builder_(_fbb);
  builder_.add_subGraph(subGraph);
  builder_.add_allTensors(allTensors);
  builder_.add_nodes(nodes);
  builder_.add_mempoolSize(mempoolSize);
  builder_.add_outputIndex(outputIndex);
  builder_.add_inputIndex(inputIndex);
  builder_.add_fmkType(fmkType);
  builder_.add_version(version);
  builder_.add_name(name);
  return builder_.Finish();
}

inline flatbuffers::Offset<MetaGraph> CreateMetaGraphDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *name = nullptr,
    const char *version = nullptr,
    int32_t fmkType = 0,
    const std::vector<uint32_t> *inputIndex = nullptr,
    const std::vector<uint32_t> *outputIndex = nullptr,
    uint32_t mempoolSize = 0,
    const std::vector<flatbuffers::Offset<mindspore::schema::v0::CNode>> *nodes = nullptr,
    const std::vector<flatbuffers::Offset<mindspore::schema::v0::Tensor>> *allTensors = nullptr,
    const std::vector<flatbuffers::Offset<mindspore::schema::v0::SubGraph>> *subGraph = nullptr) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  auto version__ = version ? _fbb.CreateString(version) : 0;
  auto inputIndex__ = inputIndex ? _fbb.CreateVector<uint32_t>(*inputIndex) : 0;
  auto outputIndex__ = outputIndex ? _fbb.CreateVector<uint32_t>(*outputIndex) : 0;
  auto nodes__ = nodes ? _fbb.CreateVector<flatbuffers::Offset<mindspore::schema::v0::CNode>>(*nodes) : 0;
  auto allTensors__ = allTensors ? _fbb.CreateVector<flatbuffers::Offset<mindspore::schema::v0::Tensor>>(*allTensors) : 0;
  auto subGraph__ = subGraph ? _fbb.CreateVector<flatbuffers::Offset<mindspore::schema::v0::SubGraph>>(*subGraph) : 0;
  return mindspore::schema::v0::CreateMetaGraph(
      _fbb,
      name__,
      version__,
      fmkType,
      inputIndex__,
      outputIndex__,
      mempoolSize,
      nodes__,
      allTensors__,
      subGraph__);
}

flatbuffers::Offset<MetaGraph> CreateMetaGraph(flatbuffers::FlatBufferBuilder &_fbb, const MetaGraphT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

inline QuantParamT *QuantParam::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<QuantParamT>(new QuantParamT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void QuantParam::UnPackTo(QuantParamT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = scale(); _o->scale = _e; }
  { auto _e = zeroPoint(); _o->zeroPoint = _e; }
  { auto _e = min(); _o->min = _e; }
  { auto _e = max(); _o->max = _e; }
  { auto _e = narrowRange(); _o->narrowRange = _e; }
  { auto _e = numBits(); _o->numBits = _e; }
  { auto _e = inited(); _o->inited = _e; }
  { auto _e = varCorr(); _o->varCorr = _e; }
  { auto _e = meanCorr(); _o->meanCorr = _e; }
  { auto _e = dstDtype(); _o->dstDtype = _e; }
  { auto _e = roundType(); _o->roundType = _e; }
  { auto _e = multiplier(); _o->multiplier = _e; }
}

inline flatbuffers::Offset<QuantParam> QuantParam::Pack(flatbuffers::FlatBufferBuilder &_fbb, const QuantParamT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateQuantParam(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<QuantParam> CreateQuantParam(flatbuffers::FlatBufferBuilder &_fbb, const QuantParamT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const QuantParamT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _scale = _o->scale;
  auto _zeroPoint = _o->zeroPoint;
  auto _min = _o->min;
  auto _max = _o->max;
  auto _narrowRange = _o->narrowRange;
  auto _numBits = _o->numBits;
  auto _inited = _o->inited;
  auto _varCorr = _o->varCorr;
  auto _meanCorr = _o->meanCorr;
  auto _dstDtype = _o->dstDtype;
  auto _roundType = _o->roundType;
  auto _multiplier = _o->multiplier;
  return mindspore::schema::v0::CreateQuantParam(
      _fbb,
      _scale,
      _zeroPoint,
      _min,
      _max,
      _narrowRange,
      _numBits,
      _inited,
      _varCorr,
      _meanCorr,
      _dstDtype,
      _roundType,
      _multiplier);
}

inline TensorT *Tensor::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<TensorT>(new TensorT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Tensor::UnPackTo(TensorT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = nodeType(); _o->nodeType = _e; }
  { auto _e = dataType(); _o->dataType = _e; }
  { auto _e = dims(); if (_e) { _o->dims.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->dims[_i] = _e->Get(_i); } } }
  { auto _e = format(); _o->format = _e; }
  { auto _e = refCount(); _o->refCount = _e; }
  { auto _e = offset(); _o->offset = _e; }
  { auto _e = data(); if (_e) { _o->data.resize(_e->size()); std::copy(_e->begin(), _e->end(), _o->data.begin()); } }
  { auto _e = quantParams(); if (_e) { _o->quantParams.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->quantParams[_i] = std::unique_ptr<mindspore::schema::v0::QuantParamT>(_e->Get(_i)->UnPack(_resolver)); } } }
  { auto _e = quantClusters(); if (_e) { _o->quantClusters.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->quantClusters[_i] = _e->Get(_i); } } }
  { auto _e = name(); if (_e) _o->name = _e->str(); }
}

inline flatbuffers::Offset<Tensor> Tensor::Pack(flatbuffers::FlatBufferBuilder &_fbb, const TensorT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateTensor(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Tensor> CreateTensor(flatbuffers::FlatBufferBuilder &_fbb, const TensorT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const TensorT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _nodeType = _o->nodeType;
  auto _dataType = _o->dataType;
  auto _dims = _o->dims.size() ? _fbb.CreateVector(_o->dims) : 0;
  auto _format = _o->format;
  auto _refCount = _o->refCount;
  auto _offset = _o->offset;
  auto _data = _o->data.size() ? _fbb.CreateVector(_o->data) : 0;
  auto _quantParams = _o->quantParams.size() ? _fbb.CreateVector<flatbuffers::Offset<mindspore::schema::v0::QuantParam>> (_o->quantParams.size(), [](size_t i, _VectorArgs *__va) { return CreateQuantParam(*__va->__fbb, __va->__o->quantParams[i].get(), __va->__rehasher); }, &_va ) : 0;
  auto _quantClusters = _o->quantClusters.size() ? _fbb.CreateVector(_o->quantClusters) : 0;
  auto _name = _o->name.empty() ? 0 : _fbb.CreateString(_o->name);
  return mindspore::schema::v0::CreateTensor(
      _fbb,
      _nodeType,
      _dataType,
      _dims,
      _format,
      _refCount,
      _offset,
      _data,
      _quantParams,
      _quantClusters,
      _name);
}

inline PrimitiveT *Primitive::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<PrimitiveT>(new PrimitiveT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Primitive::UnPackTo(PrimitiveT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = value_type(); _o->value.type = _e; }
  { auto _e = value(); if (_e) _o->value.value = mindspore::schema::v0::PrimitiveTypeUnion::UnPack(_e, value_type(), _resolver); }
}

inline flatbuffers::Offset<Primitive> Primitive::Pack(flatbuffers::FlatBufferBuilder &_fbb, const PrimitiveT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreatePrimitive(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Primitive> CreatePrimitive(flatbuffers::FlatBufferBuilder &_fbb, const PrimitiveT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const PrimitiveT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _value_type = _o->value.type;
  auto _value = _o->value.Pack(_fbb);
  return mindspore::schema::v0::CreatePrimitive(
      _fbb,
      _value_type,
      _value);
}

inline CNodeT *CNode::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<CNodeT>(new CNodeT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void CNode::UnPackTo(CNodeT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = name(); if (_e) _o->name = _e->str(); }
  { auto _e = nodeType(); _o->nodeType = _e; }
  { auto _e = primitive(); if (_e) _o->primitive = std::unique_ptr<mindspore::schema::v0::PrimitiveT>(_e->UnPack(_resolver)); }
  { auto _e = inputIndex(); if (_e) { _o->inputIndex.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->inputIndex[_i] = _e->Get(_i); } } }
  { auto _e = outputIndex(); if (_e) { _o->outputIndex.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->outputIndex[_i] = _e->Get(_i); } } }
  { auto _e = quantType(); _o->quantType = _e; }
}

inline flatbuffers::Offset<CNode> CNode::Pack(flatbuffers::FlatBufferBuilder &_fbb, const CNodeT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateCNode(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<CNode> CreateCNode(flatbuffers::FlatBufferBuilder &_fbb, const CNodeT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const CNodeT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _name = _o->name.empty() ? 0 : _fbb.CreateString(_o->name);
  auto _nodeType = _o->nodeType;
  auto _primitive = _o->primitive ? CreatePrimitive(_fbb, _o->primitive.get(), _rehasher) : 0;
  auto _inputIndex = _o->inputIndex.size() ? _fbb.CreateVector(_o->inputIndex) : 0;
  auto _outputIndex = _o->outputIndex.size() ? _fbb.CreateVector(_o->outputIndex) : 0;
  auto _quantType = _o->quantType;
  return mindspore::schema::v0::CreateCNode(
      _fbb,
      _name,
      _nodeType,
      _primitive,
      _inputIndex,
      _outputIndex,
      _quantType);
}

inline SubGraphT *SubGraph::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<SubGraphT>(new SubGraphT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void SubGraph::UnPackTo(SubGraphT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = name(); if (_e) _o->name = _e->str(); }
  { auto _e = inputIndices(); if (_e) { _o->inputIndices.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->inputIndices[_i] = _e->Get(_i); } } }
  { auto _e = outputIndices(); if (_e) { _o->outputIndices.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->outputIndices[_i] = _e->Get(_i); } } }
  { auto _e = nodeIndices(); if (_e) { _o->nodeIndices.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->nodeIndices[_i] = _e->Get(_i); } } }
  { auto _e = tensorIndices(); if (_e) { _o->tensorIndices.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->tensorIndices[_i] = _e->Get(_i); } } }
}

inline flatbuffers::Offset<SubGraph> SubGraph::Pack(flatbuffers::FlatBufferBuilder &_fbb, const SubGraphT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateSubGraph(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<SubGraph> CreateSubGraph(flatbuffers::FlatBufferBuilder &_fbb, const SubGraphT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const SubGraphT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _name = _o->name.empty() ? 0 : _fbb.CreateString(_o->name);
  auto _inputIndices = _o->inputIndices.size() ? _fbb.CreateVector(_o->inputIndices) : 0;
  auto _outputIndices = _o->outputIndices.size() ? _fbb.CreateVector(_o->outputIndices) : 0;
  auto _nodeIndices = _o->nodeIndices.size() ? _fbb.CreateVector(_o->nodeIndices) : 0;
  auto _tensorIndices = _o->tensorIndices.size() ? _fbb.CreateVector(_o->tensorIndices) : 0;
  return mindspore::schema::v0::CreateSubGraph(
      _fbb,
      _name,
      _inputIndices,
      _outputIndices,
      _nodeIndices,
      _tensorIndices);
}

inline MetaGraphT *MetaGraph::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<MetaGraphT>(new MetaGraphT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void MetaGraph::UnPackTo(MetaGraphT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = name(); if (_e) _o->name = _e->str(); }
  { auto _e = version(); if (_e) _o->version = _e->str(); }
  { auto _e = fmkType(); _o->fmkType = _e; }
  { auto _e = inputIndex(); if (_e) { _o->inputIndex.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->inputIndex[_i] = _e->Get(_i); } } }
  { auto _e = outputIndex(); if (_e) { _o->outputIndex.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->outputIndex[_i] = _e->Get(_i); } } }
  { auto _e = mempoolSize(); _o->mempoolSize = _e; }
  { auto _e = nodes(); if (_e) { _o->nodes.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->nodes[_i] = std::unique_ptr<mindspore::schema::v0::CNodeT>(_e->Get(_i)->UnPack(_resolver)); } } }
  { auto _e = allTensors(); if (_e) { _o->allTensors.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->allTensors[_i] = std::unique_ptr<mindspore::schema::v0::TensorT>(_e->Get(_i)->UnPack(_resolver)); } } }
  { auto _e = subGraph(); if (_e) { _o->subGraph.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->subGraph[_i] = std::unique_ptr<mindspore::schema::v0::SubGraphT>(_e->Get(_i)->UnPack(_resolver)); } } }
}

inline flatbuffers::Offset<MetaGraph> MetaGraph::Pack(flatbuffers::FlatBufferBuilder &_fbb, const MetaGraphT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateMetaGraph(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<MetaGraph> CreateMetaGraph(flatbuffers::FlatBufferBuilder &_fbb, const MetaGraphT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const MetaGraphT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _name = _o->name.empty() ? 0 : _fbb.CreateString(_o->name);
  auto _version = _o->version.empty() ? 0 : _fbb.CreateString(_o->version);
  auto _fmkType = _o->fmkType;
  auto _inputIndex = _o->inputIndex.size() ? _fbb.CreateVector(_o->inputIndex) : 0;
  auto _outputIndex = _o->outputIndex.size() ? _fbb.CreateVector(_o->outputIndex) : 0;
  auto _mempoolSize = _o->mempoolSize;
  auto _nodes = _o->nodes.size() ? _fbb.CreateVector<flatbuffers::Offset<mindspore::schema::v0::CNode>> (_o->nodes.size(), [](size_t i, _VectorArgs *__va) { return CreateCNode(*__va->__fbb, __va->__o->nodes[i].get(), __va->__rehasher); }, &_va ) : 0;
  auto _allTensors = _o->allTensors.size() ? _fbb.CreateVector<flatbuffers::Offset<mindspore::schema::v0::Tensor>> (_o->allTensors.size(), [](size_t i, _VectorArgs *__va) { return CreateTensor(*__va->__fbb, __va->__o->allTensors[i].get(), __va->__rehasher); }, &_va ) : 0;
  auto _subGraph = _o->subGraph.size() ? _fbb.CreateVector<flatbuffers::Offset<mindspore::schema::v0::SubGraph>> (_o->subGraph.size(), [](size_t i, _VectorArgs *__va) { return CreateSubGraph(*__va->__fbb, __va->__o->subGraph[i].get(), __va->__rehasher); }, &_va ) : 0;
  return mindspore::schema::v0::CreateMetaGraph(
      _fbb,
      _name,
      _version,
      _fmkType,
      _inputIndex,
      _outputIndex,
      _mempoolSize,
      _nodes,
      _allTensors,
      _subGraph);
}

inline bool VerifyPrimitiveType(flatbuffers::Verifier &verifier, const void *obj, PrimitiveType type) {
  switch (type) {
    case PrimitiveType_NONE: {
      return true;
    }
    case PrimitiveType_Concat: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::Concat *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_SoftMax: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::SoftMax *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_Activation: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::Activation *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_Conv2D: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::Conv2D *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_FusedBatchNorm: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::FusedBatchNorm *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_BatchNorm: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::BatchNorm *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_BiasAdd: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::BiasAdd *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_Pooling: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::Pooling *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_ROIPooling: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::ROIPooling *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_DepthwiseConv2D: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::DepthwiseConv2D *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_DeDepthwiseConv2D: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::DeDepthwiseConv2D *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_Resize: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::Resize *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_DetectionPostProcess: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::DetectionPostProcess *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_FullConnection: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::FullConnection *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_Mean: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::Mean *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_DeConv2D: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::DeConv2D *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_Scale: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::Scale *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_Reshape: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::Reshape *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_Eltwise: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::Eltwise *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_NetOutput: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::NetOutput *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_Add: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::Add *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_Sub: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::Sub *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_MatMul: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::MatMul *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_StridedSlice: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::StridedSlice *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_Power: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::Power *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_Slice: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::Slice *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_Stack: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::Stack *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_Mul: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::Mul *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_RealDiv: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::RealDiv *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_Pad: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::Pad *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_Maximum: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::Maximum *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_Minimum: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::Minimum *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_PReLU: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::PReLU *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_LeakyReLU: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::LeakyReLU *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_ArgMax: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::ArgMax *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_ArgMin: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::ArgMin *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_Exp: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::Exp *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_Crop: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::Crop *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_Range: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::Range *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_Rsqrt: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::Rsqrt *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_ExpandDims: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::ExpandDims *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_Tile: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::Tile *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_Cast: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::Cast *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_Shape: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::Shape *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_Nchw2Nhwc: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::Nchw2Nhwc *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_Nhwc2Nchw: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::Nhwc2Nchw *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_QuantDTypeCast: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::QuantDTypeCast *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_Split: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::Split *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_Permute: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::Permute *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_FakeQuantWithMinMaxVars: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::FakeQuantWithMinMaxVars *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_Equal: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::Equal *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_Less: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::Less *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_Greater: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::Greater *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_NotEqual: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::NotEqual *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_LessEqual: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::LessEqual *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_GreaterEqual: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::GreaterEqual *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_Min: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::Min *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_Floor: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::Floor *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_Abs: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::Abs *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_Neg: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::Neg *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_Cos: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::Cos *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_Sin: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::Sin *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_Sqrt: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::Sqrt *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_Square: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::Square *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_Constant: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::Constant *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_Log: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::Log *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_Tan: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::Tan *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_Atan: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::Atan *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_Asin: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::Asin *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_Clip: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::Clip *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_Transpose: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::Transpose *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_Squeeze: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::Squeeze *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_Unsqueeze: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::Unsqueeze *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_Upsample: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::Upsample *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_Dropout: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::Dropout *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_Broadcast: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::Broadcast *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_BroadcastTo: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::BroadcastTo *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_Lrn: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::Lrn *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_ZerosLike: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::ZerosLike *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_TopK: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::TopK *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_SpaceToDepth: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::SpaceToDepth *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_SpaceToBatch: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::SpaceToBatch *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_SparseToDense: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::SparseToDense *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_ReverseSequence: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::ReverseSequence *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_Rank: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::Rank *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_Gather: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::Gather *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_GatherNd: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::GatherNd *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_Fill: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::Fill *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_Elu: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::Elu *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_DepthToSpace: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::DepthToSpace *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_BatchToSpace: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::BatchToSpace *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_AddN: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::AddN *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_Ceil: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::Ceil *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_EmbeddingLookup: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::EmbeddingLookup *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_EmbeddingLookupSparse: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::EmbeddingLookupSparse *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_FloorDiv: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::FloorDiv *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_FloorMod: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::FloorMod *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_L2Norm: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::L2Norm *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_LocalResponseNormalization: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::LocalResponseNormalization *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_MatrixDiag: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::MatrixDiag *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_Reduce: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::Reduce *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_Reverse: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::Reverse *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_Round: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::Round *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_Select: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::Select *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_Scatter: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::Scatter *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_ScatterND: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::ScatterND *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_ConstantOfShape: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::ConstantOfShape *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_Unique: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::Unique *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_Unstack: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::Unstack *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_LogicalAnd: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::LogicalAnd *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_LogicalOr: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::LogicalOr *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_LogicalXor: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::LogicalXor *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_LogicalNot: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::LogicalNot *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_OnnxInt8Quantize: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::OnnxInt8Quantize *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_OnnxInt8Dequantize: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::OnnxInt8Dequantize *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_FakeQuantWithMinMax: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::FakeQuantWithMinMax *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_FakeQuantWithMinMaxPerChannel: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::FakeQuantWithMinMaxPerChannel *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_BatchNormFold: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::BatchNormFold *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_MulFold: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::MulFold *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_AddFold: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::AddFold *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_SquaredDifference: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::SquaredDifference *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_Flatten: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::Flatten *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_FlattenGrad: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::FlattenGrad *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_TupleGetItem: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::TupleGetItem *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_Div: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::Div *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_Where: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::Where *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_OneHot: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::OneHot *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_Lstm: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::Lstm *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_Conv2DGradFilter: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::Conv2DGradFilter *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_Conv2DGradInput: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::Conv2DGradInput *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_PoolingGrad: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::PoolingGrad *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_BNGrad: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::BNGrad *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_Assign: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::Assign *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_ApplyMomentum: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::ApplyMomentum *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_BiasGrad: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::BiasGrad *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_SoftmaxCrossEntropy: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::SoftmaxCrossEntropy *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_AddGrad: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::AddGrad *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_SubGrad: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::SubGrad *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_MulGrad: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::MulGrad *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_DivGrad: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::DivGrad *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_PowerGrad: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::PowerGrad *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_ActivationGrad: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::ActivationGrad *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_PriorBox: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::PriorBox *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_SpaceToBatchND: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::SpaceToBatchND *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_Depend: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::Depend *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_Return: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::Return *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_MakeTuple: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::MakeTuple *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_ToFormat: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::ToFormat *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_Proposal: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::Proposal *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_Custom: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::Custom *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_BlackBox: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::BlackBox *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_NegGrad: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::NegGrad *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_LogGrad: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::LogGrad *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_BatchToSpaceND: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::BatchToSpaceND *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_LshProjection: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::LshProjection *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_HashtableLookup: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::HashtableLookup *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_SkipGram: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::SkipGram *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_DeConv2DGradFilter: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::DeConv2DGradFilter *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_CustomPredict: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::CustomPredict *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_CustomNormalize: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::CustomNormalize *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_CustomExtractFeatures: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::CustomExtractFeatures *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_AudioSpectrogram: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::AudioSpectrogram *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_Mfcc: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::Mfcc *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_Rfft: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::Rfft *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_FftReal: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::FftReal *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_FftImag: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::FftImag *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_Sgd: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::Sgd *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_Adam: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::Adam *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_GroupConv2DGradInput: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::GroupConv2DGradInput *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_Loop: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::Loop *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_NonMaxSuppression: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::NonMaxSuppression *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_InstanceNorm: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::InstanceNorm *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_Identity: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::Identity *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_LayerNorm: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::LayerNorm *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_While: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::While *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_ControlDepend: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::ControlDepend *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_UnsortedSegmentSum: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::UnsortedSegmentSum *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_AssignAdd: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::AssignAdd *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_OnesLike: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::OnesLike *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_BinaryCrossEntropyGrad: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::BinaryCrossEntropyGrad *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_BinaryCrossEntropy: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::BinaryCrossEntropy *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_LpNormalization: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::LpNormalization *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_DropoutGrad: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::DropoutGrad *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_MaximumGrad: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::MaximumGrad *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_MinimumGrad: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::MinimumGrad *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_Switch: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::Switch *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_Partial: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::Partial *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_TensorListFromTensor: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::TensorListFromTensor *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_TensorListStack: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::TensorListStack *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_TensorListGetItem: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::TensorListGetItem *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_TensorListSetItem: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::TensorListSetItem *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_TensorListReserve: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::TensorListReserve *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_All: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::All *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_Assert: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::Assert *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_Adder: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::Adder *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_SparseSoftmaxCrossEntropy: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::SparseSoftmaxCrossEntropy *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_SmoothL1Loss: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::SmoothL1Loss *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_SmoothL1LossGrad: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::SmoothL1LossGrad *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_SigmoidCrossEntropyWithLogits: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::SigmoidCrossEntropyWithLogits *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_SigmoidCrossEntropyWithLogitsGrad: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::SigmoidCrossEntropyWithLogitsGrad *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_Reciprocal: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::Reciprocal *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_Merge: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::Merge *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_Mod: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::Mod *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_GeLU: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::GeLU *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return true;
  }
}

inline bool VerifyPrimitiveTypeVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyPrimitiveType(
        verifier,  values->Get(i), types->GetEnum<PrimitiveType>(i))) {
      return false;
    }
  }
  return true;
}

inline void *PrimitiveTypeUnion::UnPack(const void *obj, PrimitiveType type, const flatbuffers::resolver_function_t *resolver) {
  switch (type) {
    case PrimitiveType_Concat: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::Concat *>(obj);
      return ptr->UnPack(resolver);
    }
    case PrimitiveType_SoftMax: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::SoftMax *>(obj);
      return ptr->UnPack(resolver);
    }
    case PrimitiveType_Activation: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::Activation *>(obj);
      return ptr->UnPack(resolver);
    }
    case PrimitiveType_Conv2D: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::Conv2D *>(obj);
      return ptr->UnPack(resolver);
    }
    case PrimitiveType_FusedBatchNorm: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::FusedBatchNorm *>(obj);
      return ptr->UnPack(resolver);
    }
    case PrimitiveType_BatchNorm: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::BatchNorm *>(obj);
      return ptr->UnPack(resolver);
    }
    case PrimitiveType_BiasAdd: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::BiasAdd *>(obj);
      return ptr->UnPack(resolver);
    }
    case PrimitiveType_Pooling: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::Pooling *>(obj);
      return ptr->UnPack(resolver);
    }
    case PrimitiveType_ROIPooling: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::ROIPooling *>(obj);
      return ptr->UnPack(resolver);
    }
    case PrimitiveType_DepthwiseConv2D: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::DepthwiseConv2D *>(obj);
      return ptr->UnPack(resolver);
    }
    case PrimitiveType_DeDepthwiseConv2D: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::DeDepthwiseConv2D *>(obj);
      return ptr->UnPack(resolver);
    }
    case PrimitiveType_Resize: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::Resize *>(obj);
      return ptr->UnPack(resolver);
    }
    case PrimitiveType_DetectionPostProcess: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::DetectionPostProcess *>(obj);
      return ptr->UnPack(resolver);
    }
    case PrimitiveType_FullConnection: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::FullConnection *>(obj);
      return ptr->UnPack(resolver);
    }
    case PrimitiveType_Mean: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::Mean *>(obj);
      return ptr->UnPack(resolver);
    }
    case PrimitiveType_DeConv2D: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::DeConv2D *>(obj);
      return ptr->UnPack(resolver);
    }
    case PrimitiveType_Scale: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::Scale *>(obj);
      return ptr->UnPack(resolver);
    }
    case PrimitiveType_Reshape: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::Reshape *>(obj);
      return ptr->UnPack(resolver);
    }
    case PrimitiveType_Eltwise: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::Eltwise *>(obj);
      return ptr->UnPack(resolver);
    }
    case PrimitiveType_NetOutput: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::NetOutput *>(obj);
      return ptr->UnPack(resolver);
    }
    case PrimitiveType_Add: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::Add *>(obj);
      return ptr->UnPack(resolver);
    }
    case PrimitiveType_Sub: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::Sub *>(obj);
      return ptr->UnPack(resolver);
    }
    case PrimitiveType_MatMul: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::MatMul *>(obj);
      return ptr->UnPack(resolver);
    }
    case PrimitiveType_StridedSlice: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::StridedSlice *>(obj);
      return ptr->UnPack(resolver);
    }
    case PrimitiveType_Power: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::Power *>(obj);
      return ptr->UnPack(resolver);
    }
    case PrimitiveType_Slice: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::Slice *>(obj);
      return ptr->UnPack(resolver);
    }
    case PrimitiveType_Stack: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::Stack *>(obj);
      return ptr->UnPack(resolver);
    }
    case PrimitiveType_Mul: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::Mul *>(obj);
      return ptr->UnPack(resolver);
    }
    case PrimitiveType_RealDiv: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::RealDiv *>(obj);
      return ptr->UnPack(resolver);
    }
    case PrimitiveType_Pad: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::Pad *>(obj);
      return ptr->UnPack(resolver);
    }
    case PrimitiveType_Maximum: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::Maximum *>(obj);
      return ptr->UnPack(resolver);
    }
    case PrimitiveType_Minimum: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::Minimum *>(obj);
      return ptr->UnPack(resolver);
    }
    case PrimitiveType_PReLU: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::PReLU *>(obj);
      return ptr->UnPack(resolver);
    }
    case PrimitiveType_LeakyReLU: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::LeakyReLU *>(obj);
      return ptr->UnPack(resolver);
    }
    case PrimitiveType_ArgMax: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::ArgMax *>(obj);
      return ptr->UnPack(resolver);
    }
    case PrimitiveType_ArgMin: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::ArgMin *>(obj);
      return ptr->UnPack(resolver);
    }
    case PrimitiveType_Exp: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::Exp *>(obj);
      return ptr->UnPack(resolver);
    }
    case PrimitiveType_Crop: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::Crop *>(obj);
      return ptr->UnPack(resolver);
    }
    case PrimitiveType_Range: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::Range *>(obj);
      return ptr->UnPack(resolver);
    }
    case PrimitiveType_Rsqrt: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::Rsqrt *>(obj);
      return ptr->UnPack(resolver);
    }
    case PrimitiveType_ExpandDims: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::ExpandDims *>(obj);
      return ptr->UnPack(resolver);
    }
    case PrimitiveType_Tile: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::Tile *>(obj);
      return ptr->UnPack(resolver);
    }
    case PrimitiveType_Cast: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::Cast *>(obj);
      return ptr->UnPack(resolver);
    }
    case PrimitiveType_Shape: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::Shape *>(obj);
      return ptr->UnPack(resolver);
    }
    case PrimitiveType_Nchw2Nhwc: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::Nchw2Nhwc *>(obj);
      return ptr->UnPack(resolver);
    }
    case PrimitiveType_Nhwc2Nchw: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::Nhwc2Nchw *>(obj);
      return ptr->UnPack(resolver);
    }
    case PrimitiveType_QuantDTypeCast: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::QuantDTypeCast *>(obj);
      return ptr->UnPack(resolver);
    }
    case PrimitiveType_Split: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::Split *>(obj);
      return ptr->UnPack(resolver);
    }
    case PrimitiveType_Permute: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::Permute *>(obj);
      return ptr->UnPack(resolver);
    }
    case PrimitiveType_FakeQuantWithMinMaxVars: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::FakeQuantWithMinMaxVars *>(obj);
      return ptr->UnPack(resolver);
    }
    case PrimitiveType_Equal: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::Equal *>(obj);
      return ptr->UnPack(resolver);
    }
    case PrimitiveType_Less: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::Less *>(obj);
      return ptr->UnPack(resolver);
    }
    case PrimitiveType_Greater: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::Greater *>(obj);
      return ptr->UnPack(resolver);
    }
    case PrimitiveType_NotEqual: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::NotEqual *>(obj);
      return ptr->UnPack(resolver);
    }
    case PrimitiveType_LessEqual: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::LessEqual *>(obj);
      return ptr->UnPack(resolver);
    }
    case PrimitiveType_GreaterEqual: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::GreaterEqual *>(obj);
      return ptr->UnPack(resolver);
    }
    case PrimitiveType_Min: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::Min *>(obj);
      return ptr->UnPack(resolver);
    }
    case PrimitiveType_Floor: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::Floor *>(obj);
      return ptr->UnPack(resolver);
    }
    case PrimitiveType_Abs: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::Abs *>(obj);
      return ptr->UnPack(resolver);
    }
    case PrimitiveType_Neg: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::Neg *>(obj);
      return ptr->UnPack(resolver);
    }
    case PrimitiveType_Cos: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::Cos *>(obj);
      return ptr->UnPack(resolver);
    }
    case PrimitiveType_Sin: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::Sin *>(obj);
      return ptr->UnPack(resolver);
    }
    case PrimitiveType_Sqrt: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::Sqrt *>(obj);
      return ptr->UnPack(resolver);
    }
    case PrimitiveType_Square: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::Square *>(obj);
      return ptr->UnPack(resolver);
    }
    case PrimitiveType_Constant: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::Constant *>(obj);
      return ptr->UnPack(resolver);
    }
    case PrimitiveType_Log: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::Log *>(obj);
      return ptr->UnPack(resolver);
    }
    case PrimitiveType_Tan: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::Tan *>(obj);
      return ptr->UnPack(resolver);
    }
    case PrimitiveType_Atan: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::Atan *>(obj);
      return ptr->UnPack(resolver);
    }
    case PrimitiveType_Asin: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::Asin *>(obj);
      return ptr->UnPack(resolver);
    }
    case PrimitiveType_Clip: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::Clip *>(obj);
      return ptr->UnPack(resolver);
    }
    case PrimitiveType_Transpose: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::Transpose *>(obj);
      return ptr->UnPack(resolver);
    }
    case PrimitiveType_Squeeze: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::Squeeze *>(obj);
      return ptr->UnPack(resolver);
    }
    case PrimitiveType_Unsqueeze: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::Unsqueeze *>(obj);
      return ptr->UnPack(resolver);
    }
    case PrimitiveType_Upsample: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::Upsample *>(obj);
      return ptr->UnPack(resolver);
    }
    case PrimitiveType_Dropout: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::Dropout *>(obj);
      return ptr->UnPack(resolver);
    }
    case PrimitiveType_Broadcast: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::Broadcast *>(obj);
      return ptr->UnPack(resolver);
    }
    case PrimitiveType_BroadcastTo: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::BroadcastTo *>(obj);
      return ptr->UnPack(resolver);
    }
    case PrimitiveType_Lrn: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::Lrn *>(obj);
      return ptr->UnPack(resolver);
    }
    case PrimitiveType_ZerosLike: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::ZerosLike *>(obj);
      return ptr->UnPack(resolver);
    }
    case PrimitiveType_TopK: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::TopK *>(obj);
      return ptr->UnPack(resolver);
    }
    case PrimitiveType_SpaceToDepth: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::SpaceToDepth *>(obj);
      return ptr->UnPack(resolver);
    }
    case PrimitiveType_SpaceToBatch: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::SpaceToBatch *>(obj);
      return ptr->UnPack(resolver);
    }
    case PrimitiveType_SparseToDense: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::SparseToDense *>(obj);
      return ptr->UnPack(resolver);
    }
    case PrimitiveType_ReverseSequence: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::ReverseSequence *>(obj);
      return ptr->UnPack(resolver);
    }
    case PrimitiveType_Rank: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::Rank *>(obj);
      return ptr->UnPack(resolver);
    }
    case PrimitiveType_Gather: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::Gather *>(obj);
      return ptr->UnPack(resolver);
    }
    case PrimitiveType_GatherNd: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::GatherNd *>(obj);
      return ptr->UnPack(resolver);
    }
    case PrimitiveType_Fill: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::Fill *>(obj);
      return ptr->UnPack(resolver);
    }
    case PrimitiveType_Elu: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::Elu *>(obj);
      return ptr->UnPack(resolver);
    }
    case PrimitiveType_DepthToSpace: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::DepthToSpace *>(obj);
      return ptr->UnPack(resolver);
    }
    case PrimitiveType_BatchToSpace: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::BatchToSpace *>(obj);
      return ptr->UnPack(resolver);
    }
    case PrimitiveType_AddN: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::AddN *>(obj);
      return ptr->UnPack(resolver);
    }
    case PrimitiveType_Ceil: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::Ceil *>(obj);
      return ptr->UnPack(resolver);
    }
    case PrimitiveType_EmbeddingLookup: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::EmbeddingLookup *>(obj);
      return ptr->UnPack(resolver);
    }
    case PrimitiveType_EmbeddingLookupSparse: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::EmbeddingLookupSparse *>(obj);
      return ptr->UnPack(resolver);
    }
    case PrimitiveType_FloorDiv: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::FloorDiv *>(obj);
      return ptr->UnPack(resolver);
    }
    case PrimitiveType_FloorMod: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::FloorMod *>(obj);
      return ptr->UnPack(resolver);
    }
    case PrimitiveType_L2Norm: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::L2Norm *>(obj);
      return ptr->UnPack(resolver);
    }
    case PrimitiveType_LocalResponseNormalization: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::LocalResponseNormalization *>(obj);
      return ptr->UnPack(resolver);
    }
    case PrimitiveType_MatrixDiag: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::MatrixDiag *>(obj);
      return ptr->UnPack(resolver);
    }
    case PrimitiveType_Reduce: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::Reduce *>(obj);
      return ptr->UnPack(resolver);
    }
    case PrimitiveType_Reverse: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::Reverse *>(obj);
      return ptr->UnPack(resolver);
    }
    case PrimitiveType_Round: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::Round *>(obj);
      return ptr->UnPack(resolver);
    }
    case PrimitiveType_Select: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::Select *>(obj);
      return ptr->UnPack(resolver);
    }
    case PrimitiveType_Scatter: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::Scatter *>(obj);
      return ptr->UnPack(resolver);
    }
    case PrimitiveType_ScatterND: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::ScatterND *>(obj);
      return ptr->UnPack(resolver);
    }
    case PrimitiveType_ConstantOfShape: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::ConstantOfShape *>(obj);
      return ptr->UnPack(resolver);
    }
    case PrimitiveType_Unique: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::Unique *>(obj);
      return ptr->UnPack(resolver);
    }
    case PrimitiveType_Unstack: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::Unstack *>(obj);
      return ptr->UnPack(resolver);
    }
    case PrimitiveType_LogicalAnd: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::LogicalAnd *>(obj);
      return ptr->UnPack(resolver);
    }
    case PrimitiveType_LogicalOr: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::LogicalOr *>(obj);
      return ptr->UnPack(resolver);
    }
    case PrimitiveType_LogicalXor: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::LogicalXor *>(obj);
      return ptr->UnPack(resolver);
    }
    case PrimitiveType_LogicalNot: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::LogicalNot *>(obj);
      return ptr->UnPack(resolver);
    }
    case PrimitiveType_OnnxInt8Quantize: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::OnnxInt8Quantize *>(obj);
      return ptr->UnPack(resolver);
    }
    case PrimitiveType_OnnxInt8Dequantize: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::OnnxInt8Dequantize *>(obj);
      return ptr->UnPack(resolver);
    }
    case PrimitiveType_FakeQuantWithMinMax: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::FakeQuantWithMinMax *>(obj);
      return ptr->UnPack(resolver);
    }
    case PrimitiveType_FakeQuantWithMinMaxPerChannel: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::FakeQuantWithMinMaxPerChannel *>(obj);
      return ptr->UnPack(resolver);
    }
    case PrimitiveType_BatchNormFold: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::BatchNormFold *>(obj);
      return ptr->UnPack(resolver);
    }
    case PrimitiveType_MulFold: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::MulFold *>(obj);
      return ptr->UnPack(resolver);
    }
    case PrimitiveType_AddFold: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::AddFold *>(obj);
      return ptr->UnPack(resolver);
    }
    case PrimitiveType_SquaredDifference: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::SquaredDifference *>(obj);
      return ptr->UnPack(resolver);
    }
    case PrimitiveType_Flatten: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::Flatten *>(obj);
      return ptr->UnPack(resolver);
    }
    case PrimitiveType_FlattenGrad: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::FlattenGrad *>(obj);
      return ptr->UnPack(resolver);
    }
    case PrimitiveType_TupleGetItem: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::TupleGetItem *>(obj);
      return ptr->UnPack(resolver);
    }
    case PrimitiveType_Div: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::Div *>(obj);
      return ptr->UnPack(resolver);
    }
    case PrimitiveType_Where: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::Where *>(obj);
      return ptr->UnPack(resolver);
    }
    case PrimitiveType_OneHot: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::OneHot *>(obj);
      return ptr->UnPack(resolver);
    }
    case PrimitiveType_Lstm: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::Lstm *>(obj);
      return ptr->UnPack(resolver);
    }
    case PrimitiveType_Conv2DGradFilter: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::Conv2DGradFilter *>(obj);
      return ptr->UnPack(resolver);
    }
    case PrimitiveType_Conv2DGradInput: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::Conv2DGradInput *>(obj);
      return ptr->UnPack(resolver);
    }
    case PrimitiveType_PoolingGrad: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::PoolingGrad *>(obj);
      return ptr->UnPack(resolver);
    }
    case PrimitiveType_BNGrad: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::BNGrad *>(obj);
      return ptr->UnPack(resolver);
    }
    case PrimitiveType_Assign: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::Assign *>(obj);
      return ptr->UnPack(resolver);
    }
    case PrimitiveType_ApplyMomentum: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::ApplyMomentum *>(obj);
      return ptr->UnPack(resolver);
    }
    case PrimitiveType_BiasGrad: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::BiasGrad *>(obj);
      return ptr->UnPack(resolver);
    }
    case PrimitiveType_SoftmaxCrossEntropy: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::SoftmaxCrossEntropy *>(obj);
      return ptr->UnPack(resolver);
    }
    case PrimitiveType_AddGrad: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::AddGrad *>(obj);
      return ptr->UnPack(resolver);
    }
    case PrimitiveType_SubGrad: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::SubGrad *>(obj);
      return ptr->UnPack(resolver);
    }
    case PrimitiveType_MulGrad: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::MulGrad *>(obj);
      return ptr->UnPack(resolver);
    }
    case PrimitiveType_DivGrad: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::DivGrad *>(obj);
      return ptr->UnPack(resolver);
    }
    case PrimitiveType_PowerGrad: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::PowerGrad *>(obj);
      return ptr->UnPack(resolver);
    }
    case PrimitiveType_ActivationGrad: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::ActivationGrad *>(obj);
      return ptr->UnPack(resolver);
    }
    case PrimitiveType_PriorBox: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::PriorBox *>(obj);
      return ptr->UnPack(resolver);
    }
    case PrimitiveType_SpaceToBatchND: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::SpaceToBatchND *>(obj);
      return ptr->UnPack(resolver);
    }
    case PrimitiveType_Depend: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::Depend *>(obj);
      return ptr->UnPack(resolver);
    }
    case PrimitiveType_Return: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::Return *>(obj);
      return ptr->UnPack(resolver);
    }
    case PrimitiveType_MakeTuple: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::MakeTuple *>(obj);
      return ptr->UnPack(resolver);
    }
    case PrimitiveType_ToFormat: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::ToFormat *>(obj);
      return ptr->UnPack(resolver);
    }
    case PrimitiveType_Proposal: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::Proposal *>(obj);
      return ptr->UnPack(resolver);
    }
    case PrimitiveType_Custom: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::Custom *>(obj);
      return ptr->UnPack(resolver);
    }
    case PrimitiveType_BlackBox: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::BlackBox *>(obj);
      return ptr->UnPack(resolver);
    }
    case PrimitiveType_NegGrad: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::NegGrad *>(obj);
      return ptr->UnPack(resolver);
    }
    case PrimitiveType_LogGrad: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::LogGrad *>(obj);
      return ptr->UnPack(resolver);
    }
    case PrimitiveType_BatchToSpaceND: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::BatchToSpaceND *>(obj);
      return ptr->UnPack(resolver);
    }
    case PrimitiveType_LshProjection: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::LshProjection *>(obj);
      return ptr->UnPack(resolver);
    }
    case PrimitiveType_HashtableLookup: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::HashtableLookup *>(obj);
      return ptr->UnPack(resolver);
    }
    case PrimitiveType_SkipGram: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::SkipGram *>(obj);
      return ptr->UnPack(resolver);
    }
    case PrimitiveType_DeConv2DGradFilter: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::DeConv2DGradFilter *>(obj);
      return ptr->UnPack(resolver);
    }
    case PrimitiveType_CustomPredict: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::CustomPredict *>(obj);
      return ptr->UnPack(resolver);
    }
    case PrimitiveType_CustomNormalize: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::CustomNormalize *>(obj);
      return ptr->UnPack(resolver);
    }
    case PrimitiveType_CustomExtractFeatures: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::CustomExtractFeatures *>(obj);
      return ptr->UnPack(resolver);
    }
    case PrimitiveType_AudioSpectrogram: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::AudioSpectrogram *>(obj);
      return ptr->UnPack(resolver);
    }
    case PrimitiveType_Mfcc: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::Mfcc *>(obj);
      return ptr->UnPack(resolver);
    }
    case PrimitiveType_Rfft: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::Rfft *>(obj);
      return ptr->UnPack(resolver);
    }
    case PrimitiveType_FftReal: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::FftReal *>(obj);
      return ptr->UnPack(resolver);
    }
    case PrimitiveType_FftImag: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::FftImag *>(obj);
      return ptr->UnPack(resolver);
    }
    case PrimitiveType_Sgd: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::Sgd *>(obj);
      return ptr->UnPack(resolver);
    }
    case PrimitiveType_Adam: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::Adam *>(obj);
      return ptr->UnPack(resolver);
    }
    case PrimitiveType_GroupConv2DGradInput: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::GroupConv2DGradInput *>(obj);
      return ptr->UnPack(resolver);
    }
    case PrimitiveType_Loop: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::Loop *>(obj);
      return ptr->UnPack(resolver);
    }
    case PrimitiveType_NonMaxSuppression: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::NonMaxSuppression *>(obj);
      return ptr->UnPack(resolver);
    }
    case PrimitiveType_InstanceNorm: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::InstanceNorm *>(obj);
      return ptr->UnPack(resolver);
    }
    case PrimitiveType_Identity: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::Identity *>(obj);
      return ptr->UnPack(resolver);
    }
    case PrimitiveType_LayerNorm: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::LayerNorm *>(obj);
      return ptr->UnPack(resolver);
    }
    case PrimitiveType_While: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::While *>(obj);
      return ptr->UnPack(resolver);
    }
    case PrimitiveType_ControlDepend: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::ControlDepend *>(obj);
      return ptr->UnPack(resolver);
    }
    case PrimitiveType_UnsortedSegmentSum: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::UnsortedSegmentSum *>(obj);
      return ptr->UnPack(resolver);
    }
    case PrimitiveType_AssignAdd: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::AssignAdd *>(obj);
      return ptr->UnPack(resolver);
    }
    case PrimitiveType_OnesLike: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::OnesLike *>(obj);
      return ptr->UnPack(resolver);
    }
    case PrimitiveType_BinaryCrossEntropyGrad: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::BinaryCrossEntropyGrad *>(obj);
      return ptr->UnPack(resolver);
    }
    case PrimitiveType_BinaryCrossEntropy: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::BinaryCrossEntropy *>(obj);
      return ptr->UnPack(resolver);
    }
    case PrimitiveType_LpNormalization: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::LpNormalization *>(obj);
      return ptr->UnPack(resolver);
    }
    case PrimitiveType_DropoutGrad: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::DropoutGrad *>(obj);
      return ptr->UnPack(resolver);
    }
    case PrimitiveType_MaximumGrad: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::MaximumGrad *>(obj);
      return ptr->UnPack(resolver);
    }
    case PrimitiveType_MinimumGrad: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::MinimumGrad *>(obj);
      return ptr->UnPack(resolver);
    }
    case PrimitiveType_Switch: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::Switch *>(obj);
      return ptr->UnPack(resolver);
    }
    case PrimitiveType_Partial: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::Partial *>(obj);
      return ptr->UnPack(resolver);
    }
    case PrimitiveType_TensorListFromTensor: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::TensorListFromTensor *>(obj);
      return ptr->UnPack(resolver);
    }
    case PrimitiveType_TensorListStack: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::TensorListStack *>(obj);
      return ptr->UnPack(resolver);
    }
    case PrimitiveType_TensorListGetItem: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::TensorListGetItem *>(obj);
      return ptr->UnPack(resolver);
    }
    case PrimitiveType_TensorListSetItem: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::TensorListSetItem *>(obj);
      return ptr->UnPack(resolver);
    }
    case PrimitiveType_TensorListReserve: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::TensorListReserve *>(obj);
      return ptr->UnPack(resolver);
    }
    case PrimitiveType_All: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::All *>(obj);
      return ptr->UnPack(resolver);
    }
    case PrimitiveType_Assert: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::Assert *>(obj);
      return ptr->UnPack(resolver);
    }
    case PrimitiveType_Adder: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::Adder *>(obj);
      return ptr->UnPack(resolver);
    }
    case PrimitiveType_SparseSoftmaxCrossEntropy: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::SparseSoftmaxCrossEntropy *>(obj);
      return ptr->UnPack(resolver);
    }
    case PrimitiveType_SmoothL1Loss: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::SmoothL1Loss *>(obj);
      return ptr->UnPack(resolver);
    }
    case PrimitiveType_SmoothL1LossGrad: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::SmoothL1LossGrad *>(obj);
      return ptr->UnPack(resolver);
    }
    case PrimitiveType_SigmoidCrossEntropyWithLogits: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::SigmoidCrossEntropyWithLogits *>(obj);
      return ptr->UnPack(resolver);
    }
    case PrimitiveType_SigmoidCrossEntropyWithLogitsGrad: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::SigmoidCrossEntropyWithLogitsGrad *>(obj);
      return ptr->UnPack(resolver);
    }
    case PrimitiveType_Reciprocal: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::Reciprocal *>(obj);
      return ptr->UnPack(resolver);
    }
    case PrimitiveType_Merge: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::Merge *>(obj);
      return ptr->UnPack(resolver);
    }
    case PrimitiveType_Mod: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::Mod *>(obj);
      return ptr->UnPack(resolver);
    }
    case PrimitiveType_GeLU: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::GeLU *>(obj);
      return ptr->UnPack(resolver);
    }
    default: return nullptr;
  }
}

inline flatbuffers::Offset<void> PrimitiveTypeUnion::Pack(flatbuffers::FlatBufferBuilder &_fbb, const flatbuffers::rehasher_function_t *_rehasher) const {
  switch (type) {
    case PrimitiveType_Concat: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::ConcatT *>(value);
      return CreateConcat(_fbb, ptr, _rehasher).Union();
    }
    case PrimitiveType_SoftMax: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::SoftMaxT *>(value);
      return CreateSoftMax(_fbb, ptr, _rehasher).Union();
    }
    case PrimitiveType_Activation: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::ActivationT *>(value);
      return CreateActivation(_fbb, ptr, _rehasher).Union();
    }
    case PrimitiveType_Conv2D: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::Conv2DT *>(value);
      return CreateConv2D(_fbb, ptr, _rehasher).Union();
    }
    case PrimitiveType_FusedBatchNorm: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::FusedBatchNormT *>(value);
      return CreateFusedBatchNorm(_fbb, ptr, _rehasher).Union();
    }
    case PrimitiveType_BatchNorm: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::BatchNormT *>(value);
      return CreateBatchNorm(_fbb, ptr, _rehasher).Union();
    }
    case PrimitiveType_BiasAdd: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::BiasAddT *>(value);
      return CreateBiasAdd(_fbb, ptr, _rehasher).Union();
    }
    case PrimitiveType_Pooling: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::PoolingT *>(value);
      return CreatePooling(_fbb, ptr, _rehasher).Union();
    }
    case PrimitiveType_ROIPooling: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::ROIPoolingT *>(value);
      return CreateROIPooling(_fbb, ptr, _rehasher).Union();
    }
    case PrimitiveType_DepthwiseConv2D: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::DepthwiseConv2DT *>(value);
      return CreateDepthwiseConv2D(_fbb, ptr, _rehasher).Union();
    }
    case PrimitiveType_DeDepthwiseConv2D: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::DeDepthwiseConv2DT *>(value);
      return CreateDeDepthwiseConv2D(_fbb, ptr, _rehasher).Union();
    }
    case PrimitiveType_Resize: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::ResizeT *>(value);
      return CreateResize(_fbb, ptr, _rehasher).Union();
    }
    case PrimitiveType_DetectionPostProcess: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::DetectionPostProcessT *>(value);
      return CreateDetectionPostProcess(_fbb, ptr, _rehasher).Union();
    }
    case PrimitiveType_FullConnection: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::FullConnectionT *>(value);
      return CreateFullConnection(_fbb, ptr, _rehasher).Union();
    }
    case PrimitiveType_Mean: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::MeanT *>(value);
      return CreateMean(_fbb, ptr, _rehasher).Union();
    }
    case PrimitiveType_DeConv2D: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::DeConv2DT *>(value);
      return CreateDeConv2D(_fbb, ptr, _rehasher).Union();
    }
    case PrimitiveType_Scale: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::ScaleT *>(value);
      return CreateScale(_fbb, ptr, _rehasher).Union();
    }
    case PrimitiveType_Reshape: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::ReshapeT *>(value);
      return CreateReshape(_fbb, ptr, _rehasher).Union();
    }
    case PrimitiveType_Eltwise: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::EltwiseT *>(value);
      return CreateEltwise(_fbb, ptr, _rehasher).Union();
    }
    case PrimitiveType_NetOutput: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::NetOutputT *>(value);
      return CreateNetOutput(_fbb, ptr, _rehasher).Union();
    }
    case PrimitiveType_Add: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::AddT *>(value);
      return CreateAdd(_fbb, ptr, _rehasher).Union();
    }
    case PrimitiveType_Sub: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::SubT *>(value);
      return CreateSub(_fbb, ptr, _rehasher).Union();
    }
    case PrimitiveType_MatMul: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::MatMulT *>(value);
      return CreateMatMul(_fbb, ptr, _rehasher).Union();
    }
    case PrimitiveType_StridedSlice: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::StridedSliceT *>(value);
      return CreateStridedSlice(_fbb, ptr, _rehasher).Union();
    }
    case PrimitiveType_Power: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::PowerT *>(value);
      return CreatePower(_fbb, ptr, _rehasher).Union();
    }
    case PrimitiveType_Slice: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::SliceT *>(value);
      return CreateSlice(_fbb, ptr, _rehasher).Union();
    }
    case PrimitiveType_Stack: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::StackT *>(value);
      return CreateStack(_fbb, ptr, _rehasher).Union();
    }
    case PrimitiveType_Mul: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::MulT *>(value);
      return CreateMul(_fbb, ptr, _rehasher).Union();
    }
    case PrimitiveType_RealDiv: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::RealDivT *>(value);
      return CreateRealDiv(_fbb, ptr, _rehasher).Union();
    }
    case PrimitiveType_Pad: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::PadT *>(value);
      return CreatePad(_fbb, ptr, _rehasher).Union();
    }
    case PrimitiveType_Maximum: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::MaximumT *>(value);
      return CreateMaximum(_fbb, ptr, _rehasher).Union();
    }
    case PrimitiveType_Minimum: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::MinimumT *>(value);
      return CreateMinimum(_fbb, ptr, _rehasher).Union();
    }
    case PrimitiveType_PReLU: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::PReLUT *>(value);
      return CreatePReLU(_fbb, ptr, _rehasher).Union();
    }
    case PrimitiveType_LeakyReLU: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::LeakyReLUT *>(value);
      return CreateLeakyReLU(_fbb, ptr, _rehasher).Union();
    }
    case PrimitiveType_ArgMax: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::ArgMaxT *>(value);
      return CreateArgMax(_fbb, ptr, _rehasher).Union();
    }
    case PrimitiveType_ArgMin: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::ArgMinT *>(value);
      return CreateArgMin(_fbb, ptr, _rehasher).Union();
    }
    case PrimitiveType_Exp: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::ExpT *>(value);
      return CreateExp(_fbb, ptr, _rehasher).Union();
    }
    case PrimitiveType_Crop: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::CropT *>(value);
      return CreateCrop(_fbb, ptr, _rehasher).Union();
    }
    case PrimitiveType_Range: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::RangeT *>(value);
      return CreateRange(_fbb, ptr, _rehasher).Union();
    }
    case PrimitiveType_Rsqrt: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::RsqrtT *>(value);
      return CreateRsqrt(_fbb, ptr, _rehasher).Union();
    }
    case PrimitiveType_ExpandDims: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::ExpandDimsT *>(value);
      return CreateExpandDims(_fbb, ptr, _rehasher).Union();
    }
    case PrimitiveType_Tile: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::TileT *>(value);
      return CreateTile(_fbb, ptr, _rehasher).Union();
    }
    case PrimitiveType_Cast: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::CastT *>(value);
      return CreateCast(_fbb, ptr, _rehasher).Union();
    }
    case PrimitiveType_Shape: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::ShapeT *>(value);
      return CreateShape(_fbb, ptr, _rehasher).Union();
    }
    case PrimitiveType_Nchw2Nhwc: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::Nchw2NhwcT *>(value);
      return CreateNchw2Nhwc(_fbb, ptr, _rehasher).Union();
    }
    case PrimitiveType_Nhwc2Nchw: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::Nhwc2NchwT *>(value);
      return CreateNhwc2Nchw(_fbb, ptr, _rehasher).Union();
    }
    case PrimitiveType_QuantDTypeCast: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::QuantDTypeCastT *>(value);
      return CreateQuantDTypeCast(_fbb, ptr, _rehasher).Union();
    }
    case PrimitiveType_Split: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::SplitT *>(value);
      return CreateSplit(_fbb, ptr, _rehasher).Union();
    }
    case PrimitiveType_Permute: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::PermuteT *>(value);
      return CreatePermute(_fbb, ptr, _rehasher).Union();
    }
    case PrimitiveType_FakeQuantWithMinMaxVars: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::FakeQuantWithMinMaxVarsT *>(value);
      return CreateFakeQuantWithMinMaxVars(_fbb, ptr, _rehasher).Union();
    }
    case PrimitiveType_Equal: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::EqualT *>(value);
      return CreateEqual(_fbb, ptr, _rehasher).Union();
    }
    case PrimitiveType_Less: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::LessT *>(value);
      return CreateLess(_fbb, ptr, _rehasher).Union();
    }
    case PrimitiveType_Greater: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::GreaterT *>(value);
      return CreateGreater(_fbb, ptr, _rehasher).Union();
    }
    case PrimitiveType_NotEqual: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::NotEqualT *>(value);
      return CreateNotEqual(_fbb, ptr, _rehasher).Union();
    }
    case PrimitiveType_LessEqual: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::LessEqualT *>(value);
      return CreateLessEqual(_fbb, ptr, _rehasher).Union();
    }
    case PrimitiveType_GreaterEqual: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::GreaterEqualT *>(value);
      return CreateGreaterEqual(_fbb, ptr, _rehasher).Union();
    }
    case PrimitiveType_Min: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::MinT *>(value);
      return CreateMin(_fbb, ptr, _rehasher).Union();
    }
    case PrimitiveType_Floor: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::FloorT *>(value);
      return CreateFloor(_fbb, ptr, _rehasher).Union();
    }
    case PrimitiveType_Abs: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::AbsT *>(value);
      return CreateAbs(_fbb, ptr, _rehasher).Union();
    }
    case PrimitiveType_Neg: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::NegT *>(value);
      return CreateNeg(_fbb, ptr, _rehasher).Union();
    }
    case PrimitiveType_Cos: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::CosT *>(value);
      return CreateCos(_fbb, ptr, _rehasher).Union();
    }
    case PrimitiveType_Sin: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::SinT *>(value);
      return CreateSin(_fbb, ptr, _rehasher).Union();
    }
    case PrimitiveType_Sqrt: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::SqrtT *>(value);
      return CreateSqrt(_fbb, ptr, _rehasher).Union();
    }
    case PrimitiveType_Square: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::SquareT *>(value);
      return CreateSquare(_fbb, ptr, _rehasher).Union();
    }
    case PrimitiveType_Constant: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::ConstantT *>(value);
      return CreateConstant(_fbb, ptr, _rehasher).Union();
    }
    case PrimitiveType_Log: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::LogT *>(value);
      return CreateLog(_fbb, ptr, _rehasher).Union();
    }
    case PrimitiveType_Tan: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::TanT *>(value);
      return CreateTan(_fbb, ptr, _rehasher).Union();
    }
    case PrimitiveType_Atan: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::AtanT *>(value);
      return CreateAtan(_fbb, ptr, _rehasher).Union();
    }
    case PrimitiveType_Asin: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::AsinT *>(value);
      return CreateAsin(_fbb, ptr, _rehasher).Union();
    }
    case PrimitiveType_Clip: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::ClipT *>(value);
      return CreateClip(_fbb, ptr, _rehasher).Union();
    }
    case PrimitiveType_Transpose: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::TransposeT *>(value);
      return CreateTranspose(_fbb, ptr, _rehasher).Union();
    }
    case PrimitiveType_Squeeze: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::SqueezeT *>(value);
      return CreateSqueeze(_fbb, ptr, _rehasher).Union();
    }
    case PrimitiveType_Unsqueeze: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::UnsqueezeT *>(value);
      return CreateUnsqueeze(_fbb, ptr, _rehasher).Union();
    }
    case PrimitiveType_Upsample: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::UpsampleT *>(value);
      return CreateUpsample(_fbb, ptr, _rehasher).Union();
    }
    case PrimitiveType_Dropout: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::DropoutT *>(value);
      return CreateDropout(_fbb, ptr, _rehasher).Union();
    }
    case PrimitiveType_Broadcast: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::BroadcastT *>(value);
      return CreateBroadcast(_fbb, ptr, _rehasher).Union();
    }
    case PrimitiveType_BroadcastTo: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::BroadcastToT *>(value);
      return CreateBroadcastTo(_fbb, ptr, _rehasher).Union();
    }
    case PrimitiveType_Lrn: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::LrnT *>(value);
      return CreateLrn(_fbb, ptr, _rehasher).Union();
    }
    case PrimitiveType_ZerosLike: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::ZerosLikeT *>(value);
      return CreateZerosLike(_fbb, ptr, _rehasher).Union();
    }
    case PrimitiveType_TopK: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::TopKT *>(value);
      return CreateTopK(_fbb, ptr, _rehasher).Union();
    }
    case PrimitiveType_SpaceToDepth: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::SpaceToDepthT *>(value);
      return CreateSpaceToDepth(_fbb, ptr, _rehasher).Union();
    }
    case PrimitiveType_SpaceToBatch: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::SpaceToBatchT *>(value);
      return CreateSpaceToBatch(_fbb, ptr, _rehasher).Union();
    }
    case PrimitiveType_SparseToDense: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::SparseToDenseT *>(value);
      return CreateSparseToDense(_fbb, ptr, _rehasher).Union();
    }
    case PrimitiveType_ReverseSequence: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::ReverseSequenceT *>(value);
      return CreateReverseSequence(_fbb, ptr, _rehasher).Union();
    }
    case PrimitiveType_Rank: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::RankT *>(value);
      return CreateRank(_fbb, ptr, _rehasher).Union();
    }
    case PrimitiveType_Gather: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::GatherT *>(value);
      return CreateGather(_fbb, ptr, _rehasher).Union();
    }
    case PrimitiveType_GatherNd: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::GatherNdT *>(value);
      return CreateGatherNd(_fbb, ptr, _rehasher).Union();
    }
    case PrimitiveType_Fill: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::FillT *>(value);
      return CreateFill(_fbb, ptr, _rehasher).Union();
    }
    case PrimitiveType_Elu: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::EluT *>(value);
      return CreateElu(_fbb, ptr, _rehasher).Union();
    }
    case PrimitiveType_DepthToSpace: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::DepthToSpaceT *>(value);
      return CreateDepthToSpace(_fbb, ptr, _rehasher).Union();
    }
    case PrimitiveType_BatchToSpace: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::BatchToSpaceT *>(value);
      return CreateBatchToSpace(_fbb, ptr, _rehasher).Union();
    }
    case PrimitiveType_AddN: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::AddNT *>(value);
      return CreateAddN(_fbb, ptr, _rehasher).Union();
    }
    case PrimitiveType_Ceil: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::CeilT *>(value);
      return CreateCeil(_fbb, ptr, _rehasher).Union();
    }
    case PrimitiveType_EmbeddingLookup: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::EmbeddingLookupT *>(value);
      return CreateEmbeddingLookup(_fbb, ptr, _rehasher).Union();
    }
    case PrimitiveType_EmbeddingLookupSparse: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::EmbeddingLookupSparseT *>(value);
      return CreateEmbeddingLookupSparse(_fbb, ptr, _rehasher).Union();
    }
    case PrimitiveType_FloorDiv: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::FloorDivT *>(value);
      return CreateFloorDiv(_fbb, ptr, _rehasher).Union();
    }
    case PrimitiveType_FloorMod: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::FloorModT *>(value);
      return CreateFloorMod(_fbb, ptr, _rehasher).Union();
    }
    case PrimitiveType_L2Norm: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::L2NormT *>(value);
      return CreateL2Norm(_fbb, ptr, _rehasher).Union();
    }
    case PrimitiveType_LocalResponseNormalization: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::LocalResponseNormalizationT *>(value);
      return CreateLocalResponseNormalization(_fbb, ptr, _rehasher).Union();
    }
    case PrimitiveType_MatrixDiag: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::MatrixDiagT *>(value);
      return CreateMatrixDiag(_fbb, ptr, _rehasher).Union();
    }
    case PrimitiveType_Reduce: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::ReduceT *>(value);
      return CreateReduce(_fbb, ptr, _rehasher).Union();
    }
    case PrimitiveType_Reverse: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::ReverseT *>(value);
      return CreateReverse(_fbb, ptr, _rehasher).Union();
    }
    case PrimitiveType_Round: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::RoundT *>(value);
      return CreateRound(_fbb, ptr, _rehasher).Union();
    }
    case PrimitiveType_Select: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::SelectT *>(value);
      return CreateSelect(_fbb, ptr, _rehasher).Union();
    }
    case PrimitiveType_Scatter: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::ScatterT *>(value);
      return CreateScatter(_fbb, ptr, _rehasher).Union();
    }
    case PrimitiveType_ScatterND: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::ScatterNDT *>(value);
      return CreateScatterND(_fbb, ptr, _rehasher).Union();
    }
    case PrimitiveType_ConstantOfShape: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::ConstantOfShapeT *>(value);
      return CreateConstantOfShape(_fbb, ptr, _rehasher).Union();
    }
    case PrimitiveType_Unique: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::UniqueT *>(value);
      return CreateUnique(_fbb, ptr, _rehasher).Union();
    }
    case PrimitiveType_Unstack: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::UnstackT *>(value);
      return CreateUnstack(_fbb, ptr, _rehasher).Union();
    }
    case PrimitiveType_LogicalAnd: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::LogicalAndT *>(value);
      return CreateLogicalAnd(_fbb, ptr, _rehasher).Union();
    }
    case PrimitiveType_LogicalOr: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::LogicalOrT *>(value);
      return CreateLogicalOr(_fbb, ptr, _rehasher).Union();
    }
    case PrimitiveType_LogicalXor: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::LogicalXorT *>(value);
      return CreateLogicalXor(_fbb, ptr, _rehasher).Union();
    }
    case PrimitiveType_LogicalNot: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::LogicalNotT *>(value);
      return CreateLogicalNot(_fbb, ptr, _rehasher).Union();
    }
    case PrimitiveType_OnnxInt8Quantize: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::OnnxInt8QuantizeT *>(value);
      return CreateOnnxInt8Quantize(_fbb, ptr, _rehasher).Union();
    }
    case PrimitiveType_OnnxInt8Dequantize: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::OnnxInt8DequantizeT *>(value);
      return CreateOnnxInt8Dequantize(_fbb, ptr, _rehasher).Union();
    }
    case PrimitiveType_FakeQuantWithMinMax: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::FakeQuantWithMinMaxT *>(value);
      return CreateFakeQuantWithMinMax(_fbb, ptr, _rehasher).Union();
    }
    case PrimitiveType_FakeQuantWithMinMaxPerChannel: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::FakeQuantWithMinMaxPerChannelT *>(value);
      return CreateFakeQuantWithMinMaxPerChannel(_fbb, ptr, _rehasher).Union();
    }
    case PrimitiveType_BatchNormFold: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::BatchNormFoldT *>(value);
      return CreateBatchNormFold(_fbb, ptr, _rehasher).Union();
    }
    case PrimitiveType_MulFold: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::MulFoldT *>(value);
      return CreateMulFold(_fbb, ptr, _rehasher).Union();
    }
    case PrimitiveType_AddFold: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::AddFoldT *>(value);
      return CreateAddFold(_fbb, ptr, _rehasher).Union();
    }
    case PrimitiveType_SquaredDifference: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::SquaredDifferenceT *>(value);
      return CreateSquaredDifference(_fbb, ptr, _rehasher).Union();
    }
    case PrimitiveType_Flatten: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::FlattenT *>(value);
      return CreateFlatten(_fbb, ptr, _rehasher).Union();
    }
    case PrimitiveType_FlattenGrad: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::FlattenGradT *>(value);
      return CreateFlattenGrad(_fbb, ptr, _rehasher).Union();
    }
    case PrimitiveType_TupleGetItem: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::TupleGetItemT *>(value);
      return CreateTupleGetItem(_fbb, ptr, _rehasher).Union();
    }
    case PrimitiveType_Div: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::DivT *>(value);
      return CreateDiv(_fbb, ptr, _rehasher).Union();
    }
    case PrimitiveType_Where: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::WhereT *>(value);
      return CreateWhere(_fbb, ptr, _rehasher).Union();
    }
    case PrimitiveType_OneHot: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::OneHotT *>(value);
      return CreateOneHot(_fbb, ptr, _rehasher).Union();
    }
    case PrimitiveType_Lstm: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::LstmT *>(value);
      return CreateLstm(_fbb, ptr, _rehasher).Union();
    }
    case PrimitiveType_Conv2DGradFilter: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::Conv2DGradFilterT *>(value);
      return CreateConv2DGradFilter(_fbb, ptr, _rehasher).Union();
    }
    case PrimitiveType_Conv2DGradInput: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::Conv2DGradInputT *>(value);
      return CreateConv2DGradInput(_fbb, ptr, _rehasher).Union();
    }
    case PrimitiveType_PoolingGrad: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::PoolingGradT *>(value);
      return CreatePoolingGrad(_fbb, ptr, _rehasher).Union();
    }
    case PrimitiveType_BNGrad: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::BNGradT *>(value);
      return CreateBNGrad(_fbb, ptr, _rehasher).Union();
    }
    case PrimitiveType_Assign: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::AssignT *>(value);
      return CreateAssign(_fbb, ptr, _rehasher).Union();
    }
    case PrimitiveType_ApplyMomentum: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::ApplyMomentumT *>(value);
      return CreateApplyMomentum(_fbb, ptr, _rehasher).Union();
    }
    case PrimitiveType_BiasGrad: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::BiasGradT *>(value);
      return CreateBiasGrad(_fbb, ptr, _rehasher).Union();
    }
    case PrimitiveType_SoftmaxCrossEntropy: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::SoftmaxCrossEntropyT *>(value);
      return CreateSoftmaxCrossEntropy(_fbb, ptr, _rehasher).Union();
    }
    case PrimitiveType_AddGrad: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::AddGradT *>(value);
      return CreateAddGrad(_fbb, ptr, _rehasher).Union();
    }
    case PrimitiveType_SubGrad: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::SubGradT *>(value);
      return CreateSubGrad(_fbb, ptr, _rehasher).Union();
    }
    case PrimitiveType_MulGrad: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::MulGradT *>(value);
      return CreateMulGrad(_fbb, ptr, _rehasher).Union();
    }
    case PrimitiveType_DivGrad: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::DivGradT *>(value);
      return CreateDivGrad(_fbb, ptr, _rehasher).Union();
    }
    case PrimitiveType_PowerGrad: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::PowerGradT *>(value);
      return CreatePowerGrad(_fbb, ptr, _rehasher).Union();
    }
    case PrimitiveType_ActivationGrad: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::ActivationGradT *>(value);
      return CreateActivationGrad(_fbb, ptr, _rehasher).Union();
    }
    case PrimitiveType_PriorBox: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::PriorBoxT *>(value);
      return CreatePriorBox(_fbb, ptr, _rehasher).Union();
    }
    case PrimitiveType_SpaceToBatchND: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::SpaceToBatchNDT *>(value);
      return CreateSpaceToBatchND(_fbb, ptr, _rehasher).Union();
    }
    case PrimitiveType_Depend: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::DependT *>(value);
      return CreateDepend(_fbb, ptr, _rehasher).Union();
    }
    case PrimitiveType_Return: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::ReturnT *>(value);
      return CreateReturn(_fbb, ptr, _rehasher).Union();
    }
    case PrimitiveType_MakeTuple: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::MakeTupleT *>(value);
      return CreateMakeTuple(_fbb, ptr, _rehasher).Union();
    }
    case PrimitiveType_ToFormat: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::ToFormatT *>(value);
      return CreateToFormat(_fbb, ptr, _rehasher).Union();
    }
    case PrimitiveType_Proposal: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::ProposalT *>(value);
      return CreateProposal(_fbb, ptr, _rehasher).Union();
    }
    case PrimitiveType_Custom: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::CustomT *>(value);
      return CreateCustom(_fbb, ptr, _rehasher).Union();
    }
    case PrimitiveType_BlackBox: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::BlackBoxT *>(value);
      return CreateBlackBox(_fbb, ptr, _rehasher).Union();
    }
    case PrimitiveType_NegGrad: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::NegGradT *>(value);
      return CreateNegGrad(_fbb, ptr, _rehasher).Union();
    }
    case PrimitiveType_LogGrad: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::LogGradT *>(value);
      return CreateLogGrad(_fbb, ptr, _rehasher).Union();
    }
    case PrimitiveType_BatchToSpaceND: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::BatchToSpaceNDT *>(value);
      return CreateBatchToSpaceND(_fbb, ptr, _rehasher).Union();
    }
    case PrimitiveType_LshProjection: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::LshProjectionT *>(value);
      return CreateLshProjection(_fbb, ptr, _rehasher).Union();
    }
    case PrimitiveType_HashtableLookup: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::HashtableLookupT *>(value);
      return CreateHashtableLookup(_fbb, ptr, _rehasher).Union();
    }
    case PrimitiveType_SkipGram: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::SkipGramT *>(value);
      return CreateSkipGram(_fbb, ptr, _rehasher).Union();
    }
    case PrimitiveType_DeConv2DGradFilter: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::DeConv2DGradFilterT *>(value);
      return CreateDeConv2DGradFilter(_fbb, ptr, _rehasher).Union();
    }
    case PrimitiveType_CustomPredict: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::CustomPredictT *>(value);
      return CreateCustomPredict(_fbb, ptr, _rehasher).Union();
    }
    case PrimitiveType_CustomNormalize: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::CustomNormalizeT *>(value);
      return CreateCustomNormalize(_fbb, ptr, _rehasher).Union();
    }
    case PrimitiveType_CustomExtractFeatures: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::CustomExtractFeaturesT *>(value);
      return CreateCustomExtractFeatures(_fbb, ptr, _rehasher).Union();
    }
    case PrimitiveType_AudioSpectrogram: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::AudioSpectrogramT *>(value);
      return CreateAudioSpectrogram(_fbb, ptr, _rehasher).Union();
    }
    case PrimitiveType_Mfcc: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::MfccT *>(value);
      return CreateMfcc(_fbb, ptr, _rehasher).Union();
    }
    case PrimitiveType_Rfft: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::RfftT *>(value);
      return CreateRfft(_fbb, ptr, _rehasher).Union();
    }
    case PrimitiveType_FftReal: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::FftRealT *>(value);
      return CreateFftReal(_fbb, ptr, _rehasher).Union();
    }
    case PrimitiveType_FftImag: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::FftImagT *>(value);
      return CreateFftImag(_fbb, ptr, _rehasher).Union();
    }
    case PrimitiveType_Sgd: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::SgdT *>(value);
      return CreateSgd(_fbb, ptr, _rehasher).Union();
    }
    case PrimitiveType_Adam: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::AdamT *>(value);
      return CreateAdam(_fbb, ptr, _rehasher).Union();
    }
    case PrimitiveType_GroupConv2DGradInput: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::GroupConv2DGradInputT *>(value);
      return CreateGroupConv2DGradInput(_fbb, ptr, _rehasher).Union();
    }
    case PrimitiveType_Loop: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::LoopT *>(value);
      return CreateLoop(_fbb, ptr, _rehasher).Union();
    }
    case PrimitiveType_NonMaxSuppression: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::NonMaxSuppressionT *>(value);
      return CreateNonMaxSuppression(_fbb, ptr, _rehasher).Union();
    }
    case PrimitiveType_InstanceNorm: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::InstanceNormT *>(value);
      return CreateInstanceNorm(_fbb, ptr, _rehasher).Union();
    }
    case PrimitiveType_Identity: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::IdentityT *>(value);
      return CreateIdentity(_fbb, ptr, _rehasher).Union();
    }
    case PrimitiveType_LayerNorm: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::LayerNormT *>(value);
      return CreateLayerNorm(_fbb, ptr, _rehasher).Union();
    }
    case PrimitiveType_While: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::WhileT *>(value);
      return CreateWhile(_fbb, ptr, _rehasher).Union();
    }
    case PrimitiveType_ControlDepend: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::ControlDependT *>(value);
      return CreateControlDepend(_fbb, ptr, _rehasher).Union();
    }
    case PrimitiveType_UnsortedSegmentSum: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::UnsortedSegmentSumT *>(value);
      return CreateUnsortedSegmentSum(_fbb, ptr, _rehasher).Union();
    }
    case PrimitiveType_AssignAdd: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::AssignAddT *>(value);
      return CreateAssignAdd(_fbb, ptr, _rehasher).Union();
    }
    case PrimitiveType_OnesLike: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::OnesLikeT *>(value);
      return CreateOnesLike(_fbb, ptr, _rehasher).Union();
    }
    case PrimitiveType_BinaryCrossEntropyGrad: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::BinaryCrossEntropyGradT *>(value);
      return CreateBinaryCrossEntropyGrad(_fbb, ptr, _rehasher).Union();
    }
    case PrimitiveType_BinaryCrossEntropy: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::BinaryCrossEntropyT *>(value);
      return CreateBinaryCrossEntropy(_fbb, ptr, _rehasher).Union();
    }
    case PrimitiveType_LpNormalization: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::LpNormalizationT *>(value);
      return CreateLpNormalization(_fbb, ptr, _rehasher).Union();
    }
    case PrimitiveType_DropoutGrad: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::DropoutGradT *>(value);
      return CreateDropoutGrad(_fbb, ptr, _rehasher).Union();
    }
    case PrimitiveType_MaximumGrad: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::MaximumGradT *>(value);
      return CreateMaximumGrad(_fbb, ptr, _rehasher).Union();
    }
    case PrimitiveType_MinimumGrad: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::MinimumGradT *>(value);
      return CreateMinimumGrad(_fbb, ptr, _rehasher).Union();
    }
    case PrimitiveType_Switch: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::SwitchT *>(value);
      return CreateSwitch(_fbb, ptr, _rehasher).Union();
    }
    case PrimitiveType_Partial: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::PartialT *>(value);
      return CreatePartial(_fbb, ptr, _rehasher).Union();
    }
    case PrimitiveType_TensorListFromTensor: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::TensorListFromTensorT *>(value);
      return CreateTensorListFromTensor(_fbb, ptr, _rehasher).Union();
    }
    case PrimitiveType_TensorListStack: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::TensorListStackT *>(value);
      return CreateTensorListStack(_fbb, ptr, _rehasher).Union();
    }
    case PrimitiveType_TensorListGetItem: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::TensorListGetItemT *>(value);
      return CreateTensorListGetItem(_fbb, ptr, _rehasher).Union();
    }
    case PrimitiveType_TensorListSetItem: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::TensorListSetItemT *>(value);
      return CreateTensorListSetItem(_fbb, ptr, _rehasher).Union();
    }
    case PrimitiveType_TensorListReserve: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::TensorListReserveT *>(value);
      return CreateTensorListReserve(_fbb, ptr, _rehasher).Union();
    }
    case PrimitiveType_All: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::AllT *>(value);
      return CreateAll(_fbb, ptr, _rehasher).Union();
    }
    case PrimitiveType_Assert: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::AssertT *>(value);
      return CreateAssert(_fbb, ptr, _rehasher).Union();
    }
    case PrimitiveType_Adder: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::AdderT *>(value);
      return CreateAdder(_fbb, ptr, _rehasher).Union();
    }
    case PrimitiveType_SparseSoftmaxCrossEntropy: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::SparseSoftmaxCrossEntropyT *>(value);
      return CreateSparseSoftmaxCrossEntropy(_fbb, ptr, _rehasher).Union();
    }
    case PrimitiveType_SmoothL1Loss: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::SmoothL1LossT *>(value);
      return CreateSmoothL1Loss(_fbb, ptr, _rehasher).Union();
    }
    case PrimitiveType_SmoothL1LossGrad: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::SmoothL1LossGradT *>(value);
      return CreateSmoothL1LossGrad(_fbb, ptr, _rehasher).Union();
    }
    case PrimitiveType_SigmoidCrossEntropyWithLogits: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::SigmoidCrossEntropyWithLogitsT *>(value);
      return CreateSigmoidCrossEntropyWithLogits(_fbb, ptr, _rehasher).Union();
    }
    case PrimitiveType_SigmoidCrossEntropyWithLogitsGrad: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::SigmoidCrossEntropyWithLogitsGradT *>(value);
      return CreateSigmoidCrossEntropyWithLogitsGrad(_fbb, ptr, _rehasher).Union();
    }
    case PrimitiveType_Reciprocal: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::ReciprocalT *>(value);
      return CreateReciprocal(_fbb, ptr, _rehasher).Union();
    }
    case PrimitiveType_Merge: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::MergeT *>(value);
      return CreateMerge(_fbb, ptr, _rehasher).Union();
    }
    case PrimitiveType_Mod: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::ModT *>(value);
      return CreateMod(_fbb, ptr, _rehasher).Union();
    }
    case PrimitiveType_GeLU: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::GeLUT *>(value);
      return CreateGeLU(_fbb, ptr, _rehasher).Union();
    }
    default: return 0;
  }
}

inline PrimitiveTypeUnion::PrimitiveTypeUnion(const PrimitiveTypeUnion &u) : type(u.type), value(nullptr) {
  switch (type) {
    case PrimitiveType_Concat: {
      value = new mindspore::schema::v0::ConcatT(*reinterpret_cast<mindspore::schema::v0::ConcatT *>(u.value));
      break;
    }
    case PrimitiveType_SoftMax: {
      value = new mindspore::schema::v0::SoftMaxT(*reinterpret_cast<mindspore::schema::v0::SoftMaxT *>(u.value));
      break;
    }
    case PrimitiveType_Activation: {
      value = new mindspore::schema::v0::ActivationT(*reinterpret_cast<mindspore::schema::v0::ActivationT *>(u.value));
      break;
    }
    case PrimitiveType_Conv2D: {
      value = new mindspore::schema::v0::Conv2DT(*reinterpret_cast<mindspore::schema::v0::Conv2DT *>(u.value));
      break;
    }
    case PrimitiveType_FusedBatchNorm: {
      value = new mindspore::schema::v0::FusedBatchNormT(*reinterpret_cast<mindspore::schema::v0::FusedBatchNormT *>(u.value));
      break;
    }
    case PrimitiveType_BatchNorm: {
      value = new mindspore::schema::v0::BatchNormT(*reinterpret_cast<mindspore::schema::v0::BatchNormT *>(u.value));
      break;
    }
    case PrimitiveType_BiasAdd: {
      value = new mindspore::schema::v0::BiasAddT(*reinterpret_cast<mindspore::schema::v0::BiasAddT *>(u.value));
      break;
    }
    case PrimitiveType_Pooling: {
      value = new mindspore::schema::v0::PoolingT(*reinterpret_cast<mindspore::schema::v0::PoolingT *>(u.value));
      break;
    }
    case PrimitiveType_ROIPooling: {
      value = new mindspore::schema::v0::ROIPoolingT(*reinterpret_cast<mindspore::schema::v0::ROIPoolingT *>(u.value));
      break;
    }
    case PrimitiveType_DepthwiseConv2D: {
      value = new mindspore::schema::v0::DepthwiseConv2DT(*reinterpret_cast<mindspore::schema::v0::DepthwiseConv2DT *>(u.value));
      break;
    }
    case PrimitiveType_DeDepthwiseConv2D: {
      value = new mindspore::schema::v0::DeDepthwiseConv2DT(*reinterpret_cast<mindspore::schema::v0::DeDepthwiseConv2DT *>(u.value));
      break;
    }
    case PrimitiveType_Resize: {
      value = new mindspore::schema::v0::ResizeT(*reinterpret_cast<mindspore::schema::v0::ResizeT *>(u.value));
      break;
    }
    case PrimitiveType_DetectionPostProcess: {
      value = new mindspore::schema::v0::DetectionPostProcessT(*reinterpret_cast<mindspore::schema::v0::DetectionPostProcessT *>(u.value));
      break;
    }
    case PrimitiveType_FullConnection: {
      value = new mindspore::schema::v0::FullConnectionT(*reinterpret_cast<mindspore::schema::v0::FullConnectionT *>(u.value));
      break;
    }
    case PrimitiveType_Mean: {
      value = new mindspore::schema::v0::MeanT(*reinterpret_cast<mindspore::schema::v0::MeanT *>(u.value));
      break;
    }
    case PrimitiveType_DeConv2D: {
      value = new mindspore::schema::v0::DeConv2DT(*reinterpret_cast<mindspore::schema::v0::DeConv2DT *>(u.value));
      break;
    }
    case PrimitiveType_Scale: {
      value = new mindspore::schema::v0::ScaleT(*reinterpret_cast<mindspore::schema::v0::ScaleT *>(u.value));
      break;
    }
    case PrimitiveType_Reshape: {
      value = new mindspore::schema::v0::ReshapeT(*reinterpret_cast<mindspore::schema::v0::ReshapeT *>(u.value));
      break;
    }
    case PrimitiveType_Eltwise: {
      value = new mindspore::schema::v0::EltwiseT(*reinterpret_cast<mindspore::schema::v0::EltwiseT *>(u.value));
      break;
    }
    case PrimitiveType_NetOutput: {
      value = new mindspore::schema::v0::NetOutputT(*reinterpret_cast<mindspore::schema::v0::NetOutputT *>(u.value));
      break;
    }
    case PrimitiveType_Add: {
      value = new mindspore::schema::v0::AddT(*reinterpret_cast<mindspore::schema::v0::AddT *>(u.value));
      break;
    }
    case PrimitiveType_Sub: {
      value = new mindspore::schema::v0::SubT(*reinterpret_cast<mindspore::schema::v0::SubT *>(u.value));
      break;
    }
    case PrimitiveType_MatMul: {
      value = new mindspore::schema::v0::MatMulT(*reinterpret_cast<mindspore::schema::v0::MatMulT *>(u.value));
      break;
    }
    case PrimitiveType_StridedSlice: {
      value = new mindspore::schema::v0::StridedSliceT(*reinterpret_cast<mindspore::schema::v0::StridedSliceT *>(u.value));
      break;
    }
    case PrimitiveType_Power: {
      value = new mindspore::schema::v0::PowerT(*reinterpret_cast<mindspore::schema::v0::PowerT *>(u.value));
      break;
    }
    case PrimitiveType_Slice: {
      value = new mindspore::schema::v0::SliceT(*reinterpret_cast<mindspore::schema::v0::SliceT *>(u.value));
      break;
    }
    case PrimitiveType_Stack: {
      value = new mindspore::schema::v0::StackT(*reinterpret_cast<mindspore::schema::v0::StackT *>(u.value));
      break;
    }
    case PrimitiveType_Mul: {
      value = new mindspore::schema::v0::MulT(*reinterpret_cast<mindspore::schema::v0::MulT *>(u.value));
      break;
    }
    case PrimitiveType_RealDiv: {
      value = new mindspore::schema::v0::RealDivT(*reinterpret_cast<mindspore::schema::v0::RealDivT *>(u.value));
      break;
    }
    case PrimitiveType_Pad: {
      value = new mindspore::schema::v0::PadT(*reinterpret_cast<mindspore::schema::v0::PadT *>(u.value));
      break;
    }
    case PrimitiveType_Maximum: {
      value = new mindspore::schema::v0::MaximumT(*reinterpret_cast<mindspore::schema::v0::MaximumT *>(u.value));
      break;
    }
    case PrimitiveType_Minimum: {
      value = new mindspore::schema::v0::MinimumT(*reinterpret_cast<mindspore::schema::v0::MinimumT *>(u.value));
      break;
    }
    case PrimitiveType_PReLU: {
      value = new mindspore::schema::v0::PReLUT(*reinterpret_cast<mindspore::schema::v0::PReLUT *>(u.value));
      break;
    }
    case PrimitiveType_LeakyReLU: {
      value = new mindspore::schema::v0::LeakyReLUT(*reinterpret_cast<mindspore::schema::v0::LeakyReLUT *>(u.value));
      break;
    }
    case PrimitiveType_ArgMax: {
      value = new mindspore::schema::v0::ArgMaxT(*reinterpret_cast<mindspore::schema::v0::ArgMaxT *>(u.value));
      break;
    }
    case PrimitiveType_ArgMin: {
      value = new mindspore::schema::v0::ArgMinT(*reinterpret_cast<mindspore::schema::v0::ArgMinT *>(u.value));
      break;
    }
    case PrimitiveType_Exp: {
      value = new mindspore::schema::v0::ExpT(*reinterpret_cast<mindspore::schema::v0::ExpT *>(u.value));
      break;
    }
    case PrimitiveType_Crop: {
      value = new mindspore::schema::v0::CropT(*reinterpret_cast<mindspore::schema::v0::CropT *>(u.value));
      break;
    }
    case PrimitiveType_Range: {
      value = new mindspore::schema::v0::RangeT(*reinterpret_cast<mindspore::schema::v0::RangeT *>(u.value));
      break;
    }
    case PrimitiveType_Rsqrt: {
      value = new mindspore::schema::v0::RsqrtT(*reinterpret_cast<mindspore::schema::v0::RsqrtT *>(u.value));
      break;
    }
    case PrimitiveType_ExpandDims: {
      value = new mindspore::schema::v0::ExpandDimsT(*reinterpret_cast<mindspore::schema::v0::ExpandDimsT *>(u.value));
      break;
    }
    case PrimitiveType_Tile: {
      value = new mindspore::schema::v0::TileT(*reinterpret_cast<mindspore::schema::v0::TileT *>(u.value));
      break;
    }
    case PrimitiveType_Cast: {
      value = new mindspore::schema::v0::CastT(*reinterpret_cast<mindspore::schema::v0::CastT *>(u.value));
      break;
    }
    case PrimitiveType_Shape: {
      value = new mindspore::schema::v0::ShapeT(*reinterpret_cast<mindspore::schema::v0::ShapeT *>(u.value));
      break;
    }
    case PrimitiveType_Nchw2Nhwc: {
      value = new mindspore::schema::v0::Nchw2NhwcT(*reinterpret_cast<mindspore::schema::v0::Nchw2NhwcT *>(u.value));
      break;
    }
    case PrimitiveType_Nhwc2Nchw: {
      value = new mindspore::schema::v0::Nhwc2NchwT(*reinterpret_cast<mindspore::schema::v0::Nhwc2NchwT *>(u.value));
      break;
    }
    case PrimitiveType_QuantDTypeCast: {
      value = new mindspore::schema::v0::QuantDTypeCastT(*reinterpret_cast<mindspore::schema::v0::QuantDTypeCastT *>(u.value));
      break;
    }
    case PrimitiveType_Split: {
      value = new mindspore::schema::v0::SplitT(*reinterpret_cast<mindspore::schema::v0::SplitT *>(u.value));
      break;
    }
    case PrimitiveType_Permute: {
      value = new mindspore::schema::v0::PermuteT(*reinterpret_cast<mindspore::schema::v0::PermuteT *>(u.value));
      break;
    }
    case PrimitiveType_FakeQuantWithMinMaxVars: {
      value = new mindspore::schema::v0::FakeQuantWithMinMaxVarsT(*reinterpret_cast<mindspore::schema::v0::FakeQuantWithMinMaxVarsT *>(u.value));
      break;
    }
    case PrimitiveType_Equal: {
      value = new mindspore::schema::v0::EqualT(*reinterpret_cast<mindspore::schema::v0::EqualT *>(u.value));
      break;
    }
    case PrimitiveType_Less: {
      value = new mindspore::schema::v0::LessT(*reinterpret_cast<mindspore::schema::v0::LessT *>(u.value));
      break;
    }
    case PrimitiveType_Greater: {
      value = new mindspore::schema::v0::GreaterT(*reinterpret_cast<mindspore::schema::v0::GreaterT *>(u.value));
      break;
    }
    case PrimitiveType_NotEqual: {
      value = new mindspore::schema::v0::NotEqualT(*reinterpret_cast<mindspore::schema::v0::NotEqualT *>(u.value));
      break;
    }
    case PrimitiveType_LessEqual: {
      value = new mindspore::schema::v0::LessEqualT(*reinterpret_cast<mindspore::schema::v0::LessEqualT *>(u.value));
      break;
    }
    case PrimitiveType_GreaterEqual: {
      value = new mindspore::schema::v0::GreaterEqualT(*reinterpret_cast<mindspore::schema::v0::GreaterEqualT *>(u.value));
      break;
    }
    case PrimitiveType_Min: {
      value = new mindspore::schema::v0::MinT(*reinterpret_cast<mindspore::schema::v0::MinT *>(u.value));
      break;
    }
    case PrimitiveType_Floor: {
      value = new mindspore::schema::v0::FloorT(*reinterpret_cast<mindspore::schema::v0::FloorT *>(u.value));
      break;
    }
    case PrimitiveType_Abs: {
      value = new mindspore::schema::v0::AbsT(*reinterpret_cast<mindspore::schema::v0::AbsT *>(u.value));
      break;
    }
    case PrimitiveType_Neg: {
      value = new mindspore::schema::v0::NegT(*reinterpret_cast<mindspore::schema::v0::NegT *>(u.value));
      break;
    }
    case PrimitiveType_Cos: {
      value = new mindspore::schema::v0::CosT(*reinterpret_cast<mindspore::schema::v0::CosT *>(u.value));
      break;
    }
    case PrimitiveType_Sin: {
      value = new mindspore::schema::v0::SinT(*reinterpret_cast<mindspore::schema::v0::SinT *>(u.value));
      break;
    }
    case PrimitiveType_Sqrt: {
      value = new mindspore::schema::v0::SqrtT(*reinterpret_cast<mindspore::schema::v0::SqrtT *>(u.value));
      break;
    }
    case PrimitiveType_Square: {
      value = new mindspore::schema::v0::SquareT(*reinterpret_cast<mindspore::schema::v0::SquareT *>(u.value));
      break;
    }
    case PrimitiveType_Constant: {
      value = new mindspore::schema::v0::ConstantT(*reinterpret_cast<mindspore::schema::v0::ConstantT *>(u.value));
      break;
    }
    case PrimitiveType_Log: {
      value = new mindspore::schema::v0::LogT(*reinterpret_cast<mindspore::schema::v0::LogT *>(u.value));
      break;
    }
    case PrimitiveType_Tan: {
      value = new mindspore::schema::v0::TanT(*reinterpret_cast<mindspore::schema::v0::TanT *>(u.value));
      break;
    }
    case PrimitiveType_Atan: {
      value = new mindspore::schema::v0::AtanT(*reinterpret_cast<mindspore::schema::v0::AtanT *>(u.value));
      break;
    }
    case PrimitiveType_Asin: {
      value = new mindspore::schema::v0::AsinT(*reinterpret_cast<mindspore::schema::v0::AsinT *>(u.value));
      break;
    }
    case PrimitiveType_Clip: {
      value = new mindspore::schema::v0::ClipT(*reinterpret_cast<mindspore::schema::v0::ClipT *>(u.value));
      break;
    }
    case PrimitiveType_Transpose: {
      value = new mindspore::schema::v0::TransposeT(*reinterpret_cast<mindspore::schema::v0::TransposeT *>(u.value));
      break;
    }
    case PrimitiveType_Squeeze: {
      value = new mindspore::schema::v0::SqueezeT(*reinterpret_cast<mindspore::schema::v0::SqueezeT *>(u.value));
      break;
    }
    case PrimitiveType_Unsqueeze: {
      value = new mindspore::schema::v0::UnsqueezeT(*reinterpret_cast<mindspore::schema::v0::UnsqueezeT *>(u.value));
      break;
    }
    case PrimitiveType_Upsample: {
      value = new mindspore::schema::v0::UpsampleT(*reinterpret_cast<mindspore::schema::v0::UpsampleT *>(u.value));
      break;
    }
    case PrimitiveType_Dropout: {
      value = new mindspore::schema::v0::DropoutT(*reinterpret_cast<mindspore::schema::v0::DropoutT *>(u.value));
      break;
    }
    case PrimitiveType_Broadcast: {
      value = new mindspore::schema::v0::BroadcastT(*reinterpret_cast<mindspore::schema::v0::BroadcastT *>(u.value));
      break;
    }
    case PrimitiveType_BroadcastTo: {
      value = new mindspore::schema::v0::BroadcastToT(*reinterpret_cast<mindspore::schema::v0::BroadcastToT *>(u.value));
      break;
    }
    case PrimitiveType_Lrn: {
      value = new mindspore::schema::v0::LrnT(*reinterpret_cast<mindspore::schema::v0::LrnT *>(u.value));
      break;
    }
    case PrimitiveType_ZerosLike: {
      value = new mindspore::schema::v0::ZerosLikeT(*reinterpret_cast<mindspore::schema::v0::ZerosLikeT *>(u.value));
      break;
    }
    case PrimitiveType_TopK: {
      value = new mindspore::schema::v0::TopKT(*reinterpret_cast<mindspore::schema::v0::TopKT *>(u.value));
      break;
    }
    case PrimitiveType_SpaceToDepth: {
      value = new mindspore::schema::v0::SpaceToDepthT(*reinterpret_cast<mindspore::schema::v0::SpaceToDepthT *>(u.value));
      break;
    }
    case PrimitiveType_SpaceToBatch: {
      value = new mindspore::schema::v0::SpaceToBatchT(*reinterpret_cast<mindspore::schema::v0::SpaceToBatchT *>(u.value));
      break;
    }
    case PrimitiveType_SparseToDense: {
      value = new mindspore::schema::v0::SparseToDenseT(*reinterpret_cast<mindspore::schema::v0::SparseToDenseT *>(u.value));
      break;
    }
    case PrimitiveType_ReverseSequence: {
      value = new mindspore::schema::v0::ReverseSequenceT(*reinterpret_cast<mindspore::schema::v0::ReverseSequenceT *>(u.value));
      break;
    }
    case PrimitiveType_Rank: {
      value = new mindspore::schema::v0::RankT(*reinterpret_cast<mindspore::schema::v0::RankT *>(u.value));
      break;
    }
    case PrimitiveType_Gather: {
      value = new mindspore::schema::v0::GatherT(*reinterpret_cast<mindspore::schema::v0::GatherT *>(u.value));
      break;
    }
    case PrimitiveType_GatherNd: {
      value = new mindspore::schema::v0::GatherNdT(*reinterpret_cast<mindspore::schema::v0::GatherNdT *>(u.value));
      break;
    }
    case PrimitiveType_Fill: {
      value = new mindspore::schema::v0::FillT(*reinterpret_cast<mindspore::schema::v0::FillT *>(u.value));
      break;
    }
    case PrimitiveType_Elu: {
      value = new mindspore::schema::v0::EluT(*reinterpret_cast<mindspore::schema::v0::EluT *>(u.value));
      break;
    }
    case PrimitiveType_DepthToSpace: {
      value = new mindspore::schema::v0::DepthToSpaceT(*reinterpret_cast<mindspore::schema::v0::DepthToSpaceT *>(u.value));
      break;
    }
    case PrimitiveType_BatchToSpace: {
      value = new mindspore::schema::v0::BatchToSpaceT(*reinterpret_cast<mindspore::schema::v0::BatchToSpaceT *>(u.value));
      break;
    }
    case PrimitiveType_AddN: {
      value = new mindspore::schema::v0::AddNT(*reinterpret_cast<mindspore::schema::v0::AddNT *>(u.value));
      break;
    }
    case PrimitiveType_Ceil: {
      value = new mindspore::schema::v0::CeilT(*reinterpret_cast<mindspore::schema::v0::CeilT *>(u.value));
      break;
    }
    case PrimitiveType_EmbeddingLookup: {
      value = new mindspore::schema::v0::EmbeddingLookupT(*reinterpret_cast<mindspore::schema::v0::EmbeddingLookupT *>(u.value));
      break;
    }
    case PrimitiveType_EmbeddingLookupSparse: {
      value = new mindspore::schema::v0::EmbeddingLookupSparseT(*reinterpret_cast<mindspore::schema::v0::EmbeddingLookupSparseT *>(u.value));
      break;
    }
    case PrimitiveType_FloorDiv: {
      value = new mindspore::schema::v0::FloorDivT(*reinterpret_cast<mindspore::schema::v0::FloorDivT *>(u.value));
      break;
    }
    case PrimitiveType_FloorMod: {
      value = new mindspore::schema::v0::FloorModT(*reinterpret_cast<mindspore::schema::v0::FloorModT *>(u.value));
      break;
    }
    case PrimitiveType_L2Norm: {
      value = new mindspore::schema::v0::L2NormT(*reinterpret_cast<mindspore::schema::v0::L2NormT *>(u.value));
      break;
    }
    case PrimitiveType_LocalResponseNormalization: {
      value = new mindspore::schema::v0::LocalResponseNormalizationT(*reinterpret_cast<mindspore::schema::v0::LocalResponseNormalizationT *>(u.value));
      break;
    }
    case PrimitiveType_MatrixDiag: {
      value = new mindspore::schema::v0::MatrixDiagT(*reinterpret_cast<mindspore::schema::v0::MatrixDiagT *>(u.value));
      break;
    }
    case PrimitiveType_Reduce: {
      value = new mindspore::schema::v0::ReduceT(*reinterpret_cast<mindspore::schema::v0::ReduceT *>(u.value));
      break;
    }
    case PrimitiveType_Reverse: {
      value = new mindspore::schema::v0::ReverseT(*reinterpret_cast<mindspore::schema::v0::ReverseT *>(u.value));
      break;
    }
    case PrimitiveType_Round: {
      value = new mindspore::schema::v0::RoundT(*reinterpret_cast<mindspore::schema::v0::RoundT *>(u.value));
      break;
    }
    case PrimitiveType_Select: {
      value = new mindspore::schema::v0::SelectT(*reinterpret_cast<mindspore::schema::v0::SelectT *>(u.value));
      break;
    }
    case PrimitiveType_Scatter: {
      value = new mindspore::schema::v0::ScatterT(*reinterpret_cast<mindspore::schema::v0::ScatterT *>(u.value));
      break;
    }
    case PrimitiveType_ScatterND: {
      value = new mindspore::schema::v0::ScatterNDT(*reinterpret_cast<mindspore::schema::v0::ScatterNDT *>(u.value));
      break;
    }
    case PrimitiveType_ConstantOfShape: {
      value = new mindspore::schema::v0::ConstantOfShapeT(*reinterpret_cast<mindspore::schema::v0::ConstantOfShapeT *>(u.value));
      break;
    }
    case PrimitiveType_Unique: {
      value = new mindspore::schema::v0::UniqueT(*reinterpret_cast<mindspore::schema::v0::UniqueT *>(u.value));
      break;
    }
    case PrimitiveType_Unstack: {
      value = new mindspore::schema::v0::UnstackT(*reinterpret_cast<mindspore::schema::v0::UnstackT *>(u.value));
      break;
    }
    case PrimitiveType_LogicalAnd: {
      value = new mindspore::schema::v0::LogicalAndT(*reinterpret_cast<mindspore::schema::v0::LogicalAndT *>(u.value));
      break;
    }
    case PrimitiveType_LogicalOr: {
      value = new mindspore::schema::v0::LogicalOrT(*reinterpret_cast<mindspore::schema::v0::LogicalOrT *>(u.value));
      break;
    }
    case PrimitiveType_LogicalXor: {
      value = new mindspore::schema::v0::LogicalXorT(*reinterpret_cast<mindspore::schema::v0::LogicalXorT *>(u.value));
      break;
    }
    case PrimitiveType_LogicalNot: {
      value = new mindspore::schema::v0::LogicalNotT(*reinterpret_cast<mindspore::schema::v0::LogicalNotT *>(u.value));
      break;
    }
    case PrimitiveType_OnnxInt8Quantize: {
      value = new mindspore::schema::v0::OnnxInt8QuantizeT(*reinterpret_cast<mindspore::schema::v0::OnnxInt8QuantizeT *>(u.value));
      break;
    }
    case PrimitiveType_OnnxInt8Dequantize: {
      value = new mindspore::schema::v0::OnnxInt8DequantizeT(*reinterpret_cast<mindspore::schema::v0::OnnxInt8DequantizeT *>(u.value));
      break;
    }
    case PrimitiveType_FakeQuantWithMinMax: {
      value = new mindspore::schema::v0::FakeQuantWithMinMaxT(*reinterpret_cast<mindspore::schema::v0::FakeQuantWithMinMaxT *>(u.value));
      break;
    }
    case PrimitiveType_FakeQuantWithMinMaxPerChannel: {
      value = new mindspore::schema::v0::FakeQuantWithMinMaxPerChannelT(*reinterpret_cast<mindspore::schema::v0::FakeQuantWithMinMaxPerChannelT *>(u.value));
      break;
    }
    case PrimitiveType_BatchNormFold: {
      value = new mindspore::schema::v0::BatchNormFoldT(*reinterpret_cast<mindspore::schema::v0::BatchNormFoldT *>(u.value));
      break;
    }
    case PrimitiveType_MulFold: {
      value = new mindspore::schema::v0::MulFoldT(*reinterpret_cast<mindspore::schema::v0::MulFoldT *>(u.value));
      break;
    }
    case PrimitiveType_AddFold: {
      value = new mindspore::schema::v0::AddFoldT(*reinterpret_cast<mindspore::schema::v0::AddFoldT *>(u.value));
      break;
    }
    case PrimitiveType_SquaredDifference: {
      value = new mindspore::schema::v0::SquaredDifferenceT(*reinterpret_cast<mindspore::schema::v0::SquaredDifferenceT *>(u.value));
      break;
    }
    case PrimitiveType_Flatten: {
      value = new mindspore::schema::v0::FlattenT(*reinterpret_cast<mindspore::schema::v0::FlattenT *>(u.value));
      break;
    }
    case PrimitiveType_FlattenGrad: {
      value = new mindspore::schema::v0::FlattenGradT(*reinterpret_cast<mindspore::schema::v0::FlattenGradT *>(u.value));
      break;
    }
    case PrimitiveType_TupleGetItem: {
      value = new mindspore::schema::v0::TupleGetItemT(*reinterpret_cast<mindspore::schema::v0::TupleGetItemT *>(u.value));
      break;
    }
    case PrimitiveType_Div: {
      value = new mindspore::schema::v0::DivT(*reinterpret_cast<mindspore::schema::v0::DivT *>(u.value));
      break;
    }
    case PrimitiveType_Where: {
      value = new mindspore::schema::v0::WhereT(*reinterpret_cast<mindspore::schema::v0::WhereT *>(u.value));
      break;
    }
    case PrimitiveType_OneHot: {
      value = new mindspore::schema::v0::OneHotT(*reinterpret_cast<mindspore::schema::v0::OneHotT *>(u.value));
      break;
    }
    case PrimitiveType_Lstm: {
      value = new mindspore::schema::v0::LstmT(*reinterpret_cast<mindspore::schema::v0::LstmT *>(u.value));
      break;
    }
    case PrimitiveType_Conv2DGradFilter: {
      value = new mindspore::schema::v0::Conv2DGradFilterT(*reinterpret_cast<mindspore::schema::v0::Conv2DGradFilterT *>(u.value));
      break;
    }
    case PrimitiveType_Conv2DGradInput: {
      value = new mindspore::schema::v0::Conv2DGradInputT(*reinterpret_cast<mindspore::schema::v0::Conv2DGradInputT *>(u.value));
      break;
    }
    case PrimitiveType_PoolingGrad: {
      value = new mindspore::schema::v0::PoolingGradT(*reinterpret_cast<mindspore::schema::v0::PoolingGradT *>(u.value));
      break;
    }
    case PrimitiveType_BNGrad: {
      value = new mindspore::schema::v0::BNGradT(*reinterpret_cast<mindspore::schema::v0::BNGradT *>(u.value));
      break;
    }
    case PrimitiveType_Assign: {
      value = new mindspore::schema::v0::AssignT(*reinterpret_cast<mindspore::schema::v0::AssignT *>(u.value));
      break;
    }
    case PrimitiveType_ApplyMomentum: {
      value = new mindspore::schema::v0::ApplyMomentumT(*reinterpret_cast<mindspore::schema::v0::ApplyMomentumT *>(u.value));
      break;
    }
    case PrimitiveType_BiasGrad: {
      value = new mindspore::schema::v0::BiasGradT(*reinterpret_cast<mindspore::schema::v0::BiasGradT *>(u.value));
      break;
    }
    case PrimitiveType_SoftmaxCrossEntropy: {
      value = new mindspore::schema::v0::SoftmaxCrossEntropyT(*reinterpret_cast<mindspore::schema::v0::SoftmaxCrossEntropyT *>(u.value));
      break;
    }
    case PrimitiveType_AddGrad: {
      value = new mindspore::schema::v0::AddGradT(*reinterpret_cast<mindspore::schema::v0::AddGradT *>(u.value));
      break;
    }
    case PrimitiveType_SubGrad: {
      value = new mindspore::schema::v0::SubGradT(*reinterpret_cast<mindspore::schema::v0::SubGradT *>(u.value));
      break;
    }
    case PrimitiveType_MulGrad: {
      value = new mindspore::schema::v0::MulGradT(*reinterpret_cast<mindspore::schema::v0::MulGradT *>(u.value));
      break;
    }
    case PrimitiveType_DivGrad: {
      value = new mindspore::schema::v0::DivGradT(*reinterpret_cast<mindspore::schema::v0::DivGradT *>(u.value));
      break;
    }
    case PrimitiveType_PowerGrad: {
      value = new mindspore::schema::v0::PowerGradT(*reinterpret_cast<mindspore::schema::v0::PowerGradT *>(u.value));
      break;
    }
    case PrimitiveType_ActivationGrad: {
      value = new mindspore::schema::v0::ActivationGradT(*reinterpret_cast<mindspore::schema::v0::ActivationGradT *>(u.value));
      break;
    }
    case PrimitiveType_PriorBox: {
      value = new mindspore::schema::v0::PriorBoxT(*reinterpret_cast<mindspore::schema::v0::PriorBoxT *>(u.value));
      break;
    }
    case PrimitiveType_SpaceToBatchND: {
      value = new mindspore::schema::v0::SpaceToBatchNDT(*reinterpret_cast<mindspore::schema::v0::SpaceToBatchNDT *>(u.value));
      break;
    }
    case PrimitiveType_Depend: {
      value = new mindspore::schema::v0::DependT(*reinterpret_cast<mindspore::schema::v0::DependT *>(u.value));
      break;
    }
    case PrimitiveType_Return: {
      value = new mindspore::schema::v0::ReturnT(*reinterpret_cast<mindspore::schema::v0::ReturnT *>(u.value));
      break;
    }
    case PrimitiveType_MakeTuple: {
      value = new mindspore::schema::v0::MakeTupleT(*reinterpret_cast<mindspore::schema::v0::MakeTupleT *>(u.value));
      break;
    }
    case PrimitiveType_ToFormat: {
      value = new mindspore::schema::v0::ToFormatT(*reinterpret_cast<mindspore::schema::v0::ToFormatT *>(u.value));
      break;
    }
    case PrimitiveType_Proposal: {
      value = new mindspore::schema::v0::ProposalT(*reinterpret_cast<mindspore::schema::v0::ProposalT *>(u.value));
      break;
    }
    case PrimitiveType_Custom: {
      value = new mindspore::schema::v0::CustomT(*reinterpret_cast<mindspore::schema::v0::CustomT *>(u.value));
      break;
    }
    case PrimitiveType_BlackBox: {
      value = new mindspore::schema::v0::BlackBoxT(*reinterpret_cast<mindspore::schema::v0::BlackBoxT *>(u.value));
      break;
    }
    case PrimitiveType_NegGrad: {
      value = new mindspore::schema::v0::NegGradT(*reinterpret_cast<mindspore::schema::v0::NegGradT *>(u.value));
      break;
    }
    case PrimitiveType_LogGrad: {
      value = new mindspore::schema::v0::LogGradT(*reinterpret_cast<mindspore::schema::v0::LogGradT *>(u.value));
      break;
    }
    case PrimitiveType_BatchToSpaceND: {
      value = new mindspore::schema::v0::BatchToSpaceNDT(*reinterpret_cast<mindspore::schema::v0::BatchToSpaceNDT *>(u.value));
      break;
    }
    case PrimitiveType_LshProjection: {
      value = new mindspore::schema::v0::LshProjectionT(*reinterpret_cast<mindspore::schema::v0::LshProjectionT *>(u.value));
      break;
    }
    case PrimitiveType_HashtableLookup: {
      value = new mindspore::schema::v0::HashtableLookupT(*reinterpret_cast<mindspore::schema::v0::HashtableLookupT *>(u.value));
      break;
    }
    case PrimitiveType_SkipGram: {
      value = new mindspore::schema::v0::SkipGramT(*reinterpret_cast<mindspore::schema::v0::SkipGramT *>(u.value));
      break;
    }
    case PrimitiveType_DeConv2DGradFilter: {
      value = new mindspore::schema::v0::DeConv2DGradFilterT(*reinterpret_cast<mindspore::schema::v0::DeConv2DGradFilterT *>(u.value));
      break;
    }
    case PrimitiveType_CustomPredict: {
      value = new mindspore::schema::v0::CustomPredictT(*reinterpret_cast<mindspore::schema::v0::CustomPredictT *>(u.value));
      break;
    }
    case PrimitiveType_CustomNormalize: {
      value = new mindspore::schema::v0::CustomNormalizeT(*reinterpret_cast<mindspore::schema::v0::CustomNormalizeT *>(u.value));
      break;
    }
    case PrimitiveType_CustomExtractFeatures: {
      value = new mindspore::schema::v0::CustomExtractFeaturesT(*reinterpret_cast<mindspore::schema::v0::CustomExtractFeaturesT *>(u.value));
      break;
    }
    case PrimitiveType_AudioSpectrogram: {
      value = new mindspore::schema::v0::AudioSpectrogramT(*reinterpret_cast<mindspore::schema::v0::AudioSpectrogramT *>(u.value));
      break;
    }
    case PrimitiveType_Mfcc: {
      value = new mindspore::schema::v0::MfccT(*reinterpret_cast<mindspore::schema::v0::MfccT *>(u.value));
      break;
    }
    case PrimitiveType_Rfft: {
      value = new mindspore::schema::v0::RfftT(*reinterpret_cast<mindspore::schema::v0::RfftT *>(u.value));
      break;
    }
    case PrimitiveType_FftReal: {
      value = new mindspore::schema::v0::FftRealT(*reinterpret_cast<mindspore::schema::v0::FftRealT *>(u.value));
      break;
    }
    case PrimitiveType_FftImag: {
      value = new mindspore::schema::v0::FftImagT(*reinterpret_cast<mindspore::schema::v0::FftImagT *>(u.value));
      break;
    }
    case PrimitiveType_Sgd: {
      value = new mindspore::schema::v0::SgdT(*reinterpret_cast<mindspore::schema::v0::SgdT *>(u.value));
      break;
    }
    case PrimitiveType_Adam: {
      value = new mindspore::schema::v0::AdamT(*reinterpret_cast<mindspore::schema::v0::AdamT *>(u.value));
      break;
    }
    case PrimitiveType_GroupConv2DGradInput: {
      value = new mindspore::schema::v0::GroupConv2DGradInputT(*reinterpret_cast<mindspore::schema::v0::GroupConv2DGradInputT *>(u.value));
      break;
    }
    case PrimitiveType_Loop: {
      value = new mindspore::schema::v0::LoopT(*reinterpret_cast<mindspore::schema::v0::LoopT *>(u.value));
      break;
    }
    case PrimitiveType_NonMaxSuppression: {
      value = new mindspore::schema::v0::NonMaxSuppressionT(*reinterpret_cast<mindspore::schema::v0::NonMaxSuppressionT *>(u.value));
      break;
    }
    case PrimitiveType_InstanceNorm: {
      value = new mindspore::schema::v0::InstanceNormT(*reinterpret_cast<mindspore::schema::v0::InstanceNormT *>(u.value));
      break;
    }
    case PrimitiveType_Identity: {
      value = new mindspore::schema::v0::IdentityT(*reinterpret_cast<mindspore::schema::v0::IdentityT *>(u.value));
      break;
    }
    case PrimitiveType_LayerNorm: {
      value = new mindspore::schema::v0::LayerNormT(*reinterpret_cast<mindspore::schema::v0::LayerNormT *>(u.value));
      break;
    }
    case PrimitiveType_While: {
      value = new mindspore::schema::v0::WhileT(*reinterpret_cast<mindspore::schema::v0::WhileT *>(u.value));
      break;
    }
    case PrimitiveType_ControlDepend: {
      value = new mindspore::schema::v0::ControlDependT(*reinterpret_cast<mindspore::schema::v0::ControlDependT *>(u.value));
      break;
    }
    case PrimitiveType_UnsortedSegmentSum: {
      value = new mindspore::schema::v0::UnsortedSegmentSumT(*reinterpret_cast<mindspore::schema::v0::UnsortedSegmentSumT *>(u.value));
      break;
    }
    case PrimitiveType_AssignAdd: {
      value = new mindspore::schema::v0::AssignAddT(*reinterpret_cast<mindspore::schema::v0::AssignAddT *>(u.value));
      break;
    }
    case PrimitiveType_OnesLike: {
      value = new mindspore::schema::v0::OnesLikeT(*reinterpret_cast<mindspore::schema::v0::OnesLikeT *>(u.value));
      break;
    }
    case PrimitiveType_BinaryCrossEntropyGrad: {
      value = new mindspore::schema::v0::BinaryCrossEntropyGradT(*reinterpret_cast<mindspore::schema::v0::BinaryCrossEntropyGradT *>(u.value));
      break;
    }
    case PrimitiveType_BinaryCrossEntropy: {
      value = new mindspore::schema::v0::BinaryCrossEntropyT(*reinterpret_cast<mindspore::schema::v0::BinaryCrossEntropyT *>(u.value));
      break;
    }
    case PrimitiveType_LpNormalization: {
      value = new mindspore::schema::v0::LpNormalizationT(*reinterpret_cast<mindspore::schema::v0::LpNormalizationT *>(u.value));
      break;
    }
    case PrimitiveType_DropoutGrad: {
      value = new mindspore::schema::v0::DropoutGradT(*reinterpret_cast<mindspore::schema::v0::DropoutGradT *>(u.value));
      break;
    }
    case PrimitiveType_MaximumGrad: {
      value = new mindspore::schema::v0::MaximumGradT(*reinterpret_cast<mindspore::schema::v0::MaximumGradT *>(u.value));
      break;
    }
    case PrimitiveType_MinimumGrad: {
      value = new mindspore::schema::v0::MinimumGradT(*reinterpret_cast<mindspore::schema::v0::MinimumGradT *>(u.value));
      break;
    }
    case PrimitiveType_Switch: {
      value = new mindspore::schema::v0::SwitchT(*reinterpret_cast<mindspore::schema::v0::SwitchT *>(u.value));
      break;
    }
    case PrimitiveType_Partial: {
      value = new mindspore::schema::v0::PartialT(*reinterpret_cast<mindspore::schema::v0::PartialT *>(u.value));
      break;
    }
    case PrimitiveType_TensorListFromTensor: {
      value = new mindspore::schema::v0::TensorListFromTensorT(*reinterpret_cast<mindspore::schema::v0::TensorListFromTensorT *>(u.value));
      break;
    }
    case PrimitiveType_TensorListStack: {
      value = new mindspore::schema::v0::TensorListStackT(*reinterpret_cast<mindspore::schema::v0::TensorListStackT *>(u.value));
      break;
    }
    case PrimitiveType_TensorListGetItem: {
      value = new mindspore::schema::v0::TensorListGetItemT(*reinterpret_cast<mindspore::schema::v0::TensorListGetItemT *>(u.value));
      break;
    }
    case PrimitiveType_TensorListSetItem: {
      value = new mindspore::schema::v0::TensorListSetItemT(*reinterpret_cast<mindspore::schema::v0::TensorListSetItemT *>(u.value));
      break;
    }
    case PrimitiveType_TensorListReserve: {
      value = new mindspore::schema::v0::TensorListReserveT(*reinterpret_cast<mindspore::schema::v0::TensorListReserveT *>(u.value));
      break;
    }
    case PrimitiveType_All: {
      value = new mindspore::schema::v0::AllT(*reinterpret_cast<mindspore::schema::v0::AllT *>(u.value));
      break;
    }
    case PrimitiveType_Assert: {
      value = new mindspore::schema::v0::AssertT(*reinterpret_cast<mindspore::schema::v0::AssertT *>(u.value));
      break;
    }
    case PrimitiveType_Adder: {
      value = new mindspore::schema::v0::AdderT(*reinterpret_cast<mindspore::schema::v0::AdderT *>(u.value));
      break;
    }
    case PrimitiveType_SparseSoftmaxCrossEntropy: {
      value = new mindspore::schema::v0::SparseSoftmaxCrossEntropyT(*reinterpret_cast<mindspore::schema::v0::SparseSoftmaxCrossEntropyT *>(u.value));
      break;
    }
    case PrimitiveType_SmoothL1Loss: {
      value = new mindspore::schema::v0::SmoothL1LossT(*reinterpret_cast<mindspore::schema::v0::SmoothL1LossT *>(u.value));
      break;
    }
    case PrimitiveType_SmoothL1LossGrad: {
      value = new mindspore::schema::v0::SmoothL1LossGradT(*reinterpret_cast<mindspore::schema::v0::SmoothL1LossGradT *>(u.value));
      break;
    }
    case PrimitiveType_SigmoidCrossEntropyWithLogits: {
      value = new mindspore::schema::v0::SigmoidCrossEntropyWithLogitsT(*reinterpret_cast<mindspore::schema::v0::SigmoidCrossEntropyWithLogitsT *>(u.value));
      break;
    }
    case PrimitiveType_SigmoidCrossEntropyWithLogitsGrad: {
      value = new mindspore::schema::v0::SigmoidCrossEntropyWithLogitsGradT(*reinterpret_cast<mindspore::schema::v0::SigmoidCrossEntropyWithLogitsGradT *>(u.value));
      break;
    }
    case PrimitiveType_Reciprocal: {
      value = new mindspore::schema::v0::ReciprocalT(*reinterpret_cast<mindspore::schema::v0::ReciprocalT *>(u.value));
      break;
    }
    case PrimitiveType_Merge: {
      value = new mindspore::schema::v0::MergeT(*reinterpret_cast<mindspore::schema::v0::MergeT *>(u.value));
      break;
    }
    case PrimitiveType_Mod: {
      value = new mindspore::schema::v0::ModT(*reinterpret_cast<mindspore::schema::v0::ModT *>(u.value));
      break;
    }
    case PrimitiveType_GeLU: {
      value = new mindspore::schema::v0::GeLUT(*reinterpret_cast<mindspore::schema::v0::GeLUT *>(u.value));
      break;
    }
    default:
      break;
  }
}

inline void PrimitiveTypeUnion::Reset() {
  switch (type) {
    case PrimitiveType_Concat: {
      auto ptr = reinterpret_cast<mindspore::schema::v0::ConcatT *>(value);
      delete ptr;
      break;
    }
    case PrimitiveType_SoftMax: {
      auto ptr = reinterpret_cast<mindspore::schema::v0::SoftMaxT *>(value);
      delete ptr;
      break;
    }
    case PrimitiveType_Activation: {
      auto ptr = reinterpret_cast<mindspore::schema::v0::ActivationT *>(value);
      delete ptr;
      break;
    }
    case PrimitiveType_Conv2D: {
      auto ptr = reinterpret_cast<mindspore::schema::v0::Conv2DT *>(value);
      delete ptr;
      break;
    }
    case PrimitiveType_FusedBatchNorm: {
      auto ptr = reinterpret_cast<mindspore::schema::v0::FusedBatchNormT *>(value);
      delete ptr;
      break;
    }
    case PrimitiveType_BatchNorm: {
      auto ptr = reinterpret_cast<mindspore::schema::v0::BatchNormT *>(value);
      delete ptr;
      break;
    }
    case PrimitiveType_BiasAdd: {
      auto ptr = reinterpret_cast<mindspore::schema::v0::BiasAddT *>(value);
      delete ptr;
      break;
    }
    case PrimitiveType_Pooling: {
      auto ptr = reinterpret_cast<mindspore::schema::v0::PoolingT *>(value);
      delete ptr;
      break;
    }
    case PrimitiveType_ROIPooling: {
      auto ptr = reinterpret_cast<mindspore::schema::v0::ROIPoolingT *>(value);
      delete ptr;
      break;
    }
    case PrimitiveType_DepthwiseConv2D: {
      auto ptr = reinterpret_cast<mindspore::schema::v0::DepthwiseConv2DT *>(value);
      delete ptr;
      break;
    }
    case PrimitiveType_DeDepthwiseConv2D: {
      auto ptr = reinterpret_cast<mindspore::schema::v0::DeDepthwiseConv2DT *>(value);
      delete ptr;
      break;
    }
    case PrimitiveType_Resize: {
      auto ptr = reinterpret_cast<mindspore::schema::v0::ResizeT *>(value);
      delete ptr;
      break;
    }
    case PrimitiveType_DetectionPostProcess: {
      auto ptr = reinterpret_cast<mindspore::schema::v0::DetectionPostProcessT *>(value);
      delete ptr;
      break;
    }
    case PrimitiveType_FullConnection: {
      auto ptr = reinterpret_cast<mindspore::schema::v0::FullConnectionT *>(value);
      delete ptr;
      break;
    }
    case PrimitiveType_Mean: {
      auto ptr = reinterpret_cast<mindspore::schema::v0::MeanT *>(value);
      delete ptr;
      break;
    }
    case PrimitiveType_DeConv2D: {
      auto ptr = reinterpret_cast<mindspore::schema::v0::DeConv2DT *>(value);
      delete ptr;
      break;
    }
    case PrimitiveType_Scale: {
      auto ptr = reinterpret_cast<mindspore::schema::v0::ScaleT *>(value);
      delete ptr;
      break;
    }
    case PrimitiveType_Reshape: {
      auto ptr = reinterpret_cast<mindspore::schema::v0::ReshapeT *>(value);
      delete ptr;
      break;
    }
    case PrimitiveType_Eltwise: {
      auto ptr = reinterpret_cast<mindspore::schema::v0::EltwiseT *>(value);
      delete ptr;
      break;
    }
    case PrimitiveType_NetOutput: {
      auto ptr = reinterpret_cast<mindspore::schema::v0::NetOutputT *>(value);
      delete ptr;
      break;
    }
    case PrimitiveType_Add: {
      auto ptr = reinterpret_cast<mindspore::schema::v0::AddT *>(value);
      delete ptr;
      break;
    }
    case PrimitiveType_Sub: {
      auto ptr = reinterpret_cast<mindspore::schema::v0::SubT *>(value);
      delete ptr;
      break;
    }
    case PrimitiveType_MatMul: {
      auto ptr = reinterpret_cast<mindspore::schema::v0::MatMulT *>(value);
      delete ptr;
      break;
    }
    case PrimitiveType_StridedSlice: {
      auto ptr = reinterpret_cast<mindspore::schema::v0::StridedSliceT *>(value);
      delete ptr;
      break;
    }
    case PrimitiveType_Power: {
      auto ptr = reinterpret_cast<mindspore::schema::v0::PowerT *>(value);
      delete ptr;
      break;
    }
    case PrimitiveType_Slice: {
      auto ptr = reinterpret_cast<mindspore::schema::v0::SliceT *>(value);
      delete ptr;
      break;
    }
    case PrimitiveType_Stack: {
      auto ptr = reinterpret_cast<mindspore::schema::v0::StackT *>(value);
      delete ptr;
      break;
    }
    case PrimitiveType_Mul: {
      auto ptr = reinterpret_cast<mindspore::schema::v0::MulT *>(value);
      delete ptr;
      break;
    }
    case PrimitiveType_RealDiv: {
      auto ptr = reinterpret_cast<mindspore::schema::v0::RealDivT *>(value);
      delete ptr;
      break;
    }
    case PrimitiveType_Pad: {
      auto ptr = reinterpret_cast<mindspore::schema::v0::PadT *>(value);
      delete ptr;
      break;
    }
    case PrimitiveType_Maximum: {
      auto ptr = reinterpret_cast<mindspore::schema::v0::MaximumT *>(value);
      delete ptr;
      break;
    }
    case PrimitiveType_Minimum: {
      auto ptr = reinterpret_cast<mindspore::schema::v0::MinimumT *>(value);
      delete ptr;
      break;
    }
    case PrimitiveType_PReLU: {
      auto ptr = reinterpret_cast<mindspore::schema::v0::PReLUT *>(value);
      delete ptr;
      break;
    }
    case PrimitiveType_LeakyReLU: {
      auto ptr = reinterpret_cast<mindspore::schema::v0::LeakyReLUT *>(value);
      delete ptr;
      break;
    }
    case PrimitiveType_ArgMax: {
      auto ptr = reinterpret_cast<mindspore::schema::v0::ArgMaxT *>(value);
      delete ptr;
      break;
    }
    case PrimitiveType_ArgMin: {
      auto ptr = reinterpret_cast<mindspore::schema::v0::ArgMinT *>(value);
      delete ptr;
      break;
    }
    case PrimitiveType_Exp: {
      auto ptr = reinterpret_cast<mindspore::schema::v0::ExpT *>(value);
      delete ptr;
      break;
    }
    case PrimitiveType_Crop: {
      auto ptr = reinterpret_cast<mindspore::schema::v0::CropT *>(value);
      delete ptr;
      break;
    }
    case PrimitiveType_Range: {
      auto ptr = reinterpret_cast<mindspore::schema::v0::RangeT *>(value);
      delete ptr;
      break;
    }
    case PrimitiveType_Rsqrt: {
      auto ptr = reinterpret_cast<mindspore::schema::v0::RsqrtT *>(value);
      delete ptr;
      break;
    }
    case PrimitiveType_ExpandDims: {
      auto ptr = reinterpret_cast<mindspore::schema::v0::ExpandDimsT *>(value);
      delete ptr;
      break;
    }
    case PrimitiveType_Tile: {
      auto ptr = reinterpret_cast<mindspore::schema::v0::TileT *>(value);
      delete ptr;
      break;
    }
    case PrimitiveType_Cast: {
      auto ptr = reinterpret_cast<mindspore::schema::v0::CastT *>(value);
      delete ptr;
      break;
    }
    case PrimitiveType_Shape: {
      auto ptr = reinterpret_cast<mindspore::schema::v0::ShapeT *>(value);
      delete ptr;
      break;
    }
    case PrimitiveType_Nchw2Nhwc: {
      auto ptr = reinterpret_cast<mindspore::schema::v0::Nchw2NhwcT *>(value);
      delete ptr;
      break;
    }
    case PrimitiveType_Nhwc2Nchw: {
      auto ptr = reinterpret_cast<mindspore::schema::v0::Nhwc2NchwT *>(value);
      delete ptr;
      break;
    }
    case PrimitiveType_QuantDTypeCast: {
      auto ptr = reinterpret_cast<mindspore::schema::v0::QuantDTypeCastT *>(value);
      delete ptr;
      break;
    }
    case PrimitiveType_Split: {
      auto ptr = reinterpret_cast<mindspore::schema::v0::SplitT *>(value);
      delete ptr;
      break;
    }
    case PrimitiveType_Permute: {
      auto ptr = reinterpret_cast<mindspore::schema::v0::PermuteT *>(value);
      delete ptr;
      break;
    }
    case PrimitiveType_FakeQuantWithMinMaxVars: {
      auto ptr = reinterpret_cast<mindspore::schema::v0::FakeQuantWithMinMaxVarsT *>(value);
      delete ptr;
      break;
    }
    case PrimitiveType_Equal: {
      auto ptr = reinterpret_cast<mindspore::schema::v0::EqualT *>(value);
      delete ptr;
      break;
    }
    case PrimitiveType_Less: {
      auto ptr = reinterpret_cast<mindspore::schema::v0::LessT *>(value);
      delete ptr;
      break;
    }
    case PrimitiveType_Greater: {
      auto ptr = reinterpret_cast<mindspore::schema::v0::GreaterT *>(value);
      delete ptr;
      break;
    }
    case PrimitiveType_NotEqual: {
      auto ptr = reinterpret_cast<mindspore::schema::v0::NotEqualT *>(value);
      delete ptr;
      break;
    }
    case PrimitiveType_LessEqual: {
      auto ptr = reinterpret_cast<mindspore::schema::v0::LessEqualT *>(value);
      delete ptr;
      break;
    }
    case PrimitiveType_GreaterEqual: {
      auto ptr = reinterpret_cast<mindspore::schema::v0::GreaterEqualT *>(value);
      delete ptr;
      break;
    }
    case PrimitiveType_Min: {
      auto ptr = reinterpret_cast<mindspore::schema::v0::MinT *>(value);
      delete ptr;
      break;
    }
    case PrimitiveType_Floor: {
      auto ptr = reinterpret_cast<mindspore::schema::v0::FloorT *>(value);
      delete ptr;
      break;
    }
    case PrimitiveType_Abs: {
      auto ptr = reinterpret_cast<mindspore::schema::v0::AbsT *>(value);
      delete ptr;
      break;
    }
    case PrimitiveType_Neg: {
      auto ptr = reinterpret_cast<mindspore::schema::v0::NegT *>(value);
      delete ptr;
      break;
    }
    case PrimitiveType_Cos: {
      auto ptr = reinterpret_cast<mindspore::schema::v0::CosT *>(value);
      delete ptr;
      break;
    }
    case PrimitiveType_Sin: {
      auto ptr = reinterpret_cast<mindspore::schema::v0::SinT *>(value);
      delete ptr;
      break;
    }
    case PrimitiveType_Sqrt: {
      auto ptr = reinterpret_cast<mindspore::schema::v0::SqrtT *>(value);
      delete ptr;
      break;
    }
    case PrimitiveType_Square: {
      auto ptr = reinterpret_cast<mindspore::schema::v0::SquareT *>(value);
      delete ptr;
      break;
    }
    case PrimitiveType_Constant: {
      auto ptr = reinterpret_cast<mindspore::schema::v0::ConstantT *>(value);
      delete ptr;
      break;
    }
    case PrimitiveType_Log: {
      auto ptr = reinterpret_cast<mindspore::schema::v0::LogT *>(value);
      delete ptr;
      break;
    }
    case PrimitiveType_Tan: {
      auto ptr = reinterpret_cast<mindspore::schema::v0::TanT *>(value);
      delete ptr;
      break;
    }
    case PrimitiveType_Atan: {
      auto ptr = reinterpret_cast<mindspore::schema::v0::AtanT *>(value);
      delete ptr;
      break;
    }
    case PrimitiveType_Asin: {
      auto ptr = reinterpret_cast<mindspore::schema::v0::AsinT *>(value);
      delete ptr;
      break;
    }
    case PrimitiveType_Clip: {
      auto ptr = reinterpret_cast<mindspore::schema::v0::ClipT *>(value);
      delete ptr;
      break;
    }
    case PrimitiveType_Transpose: {
      auto ptr = reinterpret_cast<mindspore::schema::v0::TransposeT *>(value);
      delete ptr;
      break;
    }
    case PrimitiveType_Squeeze: {
      auto ptr = reinterpret_cast<mindspore::schema::v0::SqueezeT *>(value);
      delete ptr;
      break;
    }
    case PrimitiveType_Unsqueeze: {
      auto ptr = reinterpret_cast<mindspore::schema::v0::UnsqueezeT *>(value);
      delete ptr;
      break;
    }
    case PrimitiveType_Upsample: {
      auto ptr = reinterpret_cast<mindspore::schema::v0::UpsampleT *>(value);
      delete ptr;
      break;
    }
    case PrimitiveType_Dropout: {
      auto ptr = reinterpret_cast<mindspore::schema::v0::DropoutT *>(value);
      delete ptr;
      break;
    }
    case PrimitiveType_Broadcast: {
      auto ptr = reinterpret_cast<mindspore::schema::v0::BroadcastT *>(value);
      delete ptr;
      break;
    }
    case PrimitiveType_BroadcastTo: {
      auto ptr = reinterpret_cast<mindspore::schema::v0::BroadcastToT *>(value);
      delete ptr;
      break;
    }
    case PrimitiveType_Lrn: {
      auto ptr = reinterpret_cast<mindspore::schema::v0::LrnT *>(value);
      delete ptr;
      break;
    }
    case PrimitiveType_ZerosLike: {
      auto ptr = reinterpret_cast<mindspore::schema::v0::ZerosLikeT *>(value);
      delete ptr;
      break;
    }
    case PrimitiveType_TopK: {
      auto ptr = reinterpret_cast<mindspore::schema::v0::TopKT *>(value);
      delete ptr;
      break;
    }
    case PrimitiveType_SpaceToDepth: {
      auto ptr = reinterpret_cast<mindspore::schema::v0::SpaceToDepthT *>(value);
      delete ptr;
      break;
    }
    case PrimitiveType_SpaceToBatch: {
      auto ptr = reinterpret_cast<mindspore::schema::v0::SpaceToBatchT *>(value);
      delete ptr;
      break;
    }
    case PrimitiveType_SparseToDense: {
      auto ptr = reinterpret_cast<mindspore::schema::v0::SparseToDenseT *>(value);
      delete ptr;
      break;
    }
    case PrimitiveType_ReverseSequence: {
      auto ptr = reinterpret_cast<mindspore::schema::v0::ReverseSequenceT *>(value);
      delete ptr;
      break;
    }
    case PrimitiveType_Rank: {
      auto ptr = reinterpret_cast<mindspore::schema::v0::RankT *>(value);
      delete ptr;
      break;
    }
    case PrimitiveType_Gather: {
      auto ptr = reinterpret_cast<mindspore::schema::v0::GatherT *>(value);
      delete ptr;
      break;
    }
    case PrimitiveType_GatherNd: {
      auto ptr = reinterpret_cast<mindspore::schema::v0::GatherNdT *>(value);
      delete ptr;
      break;
    }
    case PrimitiveType_Fill: {
      auto ptr = reinterpret_cast<mindspore::schema::v0::FillT *>(value);
      delete ptr;
      break;
    }
    case PrimitiveType_Elu: {
      auto ptr = reinterpret_cast<mindspore::schema::v0::EluT *>(value);
      delete ptr;
      break;
    }
    case PrimitiveType_DepthToSpace: {
      auto ptr = reinterpret_cast<mindspore::schema::v0::DepthToSpaceT *>(value);
      delete ptr;
      break;
    }
    case PrimitiveType_BatchToSpace: {
      auto ptr = reinterpret_cast<mindspore::schema::v0::BatchToSpaceT *>(value);
      delete ptr;
      break;
    }
    case PrimitiveType_AddN: {
      auto ptr = reinterpret_cast<mindspore::schema::v0::AddNT *>(value);
      delete ptr;
      break;
    }
    case PrimitiveType_Ceil: {
      auto ptr = reinterpret_cast<mindspore::schema::v0::CeilT *>(value);
      delete ptr;
      break;
    }
    case PrimitiveType_EmbeddingLookup: {
      auto ptr = reinterpret_cast<mindspore::schema::v0::EmbeddingLookupT *>(value);
      delete ptr;
      break;
    }
    case PrimitiveType_EmbeddingLookupSparse: {
      auto ptr = reinterpret_cast<mindspore::schema::v0::EmbeddingLookupSparseT *>(value);
      delete ptr;
      break;
    }
    case PrimitiveType_FloorDiv: {
      auto ptr = reinterpret_cast<mindspore::schema::v0::FloorDivT *>(value);
      delete ptr;
      break;
    }
    case PrimitiveType_FloorMod: {
      auto ptr = reinterpret_cast<mindspore::schema::v0::FloorModT *>(value);
      delete ptr;
      break;
    }
    case PrimitiveType_L2Norm: {
      auto ptr = reinterpret_cast<mindspore::schema::v0::L2NormT *>(value);
      delete ptr;
      break;
    }
    case PrimitiveType_LocalResponseNormalization: {
      auto ptr = reinterpret_cast<mindspore::schema::v0::LocalResponseNormalizationT *>(value);
      delete ptr;
      break;
    }
    case PrimitiveType_MatrixDiag: {
      auto ptr = reinterpret_cast<mindspore::schema::v0::MatrixDiagT *>(value);
      delete ptr;
      break;
    }
    case PrimitiveType_Reduce: {
      auto ptr = reinterpret_cast<mindspore::schema::v0::ReduceT *>(value);
      delete ptr;
      break;
    }
    case PrimitiveType_Reverse: {
      auto ptr = reinterpret_cast<mindspore::schema::v0::ReverseT *>(value);
      delete ptr;
      break;
    }
    case PrimitiveType_Round: {
      auto ptr = reinterpret_cast<mindspore::schema::v0::RoundT *>(value);
      delete ptr;
      break;
    }
    case PrimitiveType_Select: {
      auto ptr = reinterpret_cast<mindspore::schema::v0::SelectT *>(value);
      delete ptr;
      break;
    }
    case PrimitiveType_Scatter: {
      auto ptr = reinterpret_cast<mindspore::schema::v0::ScatterT *>(value);
      delete ptr;
      break;
    }
    case PrimitiveType_ScatterND: {
      auto ptr = reinterpret_cast<mindspore::schema::v0::ScatterNDT *>(value);
      delete ptr;
      break;
    }
    case PrimitiveType_ConstantOfShape: {
      auto ptr = reinterpret_cast<mindspore::schema::v0::ConstantOfShapeT *>(value);
      delete ptr;
      break;
    }
    case PrimitiveType_Unique: {
      auto ptr = reinterpret_cast<mindspore::schema::v0::UniqueT *>(value);
      delete ptr;
      break;
    }
    case PrimitiveType_Unstack: {
      auto ptr = reinterpret_cast<mindspore::schema::v0::UnstackT *>(value);
      delete ptr;
      break;
    }
    case PrimitiveType_LogicalAnd: {
      auto ptr = reinterpret_cast<mindspore::schema::v0::LogicalAndT *>(value);
      delete ptr;
      break;
    }
    case PrimitiveType_LogicalOr: {
      auto ptr = reinterpret_cast<mindspore::schema::v0::LogicalOrT *>(value);
      delete ptr;
      break;
    }
    case PrimitiveType_LogicalXor: {
      auto ptr = reinterpret_cast<mindspore::schema::v0::LogicalXorT *>(value);
      delete ptr;
      break;
    }
    case PrimitiveType_LogicalNot: {
      auto ptr = reinterpret_cast<mindspore::schema::v0::LogicalNotT *>(value);
      delete ptr;
      break;
    }
    case PrimitiveType_OnnxInt8Quantize: {
      auto ptr = reinterpret_cast<mindspore::schema::v0::OnnxInt8QuantizeT *>(value);
      delete ptr;
      break;
    }
    case PrimitiveType_OnnxInt8Dequantize: {
      auto ptr = reinterpret_cast<mindspore::schema::v0::OnnxInt8DequantizeT *>(value);
      delete ptr;
      break;
    }
    case PrimitiveType_FakeQuantWithMinMax: {
      auto ptr = reinterpret_cast<mindspore::schema::v0::FakeQuantWithMinMaxT *>(value);
      delete ptr;
      break;
    }
    case PrimitiveType_FakeQuantWithMinMaxPerChannel: {
      auto ptr = reinterpret_cast<mindspore::schema::v0::FakeQuantWithMinMaxPerChannelT *>(value);
      delete ptr;
      break;
    }
    case PrimitiveType_BatchNormFold: {
      auto ptr = reinterpret_cast<mindspore::schema::v0::BatchNormFoldT *>(value);
      delete ptr;
      break;
    }
    case PrimitiveType_MulFold: {
      auto ptr = reinterpret_cast<mindspore::schema::v0::MulFoldT *>(value);
      delete ptr;
      break;
    }
    case PrimitiveType_AddFold: {
      auto ptr = reinterpret_cast<mindspore::schema::v0::AddFoldT *>(value);
      delete ptr;
      break;
    }
    case PrimitiveType_SquaredDifference: {
      auto ptr = reinterpret_cast<mindspore::schema::v0::SquaredDifferenceT *>(value);
      delete ptr;
      break;
    }
    case PrimitiveType_Flatten: {
      auto ptr = reinterpret_cast<mindspore::schema::v0::FlattenT *>(value);
      delete ptr;
      break;
    }
    case PrimitiveType_FlattenGrad: {
      auto ptr = reinterpret_cast<mindspore::schema::v0::FlattenGradT *>(value);
      delete ptr;
      break;
    }
    case PrimitiveType_TupleGetItem: {
      auto ptr = reinterpret_cast<mindspore::schema::v0::TupleGetItemT *>(value);
      delete ptr;
      break;
    }
    case PrimitiveType_Div: {
      auto ptr = reinterpret_cast<mindspore::schema::v0::DivT *>(value);
      delete ptr;
      break;
    }
    case PrimitiveType_Where: {
      auto ptr = reinterpret_cast<mindspore::schema::v0::WhereT *>(value);
      delete ptr;
      break;
    }
    case PrimitiveType_OneHot: {
      auto ptr = reinterpret_cast<mindspore::schema::v0::OneHotT *>(value);
      delete ptr;
      break;
    }
    case PrimitiveType_Lstm: {
      auto ptr = reinterpret_cast<mindspore::schema::v0::LstmT *>(value);
      delete ptr;
      break;
    }
    case PrimitiveType_Conv2DGradFilter: {
      auto ptr = reinterpret_cast<mindspore::schema::v0::Conv2DGradFilterT *>(value);
      delete ptr;
      break;
    }
    case PrimitiveType_Conv2DGradInput: {
      auto ptr = reinterpret_cast<mindspore::schema::v0::Conv2DGradInputT *>(value);
      delete ptr;
      break;
    }
    case PrimitiveType_PoolingGrad: {
      auto ptr = reinterpret_cast<mindspore::schema::v0::PoolingGradT *>(value);
      delete ptr;
      break;
    }
    case PrimitiveType_BNGrad: {
      auto ptr = reinterpret_cast<mindspore::schema::v0::BNGradT *>(value);
      delete ptr;
      break;
    }
    case PrimitiveType_Assign: {
      auto ptr = reinterpret_cast<mindspore::schema::v0::AssignT *>(value);
      delete ptr;
      break;
    }
    case PrimitiveType_ApplyMomentum: {
      auto ptr = reinterpret_cast<mindspore::schema::v0::ApplyMomentumT *>(value);
      delete ptr;
      break;
    }
    case PrimitiveType_BiasGrad: {
      auto ptr = reinterpret_cast<mindspore::schema::v0::BiasGradT *>(value);
      delete ptr;
      break;
    }
    case PrimitiveType_SoftmaxCrossEntropy: {
      auto ptr = reinterpret_cast<mindspore::schema::v0::SoftmaxCrossEntropyT *>(value);
      delete ptr;
      break;
    }
    case PrimitiveType_AddGrad: {
      auto ptr = reinterpret_cast<mindspore::schema::v0::AddGradT *>(value);
      delete ptr;
      break;
    }
    case PrimitiveType_SubGrad: {
      auto ptr = reinterpret_cast<mindspore::schema::v0::SubGradT *>(value);
      delete ptr;
      break;
    }
    case PrimitiveType_MulGrad: {
      auto ptr = reinterpret_cast<mindspore::schema::v0::MulGradT *>(value);
      delete ptr;
      break;
    }
    case PrimitiveType_DivGrad: {
      auto ptr = reinterpret_cast<mindspore::schema::v0::DivGradT *>(value);
      delete ptr;
      break;
    }
    case PrimitiveType_PowerGrad: {
      auto ptr = reinterpret_cast<mindspore::schema::v0::PowerGradT *>(value);
      delete ptr;
      break;
    }
    case PrimitiveType_ActivationGrad: {
      auto ptr = reinterpret_cast<mindspore::schema::v0::ActivationGradT *>(value);
      delete ptr;
      break;
    }
    case PrimitiveType_PriorBox: {
      auto ptr = reinterpret_cast<mindspore::schema::v0::PriorBoxT *>(value);
      delete ptr;
      break;
    }
    case PrimitiveType_SpaceToBatchND: {
      auto ptr = reinterpret_cast<mindspore::schema::v0::SpaceToBatchNDT *>(value);
      delete ptr;
      break;
    }
    case PrimitiveType_Depend: {
      auto ptr = reinterpret_cast<mindspore::schema::v0::DependT *>(value);
      delete ptr;
      break;
    }
    case PrimitiveType_Return: {
      auto ptr = reinterpret_cast<mindspore::schema::v0::ReturnT *>(value);
      delete ptr;
      break;
    }
    case PrimitiveType_MakeTuple: {
      auto ptr = reinterpret_cast<mindspore::schema::v0::MakeTupleT *>(value);
      delete ptr;
      break;
    }
    case PrimitiveType_ToFormat: {
      auto ptr = reinterpret_cast<mindspore::schema::v0::ToFormatT *>(value);
      delete ptr;
      break;
    }
    case PrimitiveType_Proposal: {
      auto ptr = reinterpret_cast<mindspore::schema::v0::ProposalT *>(value);
      delete ptr;
      break;
    }
    case PrimitiveType_Custom: {
      auto ptr = reinterpret_cast<mindspore::schema::v0::CustomT *>(value);
      delete ptr;
      break;
    }
    case PrimitiveType_BlackBox: {
      auto ptr = reinterpret_cast<mindspore::schema::v0::BlackBoxT *>(value);
      delete ptr;
      break;
    }
    case PrimitiveType_NegGrad: {
      auto ptr = reinterpret_cast<mindspore::schema::v0::NegGradT *>(value);
      delete ptr;
      break;
    }
    case PrimitiveType_LogGrad: {
      auto ptr = reinterpret_cast<mindspore::schema::v0::LogGradT *>(value);
      delete ptr;
      break;
    }
    case PrimitiveType_BatchToSpaceND: {
      auto ptr = reinterpret_cast<mindspore::schema::v0::BatchToSpaceNDT *>(value);
      delete ptr;
      break;
    }
    case PrimitiveType_LshProjection: {
      auto ptr = reinterpret_cast<mindspore::schema::v0::LshProjectionT *>(value);
      delete ptr;
      break;
    }
    case PrimitiveType_HashtableLookup: {
      auto ptr = reinterpret_cast<mindspore::schema::v0::HashtableLookupT *>(value);
      delete ptr;
      break;
    }
    case PrimitiveType_SkipGram: {
      auto ptr = reinterpret_cast<mindspore::schema::v0::SkipGramT *>(value);
      delete ptr;
      break;
    }
    case PrimitiveType_DeConv2DGradFilter: {
      auto ptr = reinterpret_cast<mindspore::schema::v0::DeConv2DGradFilterT *>(value);
      delete ptr;
      break;
    }
    case PrimitiveType_CustomPredict: {
      auto ptr = reinterpret_cast<mindspore::schema::v0::CustomPredictT *>(value);
      delete ptr;
      break;
    }
    case PrimitiveType_CustomNormalize: {
      auto ptr = reinterpret_cast<mindspore::schema::v0::CustomNormalizeT *>(value);
      delete ptr;
      break;
    }
    case PrimitiveType_CustomExtractFeatures: {
      auto ptr = reinterpret_cast<mindspore::schema::v0::CustomExtractFeaturesT *>(value);
      delete ptr;
      break;
    }
    case PrimitiveType_AudioSpectrogram: {
      auto ptr = reinterpret_cast<mindspore::schema::v0::AudioSpectrogramT *>(value);
      delete ptr;
      break;
    }
    case PrimitiveType_Mfcc: {
      auto ptr = reinterpret_cast<mindspore::schema::v0::MfccT *>(value);
      delete ptr;
      break;
    }
    case PrimitiveType_Rfft: {
      auto ptr = reinterpret_cast<mindspore::schema::v0::RfftT *>(value);
      delete ptr;
      break;
    }
    case PrimitiveType_FftReal: {
      auto ptr = reinterpret_cast<mindspore::schema::v0::FftRealT *>(value);
      delete ptr;
      break;
    }
    case PrimitiveType_FftImag: {
      auto ptr = reinterpret_cast<mindspore::schema::v0::FftImagT *>(value);
      delete ptr;
      break;
    }
    case PrimitiveType_Sgd: {
      auto ptr = reinterpret_cast<mindspore::schema::v0::SgdT *>(value);
      delete ptr;
      break;
    }
    case PrimitiveType_Adam: {
      auto ptr = reinterpret_cast<mindspore::schema::v0::AdamT *>(value);
      delete ptr;
      break;
    }
    case PrimitiveType_GroupConv2DGradInput: {
      auto ptr = reinterpret_cast<mindspore::schema::v0::GroupConv2DGradInputT *>(value);
      delete ptr;
      break;
    }
    case PrimitiveType_Loop: {
      auto ptr = reinterpret_cast<mindspore::schema::v0::LoopT *>(value);
      delete ptr;
      break;
    }
    case PrimitiveType_NonMaxSuppression: {
      auto ptr = reinterpret_cast<mindspore::schema::v0::NonMaxSuppressionT *>(value);
      delete ptr;
      break;
    }
    case PrimitiveType_InstanceNorm: {
      auto ptr = reinterpret_cast<mindspore::schema::v0::InstanceNormT *>(value);
      delete ptr;
      break;
    }
    case PrimitiveType_Identity: {
      auto ptr = reinterpret_cast<mindspore::schema::v0::IdentityT *>(value);
      delete ptr;
      break;
    }
    case PrimitiveType_LayerNorm: {
      auto ptr = reinterpret_cast<mindspore::schema::v0::LayerNormT *>(value);
      delete ptr;
      break;
    }
    case PrimitiveType_While: {
      auto ptr = reinterpret_cast<mindspore::schema::v0::WhileT *>(value);
      delete ptr;
      break;
    }
    case PrimitiveType_ControlDepend: {
      auto ptr = reinterpret_cast<mindspore::schema::v0::ControlDependT *>(value);
      delete ptr;
      break;
    }
    case PrimitiveType_UnsortedSegmentSum: {
      auto ptr = reinterpret_cast<mindspore::schema::v0::UnsortedSegmentSumT *>(value);
      delete ptr;
      break;
    }
    case PrimitiveType_AssignAdd: {
      auto ptr = reinterpret_cast<mindspore::schema::v0::AssignAddT *>(value);
      delete ptr;
      break;
    }
    case PrimitiveType_OnesLike: {
      auto ptr = reinterpret_cast<mindspore::schema::v0::OnesLikeT *>(value);
      delete ptr;
      break;
    }
    case PrimitiveType_BinaryCrossEntropyGrad: {
      auto ptr = reinterpret_cast<mindspore::schema::v0::BinaryCrossEntropyGradT *>(value);
      delete ptr;
      break;
    }
    case PrimitiveType_BinaryCrossEntropy: {
      auto ptr = reinterpret_cast<mindspore::schema::v0::BinaryCrossEntropyT *>(value);
      delete ptr;
      break;
    }
    case PrimitiveType_LpNormalization: {
      auto ptr = reinterpret_cast<mindspore::schema::v0::LpNormalizationT *>(value);
      delete ptr;
      break;
    }
    case PrimitiveType_DropoutGrad: {
      auto ptr = reinterpret_cast<mindspore::schema::v0::DropoutGradT *>(value);
      delete ptr;
      break;
    }
    case PrimitiveType_MaximumGrad: {
      auto ptr = reinterpret_cast<mindspore::schema::v0::MaximumGradT *>(value);
      delete ptr;
      break;
    }
    case PrimitiveType_MinimumGrad: {
      auto ptr = reinterpret_cast<mindspore::schema::v0::MinimumGradT *>(value);
      delete ptr;
      break;
    }
    case PrimitiveType_Switch: {
      auto ptr = reinterpret_cast<mindspore::schema::v0::SwitchT *>(value);
      delete ptr;
      break;
    }
    case PrimitiveType_Partial: {
      auto ptr = reinterpret_cast<mindspore::schema::v0::PartialT *>(value);
      delete ptr;
      break;
    }
    case PrimitiveType_TensorListFromTensor: {
      auto ptr = reinterpret_cast<mindspore::schema::v0::TensorListFromTensorT *>(value);
      delete ptr;
      break;
    }
    case PrimitiveType_TensorListStack: {
      auto ptr = reinterpret_cast<mindspore::schema::v0::TensorListStackT *>(value);
      delete ptr;
      break;
    }
    case PrimitiveType_TensorListGetItem: {
      auto ptr = reinterpret_cast<mindspore::schema::v0::TensorListGetItemT *>(value);
      delete ptr;
      break;
    }
    case PrimitiveType_TensorListSetItem: {
      auto ptr = reinterpret_cast<mindspore::schema::v0::TensorListSetItemT *>(value);
      delete ptr;
      break;
    }
    case PrimitiveType_TensorListReserve: {
      auto ptr = reinterpret_cast<mindspore::schema::v0::TensorListReserveT *>(value);
      delete ptr;
      break;
    }
    case PrimitiveType_All: {
      auto ptr = reinterpret_cast<mindspore::schema::v0::AllT *>(value);
      delete ptr;
      break;
    }
    case PrimitiveType_Assert: {
      auto ptr = reinterpret_cast<mindspore::schema::v0::AssertT *>(value);
      delete ptr;
      break;
    }
    case PrimitiveType_Adder: {
      auto ptr = reinterpret_cast<mindspore::schema::v0::AdderT *>(value);
      delete ptr;
      break;
    }
    case PrimitiveType_SparseSoftmaxCrossEntropy: {
      auto ptr = reinterpret_cast<mindspore::schema::v0::SparseSoftmaxCrossEntropyT *>(value);
      delete ptr;
      break;
    }
    case PrimitiveType_SmoothL1Loss: {
      auto ptr = reinterpret_cast<mindspore::schema::v0::SmoothL1LossT *>(value);
      delete ptr;
      break;
    }
    case PrimitiveType_SmoothL1LossGrad: {
      auto ptr = reinterpret_cast<mindspore::schema::v0::SmoothL1LossGradT *>(value);
      delete ptr;
      break;
    }
    case PrimitiveType_SigmoidCrossEntropyWithLogits: {
      auto ptr = reinterpret_cast<mindspore::schema::v0::SigmoidCrossEntropyWithLogitsT *>(value);
      delete ptr;
      break;
    }
    case PrimitiveType_SigmoidCrossEntropyWithLogitsGrad: {
      auto ptr = reinterpret_cast<mindspore::schema::v0::SigmoidCrossEntropyWithLogitsGradT *>(value);
      delete ptr;
      break;
    }
    case PrimitiveType_Reciprocal: {
      auto ptr = reinterpret_cast<mindspore::schema::v0::ReciprocalT *>(value);
      delete ptr;
      break;
    }
    case PrimitiveType_Merge: {
      auto ptr = reinterpret_cast<mindspore::schema::v0::MergeT *>(value);
      delete ptr;
      break;
    }
    case PrimitiveType_Mod: {
      auto ptr = reinterpret_cast<mindspore::schema::v0::ModT *>(value);
      delete ptr;
      break;
    }
    case PrimitiveType_GeLU: {
      auto ptr = reinterpret_cast<mindspore::schema::v0::GeLUT *>(value);
      delete ptr;
      break;
    }
    default: break;
  }
  value = nullptr;
  type = PrimitiveType_NONE;
}

inline const flatbuffers::TypeTable *NodeTypeTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    mindspore::schema::v0::NodeTypeTypeTable
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_ENUM, 3, type_codes, type_refs, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *PrimitiveTypeTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_SEQUENCE, 0, -1 },
    { flatbuffers::ET_SEQUENCE, 0, 0 },
    { flatbuffers::ET_SEQUENCE, 0, 1 },
    { flatbuffers::ET_SEQUENCE, 0, 2 },
    { flatbuffers::ET_SEQUENCE, 0, 3 },
    { flatbuffers::ET_SEQUENCE, 0, 4 },
    { flatbuffers::ET_SEQUENCE, 0, 5 },
    { flatbuffers::ET_SEQUENCE, 0, 6 },
    { flatbuffers::ET_SEQUENCE, 0, 7 },
    { flatbuffers::ET_SEQUENCE, 0, 8 },
    { flatbuffers::ET_SEQUENCE, 0, 9 },
    { flatbuffers::ET_SEQUENCE, 0, 10 },
    { flatbuffers::ET_SEQUENCE, 0, 11 },
    { flatbuffers::ET_SEQUENCE, 0, 12 },
    { flatbuffers::ET_SEQUENCE, 0, 13 },
    { flatbuffers::ET_SEQUENCE, 0, 14 },
    { flatbuffers::ET_SEQUENCE, 0, 15 },
    { flatbuffers::ET_SEQUENCE, 0, 16 },
    { flatbuffers::ET_SEQUENCE, 0, 17 },
    { flatbuffers::ET_SEQUENCE, 0, 18 },
    { flatbuffers::ET_SEQUENCE, 0, 19 },
    { flatbuffers::ET_SEQUENCE, 0, 20 },
    { flatbuffers::ET_SEQUENCE, 0, 21 },
    { flatbuffers::ET_SEQUENCE, 0, 22 },
    { flatbuffers::ET_SEQUENCE, 0, 23 },
    { flatbuffers::ET_SEQUENCE, 0, 24 },
    { flatbuffers::ET_SEQUENCE, 0, 25 },
    { flatbuffers::ET_SEQUENCE, 0, 26 },
    { flatbuffers::ET_SEQUENCE, 0, 27 },
    { flatbuffers::ET_SEQUENCE, 0, 28 },
    { flatbuffers::ET_SEQUENCE, 0, 29 },
    { flatbuffers::ET_SEQUENCE, 0, 30 },
    { flatbuffers::ET_SEQUENCE, 0, 31 },
    { flatbuffers::ET_SEQUENCE, 0, 32 },
    { flatbuffers::ET_SEQUENCE, 0, 33 },
    { flatbuffers::ET_SEQUENCE, 0, 34 },
    { flatbuffers::ET_SEQUENCE, 0, 35 },
    { flatbuffers::ET_SEQUENCE, 0, 36 },
    { flatbuffers::ET_SEQUENCE, 0, 37 },
    { flatbuffers::ET_SEQUENCE, 0, 38 },
    { flatbuffers::ET_SEQUENCE, 0, 39 },
    { flatbuffers::ET_SEQUENCE, 0, 40 },
    { flatbuffers::ET_SEQUENCE, 0, 41 },
    { flatbuffers::ET_SEQUENCE, 0, 42 },
    { flatbuffers::ET_SEQUENCE, 0, 43 },
    { flatbuffers::ET_SEQUENCE, 0, 44 },
    { flatbuffers::ET_SEQUENCE, 0, 45 },
    { flatbuffers::ET_SEQUENCE, 0, 46 },
    { flatbuffers::ET_SEQUENCE, 0, 47 },
    { flatbuffers::ET_SEQUENCE, 0, 48 },
    { flatbuffers::ET_SEQUENCE, 0, 49 },
    { flatbuffers::ET_SEQUENCE, 0, 50 },
    { flatbuffers::ET_SEQUENCE, 0, 51 },
    { flatbuffers::ET_SEQUENCE, 0, 52 },
    { flatbuffers::ET_SEQUENCE, 0, 53 },
    { flatbuffers::ET_SEQUENCE, 0, 54 },
    { flatbuffers::ET_SEQUENCE, 0, 55 },
    { flatbuffers::ET_SEQUENCE, 0, 56 },
    { flatbuffers::ET_SEQUENCE, 0, 57 },
    { flatbuffers::ET_SEQUENCE, 0, 58 },
    { flatbuffers::ET_SEQUENCE, 0, 59 },
    { flatbuffers::ET_SEQUENCE, 0, 60 },
    { flatbuffers::ET_SEQUENCE, 0, 61 },
    { flatbuffers::ET_SEQUENCE, 0, 62 },
    { flatbuffers::ET_SEQUENCE, 0, 63 },
    { flatbuffers::ET_SEQUENCE, 0, 64 },
    { flatbuffers::ET_SEQUENCE, 0, 65 },
    { flatbuffers::ET_SEQUENCE, 0, 66 },
    { flatbuffers::ET_SEQUENCE, 0, 67 },
    { flatbuffers::ET_SEQUENCE, 0, 68 },
    { flatbuffers::ET_SEQUENCE, 0, 69 },
    { flatbuffers::ET_SEQUENCE, 0, 70 },
    { flatbuffers::ET_SEQUENCE, 0, 71 },
    { flatbuffers::ET_SEQUENCE, 0, 72 },
    { flatbuffers::ET_SEQUENCE, 0, 73 },
    { flatbuffers::ET_SEQUENCE, 0, 74 },
    { flatbuffers::ET_SEQUENCE, 0, 75 },
    { flatbuffers::ET_SEQUENCE, 0, 76 },
    { flatbuffers::ET_SEQUENCE, 0, 77 },
    { flatbuffers::ET_SEQUENCE, 0, 78 },
    { flatbuffers::ET_SEQUENCE, 0, 79 },
    { flatbuffers::ET_SEQUENCE, 0, 80 },
    { flatbuffers::ET_SEQUENCE, 0, 81 },
    { flatbuffers::ET_SEQUENCE, 0, 82 },
    { flatbuffers::ET_SEQUENCE, 0, 83 },
    { flatbuffers::ET_SEQUENCE, 0, 84 },
    { flatbuffers::ET_SEQUENCE, 0, 85 },
    { flatbuffers::ET_SEQUENCE, 0, 86 },
    { flatbuffers::ET_SEQUENCE, 0, 87 },
    { flatbuffers::ET_SEQUENCE, 0, 88 },
    { flatbuffers::ET_SEQUENCE, 0, 89 },
    { flatbuffers::ET_SEQUENCE, 0, 90 },
    { flatbuffers::ET_SEQUENCE, 0, 91 },
    { flatbuffers::ET_SEQUENCE, 0, 92 },
    { flatbuffers::ET_SEQUENCE, 0, 93 },
    { flatbuffers::ET_SEQUENCE, 0, 94 },
    { flatbuffers::ET_SEQUENCE, 0, 95 },
    { flatbuffers::ET_SEQUENCE, 0, 96 },
    { flatbuffers::ET_SEQUENCE, 0, 97 },
    { flatbuffers::ET_SEQUENCE, 0, 98 },
    { flatbuffers::ET_SEQUENCE, 0, 99 },
    { flatbuffers::ET_SEQUENCE, 0, 100 },
    { flatbuffers::ET_SEQUENCE, 0, 101 },
    { flatbuffers::ET_SEQUENCE, 0, 102 },
    { flatbuffers::ET_SEQUENCE, 0, 103 },
    { flatbuffers::ET_SEQUENCE, 0, 104 },
    { flatbuffers::ET_SEQUENCE, 0, 105 },
    { flatbuffers::ET_SEQUENCE, 0, 106 },
    { flatbuffers::ET_SEQUENCE, 0, 107 },
    { flatbuffers::ET_SEQUENCE, 0, 108 },
    { flatbuffers::ET_SEQUENCE, 0, 109 },
    { flatbuffers::ET_SEQUENCE, 0, 110 },
    { flatbuffers::ET_SEQUENCE, 0, 111 },
    { flatbuffers::ET_SEQUENCE, 0, 112 },
    { flatbuffers::ET_SEQUENCE, 0, 113 },
    { flatbuffers::ET_SEQUENCE, 0, 114 },
    { flatbuffers::ET_SEQUENCE, 0, 115 },
    { flatbuffers::ET_SEQUENCE, 0, 116 },
    { flatbuffers::ET_SEQUENCE, 0, 117 },
    { flatbuffers::ET_SEQUENCE, 0, 118 },
    { flatbuffers::ET_SEQUENCE, 0, 119 },
    { flatbuffers::ET_SEQUENCE, 0, 120 },
    { flatbuffers::ET_SEQUENCE, 0, 121 },
    { flatbuffers::ET_SEQUENCE, 0, 122 },
    { flatbuffers::ET_SEQUENCE, 0, 123 },
    { flatbuffers::ET_SEQUENCE, 0, 124 },
    { flatbuffers::ET_SEQUENCE, 0, 125 },
    { flatbuffers::ET_SEQUENCE, 0, 126 },
    { flatbuffers::ET_SEQUENCE, 0, 127 },
    { flatbuffers::ET_SEQUENCE, 0, 128 },
    { flatbuffers::ET_SEQUENCE, 0, 129 },
    { flatbuffers::ET_SEQUENCE, 0, 130 },
    { flatbuffers::ET_SEQUENCE, 0, 131 },
    { flatbuffers::ET_SEQUENCE, 0, 132 },
    { flatbuffers::ET_SEQUENCE, 0, 133 },
    { flatbuffers::ET_SEQUENCE, 0, 134 },
    { flatbuffers::ET_SEQUENCE, 0, 135 },
    { flatbuffers::ET_SEQUENCE, 0, 136 },
    { flatbuffers::ET_SEQUENCE, 0, 137 },
    { flatbuffers::ET_SEQUENCE, 0, 138 },
    { flatbuffers::ET_SEQUENCE, 0, 139 },
    { flatbuffers::ET_SEQUENCE, 0, 140 },
    { flatbuffers::ET_SEQUENCE, 0, 141 },
    { flatbuffers::ET_SEQUENCE, 0, 142 },
    { flatbuffers::ET_SEQUENCE, 0, 143 },
    { flatbuffers::ET_SEQUENCE, 0, 144 },
    { flatbuffers::ET_SEQUENCE, 0, 145 },
    { flatbuffers::ET_SEQUENCE, 0, 146 },
    { flatbuffers::ET_SEQUENCE, 0, 147 },
    { flatbuffers::ET_SEQUENCE, 0, 148 },
    { flatbuffers::ET_SEQUENCE, 0, 149 },
    { flatbuffers::ET_SEQUENCE, 0, 150 },
    { flatbuffers::ET_SEQUENCE, 0, 151 },
    { flatbuffers::ET_SEQUENCE, 0, 152 },
    { flatbuffers::ET_SEQUENCE, 0, 153 },
    { flatbuffers::ET_SEQUENCE, 0, 154 },
    { flatbuffers::ET_SEQUENCE, 0, 155 },
    { flatbuffers::ET_SEQUENCE, 0, 156 },
    { flatbuffers::ET_SEQUENCE, 0, 157 },
    { flatbuffers::ET_SEQUENCE, 0, 158 },
    { flatbuffers::ET_SEQUENCE, 0, 159 },
    { flatbuffers::ET_SEQUENCE, 0, 160 },
    { flatbuffers::ET_SEQUENCE, 0, 161 },
    { flatbuffers::ET_SEQUENCE, 0, 162 },
    { flatbuffers::ET_SEQUENCE, 0, 163 },
    { flatbuffers::ET_SEQUENCE, 0, 164 },
    { flatbuffers::ET_SEQUENCE, 0, 165 },
    { flatbuffers::ET_SEQUENCE, 0, 166 },
    { flatbuffers::ET_SEQUENCE, 0, 167 },
    { flatbuffers::ET_SEQUENCE, 0, 168 },
    { flatbuffers::ET_SEQUENCE, 0, 169 },
    { flatbuffers::ET_SEQUENCE, 0, 170 },
    { flatbuffers::ET_SEQUENCE, 0, 171 },
    { flatbuffers::ET_SEQUENCE, 0, 172 },
    { flatbuffers::ET_SEQUENCE, 0, 173 },
    { flatbuffers::ET_SEQUENCE, 0, 174 },
    { flatbuffers::ET_SEQUENCE, 0, 175 },
    { flatbuffers::ET_SEQUENCE, 0, 176 },
    { flatbuffers::ET_SEQUENCE, 0, 177 },
    { flatbuffers::ET_SEQUENCE, 0, 178 },
    { flatbuffers::ET_SEQUENCE, 0, 179 },
    { flatbuffers::ET_SEQUENCE, 0, 180 },
    { flatbuffers::ET_SEQUENCE, 0, 181 },
    { flatbuffers::ET_SEQUENCE, 0, 182 },
    { flatbuffers::ET_SEQUENCE, 0, 183 },
    { flatbuffers::ET_SEQUENCE, 0, 184 },
    { flatbuffers::ET_SEQUENCE, 0, 185 },
    { flatbuffers::ET_SEQUENCE, 0, 186 },
    { flatbuffers::ET_SEQUENCE, 0, 187 },
    { flatbuffers::ET_SEQUENCE, 0, 188 },
    { flatbuffers::ET_SEQUENCE, 0, 189 },
    { flatbuffers::ET_SEQUENCE, 0, 190 },
    { flatbuffers::ET_SEQUENCE, 0, 191 },
    { flatbuffers::ET_SEQUENCE, 0, 192 },
    { flatbuffers::ET_SEQUENCE, 0, 193 },
    { flatbuffers::ET_SEQUENCE, 0, 194 },
    { flatbuffers::ET_SEQUENCE, 0, 195 },
    { flatbuffers::ET_SEQUENCE, 0, 196 },
    { flatbuffers::ET_SEQUENCE, 0, 197 },
    { flatbuffers::ET_SEQUENCE, 0, 198 },
    { flatbuffers::ET_SEQUENCE, 0, 199 },
    { flatbuffers::ET_SEQUENCE, 0, 200 },
    { flatbuffers::ET_SEQUENCE, 0, 201 },
    { flatbuffers::ET_SEQUENCE, 0, 202 },
    { flatbuffers::ET_SEQUENCE, 0, 203 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    mindspore::schema::v0::ConcatTypeTable,
    mindspore::schema::v0::SoftMaxTypeTable,
    mindspore::schema::v0::ActivationTypeTable,
    mindspore::schema::v0::Conv2DTypeTable,
    mindspore::schema::v0::FusedBatchNormTypeTable,
    mindspore::schema::v0::BatchNormTypeTable,
    mindspore::schema::v0::BiasAddTypeTable,
    mindspore::schema::v0::PoolingTypeTable,
    mindspore::schema::v0::ROIPoolingTypeTable,
    mindspore::schema::v0::DepthwiseConv2DTypeTable,
    mindspore::schema::v0::DeDepthwiseConv2DTypeTable,
    mindspore::schema::v0::ResizeTypeTable,
    mindspore::schema::v0::DetectionPostProcessTypeTable,
    mindspore::schema::v0::FullConnectionTypeTable,
    mindspore::schema::v0::MeanTypeTable,
    mindspore::schema::v0::DeConv2DTypeTable,
    mindspore::schema::v0::ScaleTypeTable,
    mindspore::schema::v0::ReshapeTypeTable,
    mindspore::schema::v0::EltwiseTypeTable,
    mindspore::schema::v0::NetOutputTypeTable,
    mindspore::schema::v0::AddTypeTable,
    mindspore::schema::v0::SubTypeTable,
    mindspore::schema::v0::MatMulTypeTable,
    mindspore::schema::v0::StridedSliceTypeTable,
    mindspore::schema::v0::PowerTypeTable,
    mindspore::schema::v0::SliceTypeTable,
    mindspore::schema::v0::StackTypeTable,
    mindspore::schema::v0::MulTypeTable,
    mindspore::schema::v0::RealDivTypeTable,
    mindspore::schema::v0::PadTypeTable,
    mindspore::schema::v0::MaximumTypeTable,
    mindspore::schema::v0::MinimumTypeTable,
    mindspore::schema::v0::PReLUTypeTable,
    mindspore::schema::v0::LeakyReLUTypeTable,
    mindspore::schema::v0::ArgMaxTypeTable,
    mindspore::schema::v0::ArgMinTypeTable,
    mindspore::schema::v0::ExpTypeTable,
    mindspore::schema::v0::CropTypeTable,
    mindspore::schema::v0::RangeTypeTable,
    mindspore::schema::v0::RsqrtTypeTable,
    mindspore::schema::v0::ExpandDimsTypeTable,
    mindspore::schema::v0::TileTypeTable,
    mindspore::schema::v0::CastTypeTable,
    mindspore::schema::v0::ShapeTypeTable,
    mindspore::schema::v0::Nchw2NhwcTypeTable,
    mindspore::schema::v0::Nhwc2NchwTypeTable,
    mindspore::schema::v0::QuantDTypeCastTypeTable,
    mindspore::schema::v0::SplitTypeTable,
    mindspore::schema::v0::PermuteTypeTable,
    mindspore::schema::v0::FakeQuantWithMinMaxVarsTypeTable,
    mindspore::schema::v0::EqualTypeTable,
    mindspore::schema::v0::LessTypeTable,
    mindspore::schema::v0::GreaterTypeTable,
    mindspore::schema::v0::NotEqualTypeTable,
    mindspore::schema::v0::LessEqualTypeTable,
    mindspore::schema::v0::GreaterEqualTypeTable,
    mindspore::schema::v0::MinTypeTable,
    mindspore::schema::v0::FloorTypeTable,
    mindspore::schema::v0::AbsTypeTable,
    mindspore::schema::v0::NegTypeTable,
    mindspore::schema::v0::CosTypeTable,
    mindspore::schema::v0::SinTypeTable,
    mindspore::schema::v0::SqrtTypeTable,
    mindspore::schema::v0::SquareTypeTable,
    mindspore::schema::v0::ConstantTypeTable,
    mindspore::schema::v0::LogTypeTable,
    mindspore::schema::v0::TanTypeTable,
    mindspore::schema::v0::AtanTypeTable,
    mindspore::schema::v0::AsinTypeTable,
    mindspore::schema::v0::ClipTypeTable,
    mindspore::schema::v0::TransposeTypeTable,
    mindspore::schema::v0::SqueezeTypeTable,
    mindspore::schema::v0::UnsqueezeTypeTable,
    mindspore::schema::v0::UpsampleTypeTable,
    mindspore::schema::v0::DropoutTypeTable,
    mindspore::schema::v0::BroadcastTypeTable,
    mindspore::schema::v0::BroadcastToTypeTable,
    mindspore::schema::v0::LrnTypeTable,
    mindspore::schema::v0::ZerosLikeTypeTable,
    mindspore::schema::v0::TopKTypeTable,
    mindspore::schema::v0::SpaceToDepthTypeTable,
    mindspore::schema::v0::SpaceToBatchTypeTable,
    mindspore::schema::v0::SparseToDenseTypeTable,
    mindspore::schema::v0::ReverseSequenceTypeTable,
    mindspore::schema::v0::RankTypeTable,
    mindspore::schema::v0::GatherTypeTable,
    mindspore::schema::v0::GatherNdTypeTable,
    mindspore::schema::v0::FillTypeTable,
    mindspore::schema::v0::EluTypeTable,
    mindspore::schema::v0::DepthToSpaceTypeTable,
    mindspore::schema::v0::BatchToSpaceTypeTable,
    mindspore::schema::v0::AddNTypeTable,
    mindspore::schema::v0::CeilTypeTable,
    mindspore::schema::v0::EmbeddingLookupTypeTable,
    mindspore::schema::v0::EmbeddingLookupSparseTypeTable,
    mindspore::schema::v0::FloorDivTypeTable,
    mindspore::schema::v0::FloorModTypeTable,
    mindspore::schema::v0::L2NormTypeTable,
    mindspore::schema::v0::LocalResponseNormalizationTypeTable,
    mindspore::schema::v0::MatrixDiagTypeTable,
    mindspore::schema::v0::ReduceTypeTable,
    mindspore::schema::v0::ReverseTypeTable,
    mindspore::schema::v0::RoundTypeTable,
    mindspore::schema::v0::SelectTypeTable,
    mindspore::schema::v0::ScatterTypeTable,
    mindspore::schema::v0::ScatterNDTypeTable,
    mindspore::schema::v0::ConstantOfShapeTypeTable,
    mindspore::schema::v0::UniqueTypeTable,
    mindspore::schema::v0::UnstackTypeTable,
    mindspore::schema::v0::LogicalAndTypeTable,
    mindspore::schema::v0::LogicalOrTypeTable,
    mindspore::schema::v0::LogicalXorTypeTable,
    mindspore::schema::v0::LogicalNotTypeTable,
    mindspore::schema::v0::OnnxInt8QuantizeTypeTable,
    mindspore::schema::v0::OnnxInt8DequantizeTypeTable,
    mindspore::schema::v0::FakeQuantWithMinMaxTypeTable,
    mindspore::schema::v0::FakeQuantWithMinMaxPerChannelTypeTable,
    mindspore::schema::v0::BatchNormFoldTypeTable,
    mindspore::schema::v0::MulFoldTypeTable,
    mindspore::schema::v0::AddFoldTypeTable,
    mindspore::schema::v0::SquaredDifferenceTypeTable,
    mindspore::schema::v0::FlattenTypeTable,
    mindspore::schema::v0::FlattenGradTypeTable,
    mindspore::schema::v0::TupleGetItemTypeTable,
    mindspore::schema::v0::DivTypeTable,
    mindspore::schema::v0::WhereTypeTable,
    mindspore::schema::v0::OneHotTypeTable,
    mindspore::schema::v0::LstmTypeTable,
    mindspore::schema::v0::Conv2DGradFilterTypeTable,
    mindspore::schema::v0::Conv2DGradInputTypeTable,
    mindspore::schema::v0::PoolingGradTypeTable,
    mindspore::schema::v0::BNGradTypeTable,
    mindspore::schema::v0::AssignTypeTable,
    mindspore::schema::v0::ApplyMomentumTypeTable,
    mindspore::schema::v0::BiasGradTypeTable,
    mindspore::schema::v0::SoftmaxCrossEntropyTypeTable,
    mindspore::schema::v0::AddGradTypeTable,
    mindspore::schema::v0::SubGradTypeTable,
    mindspore::schema::v0::MulGradTypeTable,
    mindspore::schema::v0::DivGradTypeTable,
    mindspore::schema::v0::PowerGradTypeTable,
    mindspore::schema::v0::ActivationGradTypeTable,
    mindspore::schema::v0::PriorBoxTypeTable,
    mindspore::schema::v0::SpaceToBatchNDTypeTable,
    mindspore::schema::v0::DependTypeTable,
    mindspore::schema::v0::ReturnTypeTable,
    mindspore::schema::v0::MakeTupleTypeTable,
    mindspore::schema::v0::ToFormatTypeTable,
    mindspore::schema::v0::ProposalTypeTable,
    mindspore::schema::v0::CustomTypeTable,
    mindspore::schema::v0::BlackBoxTypeTable,
    mindspore::schema::v0::NegGradTypeTable,
    mindspore::schema::v0::LogGradTypeTable,
    mindspore::schema::v0::BatchToSpaceNDTypeTable,
    mindspore::schema::v0::LshProjectionTypeTable,
    mindspore::schema::v0::HashtableLookupTypeTable,
    mindspore::schema::v0::SkipGramTypeTable,
    mindspore::schema::v0::DeConv2DGradFilterTypeTable,
    mindspore::schema::v0::CustomPredictTypeTable,
    mindspore::schema::v0::CustomNormalizeTypeTable,
    mindspore::schema::v0::CustomExtractFeaturesTypeTable,
    mindspore::schema::v0::AudioSpectrogramTypeTable,
    mindspore::schema::v0::MfccTypeTable,
    mindspore::schema::v0::RfftTypeTable,
    mindspore::schema::v0::FftRealTypeTable,
    mindspore::schema::v0::FftImagTypeTable,
    mindspore::schema::v0::SgdTypeTable,
    mindspore::schema::v0::AdamTypeTable,
    mindspore::schema::v0::GroupConv2DGradInputTypeTable,
    mindspore::schema::v0::LoopTypeTable,
    mindspore::schema::v0::NonMaxSuppressionTypeTable,
    mindspore::schema::v0::InstanceNormTypeTable,
    mindspore::schema::v0::IdentityTypeTable,
    mindspore::schema::v0::LayerNormTypeTable,
    mindspore::schema::v0::WhileTypeTable,
    mindspore::schema::v0::ControlDependTypeTable,
    mindspore::schema::v0::UnsortedSegmentSumTypeTable,
    mindspore::schema::v0::AssignAddTypeTable,
    mindspore::schema::v0::OnesLikeTypeTable,
    mindspore::schema::v0::BinaryCrossEntropyGradTypeTable,
    mindspore::schema::v0::BinaryCrossEntropyTypeTable,
    mindspore::schema::v0::LpNormalizationTypeTable,
    mindspore::schema::v0::DropoutGradTypeTable,
    mindspore::schema::v0::MaximumGradTypeTable,
    mindspore::schema::v0::MinimumGradTypeTable,
    mindspore::schema::v0::SwitchTypeTable,
    mindspore::schema::v0::PartialTypeTable,
    mindspore::schema::v0::TensorListFromTensorTypeTable,
    mindspore::schema::v0::TensorListStackTypeTable,
    mindspore::schema::v0::TensorListGetItemTypeTable,
    mindspore::schema::v0::TensorListSetItemTypeTable,
    mindspore::schema::v0::TensorListReserveTypeTable,
    mindspore::schema::v0::AllTypeTable,
    mindspore::schema::v0::AssertTypeTable,
    mindspore::schema::v0::AdderTypeTable,
    mindspore::schema::v0::SparseSoftmaxCrossEntropyTypeTable,
    mindspore::schema::v0::SmoothL1LossTypeTable,
    mindspore::schema::v0::SmoothL1LossGradTypeTable,
    mindspore::schema::v0::SigmoidCrossEntropyWithLogitsTypeTable,
    mindspore::schema::v0::SigmoidCrossEntropyWithLogitsGradTypeTable,
    mindspore::schema::v0::ReciprocalTypeTable,
    mindspore::schema::v0::MergeTypeTable,
    mindspore::schema::v0::ModTypeTable,
    mindspore::schema::v0::GeLUTypeTable
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_UNION, 205, type_codes, type_refs, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *QuantTypeTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    mindspore::schema::v0::QuantTypeTypeTable
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_ENUM, 4, type_codes, type_refs, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *QuantParamTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_DOUBLE, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_DOUBLE, 0, -1 },
    { flatbuffers::ET_DOUBLE, 0, -1 },
    { flatbuffers::ET_BOOL, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_BOOL, 0, -1 },
    { flatbuffers::ET_FLOAT, 0, -1 },
    { flatbuffers::ET_FLOAT, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 }
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 12, type_codes, nullptr, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *TensorTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_INT, 1, -1 },
    { flatbuffers::ET_INT, 0, 1 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_UCHAR, 1, -1 },
    { flatbuffers::ET_SEQUENCE, 1, 2 },
    { flatbuffers::ET_FLOAT, 1, -1 },
    { flatbuffers::ET_STRING, 0, -1 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    mindspore::schema::v0::NodeTypeTypeTable,
    mindspore::schema::v0::FormatTypeTable,
    mindspore::schema::v0::QuantParamTypeTable
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 10, type_codes, type_refs, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *PrimitiveTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_UTYPE, 0, 0 },
    { flatbuffers::ET_SEQUENCE, 0, 0 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    mindspore::schema::v0::PrimitiveTypeTypeTable
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 2, type_codes, type_refs, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *CNodeTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_STRING, 0, -1 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_SEQUENCE, 0, 1 },
    { flatbuffers::ET_UINT, 1, -1 },
    { flatbuffers::ET_UINT, 1, -1 },
    { flatbuffers::ET_INT, 0, 2 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    mindspore::schema::v0::NodeTypeTypeTable,
    mindspore::schema::v0::PrimitiveTypeTable,
    mindspore::schema::v0::QuantTypeTypeTable
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 6, type_codes, type_refs, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *SubGraphTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_STRING, 0, -1 },
    { flatbuffers::ET_UINT, 1, -1 },
    { flatbuffers::ET_UINT, 1, -1 },
    { flatbuffers::ET_UINT, 1, -1 },
    { flatbuffers::ET_UINT, 1, -1 }
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 5, type_codes, nullptr, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *MetaGraphTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_STRING, 0, -1 },
    { flatbuffers::ET_STRING, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_UINT, 1, -1 },
    { flatbuffers::ET_UINT, 1, -1 },
    { flatbuffers::ET_UINT, 0, -1 },
    { flatbuffers::ET_SEQUENCE, 1, 0 },
    { flatbuffers::ET_SEQUENCE, 1, 1 },
    { flatbuffers::ET_SEQUENCE, 1, 2 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    mindspore::schema::v0::CNodeTypeTable,
    mindspore::schema::v0::TensorTypeTable,
    mindspore::schema::v0::SubGraphTypeTable
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 9, type_codes, type_refs, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const mindspore::schema::v0::MetaGraph *GetMetaGraph(const void *buf) {
  return flatbuffers::GetRoot<mindspore::schema::v0::MetaGraph>(buf);
}

inline const mindspore::schema::v0::MetaGraph *GetSizePrefixedMetaGraph(const void *buf) {
  return flatbuffers::GetSizePrefixedRoot<mindspore::schema::v0::MetaGraph>(buf);
}

inline MetaGraph *GetMutableMetaGraph(void *buf) {
  return flatbuffers::GetMutableRoot<MetaGraph>(buf);
}

inline bool VerifyMetaGraphBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<mindspore::schema::v0::MetaGraph>(nullptr);
}

inline bool VerifySizePrefixedMetaGraphBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<mindspore::schema::v0::MetaGraph>(nullptr);
}

inline void FinishMetaGraphBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<mindspore::schema::v0::MetaGraph> root) {
  fbb.Finish(root);
}

inline void FinishSizePrefixedMetaGraphBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<mindspore::schema::v0::MetaGraph> root) {
  fbb.FinishSizePrefixed(root);
}

inline std::unique_ptr<mindspore::schema::v0::MetaGraphT> UnPackMetaGraph(
    const void *buf,
    const flatbuffers::resolver_function_t *res = nullptr) {
  return std::unique_ptr<mindspore::schema::v0::MetaGraphT>(GetMetaGraph(buf)->UnPack(res));
}

inline std::unique_ptr<mindspore::schema::v0::MetaGraphT> UnPackSizePrefixedMetaGraph(
    const void *buf,
    const flatbuffers::resolver_function_t *res = nullptr) {
  return std::unique_ptr<mindspore::schema::v0::MetaGraphT>(GetSizePrefixedMetaGraph(buf)->UnPack(res));
}

}  // namespace v0
}  // namespace schema
}  // namespace mindspore

#endif  // FLATBUFFERS_GENERATED_MODELV0_MINDSPORE_SCHEMA_V0_H_
