// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_OPS_MINDSPORE_SCHEMA_H_
#define FLATBUFFERS_GENERATED_OPS_MINDSPORE_SCHEMA_H_

#include "flatbuffers/flatbuffers.h"

#include "ops_types_generated.h"

namespace mindspore {
namespace schema {

struct Abs;
struct AbsBuilder;
struct AbsT;

struct Activation;
struct ActivationBuilder;
struct ActivationT;

struct ActivationGrad;
struct ActivationGradBuilder;
struct ActivationGradT;

struct Adam;
struct AdamBuilder;
struct AdamT;

struct AddFusion;
struct AddFusionBuilder;
struct AddFusionT;

struct AdderFusion;
struct AdderFusionBuilder;
struct AdderFusionT;

struct AddGrad;
struct AddGradBuilder;
struct AddGradT;

struct AddN;
struct AddNBuilder;
struct AddNT;

struct All;
struct AllBuilder;
struct AllT;

struct ApplyMomentum;
struct ApplyMomentumBuilder;
struct ApplyMomentumT;

struct ArgMaxFusion;
struct ArgMaxFusionBuilder;
struct ArgMaxFusionT;

struct ArgMinFusion;
struct ArgMinFusionBuilder;
struct ArgMinFusionT;

struct Assert;
struct AssertBuilder;
struct AssertT;

struct Assign;
struct AssignBuilder;
struct AssignT;

struct AssignAdd;
struct AssignAddBuilder;
struct AssignAddT;

struct AudioSpectrogram;
struct AudioSpectrogramBuilder;
struct AudioSpectrogramT;

struct AvgPoolFusion;
struct AvgPoolFusionBuilder;
struct AvgPoolFusionT;

struct AvgPoolGrad;
struct AvgPoolGradBuilder;
struct AvgPoolGradT;

struct BatchNorm;
struct BatchNormBuilder;
struct BatchNormT;

struct BatchNormGrad;
struct BatchNormGradBuilder;
struct BatchNormGradT;

struct BatchToSpace;
struct BatchToSpaceBuilder;
struct BatchToSpaceT;

struct BatchToSpaceND;
struct BatchToSpaceNDBuilder;
struct BatchToSpaceNDT;

struct BiasAdd;
struct BiasAddBuilder;
struct BiasAddT;

struct BinaryCrossEntropy;
struct BinaryCrossEntropyBuilder;
struct BinaryCrossEntropyT;

struct BinaryCrossEntropyGrad;
struct BinaryCrossEntropyGradBuilder;
struct BinaryCrossEntropyGradT;

struct BiasAddGrad;
struct BiasAddGradBuilder;
struct BiasAddGradT;

struct BroadcastTo;
struct BroadcastToBuilder;
struct BroadcastToT;

struct Cast;
struct CastBuilder;
struct CastT;

struct Ceil;
struct CeilBuilder;
struct CeilT;

struct Clip;
struct ClipBuilder;
struct ClipT;

struct Concat;
struct ConcatBuilder;
struct ConcatT;

struct Attention;
struct AttentionBuilder;
struct AttentionT;

struct Conv2DBackpropFilterFusion;
struct Conv2DBackpropFilterFusionBuilder;
struct Conv2DBackpropFilterFusionT;

struct Conv2DBackpropInputFusion;
struct Conv2DBackpropInputFusionBuilder;
struct Conv2DBackpropInputFusionT;

struct Conv2DFusion;
struct Conv2DFusionBuilder;
struct Conv2DFusionT;

struct Conv2dTransposeFusion;
struct Conv2dTransposeFusionBuilder;
struct Conv2dTransposeFusionT;

struct Cos;
struct CosBuilder;
struct CosT;

struct ConstantOfShape;
struct ConstantOfShapeBuilder;
struct ConstantOfShapeT;

struct Crop;
struct CropBuilder;
struct CropT;

struct CustomExtractFeatures;
struct CustomExtractFeaturesBuilder;
struct CustomExtractFeaturesT;

struct CustomNormalize;
struct CustomNormalizeBuilder;
struct CustomNormalizeT;

struct CustomPredict;
struct CustomPredictBuilder;
struct CustomPredictT;

struct DeConv2DGradFilter;
struct DeConv2DGradFilterBuilder;
struct DeConv2DGradFilterT;

struct Depend;
struct DependBuilder;
struct DependT;

struct DepthToSpace;
struct DepthToSpaceBuilder;
struct DepthToSpaceT;

struct DetectionPostProcess;
struct DetectionPostProcessBuilder;
struct DetectionPostProcessT;

struct DivFusion;
struct DivFusionBuilder;
struct DivFusionT;

struct DivGrad;
struct DivGradBuilder;
struct DivGradT;

struct Dropout;
struct DropoutBuilder;
struct DropoutT;

struct DropoutGrad;
struct DropoutGradBuilder;
struct DropoutGradT;

struct Elu;
struct EluBuilder;
struct EluT;

struct Eltwise;
struct EltwiseBuilder;
struct EltwiseT;

struct Equal;
struct EqualBuilder;
struct EqualT;

struct EmbeddingLookupFusion;
struct EmbeddingLookupFusionBuilder;
struct EmbeddingLookupFusionT;

struct ExpFusion;
struct ExpFusionBuilder;
struct ExpFusionT;

struct ExpandDims;
struct ExpandDimsBuilder;
struct ExpandDimsT;

struct FakeQuantWithMinMaxVars;
struct FakeQuantWithMinMaxVarsBuilder;
struct FakeQuantWithMinMaxVarsT;

struct FakeQuantWithMinMaxVarsPerChannel;
struct FakeQuantWithMinMaxVarsPerChannelBuilder;
struct FakeQuantWithMinMaxVarsPerChannelT;

struct FftReal;
struct FftRealBuilder;
struct FftRealT;

struct FftImag;
struct FftImagBuilder;
struct FftImagT;

struct Flatten;
struct FlattenBuilder;
struct FlattenT;

struct FlattenGrad;
struct FlattenGradBuilder;
struct FlattenGradT;

struct Floor;
struct FloorBuilder;
struct FloorT;

struct FloorDiv;
struct FloorDivBuilder;
struct FloorDivT;

struct FloorMod;
struct FloorModBuilder;
struct FloorModT;

struct Fill;
struct FillBuilder;
struct FillT;

struct FullConnection;
struct FullConnectionBuilder;
struct FullConnectionT;

struct FusedBatchNorm;
struct FusedBatchNormBuilder;
struct FusedBatchNormT;

struct Gather;
struct GatherBuilder;
struct GatherT;

struct GatherNd;
struct GatherNdBuilder;
struct GatherNdT;

struct Greater;
struct GreaterBuilder;
struct GreaterT;

struct GreaterEqual;
struct GreaterEqualBuilder;
struct GreaterEqualT;

struct HashtableLookup;
struct HashtableLookupBuilder;
struct HashtableLookupT;

struct InstanceNorm;
struct InstanceNormBuilder;
struct InstanceNormT;

struct LayerNormFusion;
struct LayerNormFusionBuilder;
struct LayerNormFusionT;

struct LeakyRelu;
struct LeakyReluBuilder;
struct LeakyReluT;

struct Less;
struct LessBuilder;
struct LessT;

struct LessEqual;
struct LessEqualBuilder;
struct LessEqualT;

struct Log;
struct LogBuilder;
struct LogT;

struct LogGrad;
struct LogGradBuilder;
struct LogGradT;

struct LogicalAnd;
struct LogicalAndBuilder;
struct LogicalAndT;

struct LogicalNot;
struct LogicalNotBuilder;
struct LogicalNotT;

struct LogicalOr;
struct LogicalOrBuilder;
struct LogicalOrT;

struct LpNormalization;
struct LpNormalizationBuilder;
struct LpNormalizationT;

struct LRN;
struct LRNBuilder;
struct LRNT;

struct LshProjection;
struct LshProjectionBuilder;
struct LshProjectionT;

struct LSTM;
struct LSTMBuilder;
struct LSTMT;

struct LSTMGrad;
struct LSTMGradBuilder;
struct LSTMGradT;

struct L2NormalizeFusion;
struct L2NormalizeFusionBuilder;
struct L2NormalizeFusionT;

struct MatMulFusion;
struct MatMulFusionBuilder;
struct MatMulFusionT;

struct Maximum;
struct MaximumBuilder;
struct MaximumT;

struct MaximumGrad;
struct MaximumGradBuilder;
struct MaximumGradT;

struct MaxPoolFusion;
struct MaxPoolFusionBuilder;
struct MaxPoolFusionT;

struct MaxPoolGrad;
struct MaxPoolGradBuilder;
struct MaxPoolGradT;

struct Merge;
struct MergeBuilder;
struct MergeT;

struct Mfcc;
struct MfccBuilder;
struct MfccT;

struct Minimum;
struct MinimumBuilder;
struct MinimumT;

struct MinimumGrad;
struct MinimumGradBuilder;
struct MinimumGradT;

struct Mod;
struct ModBuilder;
struct ModT;

struct MulFusion;
struct MulFusionBuilder;
struct MulFusionT;

struct MulGrad;
struct MulGradBuilder;
struct MulGradT;

struct Neg;
struct NegBuilder;
struct NegT;

struct NegGrad;
struct NegGradBuilder;
struct NegGradT;

struct NotEqual;
struct NotEqualBuilder;
struct NotEqualT;

struct NonMaxSuppression;
struct NonMaxSuppressionBuilder;
struct NonMaxSuppressionT;

struct OneHot;
struct OneHotBuilder;
struct OneHotT;

struct OnesLike;
struct OnesLikeBuilder;
struct OnesLikeT;

struct PadFusion;
struct PadFusionBuilder;
struct PadFusionT;

struct PartialFusion;
struct PartialFusionBuilder;
struct PartialFusionT;

struct PowerGrad;
struct PowerGradBuilder;
struct PowerGradT;

struct PowFusion;
struct PowFusionBuilder;
struct PowFusionT;

struct PriorBox;
struct PriorBoxBuilder;
struct PriorBoxT;

struct PReLUFusion;
struct PReLUFusionBuilder;
struct PReLUFusionT;

struct Rank;
struct RankBuilder;
struct RankT;

struct Range;
struct RangeBuilder;
struct RangeT;

struct Reciprocal;
struct ReciprocalBuilder;
struct ReciprocalT;

struct RealDiv;
struct RealDivBuilder;
struct RealDivT;

struct ReduceFusion;
struct ReduceFusionBuilder;
struct ReduceFusionT;

struct Reshape;
struct ReshapeBuilder;
struct ReshapeT;

struct Resize;
struct ResizeBuilder;
struct ResizeT;

struct ReverseSequence;
struct ReverseSequenceBuilder;
struct ReverseSequenceT;

struct ReverseV2;
struct ReverseV2Builder;
struct ReverseV2T;

struct Rfft;
struct RfftBuilder;
struct RfftT;

struct ROIPooling;
struct ROIPoolingBuilder;
struct ROIPoolingT;

struct Round;
struct RoundBuilder;
struct RoundT;

struct Rsqrt;
struct RsqrtBuilder;
struct RsqrtT;

struct QuantDTypeCast;
struct QuantDTypeCastBuilder;
struct QuantDTypeCastT;

struct ScaleFusion;
struct ScaleFusionBuilder;
struct ScaleFusionT;

struct ScatterNd;
struct ScatterNdBuilder;
struct ScatterNdT;

struct SGD;
struct SGDBuilder;
struct SGDT;

struct Shape;
struct ShapeBuilder;
struct ShapeT;

struct SigmoidCrossEntropyWithLogits;
struct SigmoidCrossEntropyWithLogitsBuilder;
struct SigmoidCrossEntropyWithLogitsT;

struct SigmoidCrossEntropyWithLogitsGrad;
struct SigmoidCrossEntropyWithLogitsGradBuilder;
struct SigmoidCrossEntropyWithLogitsGradT;

struct Sin;
struct SinBuilder;
struct SinT;

struct SkipGram;
struct SkipGramBuilder;
struct SkipGramT;

struct SliceFusion;
struct SliceFusionBuilder;
struct SliceFusionT;

struct SmoothL1Loss;
struct SmoothL1LossBuilder;
struct SmoothL1LossT;

struct SmoothL1LossGrad;
struct SmoothL1LossGradBuilder;
struct SmoothL1LossGradT;

struct Softmax;
struct SoftmaxBuilder;
struct SoftmaxT;

struct SoftmaxCrossEntropyWithLogits;
struct SoftmaxCrossEntropyWithLogitsBuilder;
struct SoftmaxCrossEntropyWithLogitsT;

struct SpaceToBatch;
struct SpaceToBatchBuilder;
struct SpaceToBatchT;

struct SpaceToBatchND;
struct SpaceToBatchNDBuilder;
struct SpaceToBatchNDT;

struct SpaceToDepth;
struct SpaceToDepthBuilder;
struct SpaceToDepthT;

struct SparseSoftmaxCrossEntropyWithLogits;
struct SparseSoftmaxCrossEntropyWithLogitsBuilder;
struct SparseSoftmaxCrossEntropyWithLogitsT;

struct SparseToDense;
struct SparseToDenseBuilder;
struct SparseToDenseT;

struct Split;
struct SplitBuilder;
struct SplitT;

struct Sqrt;
struct SqrtBuilder;
struct SqrtT;

struct Squeeze;
struct SqueezeBuilder;
struct SqueezeT;

struct Square;
struct SquareBuilder;
struct SquareT;

struct SquaredDifference;
struct SquaredDifferenceBuilder;
struct SquaredDifferenceT;

struct Stack;
struct StackBuilder;
struct StackT;

struct StridedSlice;
struct StridedSliceBuilder;
struct StridedSliceT;

struct SubFusion;
struct SubFusionBuilder;
struct SubFusionT;

struct SubGrad;
struct SubGradBuilder;
struct SubGradT;

struct Switch;
struct SwitchBuilder;
struct SwitchT;

struct TensorListFromTensor;
struct TensorListFromTensorBuilder;
struct TensorListFromTensorT;

struct TensorListGetItem;
struct TensorListGetItemBuilder;
struct TensorListGetItemT;

struct TensorListReserve;
struct TensorListReserveBuilder;
struct TensorListReserveT;

struct TensorListSetItem;
struct TensorListSetItemBuilder;
struct TensorListSetItemT;

struct TensorListStack;
struct TensorListStackBuilder;
struct TensorListStackT;

struct TileFusion;
struct TileFusionBuilder;
struct TileFusionT;

struct TopKFusion;
struct TopKFusionBuilder;
struct TopKFusionT;

struct Transpose;
struct TransposeBuilder;
struct TransposeT;

struct Unique;
struct UniqueBuilder;
struct UniqueT;

struct UnsortedSegmentSum;
struct UnsortedSegmentSumBuilder;
struct UnsortedSegmentSumT;

struct Unsqueeze;
struct UnsqueezeBuilder;
struct UnsqueezeT;

struct Unstack;
struct UnstackBuilder;
struct UnstackT;

struct Where;
struct WhereBuilder;
struct WhereT;

struct ZerosLike;
struct ZerosLikeBuilder;
struct ZerosLikeT;

struct Select;
struct SelectBuilder;
struct SelectT;

struct GRU;
struct GRUBuilder;
struct GRUT;

struct NonZero;
struct NonZeroBuilder;
struct NonZeroT;

struct InvertPermutation;
struct InvertPermutationBuilder;
struct InvertPermutationT;

struct Size;
struct SizeBuilder;
struct SizeT;

struct RandomStandardNormal;
struct RandomStandardNormalBuilder;
struct RandomStandardNormalT;

struct CropAndResize;
struct CropAndResizeBuilder;
struct CropAndResizeT;

struct Erf;
struct ErfBuilder;
struct ErfT;

struct StridedSliceGrad;
struct StridedSliceGradBuilder;
struct StridedSliceGradT;

struct IsFinite;
struct IsFiniteBuilder;
struct IsFiniteT;

struct LinSpace;
struct LinSpaceBuilder;
struct LinSpaceT;

struct UniformReal;
struct UniformRealBuilder;
struct UniformRealT;

struct AbsGrad;
struct AbsGradBuilder;
struct AbsGradT;

struct RsqrtGrad;
struct RsqrtGradBuilder;
struct RsqrtGradT;

struct SqrtGrad;
struct SqrtGradBuilder;
struct SqrtGradT;

struct LayerNormGrad;
struct LayerNormGradBuilder;
struct LayerNormGradT;

struct ResizeGrad;
struct ResizeGradBuilder;
struct ResizeGradT;

struct Splice;
struct SpliceBuilder;
struct SpliceT;

struct LogSoftmax;
struct LogSoftmaxBuilder;
struct LogSoftmaxT;

struct Call;
struct CallBuilder;
struct CallT;

struct CumSum;
struct CumSumBuilder;
struct CumSumT;

struct Custom;
struct CustomBuilder;
struct CustomT;

struct SplitWithOverlap;
struct SplitWithOverlapBuilder;
struct SplitWithOverlapT;

struct GenOP;
struct GenOPBuilder;
struct GenOPT;

struct RaggedRange;
struct RaggedRangeBuilder;
struct RaggedRangeT;

struct GLU;
struct GLUBuilder;
struct GLUT;

struct TensorArray;
struct TensorArrayBuilder;
struct TensorArrayT;

struct TensorArrayRead;
struct TensorArrayReadBuilder;
struct TensorArrayReadT;

struct TensorArrayWrite;
struct TensorArrayWriteBuilder;
struct TensorArrayWriteT;

struct Affine;
struct AffineBuilder;
struct AffineT;

struct ScatterNdUpdate;
struct ScatterNdUpdateBuilder;
struct ScatterNdUpdateT;

inline const flatbuffers::TypeTable *AbsTypeTable();

inline const flatbuffers::TypeTable *ActivationTypeTable();

inline const flatbuffers::TypeTable *ActivationGradTypeTable();

inline const flatbuffers::TypeTable *AdamTypeTable();

inline const flatbuffers::TypeTable *AddFusionTypeTable();

inline const flatbuffers::TypeTable *AdderFusionTypeTable();

inline const flatbuffers::TypeTable *AddGradTypeTable();

inline const flatbuffers::TypeTable *AddNTypeTable();

inline const flatbuffers::TypeTable *AllTypeTable();

inline const flatbuffers::TypeTable *ApplyMomentumTypeTable();

inline const flatbuffers::TypeTable *ArgMaxFusionTypeTable();

inline const flatbuffers::TypeTable *ArgMinFusionTypeTable();

inline const flatbuffers::TypeTable *AssertTypeTable();

inline const flatbuffers::TypeTable *AssignTypeTable();

inline const flatbuffers::TypeTable *AssignAddTypeTable();

inline const flatbuffers::TypeTable *AudioSpectrogramTypeTable();

inline const flatbuffers::TypeTable *AvgPoolFusionTypeTable();

inline const flatbuffers::TypeTable *AvgPoolGradTypeTable();

inline const flatbuffers::TypeTable *BatchNormTypeTable();

inline const flatbuffers::TypeTable *BatchNormGradTypeTable();

inline const flatbuffers::TypeTable *BatchToSpaceTypeTable();

inline const flatbuffers::TypeTable *BatchToSpaceNDTypeTable();

inline const flatbuffers::TypeTable *BiasAddTypeTable();

inline const flatbuffers::TypeTable *BinaryCrossEntropyTypeTable();

inline const flatbuffers::TypeTable *BinaryCrossEntropyGradTypeTable();

inline const flatbuffers::TypeTable *BiasAddGradTypeTable();

inline const flatbuffers::TypeTable *BroadcastToTypeTable();

inline const flatbuffers::TypeTable *CastTypeTable();

inline const flatbuffers::TypeTable *CeilTypeTable();

inline const flatbuffers::TypeTable *ClipTypeTable();

inline const flatbuffers::TypeTable *ConcatTypeTable();

inline const flatbuffers::TypeTable *AttentionTypeTable();

inline const flatbuffers::TypeTable *Conv2DBackpropFilterFusionTypeTable();

inline const flatbuffers::TypeTable *Conv2DBackpropInputFusionTypeTable();

inline const flatbuffers::TypeTable *Conv2DFusionTypeTable();

inline const flatbuffers::TypeTable *Conv2dTransposeFusionTypeTable();

inline const flatbuffers::TypeTable *CosTypeTable();

inline const flatbuffers::TypeTable *ConstantOfShapeTypeTable();

inline const flatbuffers::TypeTable *CropTypeTable();

inline const flatbuffers::TypeTable *CustomExtractFeaturesTypeTable();

inline const flatbuffers::TypeTable *CustomNormalizeTypeTable();

inline const flatbuffers::TypeTable *CustomPredictTypeTable();

inline const flatbuffers::TypeTable *DeConv2DGradFilterTypeTable();

inline const flatbuffers::TypeTable *DependTypeTable();

inline const flatbuffers::TypeTable *DepthToSpaceTypeTable();

inline const flatbuffers::TypeTable *DetectionPostProcessTypeTable();

inline const flatbuffers::TypeTable *DivFusionTypeTable();

inline const flatbuffers::TypeTable *DivGradTypeTable();

inline const flatbuffers::TypeTable *DropoutTypeTable();

inline const flatbuffers::TypeTable *DropoutGradTypeTable();

inline const flatbuffers::TypeTable *EluTypeTable();

inline const flatbuffers::TypeTable *EltwiseTypeTable();

inline const flatbuffers::TypeTable *EqualTypeTable();

inline const flatbuffers::TypeTable *EmbeddingLookupFusionTypeTable();

inline const flatbuffers::TypeTable *ExpFusionTypeTable();

inline const flatbuffers::TypeTable *ExpandDimsTypeTable();

inline const flatbuffers::TypeTable *FakeQuantWithMinMaxVarsTypeTable();

inline const flatbuffers::TypeTable *FakeQuantWithMinMaxVarsPerChannelTypeTable();

inline const flatbuffers::TypeTable *FftRealTypeTable();

inline const flatbuffers::TypeTable *FftImagTypeTable();

inline const flatbuffers::TypeTable *FlattenTypeTable();

inline const flatbuffers::TypeTable *FlattenGradTypeTable();

inline const flatbuffers::TypeTable *FloorTypeTable();

inline const flatbuffers::TypeTable *FloorDivTypeTable();

inline const flatbuffers::TypeTable *FloorModTypeTable();

inline const flatbuffers::TypeTable *FillTypeTable();

inline const flatbuffers::TypeTable *FullConnectionTypeTable();

inline const flatbuffers::TypeTable *FusedBatchNormTypeTable();

inline const flatbuffers::TypeTable *GatherTypeTable();

inline const flatbuffers::TypeTable *GatherNdTypeTable();

inline const flatbuffers::TypeTable *GreaterTypeTable();

inline const flatbuffers::TypeTable *GreaterEqualTypeTable();

inline const flatbuffers::TypeTable *HashtableLookupTypeTable();

inline const flatbuffers::TypeTable *InstanceNormTypeTable();

inline const flatbuffers::TypeTable *LayerNormFusionTypeTable();

inline const flatbuffers::TypeTable *LeakyReluTypeTable();

inline const flatbuffers::TypeTable *LessTypeTable();

inline const flatbuffers::TypeTable *LessEqualTypeTable();

inline const flatbuffers::TypeTable *LogTypeTable();

inline const flatbuffers::TypeTable *LogGradTypeTable();

inline const flatbuffers::TypeTable *LogicalAndTypeTable();

inline const flatbuffers::TypeTable *LogicalNotTypeTable();

inline const flatbuffers::TypeTable *LogicalOrTypeTable();

inline const flatbuffers::TypeTable *LpNormalizationTypeTable();

inline const flatbuffers::TypeTable *LRNTypeTable();

inline const flatbuffers::TypeTable *LshProjectionTypeTable();

inline const flatbuffers::TypeTable *LSTMTypeTable();

inline const flatbuffers::TypeTable *LSTMGradTypeTable();

inline const flatbuffers::TypeTable *L2NormalizeFusionTypeTable();

inline const flatbuffers::TypeTable *MatMulFusionTypeTable();

inline const flatbuffers::TypeTable *MaximumTypeTable();

inline const flatbuffers::TypeTable *MaximumGradTypeTable();

inline const flatbuffers::TypeTable *MaxPoolFusionTypeTable();

inline const flatbuffers::TypeTable *MaxPoolGradTypeTable();

inline const flatbuffers::TypeTable *MergeTypeTable();

inline const flatbuffers::TypeTable *MfccTypeTable();

inline const flatbuffers::TypeTable *MinimumTypeTable();

inline const flatbuffers::TypeTable *MinimumGradTypeTable();

inline const flatbuffers::TypeTable *ModTypeTable();

inline const flatbuffers::TypeTable *MulFusionTypeTable();

inline const flatbuffers::TypeTable *MulGradTypeTable();

inline const flatbuffers::TypeTable *NegTypeTable();

inline const flatbuffers::TypeTable *NegGradTypeTable();

inline const flatbuffers::TypeTable *NotEqualTypeTable();

inline const flatbuffers::TypeTable *NonMaxSuppressionTypeTable();

inline const flatbuffers::TypeTable *OneHotTypeTable();

inline const flatbuffers::TypeTable *OnesLikeTypeTable();

inline const flatbuffers::TypeTable *PadFusionTypeTable();

inline const flatbuffers::TypeTable *PartialFusionTypeTable();

inline const flatbuffers::TypeTable *PowerGradTypeTable();

inline const flatbuffers::TypeTable *PowFusionTypeTable();

inline const flatbuffers::TypeTable *PriorBoxTypeTable();

inline const flatbuffers::TypeTable *PReLUFusionTypeTable();

inline const flatbuffers::TypeTable *RankTypeTable();

inline const flatbuffers::TypeTable *RangeTypeTable();

inline const flatbuffers::TypeTable *ReciprocalTypeTable();

inline const flatbuffers::TypeTable *RealDivTypeTable();

inline const flatbuffers::TypeTable *ReduceFusionTypeTable();

inline const flatbuffers::TypeTable *ReshapeTypeTable();

inline const flatbuffers::TypeTable *ResizeTypeTable();

inline const flatbuffers::TypeTable *ReverseSequenceTypeTable();

inline const flatbuffers::TypeTable *ReverseV2TypeTable();

inline const flatbuffers::TypeTable *RfftTypeTable();

inline const flatbuffers::TypeTable *ROIPoolingTypeTable();

inline const flatbuffers::TypeTable *RoundTypeTable();

inline const flatbuffers::TypeTable *RsqrtTypeTable();

inline const flatbuffers::TypeTable *QuantDTypeCastTypeTable();

inline const flatbuffers::TypeTable *ScaleFusionTypeTable();

inline const flatbuffers::TypeTable *ScatterNdTypeTable();

inline const flatbuffers::TypeTable *SGDTypeTable();

inline const flatbuffers::TypeTable *ShapeTypeTable();

inline const flatbuffers::TypeTable *SigmoidCrossEntropyWithLogitsTypeTable();

inline const flatbuffers::TypeTable *SigmoidCrossEntropyWithLogitsGradTypeTable();

inline const flatbuffers::TypeTable *SinTypeTable();

inline const flatbuffers::TypeTable *SkipGramTypeTable();

inline const flatbuffers::TypeTable *SliceFusionTypeTable();

inline const flatbuffers::TypeTable *SmoothL1LossTypeTable();

inline const flatbuffers::TypeTable *SmoothL1LossGradTypeTable();

inline const flatbuffers::TypeTable *SoftmaxTypeTable();

inline const flatbuffers::TypeTable *SoftmaxCrossEntropyWithLogitsTypeTable();

inline const flatbuffers::TypeTable *SpaceToBatchTypeTable();

inline const flatbuffers::TypeTable *SpaceToBatchNDTypeTable();

inline const flatbuffers::TypeTable *SpaceToDepthTypeTable();

inline const flatbuffers::TypeTable *SparseSoftmaxCrossEntropyWithLogitsTypeTable();

inline const flatbuffers::TypeTable *SparseToDenseTypeTable();

inline const flatbuffers::TypeTable *SplitTypeTable();

inline const flatbuffers::TypeTable *SqrtTypeTable();

inline const flatbuffers::TypeTable *SqueezeTypeTable();

inline const flatbuffers::TypeTable *SquareTypeTable();

inline const flatbuffers::TypeTable *SquaredDifferenceTypeTable();

inline const flatbuffers::TypeTable *StackTypeTable();

inline const flatbuffers::TypeTable *StridedSliceTypeTable();

inline const flatbuffers::TypeTable *SubFusionTypeTable();

inline const flatbuffers::TypeTable *SubGradTypeTable();

inline const flatbuffers::TypeTable *SwitchTypeTable();

inline const flatbuffers::TypeTable *TensorListFromTensorTypeTable();

inline const flatbuffers::TypeTable *TensorListGetItemTypeTable();

inline const flatbuffers::TypeTable *TensorListReserveTypeTable();

inline const flatbuffers::TypeTable *TensorListSetItemTypeTable();

inline const flatbuffers::TypeTable *TensorListStackTypeTable();

inline const flatbuffers::TypeTable *TileFusionTypeTable();

inline const flatbuffers::TypeTable *TopKFusionTypeTable();

inline const flatbuffers::TypeTable *TransposeTypeTable();

inline const flatbuffers::TypeTable *UniqueTypeTable();

inline const flatbuffers::TypeTable *UnsortedSegmentSumTypeTable();

inline const flatbuffers::TypeTable *UnsqueezeTypeTable();

inline const flatbuffers::TypeTable *UnstackTypeTable();

inline const flatbuffers::TypeTable *WhereTypeTable();

inline const flatbuffers::TypeTable *ZerosLikeTypeTable();

inline const flatbuffers::TypeTable *SelectTypeTable();

inline const flatbuffers::TypeTable *GRUTypeTable();

inline const flatbuffers::TypeTable *NonZeroTypeTable();

inline const flatbuffers::TypeTable *InvertPermutationTypeTable();

inline const flatbuffers::TypeTable *SizeTypeTable();

inline const flatbuffers::TypeTable *RandomStandardNormalTypeTable();

inline const flatbuffers::TypeTable *CropAndResizeTypeTable();

inline const flatbuffers::TypeTable *ErfTypeTable();

inline const flatbuffers::TypeTable *StridedSliceGradTypeTable();

inline const flatbuffers::TypeTable *IsFiniteTypeTable();

inline const flatbuffers::TypeTable *LinSpaceTypeTable();

inline const flatbuffers::TypeTable *UniformRealTypeTable();

inline const flatbuffers::TypeTable *AbsGradTypeTable();

inline const flatbuffers::TypeTable *RsqrtGradTypeTable();

inline const flatbuffers::TypeTable *SqrtGradTypeTable();

inline const flatbuffers::TypeTable *LayerNormGradTypeTable();

inline const flatbuffers::TypeTable *ResizeGradTypeTable();

inline const flatbuffers::TypeTable *SpliceTypeTable();

inline const flatbuffers::TypeTable *LogSoftmaxTypeTable();

inline const flatbuffers::TypeTable *CallTypeTable();

inline const flatbuffers::TypeTable *CumSumTypeTable();

inline const flatbuffers::TypeTable *CustomTypeTable();

inline const flatbuffers::TypeTable *SplitWithOverlapTypeTable();

inline const flatbuffers::TypeTable *GenOPTypeTable();

inline const flatbuffers::TypeTable *RaggedRangeTypeTable();

inline const flatbuffers::TypeTable *GLUTypeTable();

inline const flatbuffers::TypeTable *TensorArrayTypeTable();

inline const flatbuffers::TypeTable *TensorArrayReadTypeTable();

inline const flatbuffers::TypeTable *TensorArrayWriteTypeTable();

inline const flatbuffers::TypeTable *AffineTypeTable();

inline const flatbuffers::TypeTable *ScatterNdUpdateTypeTable();

enum PrimitiveType : uint8_t {
  PrimitiveType_NONE = 0,
  PrimitiveType_Abs = 1,
  PrimitiveType_Activation = 2,
  PrimitiveType_ActivationGrad = 3,
  PrimitiveType_Adam = 4,
  PrimitiveType_AddFusion = 5,
  PrimitiveType_AdderFusion = 6,
  PrimitiveType_AddGrad = 7,
  PrimitiveType_AddN = 8,
  PrimitiveType_All = 9,
  PrimitiveType_ApplyMomentum = 10,
  PrimitiveType_ArgMaxFusion = 11,
  PrimitiveType_ArgMinFusion = 12,
  PrimitiveType_Assert = 13,
  PrimitiveType_Assign = 14,
  PrimitiveType_AssignAdd = 15,
  PrimitiveType_AudioSpectrogram = 16,
  PrimitiveType_AvgPoolFusion = 17,
  PrimitiveType_AvgPoolGrad = 18,
  PrimitiveType_BatchNorm = 19,
  PrimitiveType_BatchNormGrad = 20,
  PrimitiveType_BatchToSpace = 21,
  PrimitiveType_BatchToSpaceND = 22,
  PrimitiveType_BiasAdd = 23,
  PrimitiveType_BinaryCrossEntropy = 24,
  PrimitiveType_BinaryCrossEntropyGrad = 25,
  PrimitiveType_BiasAddGrad = 26,
  PrimitiveType_BroadcastTo = 27,
  PrimitiveType_Cast = 28,
  PrimitiveType_Ceil = 29,
  PrimitiveType_Clip = 30,
  PrimitiveType_Concat = 31,
  PrimitiveType_Attention = 32,
  PrimitiveType_Conv2DBackpropFilterFusion = 33,
  PrimitiveType_Conv2DBackpropInputFusion = 34,
  PrimitiveType_Conv2DFusion = 35,
  PrimitiveType_Conv2dTransposeFusion = 36,
  PrimitiveType_Cos = 37,
  PrimitiveType_ConstantOfShape = 38,
  PrimitiveType_Crop = 39,
  PrimitiveType_CustomExtractFeatures = 40,
  PrimitiveType_CustomNormalize = 41,
  PrimitiveType_CustomPredict = 42,
  PrimitiveType_DeConv2DGradFilter = 43,
  PrimitiveType_Depend = 44,
  PrimitiveType_DepthToSpace = 45,
  PrimitiveType_DetectionPostProcess = 46,
  PrimitiveType_DivFusion = 47,
  PrimitiveType_DivGrad = 48,
  PrimitiveType_Dropout = 49,
  PrimitiveType_DropoutGrad = 50,
  PrimitiveType_Elu = 51,
  PrimitiveType_Eltwise = 52,
  PrimitiveType_Equal = 53,
  PrimitiveType_EmbeddingLookupFusion = 54,
  PrimitiveType_ExpFusion = 55,
  PrimitiveType_ExpandDims = 56,
  PrimitiveType_FakeQuantWithMinMaxVars = 57,
  PrimitiveType_FakeQuantWithMinMaxVarsPerChannel = 58,
  PrimitiveType_FftReal = 59,
  PrimitiveType_FftImag = 60,
  PrimitiveType_Flatten = 61,
  PrimitiveType_FlattenGrad = 62,
  PrimitiveType_Floor = 63,
  PrimitiveType_FloorDiv = 64,
  PrimitiveType_FloorMod = 65,
  PrimitiveType_Fill = 66,
  PrimitiveType_FullConnection = 67,
  PrimitiveType_FusedBatchNorm = 68,
  PrimitiveType_Gather = 69,
  PrimitiveType_GatherNd = 70,
  PrimitiveType_Greater = 71,
  PrimitiveType_GreaterEqual = 72,
  PrimitiveType_HashtableLookup = 73,
  PrimitiveType_InstanceNorm = 74,
  PrimitiveType_LayerNormFusion = 75,
  PrimitiveType_LeakyRelu = 76,
  PrimitiveType_Less = 77,
  PrimitiveType_LessEqual = 78,
  PrimitiveType_Log = 79,
  PrimitiveType_LogGrad = 80,
  PrimitiveType_LogicalAnd = 81,
  PrimitiveType_LogicalNot = 82,
  PrimitiveType_LogicalOr = 83,
  PrimitiveType_LpNormalization = 84,
  PrimitiveType_LRN = 85,
  PrimitiveType_LshProjection = 86,
  PrimitiveType_LSTM = 87,
  PrimitiveType_L2NormalizeFusion = 88,
  PrimitiveType_MatMulFusion = 89,
  PrimitiveType_Maximum = 90,
  PrimitiveType_MaximumGrad = 91,
  PrimitiveType_MaxPoolFusion = 92,
  PrimitiveType_MaxPoolGrad = 93,
  PrimitiveType_Merge = 94,
  PrimitiveType_Mfcc = 95,
  PrimitiveType_Minimum = 96,
  PrimitiveType_MinimumGrad = 97,
  PrimitiveType_Mod = 98,
  PrimitiveType_MulFusion = 99,
  PrimitiveType_MulGrad = 100,
  PrimitiveType_Neg = 101,
  PrimitiveType_NegGrad = 102,
  PrimitiveType_NotEqual = 103,
  PrimitiveType_NonMaxSuppression = 104,
  PrimitiveType_OneHot = 105,
  PrimitiveType_OnesLike = 106,
  PrimitiveType_PadFusion = 107,
  PrimitiveType_PartialFusion = 108,
  PrimitiveType_PowerGrad = 109,
  PrimitiveType_PowFusion = 110,
  PrimitiveType_PriorBox = 111,
  PrimitiveType_PReLUFusion = 112,
  PrimitiveType_QuantDTypeCast = 113,
  PrimitiveType_Rank = 114,
  PrimitiveType_Range = 115,
  PrimitiveType_Reciprocal = 116,
  PrimitiveType_RealDiv = 117,
  PrimitiveType_ReduceFusion = 118,
  PrimitiveType_Reshape = 119,
  PrimitiveType_Resize = 120,
  PrimitiveType_ReverseSequence = 121,
  PrimitiveType_ReverseV2 = 122,
  PrimitiveType_Rfft = 123,
  PrimitiveType_ROIPooling = 124,
  PrimitiveType_Round = 125,
  PrimitiveType_Rsqrt = 126,
  PrimitiveType_ScaleFusion = 127,
  PrimitiveType_ScatterNd = 128,
  PrimitiveType_SGD = 129,
  PrimitiveType_Shape = 130,
  PrimitiveType_SigmoidCrossEntropyWithLogits = 131,
  PrimitiveType_SigmoidCrossEntropyWithLogitsGrad = 132,
  PrimitiveType_Sin = 133,
  PrimitiveType_SkipGram = 134,
  PrimitiveType_SliceFusion = 135,
  PrimitiveType_SmoothL1Loss = 136,
  PrimitiveType_SmoothL1LossGrad = 137,
  PrimitiveType_Softmax = 138,
  PrimitiveType_SoftmaxCrossEntropyWithLogits = 139,
  PrimitiveType_SpaceToBatch = 140,
  PrimitiveType_SpaceToBatchND = 141,
  PrimitiveType_SpaceToDepth = 142,
  PrimitiveType_SparseSoftmaxCrossEntropyWithLogits = 143,
  PrimitiveType_SparseToDense = 144,
  PrimitiveType_Split = 145,
  PrimitiveType_Sqrt = 146,
  PrimitiveType_Squeeze = 147,
  PrimitiveType_Square = 148,
  PrimitiveType_SquaredDifference = 149,
  PrimitiveType_Stack = 150,
  PrimitiveType_StridedSlice = 151,
  PrimitiveType_SubFusion = 152,
  PrimitiveType_SubGrad = 153,
  PrimitiveType_Switch = 154,
  PrimitiveType_TensorListFromTensor = 155,
  PrimitiveType_TensorListGetItem = 156,
  PrimitiveType_TensorListReserve = 157,
  PrimitiveType_TensorListSetItem = 158,
  PrimitiveType_TensorListStack = 159,
  PrimitiveType_TileFusion = 160,
  PrimitiveType_TopKFusion = 161,
  PrimitiveType_Transpose = 162,
  PrimitiveType_Unique = 163,
  PrimitiveType_UnsortedSegmentSum = 164,
  PrimitiveType_Unsqueeze = 165,
  PrimitiveType_Unstack = 166,
  PrimitiveType_LSTMGrad = 167,
  PrimitiveType_Where = 168,
  PrimitiveType_ZerosLike = 169,
  PrimitiveType_Select = 170,
  PrimitiveType_ScatterNdUpdate = 171,
  PrimitiveType_GRU = 172,
  PrimitiveType_NonZero = 173,
  PrimitiveType_InvertPermutation = 174,
  PrimitiveType_Size = 175,
  PrimitiveType_RandomStandardNormal = 176,
  PrimitiveType_CropAndResize = 177,
  PrimitiveType_Erf = 178,
  PrimitiveType_StridedSliceGrad = 179,
  PrimitiveType_IsFinite = 180,
  PrimitiveType_LinSpace = 181,
  PrimitiveType_UniformReal = 182,
  PrimitiveType_AbsGrad = 183,
  PrimitiveType_RsqrtGrad = 184,
  PrimitiveType_SqrtGrad = 185,
  PrimitiveType_LayerNormGrad = 186,
  PrimitiveType_ResizeGrad = 187,
  PrimitiveType_Splice = 188,
  PrimitiveType_LogSoftmax = 189,
  PrimitiveType_Call = 190,
  PrimitiveType_Custom = 191,
  PrimitiveType_CumSum = 192,
  PrimitiveType_SplitWithOverlap = 193,
  PrimitiveType_GenOP = 194,
  PrimitiveType_RaggedRange = 195,
  PrimitiveType_GLU = 196,
  PrimitiveType_TensorArray = 197,
  PrimitiveType_TensorArrayRead = 198,
  PrimitiveType_TensorArrayWrite = 199,
  PrimitiveType_Affine = 200,
  PrimitiveType_MIN = PrimitiveType_NONE,
  PrimitiveType_MAX = PrimitiveType_Affine
};

inline const PrimitiveType (&EnumValuesPrimitiveType())[201] {
  static const PrimitiveType values[] = {
    PrimitiveType_NONE,
    PrimitiveType_Abs,
    PrimitiveType_Activation,
    PrimitiveType_ActivationGrad,
    PrimitiveType_Adam,
    PrimitiveType_AddFusion,
    PrimitiveType_AdderFusion,
    PrimitiveType_AddGrad,
    PrimitiveType_AddN,
    PrimitiveType_All,
    PrimitiveType_ApplyMomentum,
    PrimitiveType_ArgMaxFusion,
    PrimitiveType_ArgMinFusion,
    PrimitiveType_Assert,
    PrimitiveType_Assign,
    PrimitiveType_AssignAdd,
    PrimitiveType_AudioSpectrogram,
    PrimitiveType_AvgPoolFusion,
    PrimitiveType_AvgPoolGrad,
    PrimitiveType_BatchNorm,
    PrimitiveType_BatchNormGrad,
    PrimitiveType_BatchToSpace,
    PrimitiveType_BatchToSpaceND,
    PrimitiveType_BiasAdd,
    PrimitiveType_BinaryCrossEntropy,
    PrimitiveType_BinaryCrossEntropyGrad,
    PrimitiveType_BiasAddGrad,
    PrimitiveType_BroadcastTo,
    PrimitiveType_Cast,
    PrimitiveType_Ceil,
    PrimitiveType_Clip,
    PrimitiveType_Concat,
    PrimitiveType_Attention,
    PrimitiveType_Conv2DBackpropFilterFusion,
    PrimitiveType_Conv2DBackpropInputFusion,
    PrimitiveType_Conv2DFusion,
    PrimitiveType_Conv2dTransposeFusion,
    PrimitiveType_Cos,
    PrimitiveType_ConstantOfShape,
    PrimitiveType_Crop,
    PrimitiveType_CustomExtractFeatures,
    PrimitiveType_CustomNormalize,
    PrimitiveType_CustomPredict,
    PrimitiveType_DeConv2DGradFilter,
    PrimitiveType_Depend,
    PrimitiveType_DepthToSpace,
    PrimitiveType_DetectionPostProcess,
    PrimitiveType_DivFusion,
    PrimitiveType_DivGrad,
    PrimitiveType_Dropout,
    PrimitiveType_DropoutGrad,
    PrimitiveType_Elu,
    PrimitiveType_Eltwise,
    PrimitiveType_Equal,
    PrimitiveType_EmbeddingLookupFusion,
    PrimitiveType_ExpFusion,
    PrimitiveType_ExpandDims,
    PrimitiveType_FakeQuantWithMinMaxVars,
    PrimitiveType_FakeQuantWithMinMaxVarsPerChannel,
    PrimitiveType_FftReal,
    PrimitiveType_FftImag,
    PrimitiveType_Flatten,
    PrimitiveType_FlattenGrad,
    PrimitiveType_Floor,
    PrimitiveType_FloorDiv,
    PrimitiveType_FloorMod,
    PrimitiveType_Fill,
    PrimitiveType_FullConnection,
    PrimitiveType_FusedBatchNorm,
    PrimitiveType_Gather,
    PrimitiveType_GatherNd,
    PrimitiveType_Greater,
    PrimitiveType_GreaterEqual,
    PrimitiveType_HashtableLookup,
    PrimitiveType_InstanceNorm,
    PrimitiveType_LayerNormFusion,
    PrimitiveType_LeakyRelu,
    PrimitiveType_Less,
    PrimitiveType_LessEqual,
    PrimitiveType_Log,
    PrimitiveType_LogGrad,
    PrimitiveType_LogicalAnd,
    PrimitiveType_LogicalNot,
    PrimitiveType_LogicalOr,
    PrimitiveType_LpNormalization,
    PrimitiveType_LRN,
    PrimitiveType_LshProjection,
    PrimitiveType_LSTM,
    PrimitiveType_L2NormalizeFusion,
    PrimitiveType_MatMulFusion,
    PrimitiveType_Maximum,
    PrimitiveType_MaximumGrad,
    PrimitiveType_MaxPoolFusion,
    PrimitiveType_MaxPoolGrad,
    PrimitiveType_Merge,
    PrimitiveType_Mfcc,
    PrimitiveType_Minimum,
    PrimitiveType_MinimumGrad,
    PrimitiveType_Mod,
    PrimitiveType_MulFusion,
    PrimitiveType_MulGrad,
    PrimitiveType_Neg,
    PrimitiveType_NegGrad,
    PrimitiveType_NotEqual,
    PrimitiveType_NonMaxSuppression,
    PrimitiveType_OneHot,
    PrimitiveType_OnesLike,
    PrimitiveType_PadFusion,
    PrimitiveType_PartialFusion,
    PrimitiveType_PowerGrad,
    PrimitiveType_PowFusion,
    PrimitiveType_PriorBox,
    PrimitiveType_PReLUFusion,
    PrimitiveType_QuantDTypeCast,
    PrimitiveType_Rank,
    PrimitiveType_Range,
    PrimitiveType_Reciprocal,
    PrimitiveType_RealDiv,
    PrimitiveType_ReduceFusion,
    PrimitiveType_Reshape,
    PrimitiveType_Resize,
    PrimitiveType_ReverseSequence,
    PrimitiveType_ReverseV2,
    PrimitiveType_Rfft,
    PrimitiveType_ROIPooling,
    PrimitiveType_Round,
    PrimitiveType_Rsqrt,
    PrimitiveType_ScaleFusion,
    PrimitiveType_ScatterNd,
    PrimitiveType_SGD,
    PrimitiveType_Shape,
    PrimitiveType_SigmoidCrossEntropyWithLogits,
    PrimitiveType_SigmoidCrossEntropyWithLogitsGrad,
    PrimitiveType_Sin,
    PrimitiveType_SkipGram,
    PrimitiveType_SliceFusion,
    PrimitiveType_SmoothL1Loss,
    PrimitiveType_SmoothL1LossGrad,
    PrimitiveType_Softmax,
    PrimitiveType_SoftmaxCrossEntropyWithLogits,
    PrimitiveType_SpaceToBatch,
    PrimitiveType_SpaceToBatchND,
    PrimitiveType_SpaceToDepth,
    PrimitiveType_SparseSoftmaxCrossEntropyWithLogits,
    PrimitiveType_SparseToDense,
    PrimitiveType_Split,
    PrimitiveType_Sqrt,
    PrimitiveType_Squeeze,
    PrimitiveType_Square,
    PrimitiveType_SquaredDifference,
    PrimitiveType_Stack,
    PrimitiveType_StridedSlice,
    PrimitiveType_SubFusion,
    PrimitiveType_SubGrad,
    PrimitiveType_Switch,
    PrimitiveType_TensorListFromTensor,
    PrimitiveType_TensorListGetItem,
    PrimitiveType_TensorListReserve,
    PrimitiveType_TensorListSetItem,
    PrimitiveType_TensorListStack,
    PrimitiveType_TileFusion,
    PrimitiveType_TopKFusion,
    PrimitiveType_Transpose,
    PrimitiveType_Unique,
    PrimitiveType_UnsortedSegmentSum,
    PrimitiveType_Unsqueeze,
    PrimitiveType_Unstack,
    PrimitiveType_LSTMGrad,
    PrimitiveType_Where,
    PrimitiveType_ZerosLike,
    PrimitiveType_Select,
    PrimitiveType_ScatterNdUpdate,
    PrimitiveType_GRU,
    PrimitiveType_NonZero,
    PrimitiveType_InvertPermutation,
    PrimitiveType_Size,
    PrimitiveType_RandomStandardNormal,
    PrimitiveType_CropAndResize,
    PrimitiveType_Erf,
    PrimitiveType_StridedSliceGrad,
    PrimitiveType_IsFinite,
    PrimitiveType_LinSpace,
    PrimitiveType_UniformReal,
    PrimitiveType_AbsGrad,
    PrimitiveType_RsqrtGrad,
    PrimitiveType_SqrtGrad,
    PrimitiveType_LayerNormGrad,
    PrimitiveType_ResizeGrad,
    PrimitiveType_Splice,
    PrimitiveType_LogSoftmax,
    PrimitiveType_Call,
    PrimitiveType_Custom,
    PrimitiveType_CumSum,
    PrimitiveType_SplitWithOverlap,
    PrimitiveType_GenOP,
    PrimitiveType_RaggedRange,
    PrimitiveType_GLU,
    PrimitiveType_TensorArray,
    PrimitiveType_TensorArrayRead,
    PrimitiveType_TensorArrayWrite,
    PrimitiveType_Affine
  };
  return values;
}

inline const char * const *EnumNamesPrimitiveType() {
  static const char * const names[202] = {
    "NONE",
    "Abs",
    "Activation",
    "ActivationGrad",
    "Adam",
    "AddFusion",
    "AdderFusion",
    "AddGrad",
    "AddN",
    "All",
    "ApplyMomentum",
    "ArgMaxFusion",
    "ArgMinFusion",
    "Assert",
    "Assign",
    "AssignAdd",
    "AudioSpectrogram",
    "AvgPoolFusion",
    "AvgPoolGrad",
    "BatchNorm",
    "BatchNormGrad",
    "BatchToSpace",
    "BatchToSpaceND",
    "BiasAdd",
    "BinaryCrossEntropy",
    "BinaryCrossEntropyGrad",
    "BiasAddGrad",
    "BroadcastTo",
    "Cast",
    "Ceil",
    "Clip",
    "Concat",
    "Attention",
    "Conv2DBackpropFilterFusion",
    "Conv2DBackpropInputFusion",
    "Conv2DFusion",
    "Conv2dTransposeFusion",
    "Cos",
    "ConstantOfShape",
    "Crop",
    "CustomExtractFeatures",
    "CustomNormalize",
    "CustomPredict",
    "DeConv2DGradFilter",
    "Depend",
    "DepthToSpace",
    "DetectionPostProcess",
    "DivFusion",
    "DivGrad",
    "Dropout",
    "DropoutGrad",
    "Elu",
    "Eltwise",
    "Equal",
    "EmbeddingLookupFusion",
    "ExpFusion",
    "ExpandDims",
    "FakeQuantWithMinMaxVars",
    "FakeQuantWithMinMaxVarsPerChannel",
    "FftReal",
    "FftImag",
    "Flatten",
    "FlattenGrad",
    "Floor",
    "FloorDiv",
    "FloorMod",
    "Fill",
    "FullConnection",
    "FusedBatchNorm",
    "Gather",
    "GatherNd",
    "Greater",
    "GreaterEqual",
    "HashtableLookup",
    "InstanceNorm",
    "LayerNormFusion",
    "LeakyRelu",
    "Less",
    "LessEqual",
    "Log",
    "LogGrad",
    "LogicalAnd",
    "LogicalNot",
    "LogicalOr",
    "LpNormalization",
    "LRN",
    "LshProjection",
    "LSTM",
    "L2NormalizeFusion",
    "MatMulFusion",
    "Maximum",
    "MaximumGrad",
    "MaxPoolFusion",
    "MaxPoolGrad",
    "Merge",
    "Mfcc",
    "Minimum",
    "MinimumGrad",
    "Mod",
    "MulFusion",
    "MulGrad",
    "Neg",
    "NegGrad",
    "NotEqual",
    "NonMaxSuppression",
    "OneHot",
    "OnesLike",
    "PadFusion",
    "PartialFusion",
    "PowerGrad",
    "PowFusion",
    "PriorBox",
    "PReLUFusion",
    "QuantDTypeCast",
    "Rank",
    "Range",
    "Reciprocal",
    "RealDiv",
    "ReduceFusion",
    "Reshape",
    "Resize",
    "ReverseSequence",
    "ReverseV2",
    "Rfft",
    "ROIPooling",
    "Round",
    "Rsqrt",
    "ScaleFusion",
    "ScatterNd",
    "SGD",
    "Shape",
    "SigmoidCrossEntropyWithLogits",
    "SigmoidCrossEntropyWithLogitsGrad",
    "Sin",
    "SkipGram",
    "SliceFusion",
    "SmoothL1Loss",
    "SmoothL1LossGrad",
    "Softmax",
    "SoftmaxCrossEntropyWithLogits",
    "SpaceToBatch",
    "SpaceToBatchND",
    "SpaceToDepth",
    "SparseSoftmaxCrossEntropyWithLogits",
    "SparseToDense",
    "Split",
    "Sqrt",
    "Squeeze",
    "Square",
    "SquaredDifference",
    "Stack",
    "StridedSlice",
    "SubFusion",
    "SubGrad",
    "Switch",
    "TensorListFromTensor",
    "TensorListGetItem",
    "TensorListReserve",
    "TensorListSetItem",
    "TensorListStack",
    "TileFusion",
    "TopKFusion",
    "Transpose",
    "Unique",
    "UnsortedSegmentSum",
    "Unsqueeze",
    "Unstack",
    "LSTMGrad",
    "Where",
    "ZerosLike",
    "Select",
    "ScatterNdUpdate",
    "GRU",
    "NonZero",
    "InvertPermutation",
    "Size",
    "RandomStandardNormal",
    "CropAndResize",
    "Erf",
    "StridedSliceGrad",
    "IsFinite",
    "LinSpace",
    "UniformReal",
    "AbsGrad",
    "RsqrtGrad",
    "SqrtGrad",
    "LayerNormGrad",
    "ResizeGrad",
    "Splice",
    "LogSoftmax",
    "Call",
    "Custom",
    "CumSum",
    "SplitWithOverlap",
    "GenOP",
    "RaggedRange",
    "GLU",
    "TensorArray",
    "TensorArrayRead",
    "TensorArrayWrite",
    "Affine",
    nullptr
  };
  return names;
}

inline const char *EnumNamePrimitiveType(PrimitiveType e) {
  if (flatbuffers::IsOutRange(e, PrimitiveType_NONE, PrimitiveType_Affine)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesPrimitiveType()[index];
}

template<typename T> struct PrimitiveTypeTraits {
  static const PrimitiveType enum_value = PrimitiveType_NONE;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::Abs> {
  static const PrimitiveType enum_value = PrimitiveType_Abs;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::Activation> {
  static const PrimitiveType enum_value = PrimitiveType_Activation;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::ActivationGrad> {
  static const PrimitiveType enum_value = PrimitiveType_ActivationGrad;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::Adam> {
  static const PrimitiveType enum_value = PrimitiveType_Adam;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::AddFusion> {
  static const PrimitiveType enum_value = PrimitiveType_AddFusion;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::AdderFusion> {
  static const PrimitiveType enum_value = PrimitiveType_AdderFusion;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::AddGrad> {
  static const PrimitiveType enum_value = PrimitiveType_AddGrad;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::AddN> {
  static const PrimitiveType enum_value = PrimitiveType_AddN;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::All> {
  static const PrimitiveType enum_value = PrimitiveType_All;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::ApplyMomentum> {
  static const PrimitiveType enum_value = PrimitiveType_ApplyMomentum;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::ArgMaxFusion> {
  static const PrimitiveType enum_value = PrimitiveType_ArgMaxFusion;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::ArgMinFusion> {
  static const PrimitiveType enum_value = PrimitiveType_ArgMinFusion;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::Assert> {
  static const PrimitiveType enum_value = PrimitiveType_Assert;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::Assign> {
  static const PrimitiveType enum_value = PrimitiveType_Assign;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::AssignAdd> {
  static const PrimitiveType enum_value = PrimitiveType_AssignAdd;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::AudioSpectrogram> {
  static const PrimitiveType enum_value = PrimitiveType_AudioSpectrogram;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::AvgPoolFusion> {
  static const PrimitiveType enum_value = PrimitiveType_AvgPoolFusion;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::AvgPoolGrad> {
  static const PrimitiveType enum_value = PrimitiveType_AvgPoolGrad;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::BatchNorm> {
  static const PrimitiveType enum_value = PrimitiveType_BatchNorm;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::BatchNormGrad> {
  static const PrimitiveType enum_value = PrimitiveType_BatchNormGrad;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::BatchToSpace> {
  static const PrimitiveType enum_value = PrimitiveType_BatchToSpace;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::BatchToSpaceND> {
  static const PrimitiveType enum_value = PrimitiveType_BatchToSpaceND;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::BiasAdd> {
  static const PrimitiveType enum_value = PrimitiveType_BiasAdd;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::BinaryCrossEntropy> {
  static const PrimitiveType enum_value = PrimitiveType_BinaryCrossEntropy;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::BinaryCrossEntropyGrad> {
  static const PrimitiveType enum_value = PrimitiveType_BinaryCrossEntropyGrad;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::BiasAddGrad> {
  static const PrimitiveType enum_value = PrimitiveType_BiasAddGrad;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::BroadcastTo> {
  static const PrimitiveType enum_value = PrimitiveType_BroadcastTo;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::Cast> {
  static const PrimitiveType enum_value = PrimitiveType_Cast;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::Ceil> {
  static const PrimitiveType enum_value = PrimitiveType_Ceil;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::Clip> {
  static const PrimitiveType enum_value = PrimitiveType_Clip;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::Concat> {
  static const PrimitiveType enum_value = PrimitiveType_Concat;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::Attention> {
  static const PrimitiveType enum_value = PrimitiveType_Attention;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::Conv2DBackpropFilterFusion> {
  static const PrimitiveType enum_value = PrimitiveType_Conv2DBackpropFilterFusion;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::Conv2DBackpropInputFusion> {
  static const PrimitiveType enum_value = PrimitiveType_Conv2DBackpropInputFusion;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::Conv2DFusion> {
  static const PrimitiveType enum_value = PrimitiveType_Conv2DFusion;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::Conv2dTransposeFusion> {
  static const PrimitiveType enum_value = PrimitiveType_Conv2dTransposeFusion;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::Cos> {
  static const PrimitiveType enum_value = PrimitiveType_Cos;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::ConstantOfShape> {
  static const PrimitiveType enum_value = PrimitiveType_ConstantOfShape;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::Crop> {
  static const PrimitiveType enum_value = PrimitiveType_Crop;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::CustomExtractFeatures> {
  static const PrimitiveType enum_value = PrimitiveType_CustomExtractFeatures;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::CustomNormalize> {
  static const PrimitiveType enum_value = PrimitiveType_CustomNormalize;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::CustomPredict> {
  static const PrimitiveType enum_value = PrimitiveType_CustomPredict;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::DeConv2DGradFilter> {
  static const PrimitiveType enum_value = PrimitiveType_DeConv2DGradFilter;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::Depend> {
  static const PrimitiveType enum_value = PrimitiveType_Depend;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::DepthToSpace> {
  static const PrimitiveType enum_value = PrimitiveType_DepthToSpace;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::DetectionPostProcess> {
  static const PrimitiveType enum_value = PrimitiveType_DetectionPostProcess;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::DivFusion> {
  static const PrimitiveType enum_value = PrimitiveType_DivFusion;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::DivGrad> {
  static const PrimitiveType enum_value = PrimitiveType_DivGrad;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::Dropout> {
  static const PrimitiveType enum_value = PrimitiveType_Dropout;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::DropoutGrad> {
  static const PrimitiveType enum_value = PrimitiveType_DropoutGrad;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::Elu> {
  static const PrimitiveType enum_value = PrimitiveType_Elu;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::Eltwise> {
  static const PrimitiveType enum_value = PrimitiveType_Eltwise;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::Equal> {
  static const PrimitiveType enum_value = PrimitiveType_Equal;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::EmbeddingLookupFusion> {
  static const PrimitiveType enum_value = PrimitiveType_EmbeddingLookupFusion;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::ExpFusion> {
  static const PrimitiveType enum_value = PrimitiveType_ExpFusion;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::ExpandDims> {
  static const PrimitiveType enum_value = PrimitiveType_ExpandDims;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::FakeQuantWithMinMaxVars> {
  static const PrimitiveType enum_value = PrimitiveType_FakeQuantWithMinMaxVars;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::FakeQuantWithMinMaxVarsPerChannel> {
  static const PrimitiveType enum_value = PrimitiveType_FakeQuantWithMinMaxVarsPerChannel;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::FftReal> {
  static const PrimitiveType enum_value = PrimitiveType_FftReal;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::FftImag> {
  static const PrimitiveType enum_value = PrimitiveType_FftImag;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::Flatten> {
  static const PrimitiveType enum_value = PrimitiveType_Flatten;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::FlattenGrad> {
  static const PrimitiveType enum_value = PrimitiveType_FlattenGrad;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::Floor> {
  static const PrimitiveType enum_value = PrimitiveType_Floor;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::FloorDiv> {
  static const PrimitiveType enum_value = PrimitiveType_FloorDiv;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::FloorMod> {
  static const PrimitiveType enum_value = PrimitiveType_FloorMod;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::Fill> {
  static const PrimitiveType enum_value = PrimitiveType_Fill;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::FullConnection> {
  static const PrimitiveType enum_value = PrimitiveType_FullConnection;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::FusedBatchNorm> {
  static const PrimitiveType enum_value = PrimitiveType_FusedBatchNorm;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::Gather> {
  static const PrimitiveType enum_value = PrimitiveType_Gather;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::GatherNd> {
  static const PrimitiveType enum_value = PrimitiveType_GatherNd;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::Greater> {
  static const PrimitiveType enum_value = PrimitiveType_Greater;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::GreaterEqual> {
  static const PrimitiveType enum_value = PrimitiveType_GreaterEqual;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::HashtableLookup> {
  static const PrimitiveType enum_value = PrimitiveType_HashtableLookup;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::InstanceNorm> {
  static const PrimitiveType enum_value = PrimitiveType_InstanceNorm;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::LayerNormFusion> {
  static const PrimitiveType enum_value = PrimitiveType_LayerNormFusion;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::LeakyRelu> {
  static const PrimitiveType enum_value = PrimitiveType_LeakyRelu;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::Less> {
  static const PrimitiveType enum_value = PrimitiveType_Less;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::LessEqual> {
  static const PrimitiveType enum_value = PrimitiveType_LessEqual;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::Log> {
  static const PrimitiveType enum_value = PrimitiveType_Log;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::LogGrad> {
  static const PrimitiveType enum_value = PrimitiveType_LogGrad;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::LogicalAnd> {
  static const PrimitiveType enum_value = PrimitiveType_LogicalAnd;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::LogicalNot> {
  static const PrimitiveType enum_value = PrimitiveType_LogicalNot;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::LogicalOr> {
  static const PrimitiveType enum_value = PrimitiveType_LogicalOr;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::LpNormalization> {
  static const PrimitiveType enum_value = PrimitiveType_LpNormalization;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::LRN> {
  static const PrimitiveType enum_value = PrimitiveType_LRN;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::LshProjection> {
  static const PrimitiveType enum_value = PrimitiveType_LshProjection;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::LSTM> {
  static const PrimitiveType enum_value = PrimitiveType_LSTM;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::L2NormalizeFusion> {
  static const PrimitiveType enum_value = PrimitiveType_L2NormalizeFusion;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::MatMulFusion> {
  static const PrimitiveType enum_value = PrimitiveType_MatMulFusion;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::Maximum> {
  static const PrimitiveType enum_value = PrimitiveType_Maximum;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::MaximumGrad> {
  static const PrimitiveType enum_value = PrimitiveType_MaximumGrad;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::MaxPoolFusion> {
  static const PrimitiveType enum_value = PrimitiveType_MaxPoolFusion;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::MaxPoolGrad> {
  static const PrimitiveType enum_value = PrimitiveType_MaxPoolGrad;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::Merge> {
  static const PrimitiveType enum_value = PrimitiveType_Merge;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::Mfcc> {
  static const PrimitiveType enum_value = PrimitiveType_Mfcc;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::Minimum> {
  static const PrimitiveType enum_value = PrimitiveType_Minimum;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::MinimumGrad> {
  static const PrimitiveType enum_value = PrimitiveType_MinimumGrad;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::Mod> {
  static const PrimitiveType enum_value = PrimitiveType_Mod;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::MulFusion> {
  static const PrimitiveType enum_value = PrimitiveType_MulFusion;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::MulGrad> {
  static const PrimitiveType enum_value = PrimitiveType_MulGrad;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::Neg> {
  static const PrimitiveType enum_value = PrimitiveType_Neg;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::NegGrad> {
  static const PrimitiveType enum_value = PrimitiveType_NegGrad;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::NotEqual> {
  static const PrimitiveType enum_value = PrimitiveType_NotEqual;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::NonMaxSuppression> {
  static const PrimitiveType enum_value = PrimitiveType_NonMaxSuppression;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::OneHot> {
  static const PrimitiveType enum_value = PrimitiveType_OneHot;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::OnesLike> {
  static const PrimitiveType enum_value = PrimitiveType_OnesLike;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::PadFusion> {
  static const PrimitiveType enum_value = PrimitiveType_PadFusion;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::PartialFusion> {
  static const PrimitiveType enum_value = PrimitiveType_PartialFusion;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::PowerGrad> {
  static const PrimitiveType enum_value = PrimitiveType_PowerGrad;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::PowFusion> {
  static const PrimitiveType enum_value = PrimitiveType_PowFusion;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::PriorBox> {
  static const PrimitiveType enum_value = PrimitiveType_PriorBox;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::PReLUFusion> {
  static const PrimitiveType enum_value = PrimitiveType_PReLUFusion;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::QuantDTypeCast> {
  static const PrimitiveType enum_value = PrimitiveType_QuantDTypeCast;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::Rank> {
  static const PrimitiveType enum_value = PrimitiveType_Rank;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::Range> {
  static const PrimitiveType enum_value = PrimitiveType_Range;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::Reciprocal> {
  static const PrimitiveType enum_value = PrimitiveType_Reciprocal;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::RealDiv> {
  static const PrimitiveType enum_value = PrimitiveType_RealDiv;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::ReduceFusion> {
  static const PrimitiveType enum_value = PrimitiveType_ReduceFusion;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::Reshape> {
  static const PrimitiveType enum_value = PrimitiveType_Reshape;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::Resize> {
  static const PrimitiveType enum_value = PrimitiveType_Resize;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::ReverseSequence> {
  static const PrimitiveType enum_value = PrimitiveType_ReverseSequence;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::ReverseV2> {
  static const PrimitiveType enum_value = PrimitiveType_ReverseV2;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::Rfft> {
  static const PrimitiveType enum_value = PrimitiveType_Rfft;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::ROIPooling> {
  static const PrimitiveType enum_value = PrimitiveType_ROIPooling;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::Round> {
  static const PrimitiveType enum_value = PrimitiveType_Round;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::Rsqrt> {
  static const PrimitiveType enum_value = PrimitiveType_Rsqrt;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::ScaleFusion> {
  static const PrimitiveType enum_value = PrimitiveType_ScaleFusion;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::ScatterNd> {
  static const PrimitiveType enum_value = PrimitiveType_ScatterNd;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::SGD> {
  static const PrimitiveType enum_value = PrimitiveType_SGD;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::Shape> {
  static const PrimitiveType enum_value = PrimitiveType_Shape;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::SigmoidCrossEntropyWithLogits> {
  static const PrimitiveType enum_value = PrimitiveType_SigmoidCrossEntropyWithLogits;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::SigmoidCrossEntropyWithLogitsGrad> {
  static const PrimitiveType enum_value = PrimitiveType_SigmoidCrossEntropyWithLogitsGrad;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::Sin> {
  static const PrimitiveType enum_value = PrimitiveType_Sin;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::SkipGram> {
  static const PrimitiveType enum_value = PrimitiveType_SkipGram;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::SliceFusion> {
  static const PrimitiveType enum_value = PrimitiveType_SliceFusion;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::SmoothL1Loss> {
  static const PrimitiveType enum_value = PrimitiveType_SmoothL1Loss;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::SmoothL1LossGrad> {
  static const PrimitiveType enum_value = PrimitiveType_SmoothL1LossGrad;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::Softmax> {
  static const PrimitiveType enum_value = PrimitiveType_Softmax;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::SoftmaxCrossEntropyWithLogits> {
  static const PrimitiveType enum_value = PrimitiveType_SoftmaxCrossEntropyWithLogits;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::SpaceToBatch> {
  static const PrimitiveType enum_value = PrimitiveType_SpaceToBatch;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::SpaceToBatchND> {
  static const PrimitiveType enum_value = PrimitiveType_SpaceToBatchND;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::SpaceToDepth> {
  static const PrimitiveType enum_value = PrimitiveType_SpaceToDepth;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::SparseSoftmaxCrossEntropyWithLogits> {
  static const PrimitiveType enum_value = PrimitiveType_SparseSoftmaxCrossEntropyWithLogits;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::SparseToDense> {
  static const PrimitiveType enum_value = PrimitiveType_SparseToDense;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::Split> {
  static const PrimitiveType enum_value = PrimitiveType_Split;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::Sqrt> {
  static const PrimitiveType enum_value = PrimitiveType_Sqrt;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::Squeeze> {
  static const PrimitiveType enum_value = PrimitiveType_Squeeze;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::Square> {
  static const PrimitiveType enum_value = PrimitiveType_Square;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::SquaredDifference> {
  static const PrimitiveType enum_value = PrimitiveType_SquaredDifference;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::Stack> {
  static const PrimitiveType enum_value = PrimitiveType_Stack;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::StridedSlice> {
  static const PrimitiveType enum_value = PrimitiveType_StridedSlice;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::SubFusion> {
  static const PrimitiveType enum_value = PrimitiveType_SubFusion;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::SubGrad> {
  static const PrimitiveType enum_value = PrimitiveType_SubGrad;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::Switch> {
  static const PrimitiveType enum_value = PrimitiveType_Switch;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::TensorListFromTensor> {
  static const PrimitiveType enum_value = PrimitiveType_TensorListFromTensor;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::TensorListGetItem> {
  static const PrimitiveType enum_value = PrimitiveType_TensorListGetItem;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::TensorListReserve> {
  static const PrimitiveType enum_value = PrimitiveType_TensorListReserve;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::TensorListSetItem> {
  static const PrimitiveType enum_value = PrimitiveType_TensorListSetItem;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::TensorListStack> {
  static const PrimitiveType enum_value = PrimitiveType_TensorListStack;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::TileFusion> {
  static const PrimitiveType enum_value = PrimitiveType_TileFusion;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::TopKFusion> {
  static const PrimitiveType enum_value = PrimitiveType_TopKFusion;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::Transpose> {
  static const PrimitiveType enum_value = PrimitiveType_Transpose;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::Unique> {
  static const PrimitiveType enum_value = PrimitiveType_Unique;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::UnsortedSegmentSum> {
  static const PrimitiveType enum_value = PrimitiveType_UnsortedSegmentSum;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::Unsqueeze> {
  static const PrimitiveType enum_value = PrimitiveType_Unsqueeze;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::Unstack> {
  static const PrimitiveType enum_value = PrimitiveType_Unstack;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::LSTMGrad> {
  static const PrimitiveType enum_value = PrimitiveType_LSTMGrad;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::Where> {
  static const PrimitiveType enum_value = PrimitiveType_Where;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::ZerosLike> {
  static const PrimitiveType enum_value = PrimitiveType_ZerosLike;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::Select> {
  static const PrimitiveType enum_value = PrimitiveType_Select;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::ScatterNdUpdate> {
  static const PrimitiveType enum_value = PrimitiveType_ScatterNdUpdate;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::GRU> {
  static const PrimitiveType enum_value = PrimitiveType_GRU;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::NonZero> {
  static const PrimitiveType enum_value = PrimitiveType_NonZero;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::InvertPermutation> {
  static const PrimitiveType enum_value = PrimitiveType_InvertPermutation;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::Size> {
  static const PrimitiveType enum_value = PrimitiveType_Size;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::RandomStandardNormal> {
  static const PrimitiveType enum_value = PrimitiveType_RandomStandardNormal;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::CropAndResize> {
  static const PrimitiveType enum_value = PrimitiveType_CropAndResize;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::Erf> {
  static const PrimitiveType enum_value = PrimitiveType_Erf;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::StridedSliceGrad> {
  static const PrimitiveType enum_value = PrimitiveType_StridedSliceGrad;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::IsFinite> {
  static const PrimitiveType enum_value = PrimitiveType_IsFinite;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::LinSpace> {
  static const PrimitiveType enum_value = PrimitiveType_LinSpace;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::UniformReal> {
  static const PrimitiveType enum_value = PrimitiveType_UniformReal;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::AbsGrad> {
  static const PrimitiveType enum_value = PrimitiveType_AbsGrad;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::RsqrtGrad> {
  static const PrimitiveType enum_value = PrimitiveType_RsqrtGrad;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::SqrtGrad> {
  static const PrimitiveType enum_value = PrimitiveType_SqrtGrad;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::LayerNormGrad> {
  static const PrimitiveType enum_value = PrimitiveType_LayerNormGrad;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::ResizeGrad> {
  static const PrimitiveType enum_value = PrimitiveType_ResizeGrad;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::Splice> {
  static const PrimitiveType enum_value = PrimitiveType_Splice;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::LogSoftmax> {
  static const PrimitiveType enum_value = PrimitiveType_LogSoftmax;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::Call> {
  static const PrimitiveType enum_value = PrimitiveType_Call;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::Custom> {
  static const PrimitiveType enum_value = PrimitiveType_Custom;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::CumSum> {
  static const PrimitiveType enum_value = PrimitiveType_CumSum;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::SplitWithOverlap> {
  static const PrimitiveType enum_value = PrimitiveType_SplitWithOverlap;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::GenOP> {
  static const PrimitiveType enum_value = PrimitiveType_GenOP;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::RaggedRange> {
  static const PrimitiveType enum_value = PrimitiveType_RaggedRange;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::GLU> {
  static const PrimitiveType enum_value = PrimitiveType_GLU;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::TensorArray> {
  static const PrimitiveType enum_value = PrimitiveType_TensorArray;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::TensorArrayRead> {
  static const PrimitiveType enum_value = PrimitiveType_TensorArrayRead;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::TensorArrayWrite> {
  static const PrimitiveType enum_value = PrimitiveType_TensorArrayWrite;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::Affine> {
  static const PrimitiveType enum_value = PrimitiveType_Affine;
};

struct PrimitiveTypeUnion {
  PrimitiveType type;
  void *value;

  PrimitiveTypeUnion() : type(PrimitiveType_NONE), value(nullptr) {}
  PrimitiveTypeUnion(PrimitiveTypeUnion&& u) FLATBUFFERS_NOEXCEPT :
    type(PrimitiveType_NONE), value(nullptr)
    { std::swap(type, u.type); std::swap(value, u.value); }
  PrimitiveTypeUnion(const PrimitiveTypeUnion &);
  PrimitiveTypeUnion &operator=(const PrimitiveTypeUnion &u)
    { PrimitiveTypeUnion t(u); std::swap(type, t.type); std::swap(value, t.value); return *this; }
  PrimitiveTypeUnion &operator=(PrimitiveTypeUnion &&u) FLATBUFFERS_NOEXCEPT
    { std::swap(type, u.type); std::swap(value, u.value); return *this; }
  ~PrimitiveTypeUnion() { Reset(); }

  void Reset();

#ifndef FLATBUFFERS_CPP98_STL
  template <typename T>
  void Set(T&& val) {
    using RT = typename std::remove_reference<T>::type;
    Reset();
    type = PrimitiveTypeTraits<typename RT::TableType>::enum_value;
    if (type != PrimitiveType_NONE) {
      value = new RT(std::forward<T>(val));
    }
  }
#endif  // FLATBUFFERS_CPP98_STL

  static void *UnPack(const void *obj, PrimitiveType type, const flatbuffers::resolver_function_t *resolver);
  flatbuffers::Offset<void> Pack(flatbuffers::FlatBufferBuilder &_fbb, const flatbuffers::rehasher_function_t *_rehasher = nullptr) const;

  mindspore::schema::AbsT *AsAbs() {
    return type == PrimitiveType_Abs ?
      reinterpret_cast<mindspore::schema::AbsT *>(value) : nullptr;
  }
  const mindspore::schema::AbsT *AsAbs() const {
    return type == PrimitiveType_Abs ?
      reinterpret_cast<const mindspore::schema::AbsT *>(value) : nullptr;
  }
  mindspore::schema::ActivationT *AsActivation() {
    return type == PrimitiveType_Activation ?
      reinterpret_cast<mindspore::schema::ActivationT *>(value) : nullptr;
  }
  const mindspore::schema::ActivationT *AsActivation() const {
    return type == PrimitiveType_Activation ?
      reinterpret_cast<const mindspore::schema::ActivationT *>(value) : nullptr;
  }
  mindspore::schema::ActivationGradT *AsActivationGrad() {
    return type == PrimitiveType_ActivationGrad ?
      reinterpret_cast<mindspore::schema::ActivationGradT *>(value) : nullptr;
  }
  const mindspore::schema::ActivationGradT *AsActivationGrad() const {
    return type == PrimitiveType_ActivationGrad ?
      reinterpret_cast<const mindspore::schema::ActivationGradT *>(value) : nullptr;
  }
  mindspore::schema::AdamT *AsAdam() {
    return type == PrimitiveType_Adam ?
      reinterpret_cast<mindspore::schema::AdamT *>(value) : nullptr;
  }
  const mindspore::schema::AdamT *AsAdam() const {
    return type == PrimitiveType_Adam ?
      reinterpret_cast<const mindspore::schema::AdamT *>(value) : nullptr;
  }
  mindspore::schema::AddFusionT *AsAddFusion() {
    return type == PrimitiveType_AddFusion ?
      reinterpret_cast<mindspore::schema::AddFusionT *>(value) : nullptr;
  }
  const mindspore::schema::AddFusionT *AsAddFusion() const {
    return type == PrimitiveType_AddFusion ?
      reinterpret_cast<const mindspore::schema::AddFusionT *>(value) : nullptr;
  }
  mindspore::schema::AdderFusionT *AsAdderFusion() {
    return type == PrimitiveType_AdderFusion ?
      reinterpret_cast<mindspore::schema::AdderFusionT *>(value) : nullptr;
  }
  const mindspore::schema::AdderFusionT *AsAdderFusion() const {
    return type == PrimitiveType_AdderFusion ?
      reinterpret_cast<const mindspore::schema::AdderFusionT *>(value) : nullptr;
  }
  mindspore::schema::AddGradT *AsAddGrad() {
    return type == PrimitiveType_AddGrad ?
      reinterpret_cast<mindspore::schema::AddGradT *>(value) : nullptr;
  }
  const mindspore::schema::AddGradT *AsAddGrad() const {
    return type == PrimitiveType_AddGrad ?
      reinterpret_cast<const mindspore::schema::AddGradT *>(value) : nullptr;
  }
  mindspore::schema::AddNT *AsAddN() {
    return type == PrimitiveType_AddN ?
      reinterpret_cast<mindspore::schema::AddNT *>(value) : nullptr;
  }
  const mindspore::schema::AddNT *AsAddN() const {
    return type == PrimitiveType_AddN ?
      reinterpret_cast<const mindspore::schema::AddNT *>(value) : nullptr;
  }
  mindspore::schema::AllT *AsAll() {
    return type == PrimitiveType_All ?
      reinterpret_cast<mindspore::schema::AllT *>(value) : nullptr;
  }
  const mindspore::schema::AllT *AsAll() const {
    return type == PrimitiveType_All ?
      reinterpret_cast<const mindspore::schema::AllT *>(value) : nullptr;
  }
  mindspore::schema::ApplyMomentumT *AsApplyMomentum() {
    return type == PrimitiveType_ApplyMomentum ?
      reinterpret_cast<mindspore::schema::ApplyMomentumT *>(value) : nullptr;
  }
  const mindspore::schema::ApplyMomentumT *AsApplyMomentum() const {
    return type == PrimitiveType_ApplyMomentum ?
      reinterpret_cast<const mindspore::schema::ApplyMomentumT *>(value) : nullptr;
  }
  mindspore::schema::ArgMaxFusionT *AsArgMaxFusion() {
    return type == PrimitiveType_ArgMaxFusion ?
      reinterpret_cast<mindspore::schema::ArgMaxFusionT *>(value) : nullptr;
  }
  const mindspore::schema::ArgMaxFusionT *AsArgMaxFusion() const {
    return type == PrimitiveType_ArgMaxFusion ?
      reinterpret_cast<const mindspore::schema::ArgMaxFusionT *>(value) : nullptr;
  }
  mindspore::schema::ArgMinFusionT *AsArgMinFusion() {
    return type == PrimitiveType_ArgMinFusion ?
      reinterpret_cast<mindspore::schema::ArgMinFusionT *>(value) : nullptr;
  }
  const mindspore::schema::ArgMinFusionT *AsArgMinFusion() const {
    return type == PrimitiveType_ArgMinFusion ?
      reinterpret_cast<const mindspore::schema::ArgMinFusionT *>(value) : nullptr;
  }
  mindspore::schema::AssertT *AsAssert() {
    return type == PrimitiveType_Assert ?
      reinterpret_cast<mindspore::schema::AssertT *>(value) : nullptr;
  }
  const mindspore::schema::AssertT *AsAssert() const {
    return type == PrimitiveType_Assert ?
      reinterpret_cast<const mindspore::schema::AssertT *>(value) : nullptr;
  }
  mindspore::schema::AssignT *AsAssign() {
    return type == PrimitiveType_Assign ?
      reinterpret_cast<mindspore::schema::AssignT *>(value) : nullptr;
  }
  const mindspore::schema::AssignT *AsAssign() const {
    return type == PrimitiveType_Assign ?
      reinterpret_cast<const mindspore::schema::AssignT *>(value) : nullptr;
  }
  mindspore::schema::AssignAddT *AsAssignAdd() {
    return type == PrimitiveType_AssignAdd ?
      reinterpret_cast<mindspore::schema::AssignAddT *>(value) : nullptr;
  }
  const mindspore::schema::AssignAddT *AsAssignAdd() const {
    return type == PrimitiveType_AssignAdd ?
      reinterpret_cast<const mindspore::schema::AssignAddT *>(value) : nullptr;
  }
  mindspore::schema::AudioSpectrogramT *AsAudioSpectrogram() {
    return type == PrimitiveType_AudioSpectrogram ?
      reinterpret_cast<mindspore::schema::AudioSpectrogramT *>(value) : nullptr;
  }
  const mindspore::schema::AudioSpectrogramT *AsAudioSpectrogram() const {
    return type == PrimitiveType_AudioSpectrogram ?
      reinterpret_cast<const mindspore::schema::AudioSpectrogramT *>(value) : nullptr;
  }
  mindspore::schema::AvgPoolFusionT *AsAvgPoolFusion() {
    return type == PrimitiveType_AvgPoolFusion ?
      reinterpret_cast<mindspore::schema::AvgPoolFusionT *>(value) : nullptr;
  }
  const mindspore::schema::AvgPoolFusionT *AsAvgPoolFusion() const {
    return type == PrimitiveType_AvgPoolFusion ?
      reinterpret_cast<const mindspore::schema::AvgPoolFusionT *>(value) : nullptr;
  }
  mindspore::schema::AvgPoolGradT *AsAvgPoolGrad() {
    return type == PrimitiveType_AvgPoolGrad ?
      reinterpret_cast<mindspore::schema::AvgPoolGradT *>(value) : nullptr;
  }
  const mindspore::schema::AvgPoolGradT *AsAvgPoolGrad() const {
    return type == PrimitiveType_AvgPoolGrad ?
      reinterpret_cast<const mindspore::schema::AvgPoolGradT *>(value) : nullptr;
  }
  mindspore::schema::BatchNormT *AsBatchNorm() {
    return type == PrimitiveType_BatchNorm ?
      reinterpret_cast<mindspore::schema::BatchNormT *>(value) : nullptr;
  }
  const mindspore::schema::BatchNormT *AsBatchNorm() const {
    return type == PrimitiveType_BatchNorm ?
      reinterpret_cast<const mindspore::schema::BatchNormT *>(value) : nullptr;
  }
  mindspore::schema::BatchNormGradT *AsBatchNormGrad() {
    return type == PrimitiveType_BatchNormGrad ?
      reinterpret_cast<mindspore::schema::BatchNormGradT *>(value) : nullptr;
  }
  const mindspore::schema::BatchNormGradT *AsBatchNormGrad() const {
    return type == PrimitiveType_BatchNormGrad ?
      reinterpret_cast<const mindspore::schema::BatchNormGradT *>(value) : nullptr;
  }
  mindspore::schema::BatchToSpaceT *AsBatchToSpace() {
    return type == PrimitiveType_BatchToSpace ?
      reinterpret_cast<mindspore::schema::BatchToSpaceT *>(value) : nullptr;
  }
  const mindspore::schema::BatchToSpaceT *AsBatchToSpace() const {
    return type == PrimitiveType_BatchToSpace ?
      reinterpret_cast<const mindspore::schema::BatchToSpaceT *>(value) : nullptr;
  }
  mindspore::schema::BatchToSpaceNDT *AsBatchToSpaceND() {
    return type == PrimitiveType_BatchToSpaceND ?
      reinterpret_cast<mindspore::schema::BatchToSpaceNDT *>(value) : nullptr;
  }
  const mindspore::schema::BatchToSpaceNDT *AsBatchToSpaceND() const {
    return type == PrimitiveType_BatchToSpaceND ?
      reinterpret_cast<const mindspore::schema::BatchToSpaceNDT *>(value) : nullptr;
  }
  mindspore::schema::BiasAddT *AsBiasAdd() {
    return type == PrimitiveType_BiasAdd ?
      reinterpret_cast<mindspore::schema::BiasAddT *>(value) : nullptr;
  }
  const mindspore::schema::BiasAddT *AsBiasAdd() const {
    return type == PrimitiveType_BiasAdd ?
      reinterpret_cast<const mindspore::schema::BiasAddT *>(value) : nullptr;
  }
  mindspore::schema::BinaryCrossEntropyT *AsBinaryCrossEntropy() {
    return type == PrimitiveType_BinaryCrossEntropy ?
      reinterpret_cast<mindspore::schema::BinaryCrossEntropyT *>(value) : nullptr;
  }
  const mindspore::schema::BinaryCrossEntropyT *AsBinaryCrossEntropy() const {
    return type == PrimitiveType_BinaryCrossEntropy ?
      reinterpret_cast<const mindspore::schema::BinaryCrossEntropyT *>(value) : nullptr;
  }
  mindspore::schema::BinaryCrossEntropyGradT *AsBinaryCrossEntropyGrad() {
    return type == PrimitiveType_BinaryCrossEntropyGrad ?
      reinterpret_cast<mindspore::schema::BinaryCrossEntropyGradT *>(value) : nullptr;
  }
  const mindspore::schema::BinaryCrossEntropyGradT *AsBinaryCrossEntropyGrad() const {
    return type == PrimitiveType_BinaryCrossEntropyGrad ?
      reinterpret_cast<const mindspore::schema::BinaryCrossEntropyGradT *>(value) : nullptr;
  }
  mindspore::schema::BiasAddGradT *AsBiasAddGrad() {
    return type == PrimitiveType_BiasAddGrad ?
      reinterpret_cast<mindspore::schema::BiasAddGradT *>(value) : nullptr;
  }
  const mindspore::schema::BiasAddGradT *AsBiasAddGrad() const {
    return type == PrimitiveType_BiasAddGrad ?
      reinterpret_cast<const mindspore::schema::BiasAddGradT *>(value) : nullptr;
  }
  mindspore::schema::BroadcastToT *AsBroadcastTo() {
    return type == PrimitiveType_BroadcastTo ?
      reinterpret_cast<mindspore::schema::BroadcastToT *>(value) : nullptr;
  }
  const mindspore::schema::BroadcastToT *AsBroadcastTo() const {
    return type == PrimitiveType_BroadcastTo ?
      reinterpret_cast<const mindspore::schema::BroadcastToT *>(value) : nullptr;
  }
  mindspore::schema::CastT *AsCast() {
    return type == PrimitiveType_Cast ?
      reinterpret_cast<mindspore::schema::CastT *>(value) : nullptr;
  }
  const mindspore::schema::CastT *AsCast() const {
    return type == PrimitiveType_Cast ?
      reinterpret_cast<const mindspore::schema::CastT *>(value) : nullptr;
  }
  mindspore::schema::CeilT *AsCeil() {
    return type == PrimitiveType_Ceil ?
      reinterpret_cast<mindspore::schema::CeilT *>(value) : nullptr;
  }
  const mindspore::schema::CeilT *AsCeil() const {
    return type == PrimitiveType_Ceil ?
      reinterpret_cast<const mindspore::schema::CeilT *>(value) : nullptr;
  }
  mindspore::schema::ClipT *AsClip() {
    return type == PrimitiveType_Clip ?
      reinterpret_cast<mindspore::schema::ClipT *>(value) : nullptr;
  }
  const mindspore::schema::ClipT *AsClip() const {
    return type == PrimitiveType_Clip ?
      reinterpret_cast<const mindspore::schema::ClipT *>(value) : nullptr;
  }
  mindspore::schema::ConcatT *AsConcat() {
    return type == PrimitiveType_Concat ?
      reinterpret_cast<mindspore::schema::ConcatT *>(value) : nullptr;
  }
  const mindspore::schema::ConcatT *AsConcat() const {
    return type == PrimitiveType_Concat ?
      reinterpret_cast<const mindspore::schema::ConcatT *>(value) : nullptr;
  }
  mindspore::schema::AttentionT *AsAttention() {
    return type == PrimitiveType_Attention ?
      reinterpret_cast<mindspore::schema::AttentionT *>(value) : nullptr;
  }
  const mindspore::schema::AttentionT *AsAttention() const {
    return type == PrimitiveType_Attention ?
      reinterpret_cast<const mindspore::schema::AttentionT *>(value) : nullptr;
  }
  mindspore::schema::Conv2DBackpropFilterFusionT *AsConv2DBackpropFilterFusion() {
    return type == PrimitiveType_Conv2DBackpropFilterFusion ?
      reinterpret_cast<mindspore::schema::Conv2DBackpropFilterFusionT *>(value) : nullptr;
  }
  const mindspore::schema::Conv2DBackpropFilterFusionT *AsConv2DBackpropFilterFusion() const {
    return type == PrimitiveType_Conv2DBackpropFilterFusion ?
      reinterpret_cast<const mindspore::schema::Conv2DBackpropFilterFusionT *>(value) : nullptr;
  }
  mindspore::schema::Conv2DBackpropInputFusionT *AsConv2DBackpropInputFusion() {
    return type == PrimitiveType_Conv2DBackpropInputFusion ?
      reinterpret_cast<mindspore::schema::Conv2DBackpropInputFusionT *>(value) : nullptr;
  }
  const mindspore::schema::Conv2DBackpropInputFusionT *AsConv2DBackpropInputFusion() const {
    return type == PrimitiveType_Conv2DBackpropInputFusion ?
      reinterpret_cast<const mindspore::schema::Conv2DBackpropInputFusionT *>(value) : nullptr;
  }
  mindspore::schema::Conv2DFusionT *AsConv2DFusion() {
    return type == PrimitiveType_Conv2DFusion ?
      reinterpret_cast<mindspore::schema::Conv2DFusionT *>(value) : nullptr;
  }
  const mindspore::schema::Conv2DFusionT *AsConv2DFusion() const {
    return type == PrimitiveType_Conv2DFusion ?
      reinterpret_cast<const mindspore::schema::Conv2DFusionT *>(value) : nullptr;
  }
  mindspore::schema::Conv2dTransposeFusionT *AsConv2dTransposeFusion() {
    return type == PrimitiveType_Conv2dTransposeFusion ?
      reinterpret_cast<mindspore::schema::Conv2dTransposeFusionT *>(value) : nullptr;
  }
  const mindspore::schema::Conv2dTransposeFusionT *AsConv2dTransposeFusion() const {
    return type == PrimitiveType_Conv2dTransposeFusion ?
      reinterpret_cast<const mindspore::schema::Conv2dTransposeFusionT *>(value) : nullptr;
  }
  mindspore::schema::CosT *AsCos() {
    return type == PrimitiveType_Cos ?
      reinterpret_cast<mindspore::schema::CosT *>(value) : nullptr;
  }
  const mindspore::schema::CosT *AsCos() const {
    return type == PrimitiveType_Cos ?
      reinterpret_cast<const mindspore::schema::CosT *>(value) : nullptr;
  }
  mindspore::schema::ConstantOfShapeT *AsConstantOfShape() {
    return type == PrimitiveType_ConstantOfShape ?
      reinterpret_cast<mindspore::schema::ConstantOfShapeT *>(value) : nullptr;
  }
  const mindspore::schema::ConstantOfShapeT *AsConstantOfShape() const {
    return type == PrimitiveType_ConstantOfShape ?
      reinterpret_cast<const mindspore::schema::ConstantOfShapeT *>(value) : nullptr;
  }
  mindspore::schema::CropT *AsCrop() {
    return type == PrimitiveType_Crop ?
      reinterpret_cast<mindspore::schema::CropT *>(value) : nullptr;
  }
  const mindspore::schema::CropT *AsCrop() const {
    return type == PrimitiveType_Crop ?
      reinterpret_cast<const mindspore::schema::CropT *>(value) : nullptr;
  }
  mindspore::schema::CustomExtractFeaturesT *AsCustomExtractFeatures() {
    return type == PrimitiveType_CustomExtractFeatures ?
      reinterpret_cast<mindspore::schema::CustomExtractFeaturesT *>(value) : nullptr;
  }
  const mindspore::schema::CustomExtractFeaturesT *AsCustomExtractFeatures() const {
    return type == PrimitiveType_CustomExtractFeatures ?
      reinterpret_cast<const mindspore::schema::CustomExtractFeaturesT *>(value) : nullptr;
  }
  mindspore::schema::CustomNormalizeT *AsCustomNormalize() {
    return type == PrimitiveType_CustomNormalize ?
      reinterpret_cast<mindspore::schema::CustomNormalizeT *>(value) : nullptr;
  }
  const mindspore::schema::CustomNormalizeT *AsCustomNormalize() const {
    return type == PrimitiveType_CustomNormalize ?
      reinterpret_cast<const mindspore::schema::CustomNormalizeT *>(value) : nullptr;
  }
  mindspore::schema::CustomPredictT *AsCustomPredict() {
    return type == PrimitiveType_CustomPredict ?
      reinterpret_cast<mindspore::schema::CustomPredictT *>(value) : nullptr;
  }
  const mindspore::schema::CustomPredictT *AsCustomPredict() const {
    return type == PrimitiveType_CustomPredict ?
      reinterpret_cast<const mindspore::schema::CustomPredictT *>(value) : nullptr;
  }
  mindspore::schema::DeConv2DGradFilterT *AsDeConv2DGradFilter() {
    return type == PrimitiveType_DeConv2DGradFilter ?
      reinterpret_cast<mindspore::schema::DeConv2DGradFilterT *>(value) : nullptr;
  }
  const mindspore::schema::DeConv2DGradFilterT *AsDeConv2DGradFilter() const {
    return type == PrimitiveType_DeConv2DGradFilter ?
      reinterpret_cast<const mindspore::schema::DeConv2DGradFilterT *>(value) : nullptr;
  }
  mindspore::schema::DependT *AsDepend() {
    return type == PrimitiveType_Depend ?
      reinterpret_cast<mindspore::schema::DependT *>(value) : nullptr;
  }
  const mindspore::schema::DependT *AsDepend() const {
    return type == PrimitiveType_Depend ?
      reinterpret_cast<const mindspore::schema::DependT *>(value) : nullptr;
  }
  mindspore::schema::DepthToSpaceT *AsDepthToSpace() {
    return type == PrimitiveType_DepthToSpace ?
      reinterpret_cast<mindspore::schema::DepthToSpaceT *>(value) : nullptr;
  }
  const mindspore::schema::DepthToSpaceT *AsDepthToSpace() const {
    return type == PrimitiveType_DepthToSpace ?
      reinterpret_cast<const mindspore::schema::DepthToSpaceT *>(value) : nullptr;
  }
  mindspore::schema::DetectionPostProcessT *AsDetectionPostProcess() {
    return type == PrimitiveType_DetectionPostProcess ?
      reinterpret_cast<mindspore::schema::DetectionPostProcessT *>(value) : nullptr;
  }
  const mindspore::schema::DetectionPostProcessT *AsDetectionPostProcess() const {
    return type == PrimitiveType_DetectionPostProcess ?
      reinterpret_cast<const mindspore::schema::DetectionPostProcessT *>(value) : nullptr;
  }
  mindspore::schema::DivFusionT *AsDivFusion() {
    return type == PrimitiveType_DivFusion ?
      reinterpret_cast<mindspore::schema::DivFusionT *>(value) : nullptr;
  }
  const mindspore::schema::DivFusionT *AsDivFusion() const {
    return type == PrimitiveType_DivFusion ?
      reinterpret_cast<const mindspore::schema::DivFusionT *>(value) : nullptr;
  }
  mindspore::schema::DivGradT *AsDivGrad() {
    return type == PrimitiveType_DivGrad ?
      reinterpret_cast<mindspore::schema::DivGradT *>(value) : nullptr;
  }
  const mindspore::schema::DivGradT *AsDivGrad() const {
    return type == PrimitiveType_DivGrad ?
      reinterpret_cast<const mindspore::schema::DivGradT *>(value) : nullptr;
  }
  mindspore::schema::DropoutT *AsDropout() {
    return type == PrimitiveType_Dropout ?
      reinterpret_cast<mindspore::schema::DropoutT *>(value) : nullptr;
  }
  const mindspore::schema::DropoutT *AsDropout() const {
    return type == PrimitiveType_Dropout ?
      reinterpret_cast<const mindspore::schema::DropoutT *>(value) : nullptr;
  }
  mindspore::schema::DropoutGradT *AsDropoutGrad() {
    return type == PrimitiveType_DropoutGrad ?
      reinterpret_cast<mindspore::schema::DropoutGradT *>(value) : nullptr;
  }
  const mindspore::schema::DropoutGradT *AsDropoutGrad() const {
    return type == PrimitiveType_DropoutGrad ?
      reinterpret_cast<const mindspore::schema::DropoutGradT *>(value) : nullptr;
  }
  mindspore::schema::EluT *AsElu() {
    return type == PrimitiveType_Elu ?
      reinterpret_cast<mindspore::schema::EluT *>(value) : nullptr;
  }
  const mindspore::schema::EluT *AsElu() const {
    return type == PrimitiveType_Elu ?
      reinterpret_cast<const mindspore::schema::EluT *>(value) : nullptr;
  }
  mindspore::schema::EltwiseT *AsEltwise() {
    return type == PrimitiveType_Eltwise ?
      reinterpret_cast<mindspore::schema::EltwiseT *>(value) : nullptr;
  }
  const mindspore::schema::EltwiseT *AsEltwise() const {
    return type == PrimitiveType_Eltwise ?
      reinterpret_cast<const mindspore::schema::EltwiseT *>(value) : nullptr;
  }
  mindspore::schema::EqualT *AsEqual() {
    return type == PrimitiveType_Equal ?
      reinterpret_cast<mindspore::schema::EqualT *>(value) : nullptr;
  }
  const mindspore::schema::EqualT *AsEqual() const {
    return type == PrimitiveType_Equal ?
      reinterpret_cast<const mindspore::schema::EqualT *>(value) : nullptr;
  }
  mindspore::schema::EmbeddingLookupFusionT *AsEmbeddingLookupFusion() {
    return type == PrimitiveType_EmbeddingLookupFusion ?
      reinterpret_cast<mindspore::schema::EmbeddingLookupFusionT *>(value) : nullptr;
  }
  const mindspore::schema::EmbeddingLookupFusionT *AsEmbeddingLookupFusion() const {
    return type == PrimitiveType_EmbeddingLookupFusion ?
      reinterpret_cast<const mindspore::schema::EmbeddingLookupFusionT *>(value) : nullptr;
  }
  mindspore::schema::ExpFusionT *AsExpFusion() {
    return type == PrimitiveType_ExpFusion ?
      reinterpret_cast<mindspore::schema::ExpFusionT *>(value) : nullptr;
  }
  const mindspore::schema::ExpFusionT *AsExpFusion() const {
    return type == PrimitiveType_ExpFusion ?
      reinterpret_cast<const mindspore::schema::ExpFusionT *>(value) : nullptr;
  }
  mindspore::schema::ExpandDimsT *AsExpandDims() {
    return type == PrimitiveType_ExpandDims ?
      reinterpret_cast<mindspore::schema::ExpandDimsT *>(value) : nullptr;
  }
  const mindspore::schema::ExpandDimsT *AsExpandDims() const {
    return type == PrimitiveType_ExpandDims ?
      reinterpret_cast<const mindspore::schema::ExpandDimsT *>(value) : nullptr;
  }
  mindspore::schema::FakeQuantWithMinMaxVarsT *AsFakeQuantWithMinMaxVars() {
    return type == PrimitiveType_FakeQuantWithMinMaxVars ?
      reinterpret_cast<mindspore::schema::FakeQuantWithMinMaxVarsT *>(value) : nullptr;
  }
  const mindspore::schema::FakeQuantWithMinMaxVarsT *AsFakeQuantWithMinMaxVars() const {
    return type == PrimitiveType_FakeQuantWithMinMaxVars ?
      reinterpret_cast<const mindspore::schema::FakeQuantWithMinMaxVarsT *>(value) : nullptr;
  }
  mindspore::schema::FakeQuantWithMinMaxVarsPerChannelT *AsFakeQuantWithMinMaxVarsPerChannel() {
    return type == PrimitiveType_FakeQuantWithMinMaxVarsPerChannel ?
      reinterpret_cast<mindspore::schema::FakeQuantWithMinMaxVarsPerChannelT *>(value) : nullptr;
  }
  const mindspore::schema::FakeQuantWithMinMaxVarsPerChannelT *AsFakeQuantWithMinMaxVarsPerChannel() const {
    return type == PrimitiveType_FakeQuantWithMinMaxVarsPerChannel ?
      reinterpret_cast<const mindspore::schema::FakeQuantWithMinMaxVarsPerChannelT *>(value) : nullptr;
  }
  mindspore::schema::FftRealT *AsFftReal() {
    return type == PrimitiveType_FftReal ?
      reinterpret_cast<mindspore::schema::FftRealT *>(value) : nullptr;
  }
  const mindspore::schema::FftRealT *AsFftReal() const {
    return type == PrimitiveType_FftReal ?
      reinterpret_cast<const mindspore::schema::FftRealT *>(value) : nullptr;
  }
  mindspore::schema::FftImagT *AsFftImag() {
    return type == PrimitiveType_FftImag ?
      reinterpret_cast<mindspore::schema::FftImagT *>(value) : nullptr;
  }
  const mindspore::schema::FftImagT *AsFftImag() const {
    return type == PrimitiveType_FftImag ?
      reinterpret_cast<const mindspore::schema::FftImagT *>(value) : nullptr;
  }
  mindspore::schema::FlattenT *AsFlatten() {
    return type == PrimitiveType_Flatten ?
      reinterpret_cast<mindspore::schema::FlattenT *>(value) : nullptr;
  }
  const mindspore::schema::FlattenT *AsFlatten() const {
    return type == PrimitiveType_Flatten ?
      reinterpret_cast<const mindspore::schema::FlattenT *>(value) : nullptr;
  }
  mindspore::schema::FlattenGradT *AsFlattenGrad() {
    return type == PrimitiveType_FlattenGrad ?
      reinterpret_cast<mindspore::schema::FlattenGradT *>(value) : nullptr;
  }
  const mindspore::schema::FlattenGradT *AsFlattenGrad() const {
    return type == PrimitiveType_FlattenGrad ?
      reinterpret_cast<const mindspore::schema::FlattenGradT *>(value) : nullptr;
  }
  mindspore::schema::FloorT *AsFloor() {
    return type == PrimitiveType_Floor ?
      reinterpret_cast<mindspore::schema::FloorT *>(value) : nullptr;
  }
  const mindspore::schema::FloorT *AsFloor() const {
    return type == PrimitiveType_Floor ?
      reinterpret_cast<const mindspore::schema::FloorT *>(value) : nullptr;
  }
  mindspore::schema::FloorDivT *AsFloorDiv() {
    return type == PrimitiveType_FloorDiv ?
      reinterpret_cast<mindspore::schema::FloorDivT *>(value) : nullptr;
  }
  const mindspore::schema::FloorDivT *AsFloorDiv() const {
    return type == PrimitiveType_FloorDiv ?
      reinterpret_cast<const mindspore::schema::FloorDivT *>(value) : nullptr;
  }
  mindspore::schema::FloorModT *AsFloorMod() {
    return type == PrimitiveType_FloorMod ?
      reinterpret_cast<mindspore::schema::FloorModT *>(value) : nullptr;
  }
  const mindspore::schema::FloorModT *AsFloorMod() const {
    return type == PrimitiveType_FloorMod ?
      reinterpret_cast<const mindspore::schema::FloorModT *>(value) : nullptr;
  }
  mindspore::schema::FillT *AsFill() {
    return type == PrimitiveType_Fill ?
      reinterpret_cast<mindspore::schema::FillT *>(value) : nullptr;
  }
  const mindspore::schema::FillT *AsFill() const {
    return type == PrimitiveType_Fill ?
      reinterpret_cast<const mindspore::schema::FillT *>(value) : nullptr;
  }
  mindspore::schema::FullConnectionT *AsFullConnection() {
    return type == PrimitiveType_FullConnection ?
      reinterpret_cast<mindspore::schema::FullConnectionT *>(value) : nullptr;
  }
  const mindspore::schema::FullConnectionT *AsFullConnection() const {
    return type == PrimitiveType_FullConnection ?
      reinterpret_cast<const mindspore::schema::FullConnectionT *>(value) : nullptr;
  }
  mindspore::schema::FusedBatchNormT *AsFusedBatchNorm() {
    return type == PrimitiveType_FusedBatchNorm ?
      reinterpret_cast<mindspore::schema::FusedBatchNormT *>(value) : nullptr;
  }
  const mindspore::schema::FusedBatchNormT *AsFusedBatchNorm() const {
    return type == PrimitiveType_FusedBatchNorm ?
      reinterpret_cast<const mindspore::schema::FusedBatchNormT *>(value) : nullptr;
  }
  mindspore::schema::GatherT *AsGather() {
    return type == PrimitiveType_Gather ?
      reinterpret_cast<mindspore::schema::GatherT *>(value) : nullptr;
  }
  const mindspore::schema::GatherT *AsGather() const {
    return type == PrimitiveType_Gather ?
      reinterpret_cast<const mindspore::schema::GatherT *>(value) : nullptr;
  }
  mindspore::schema::GatherNdT *AsGatherNd() {
    return type == PrimitiveType_GatherNd ?
      reinterpret_cast<mindspore::schema::GatherNdT *>(value) : nullptr;
  }
  const mindspore::schema::GatherNdT *AsGatherNd() const {
    return type == PrimitiveType_GatherNd ?
      reinterpret_cast<const mindspore::schema::GatherNdT *>(value) : nullptr;
  }
  mindspore::schema::GreaterT *AsGreater() {
    return type == PrimitiveType_Greater ?
      reinterpret_cast<mindspore::schema::GreaterT *>(value) : nullptr;
  }
  const mindspore::schema::GreaterT *AsGreater() const {
    return type == PrimitiveType_Greater ?
      reinterpret_cast<const mindspore::schema::GreaterT *>(value) : nullptr;
  }
  mindspore::schema::GreaterEqualT *AsGreaterEqual() {
    return type == PrimitiveType_GreaterEqual ?
      reinterpret_cast<mindspore::schema::GreaterEqualT *>(value) : nullptr;
  }
  const mindspore::schema::GreaterEqualT *AsGreaterEqual() const {
    return type == PrimitiveType_GreaterEqual ?
      reinterpret_cast<const mindspore::schema::GreaterEqualT *>(value) : nullptr;
  }
  mindspore::schema::HashtableLookupT *AsHashtableLookup() {
    return type == PrimitiveType_HashtableLookup ?
      reinterpret_cast<mindspore::schema::HashtableLookupT *>(value) : nullptr;
  }
  const mindspore::schema::HashtableLookupT *AsHashtableLookup() const {
    return type == PrimitiveType_HashtableLookup ?
      reinterpret_cast<const mindspore::schema::HashtableLookupT *>(value) : nullptr;
  }
  mindspore::schema::InstanceNormT *AsInstanceNorm() {
    return type == PrimitiveType_InstanceNorm ?
      reinterpret_cast<mindspore::schema::InstanceNormT *>(value) : nullptr;
  }
  const mindspore::schema::InstanceNormT *AsInstanceNorm() const {
    return type == PrimitiveType_InstanceNorm ?
      reinterpret_cast<const mindspore::schema::InstanceNormT *>(value) : nullptr;
  }
  mindspore::schema::LayerNormFusionT *AsLayerNormFusion() {
    return type == PrimitiveType_LayerNormFusion ?
      reinterpret_cast<mindspore::schema::LayerNormFusionT *>(value) : nullptr;
  }
  const mindspore::schema::LayerNormFusionT *AsLayerNormFusion() const {
    return type == PrimitiveType_LayerNormFusion ?
      reinterpret_cast<const mindspore::schema::LayerNormFusionT *>(value) : nullptr;
  }
  mindspore::schema::LeakyReluT *AsLeakyRelu() {
    return type == PrimitiveType_LeakyRelu ?
      reinterpret_cast<mindspore::schema::LeakyReluT *>(value) : nullptr;
  }
  const mindspore::schema::LeakyReluT *AsLeakyRelu() const {
    return type == PrimitiveType_LeakyRelu ?
      reinterpret_cast<const mindspore::schema::LeakyReluT *>(value) : nullptr;
  }
  mindspore::schema::LessT *AsLess() {
    return type == PrimitiveType_Less ?
      reinterpret_cast<mindspore::schema::LessT *>(value) : nullptr;
  }
  const mindspore::schema::LessT *AsLess() const {
    return type == PrimitiveType_Less ?
      reinterpret_cast<const mindspore::schema::LessT *>(value) : nullptr;
  }
  mindspore::schema::LessEqualT *AsLessEqual() {
    return type == PrimitiveType_LessEqual ?
      reinterpret_cast<mindspore::schema::LessEqualT *>(value) : nullptr;
  }
  const mindspore::schema::LessEqualT *AsLessEqual() const {
    return type == PrimitiveType_LessEqual ?
      reinterpret_cast<const mindspore::schema::LessEqualT *>(value) : nullptr;
  }
  mindspore::schema::LogT *AsLog() {
    return type == PrimitiveType_Log ?
      reinterpret_cast<mindspore::schema::LogT *>(value) : nullptr;
  }
  const mindspore::schema::LogT *AsLog() const {
    return type == PrimitiveType_Log ?
      reinterpret_cast<const mindspore::schema::LogT *>(value) : nullptr;
  }
  mindspore::schema::LogGradT *AsLogGrad() {
    return type == PrimitiveType_LogGrad ?
      reinterpret_cast<mindspore::schema::LogGradT *>(value) : nullptr;
  }
  const mindspore::schema::LogGradT *AsLogGrad() const {
    return type == PrimitiveType_LogGrad ?
      reinterpret_cast<const mindspore::schema::LogGradT *>(value) : nullptr;
  }
  mindspore::schema::LogicalAndT *AsLogicalAnd() {
    return type == PrimitiveType_LogicalAnd ?
      reinterpret_cast<mindspore::schema::LogicalAndT *>(value) : nullptr;
  }
  const mindspore::schema::LogicalAndT *AsLogicalAnd() const {
    return type == PrimitiveType_LogicalAnd ?
      reinterpret_cast<const mindspore::schema::LogicalAndT *>(value) : nullptr;
  }
  mindspore::schema::LogicalNotT *AsLogicalNot() {
    return type == PrimitiveType_LogicalNot ?
      reinterpret_cast<mindspore::schema::LogicalNotT *>(value) : nullptr;
  }
  const mindspore::schema::LogicalNotT *AsLogicalNot() const {
    return type == PrimitiveType_LogicalNot ?
      reinterpret_cast<const mindspore::schema::LogicalNotT *>(value) : nullptr;
  }
  mindspore::schema::LogicalOrT *AsLogicalOr() {
    return type == PrimitiveType_LogicalOr ?
      reinterpret_cast<mindspore::schema::LogicalOrT *>(value) : nullptr;
  }
  const mindspore::schema::LogicalOrT *AsLogicalOr() const {
    return type == PrimitiveType_LogicalOr ?
      reinterpret_cast<const mindspore::schema::LogicalOrT *>(value) : nullptr;
  }
  mindspore::schema::LpNormalizationT *AsLpNormalization() {
    return type == PrimitiveType_LpNormalization ?
      reinterpret_cast<mindspore::schema::LpNormalizationT *>(value) : nullptr;
  }
  const mindspore::schema::LpNormalizationT *AsLpNormalization() const {
    return type == PrimitiveType_LpNormalization ?
      reinterpret_cast<const mindspore::schema::LpNormalizationT *>(value) : nullptr;
  }
  mindspore::schema::LRNT *AsLRN() {
    return type == PrimitiveType_LRN ?
      reinterpret_cast<mindspore::schema::LRNT *>(value) : nullptr;
  }
  const mindspore::schema::LRNT *AsLRN() const {
    return type == PrimitiveType_LRN ?
      reinterpret_cast<const mindspore::schema::LRNT *>(value) : nullptr;
  }
  mindspore::schema::LshProjectionT *AsLshProjection() {
    return type == PrimitiveType_LshProjection ?
      reinterpret_cast<mindspore::schema::LshProjectionT *>(value) : nullptr;
  }
  const mindspore::schema::LshProjectionT *AsLshProjection() const {
    return type == PrimitiveType_LshProjection ?
      reinterpret_cast<const mindspore::schema::LshProjectionT *>(value) : nullptr;
  }
  mindspore::schema::LSTMT *AsLSTM() {
    return type == PrimitiveType_LSTM ?
      reinterpret_cast<mindspore::schema::LSTMT *>(value) : nullptr;
  }
  const mindspore::schema::LSTMT *AsLSTM() const {
    return type == PrimitiveType_LSTM ?
      reinterpret_cast<const mindspore::schema::LSTMT *>(value) : nullptr;
  }
  mindspore::schema::L2NormalizeFusionT *AsL2NormalizeFusion() {
    return type == PrimitiveType_L2NormalizeFusion ?
      reinterpret_cast<mindspore::schema::L2NormalizeFusionT *>(value) : nullptr;
  }
  const mindspore::schema::L2NormalizeFusionT *AsL2NormalizeFusion() const {
    return type == PrimitiveType_L2NormalizeFusion ?
      reinterpret_cast<const mindspore::schema::L2NormalizeFusionT *>(value) : nullptr;
  }
  mindspore::schema::MatMulFusionT *AsMatMulFusion() {
    return type == PrimitiveType_MatMulFusion ?
      reinterpret_cast<mindspore::schema::MatMulFusionT *>(value) : nullptr;
  }
  const mindspore::schema::MatMulFusionT *AsMatMulFusion() const {
    return type == PrimitiveType_MatMulFusion ?
      reinterpret_cast<const mindspore::schema::MatMulFusionT *>(value) : nullptr;
  }
  mindspore::schema::MaximumT *AsMaximum() {
    return type == PrimitiveType_Maximum ?
      reinterpret_cast<mindspore::schema::MaximumT *>(value) : nullptr;
  }
  const mindspore::schema::MaximumT *AsMaximum() const {
    return type == PrimitiveType_Maximum ?
      reinterpret_cast<const mindspore::schema::MaximumT *>(value) : nullptr;
  }
  mindspore::schema::MaximumGradT *AsMaximumGrad() {
    return type == PrimitiveType_MaximumGrad ?
      reinterpret_cast<mindspore::schema::MaximumGradT *>(value) : nullptr;
  }
  const mindspore::schema::MaximumGradT *AsMaximumGrad() const {
    return type == PrimitiveType_MaximumGrad ?
      reinterpret_cast<const mindspore::schema::MaximumGradT *>(value) : nullptr;
  }
  mindspore::schema::MaxPoolFusionT *AsMaxPoolFusion() {
    return type == PrimitiveType_MaxPoolFusion ?
      reinterpret_cast<mindspore::schema::MaxPoolFusionT *>(value) : nullptr;
  }
  const mindspore::schema::MaxPoolFusionT *AsMaxPoolFusion() const {
    return type == PrimitiveType_MaxPoolFusion ?
      reinterpret_cast<const mindspore::schema::MaxPoolFusionT *>(value) : nullptr;
  }
  mindspore::schema::MaxPoolGradT *AsMaxPoolGrad() {
    return type == PrimitiveType_MaxPoolGrad ?
      reinterpret_cast<mindspore::schema::MaxPoolGradT *>(value) : nullptr;
  }
  const mindspore::schema::MaxPoolGradT *AsMaxPoolGrad() const {
    return type == PrimitiveType_MaxPoolGrad ?
      reinterpret_cast<const mindspore::schema::MaxPoolGradT *>(value) : nullptr;
  }
  mindspore::schema::MergeT *AsMerge() {
    return type == PrimitiveType_Merge ?
      reinterpret_cast<mindspore::schema::MergeT *>(value) : nullptr;
  }
  const mindspore::schema::MergeT *AsMerge() const {
    return type == PrimitiveType_Merge ?
      reinterpret_cast<const mindspore::schema::MergeT *>(value) : nullptr;
  }
  mindspore::schema::MfccT *AsMfcc() {
    return type == PrimitiveType_Mfcc ?
      reinterpret_cast<mindspore::schema::MfccT *>(value) : nullptr;
  }
  const mindspore::schema::MfccT *AsMfcc() const {
    return type == PrimitiveType_Mfcc ?
      reinterpret_cast<const mindspore::schema::MfccT *>(value) : nullptr;
  }
  mindspore::schema::MinimumT *AsMinimum() {
    return type == PrimitiveType_Minimum ?
      reinterpret_cast<mindspore::schema::MinimumT *>(value) : nullptr;
  }
  const mindspore::schema::MinimumT *AsMinimum() const {
    return type == PrimitiveType_Minimum ?
      reinterpret_cast<const mindspore::schema::MinimumT *>(value) : nullptr;
  }
  mindspore::schema::MinimumGradT *AsMinimumGrad() {
    return type == PrimitiveType_MinimumGrad ?
      reinterpret_cast<mindspore::schema::MinimumGradT *>(value) : nullptr;
  }
  const mindspore::schema::MinimumGradT *AsMinimumGrad() const {
    return type == PrimitiveType_MinimumGrad ?
      reinterpret_cast<const mindspore::schema::MinimumGradT *>(value) : nullptr;
  }
  mindspore::schema::ModT *AsMod() {
    return type == PrimitiveType_Mod ?
      reinterpret_cast<mindspore::schema::ModT *>(value) : nullptr;
  }
  const mindspore::schema::ModT *AsMod() const {
    return type == PrimitiveType_Mod ?
      reinterpret_cast<const mindspore::schema::ModT *>(value) : nullptr;
  }
  mindspore::schema::MulFusionT *AsMulFusion() {
    return type == PrimitiveType_MulFusion ?
      reinterpret_cast<mindspore::schema::MulFusionT *>(value) : nullptr;
  }
  const mindspore::schema::MulFusionT *AsMulFusion() const {
    return type == PrimitiveType_MulFusion ?
      reinterpret_cast<const mindspore::schema::MulFusionT *>(value) : nullptr;
  }
  mindspore::schema::MulGradT *AsMulGrad() {
    return type == PrimitiveType_MulGrad ?
      reinterpret_cast<mindspore::schema::MulGradT *>(value) : nullptr;
  }
  const mindspore::schema::MulGradT *AsMulGrad() const {
    return type == PrimitiveType_MulGrad ?
      reinterpret_cast<const mindspore::schema::MulGradT *>(value) : nullptr;
  }
  mindspore::schema::NegT *AsNeg() {
    return type == PrimitiveType_Neg ?
      reinterpret_cast<mindspore::schema::NegT *>(value) : nullptr;
  }
  const mindspore::schema::NegT *AsNeg() const {
    return type == PrimitiveType_Neg ?
      reinterpret_cast<const mindspore::schema::NegT *>(value) : nullptr;
  }
  mindspore::schema::NegGradT *AsNegGrad() {
    return type == PrimitiveType_NegGrad ?
      reinterpret_cast<mindspore::schema::NegGradT *>(value) : nullptr;
  }
  const mindspore::schema::NegGradT *AsNegGrad() const {
    return type == PrimitiveType_NegGrad ?
      reinterpret_cast<const mindspore::schema::NegGradT *>(value) : nullptr;
  }
  mindspore::schema::NotEqualT *AsNotEqual() {
    return type == PrimitiveType_NotEqual ?
      reinterpret_cast<mindspore::schema::NotEqualT *>(value) : nullptr;
  }
  const mindspore::schema::NotEqualT *AsNotEqual() const {
    return type == PrimitiveType_NotEqual ?
      reinterpret_cast<const mindspore::schema::NotEqualT *>(value) : nullptr;
  }
  mindspore::schema::NonMaxSuppressionT *AsNonMaxSuppression() {
    return type == PrimitiveType_NonMaxSuppression ?
      reinterpret_cast<mindspore::schema::NonMaxSuppressionT *>(value) : nullptr;
  }
  const mindspore::schema::NonMaxSuppressionT *AsNonMaxSuppression() const {
    return type == PrimitiveType_NonMaxSuppression ?
      reinterpret_cast<const mindspore::schema::NonMaxSuppressionT *>(value) : nullptr;
  }
  mindspore::schema::OneHotT *AsOneHot() {
    return type == PrimitiveType_OneHot ?
      reinterpret_cast<mindspore::schema::OneHotT *>(value) : nullptr;
  }
  const mindspore::schema::OneHotT *AsOneHot() const {
    return type == PrimitiveType_OneHot ?
      reinterpret_cast<const mindspore::schema::OneHotT *>(value) : nullptr;
  }
  mindspore::schema::OnesLikeT *AsOnesLike() {
    return type == PrimitiveType_OnesLike ?
      reinterpret_cast<mindspore::schema::OnesLikeT *>(value) : nullptr;
  }
  const mindspore::schema::OnesLikeT *AsOnesLike() const {
    return type == PrimitiveType_OnesLike ?
      reinterpret_cast<const mindspore::schema::OnesLikeT *>(value) : nullptr;
  }
  mindspore::schema::PadFusionT *AsPadFusion() {
    return type == PrimitiveType_PadFusion ?
      reinterpret_cast<mindspore::schema::PadFusionT *>(value) : nullptr;
  }
  const mindspore::schema::PadFusionT *AsPadFusion() const {
    return type == PrimitiveType_PadFusion ?
      reinterpret_cast<const mindspore::schema::PadFusionT *>(value) : nullptr;
  }
  mindspore::schema::PartialFusionT *AsPartialFusion() {
    return type == PrimitiveType_PartialFusion ?
      reinterpret_cast<mindspore::schema::PartialFusionT *>(value) : nullptr;
  }
  const mindspore::schema::PartialFusionT *AsPartialFusion() const {
    return type == PrimitiveType_PartialFusion ?
      reinterpret_cast<const mindspore::schema::PartialFusionT *>(value) : nullptr;
  }
  mindspore::schema::PowerGradT *AsPowerGrad() {
    return type == PrimitiveType_PowerGrad ?
      reinterpret_cast<mindspore::schema::PowerGradT *>(value) : nullptr;
  }
  const mindspore::schema::PowerGradT *AsPowerGrad() const {
    return type == PrimitiveType_PowerGrad ?
      reinterpret_cast<const mindspore::schema::PowerGradT *>(value) : nullptr;
  }
  mindspore::schema::PowFusionT *AsPowFusion() {
    return type == PrimitiveType_PowFusion ?
      reinterpret_cast<mindspore::schema::PowFusionT *>(value) : nullptr;
  }
  const mindspore::schema::PowFusionT *AsPowFusion() const {
    return type == PrimitiveType_PowFusion ?
      reinterpret_cast<const mindspore::schema::PowFusionT *>(value) : nullptr;
  }
  mindspore::schema::PriorBoxT *AsPriorBox() {
    return type == PrimitiveType_PriorBox ?
      reinterpret_cast<mindspore::schema::PriorBoxT *>(value) : nullptr;
  }
  const mindspore::schema::PriorBoxT *AsPriorBox() const {
    return type == PrimitiveType_PriorBox ?
      reinterpret_cast<const mindspore::schema::PriorBoxT *>(value) : nullptr;
  }
  mindspore::schema::PReLUFusionT *AsPReLUFusion() {
    return type == PrimitiveType_PReLUFusion ?
      reinterpret_cast<mindspore::schema::PReLUFusionT *>(value) : nullptr;
  }
  const mindspore::schema::PReLUFusionT *AsPReLUFusion() const {
    return type == PrimitiveType_PReLUFusion ?
      reinterpret_cast<const mindspore::schema::PReLUFusionT *>(value) : nullptr;
  }
  mindspore::schema::QuantDTypeCastT *AsQuantDTypeCast() {
    return type == PrimitiveType_QuantDTypeCast ?
      reinterpret_cast<mindspore::schema::QuantDTypeCastT *>(value) : nullptr;
  }
  const mindspore::schema::QuantDTypeCastT *AsQuantDTypeCast() const {
    return type == PrimitiveType_QuantDTypeCast ?
      reinterpret_cast<const mindspore::schema::QuantDTypeCastT *>(value) : nullptr;
  }
  mindspore::schema::RankT *AsRank() {
    return type == PrimitiveType_Rank ?
      reinterpret_cast<mindspore::schema::RankT *>(value) : nullptr;
  }
  const mindspore::schema::RankT *AsRank() const {
    return type == PrimitiveType_Rank ?
      reinterpret_cast<const mindspore::schema::RankT *>(value) : nullptr;
  }
  mindspore::schema::RangeT *AsRange() {
    return type == PrimitiveType_Range ?
      reinterpret_cast<mindspore::schema::RangeT *>(value) : nullptr;
  }
  const mindspore::schema::RangeT *AsRange() const {
    return type == PrimitiveType_Range ?
      reinterpret_cast<const mindspore::schema::RangeT *>(value) : nullptr;
  }
  mindspore::schema::ReciprocalT *AsReciprocal() {
    return type == PrimitiveType_Reciprocal ?
      reinterpret_cast<mindspore::schema::ReciprocalT *>(value) : nullptr;
  }
  const mindspore::schema::ReciprocalT *AsReciprocal() const {
    return type == PrimitiveType_Reciprocal ?
      reinterpret_cast<const mindspore::schema::ReciprocalT *>(value) : nullptr;
  }
  mindspore::schema::RealDivT *AsRealDiv() {
    return type == PrimitiveType_RealDiv ?
      reinterpret_cast<mindspore::schema::RealDivT *>(value) : nullptr;
  }
  const mindspore::schema::RealDivT *AsRealDiv() const {
    return type == PrimitiveType_RealDiv ?
      reinterpret_cast<const mindspore::schema::RealDivT *>(value) : nullptr;
  }
  mindspore::schema::ReduceFusionT *AsReduceFusion() {
    return type == PrimitiveType_ReduceFusion ?
      reinterpret_cast<mindspore::schema::ReduceFusionT *>(value) : nullptr;
  }
  const mindspore::schema::ReduceFusionT *AsReduceFusion() const {
    return type == PrimitiveType_ReduceFusion ?
      reinterpret_cast<const mindspore::schema::ReduceFusionT *>(value) : nullptr;
  }
  mindspore::schema::ReshapeT *AsReshape() {
    return type == PrimitiveType_Reshape ?
      reinterpret_cast<mindspore::schema::ReshapeT *>(value) : nullptr;
  }
  const mindspore::schema::ReshapeT *AsReshape() const {
    return type == PrimitiveType_Reshape ?
      reinterpret_cast<const mindspore::schema::ReshapeT *>(value) : nullptr;
  }
  mindspore::schema::ResizeT *AsResize() {
    return type == PrimitiveType_Resize ?
      reinterpret_cast<mindspore::schema::ResizeT *>(value) : nullptr;
  }
  const mindspore::schema::ResizeT *AsResize() const {
    return type == PrimitiveType_Resize ?
      reinterpret_cast<const mindspore::schema::ResizeT *>(value) : nullptr;
  }
  mindspore::schema::ReverseSequenceT *AsReverseSequence() {
    return type == PrimitiveType_ReverseSequence ?
      reinterpret_cast<mindspore::schema::ReverseSequenceT *>(value) : nullptr;
  }
  const mindspore::schema::ReverseSequenceT *AsReverseSequence() const {
    return type == PrimitiveType_ReverseSequence ?
      reinterpret_cast<const mindspore::schema::ReverseSequenceT *>(value) : nullptr;
  }
  mindspore::schema::ReverseV2T *AsReverseV2() {
    return type == PrimitiveType_ReverseV2 ?
      reinterpret_cast<mindspore::schema::ReverseV2T *>(value) : nullptr;
  }
  const mindspore::schema::ReverseV2T *AsReverseV2() const {
    return type == PrimitiveType_ReverseV2 ?
      reinterpret_cast<const mindspore::schema::ReverseV2T *>(value) : nullptr;
  }
  mindspore::schema::RfftT *AsRfft() {
    return type == PrimitiveType_Rfft ?
      reinterpret_cast<mindspore::schema::RfftT *>(value) : nullptr;
  }
  const mindspore::schema::RfftT *AsRfft() const {
    return type == PrimitiveType_Rfft ?
      reinterpret_cast<const mindspore::schema::RfftT *>(value) : nullptr;
  }
  mindspore::schema::ROIPoolingT *AsROIPooling() {
    return type == PrimitiveType_ROIPooling ?
      reinterpret_cast<mindspore::schema::ROIPoolingT *>(value) : nullptr;
  }
  const mindspore::schema::ROIPoolingT *AsROIPooling() const {
    return type == PrimitiveType_ROIPooling ?
      reinterpret_cast<const mindspore::schema::ROIPoolingT *>(value) : nullptr;
  }
  mindspore::schema::RoundT *AsRound() {
    return type == PrimitiveType_Round ?
      reinterpret_cast<mindspore::schema::RoundT *>(value) : nullptr;
  }
  const mindspore::schema::RoundT *AsRound() const {
    return type == PrimitiveType_Round ?
      reinterpret_cast<const mindspore::schema::RoundT *>(value) : nullptr;
  }
  mindspore::schema::RsqrtT *AsRsqrt() {
    return type == PrimitiveType_Rsqrt ?
      reinterpret_cast<mindspore::schema::RsqrtT *>(value) : nullptr;
  }
  const mindspore::schema::RsqrtT *AsRsqrt() const {
    return type == PrimitiveType_Rsqrt ?
      reinterpret_cast<const mindspore::schema::RsqrtT *>(value) : nullptr;
  }
  mindspore::schema::ScaleFusionT *AsScaleFusion() {
    return type == PrimitiveType_ScaleFusion ?
      reinterpret_cast<mindspore::schema::ScaleFusionT *>(value) : nullptr;
  }
  const mindspore::schema::ScaleFusionT *AsScaleFusion() const {
    return type == PrimitiveType_ScaleFusion ?
      reinterpret_cast<const mindspore::schema::ScaleFusionT *>(value) : nullptr;
  }
  mindspore::schema::ScatterNdT *AsScatterNd() {
    return type == PrimitiveType_ScatterNd ?
      reinterpret_cast<mindspore::schema::ScatterNdT *>(value) : nullptr;
  }
  const mindspore::schema::ScatterNdT *AsScatterNd() const {
    return type == PrimitiveType_ScatterNd ?
      reinterpret_cast<const mindspore::schema::ScatterNdT *>(value) : nullptr;
  }
  mindspore::schema::SGDT *AsSGD() {
    return type == PrimitiveType_SGD ?
      reinterpret_cast<mindspore::schema::SGDT *>(value) : nullptr;
  }
  const mindspore::schema::SGDT *AsSGD() const {
    return type == PrimitiveType_SGD ?
      reinterpret_cast<const mindspore::schema::SGDT *>(value) : nullptr;
  }
  mindspore::schema::ShapeT *AsShape() {
    return type == PrimitiveType_Shape ?
      reinterpret_cast<mindspore::schema::ShapeT *>(value) : nullptr;
  }
  const mindspore::schema::ShapeT *AsShape() const {
    return type == PrimitiveType_Shape ?
      reinterpret_cast<const mindspore::schema::ShapeT *>(value) : nullptr;
  }
  mindspore::schema::SigmoidCrossEntropyWithLogitsT *AsSigmoidCrossEntropyWithLogits() {
    return type == PrimitiveType_SigmoidCrossEntropyWithLogits ?
      reinterpret_cast<mindspore::schema::SigmoidCrossEntropyWithLogitsT *>(value) : nullptr;
  }
  const mindspore::schema::SigmoidCrossEntropyWithLogitsT *AsSigmoidCrossEntropyWithLogits() const {
    return type == PrimitiveType_SigmoidCrossEntropyWithLogits ?
      reinterpret_cast<const mindspore::schema::SigmoidCrossEntropyWithLogitsT *>(value) : nullptr;
  }
  mindspore::schema::SigmoidCrossEntropyWithLogitsGradT *AsSigmoidCrossEntropyWithLogitsGrad() {
    return type == PrimitiveType_SigmoidCrossEntropyWithLogitsGrad ?
      reinterpret_cast<mindspore::schema::SigmoidCrossEntropyWithLogitsGradT *>(value) : nullptr;
  }
  const mindspore::schema::SigmoidCrossEntropyWithLogitsGradT *AsSigmoidCrossEntropyWithLogitsGrad() const {
    return type == PrimitiveType_SigmoidCrossEntropyWithLogitsGrad ?
      reinterpret_cast<const mindspore::schema::SigmoidCrossEntropyWithLogitsGradT *>(value) : nullptr;
  }
  mindspore::schema::SinT *AsSin() {
    return type == PrimitiveType_Sin ?
      reinterpret_cast<mindspore::schema::SinT *>(value) : nullptr;
  }
  const mindspore::schema::SinT *AsSin() const {
    return type == PrimitiveType_Sin ?
      reinterpret_cast<const mindspore::schema::SinT *>(value) : nullptr;
  }
  mindspore::schema::SkipGramT *AsSkipGram() {
    return type == PrimitiveType_SkipGram ?
      reinterpret_cast<mindspore::schema::SkipGramT *>(value) : nullptr;
  }
  const mindspore::schema::SkipGramT *AsSkipGram() const {
    return type == PrimitiveType_SkipGram ?
      reinterpret_cast<const mindspore::schema::SkipGramT *>(value) : nullptr;
  }
  mindspore::schema::SliceFusionT *AsSliceFusion() {
    return type == PrimitiveType_SliceFusion ?
      reinterpret_cast<mindspore::schema::SliceFusionT *>(value) : nullptr;
  }
  const mindspore::schema::SliceFusionT *AsSliceFusion() const {
    return type == PrimitiveType_SliceFusion ?
      reinterpret_cast<const mindspore::schema::SliceFusionT *>(value) : nullptr;
  }
  mindspore::schema::SmoothL1LossT *AsSmoothL1Loss() {
    return type == PrimitiveType_SmoothL1Loss ?
      reinterpret_cast<mindspore::schema::SmoothL1LossT *>(value) : nullptr;
  }
  const mindspore::schema::SmoothL1LossT *AsSmoothL1Loss() const {
    return type == PrimitiveType_SmoothL1Loss ?
      reinterpret_cast<const mindspore::schema::SmoothL1LossT *>(value) : nullptr;
  }
  mindspore::schema::SmoothL1LossGradT *AsSmoothL1LossGrad() {
    return type == PrimitiveType_SmoothL1LossGrad ?
      reinterpret_cast<mindspore::schema::SmoothL1LossGradT *>(value) : nullptr;
  }
  const mindspore::schema::SmoothL1LossGradT *AsSmoothL1LossGrad() const {
    return type == PrimitiveType_SmoothL1LossGrad ?
      reinterpret_cast<const mindspore::schema::SmoothL1LossGradT *>(value) : nullptr;
  }
  mindspore::schema::SoftmaxT *AsSoftmax() {
    return type == PrimitiveType_Softmax ?
      reinterpret_cast<mindspore::schema::SoftmaxT *>(value) : nullptr;
  }
  const mindspore::schema::SoftmaxT *AsSoftmax() const {
    return type == PrimitiveType_Softmax ?
      reinterpret_cast<const mindspore::schema::SoftmaxT *>(value) : nullptr;
  }
  mindspore::schema::SoftmaxCrossEntropyWithLogitsT *AsSoftmaxCrossEntropyWithLogits() {
    return type == PrimitiveType_SoftmaxCrossEntropyWithLogits ?
      reinterpret_cast<mindspore::schema::SoftmaxCrossEntropyWithLogitsT *>(value) : nullptr;
  }
  const mindspore::schema::SoftmaxCrossEntropyWithLogitsT *AsSoftmaxCrossEntropyWithLogits() const {
    return type == PrimitiveType_SoftmaxCrossEntropyWithLogits ?
      reinterpret_cast<const mindspore::schema::SoftmaxCrossEntropyWithLogitsT *>(value) : nullptr;
  }
  mindspore::schema::SpaceToBatchT *AsSpaceToBatch() {
    return type == PrimitiveType_SpaceToBatch ?
      reinterpret_cast<mindspore::schema::SpaceToBatchT *>(value) : nullptr;
  }
  const mindspore::schema::SpaceToBatchT *AsSpaceToBatch() const {
    return type == PrimitiveType_SpaceToBatch ?
      reinterpret_cast<const mindspore::schema::SpaceToBatchT *>(value) : nullptr;
  }
  mindspore::schema::SpaceToBatchNDT *AsSpaceToBatchND() {
    return type == PrimitiveType_SpaceToBatchND ?
      reinterpret_cast<mindspore::schema::SpaceToBatchNDT *>(value) : nullptr;
  }
  const mindspore::schema::SpaceToBatchNDT *AsSpaceToBatchND() const {
    return type == PrimitiveType_SpaceToBatchND ?
      reinterpret_cast<const mindspore::schema::SpaceToBatchNDT *>(value) : nullptr;
  }
  mindspore::schema::SpaceToDepthT *AsSpaceToDepth() {
    return type == PrimitiveType_SpaceToDepth ?
      reinterpret_cast<mindspore::schema::SpaceToDepthT *>(value) : nullptr;
  }
  const mindspore::schema::SpaceToDepthT *AsSpaceToDepth() const {
    return type == PrimitiveType_SpaceToDepth ?
      reinterpret_cast<const mindspore::schema::SpaceToDepthT *>(value) : nullptr;
  }
  mindspore::schema::SparseSoftmaxCrossEntropyWithLogitsT *AsSparseSoftmaxCrossEntropyWithLogits() {
    return type == PrimitiveType_SparseSoftmaxCrossEntropyWithLogits ?
      reinterpret_cast<mindspore::schema::SparseSoftmaxCrossEntropyWithLogitsT *>(value) : nullptr;
  }
  const mindspore::schema::SparseSoftmaxCrossEntropyWithLogitsT *AsSparseSoftmaxCrossEntropyWithLogits() const {
    return type == PrimitiveType_SparseSoftmaxCrossEntropyWithLogits ?
      reinterpret_cast<const mindspore::schema::SparseSoftmaxCrossEntropyWithLogitsT *>(value) : nullptr;
  }
  mindspore::schema::SparseToDenseT *AsSparseToDense() {
    return type == PrimitiveType_SparseToDense ?
      reinterpret_cast<mindspore::schema::SparseToDenseT *>(value) : nullptr;
  }
  const mindspore::schema::SparseToDenseT *AsSparseToDense() const {
    return type == PrimitiveType_SparseToDense ?
      reinterpret_cast<const mindspore::schema::SparseToDenseT *>(value) : nullptr;
  }
  mindspore::schema::SplitT *AsSplit() {
    return type == PrimitiveType_Split ?
      reinterpret_cast<mindspore::schema::SplitT *>(value) : nullptr;
  }
  const mindspore::schema::SplitT *AsSplit() const {
    return type == PrimitiveType_Split ?
      reinterpret_cast<const mindspore::schema::SplitT *>(value) : nullptr;
  }
  mindspore::schema::SqrtT *AsSqrt() {
    return type == PrimitiveType_Sqrt ?
      reinterpret_cast<mindspore::schema::SqrtT *>(value) : nullptr;
  }
  const mindspore::schema::SqrtT *AsSqrt() const {
    return type == PrimitiveType_Sqrt ?
      reinterpret_cast<const mindspore::schema::SqrtT *>(value) : nullptr;
  }
  mindspore::schema::SqueezeT *AsSqueeze() {
    return type == PrimitiveType_Squeeze ?
      reinterpret_cast<mindspore::schema::SqueezeT *>(value) : nullptr;
  }
  const mindspore::schema::SqueezeT *AsSqueeze() const {
    return type == PrimitiveType_Squeeze ?
      reinterpret_cast<const mindspore::schema::SqueezeT *>(value) : nullptr;
  }
  mindspore::schema::SquareT *AsSquare() {
    return type == PrimitiveType_Square ?
      reinterpret_cast<mindspore::schema::SquareT *>(value) : nullptr;
  }
  const mindspore::schema::SquareT *AsSquare() const {
    return type == PrimitiveType_Square ?
      reinterpret_cast<const mindspore::schema::SquareT *>(value) : nullptr;
  }
  mindspore::schema::SquaredDifferenceT *AsSquaredDifference() {
    return type == PrimitiveType_SquaredDifference ?
      reinterpret_cast<mindspore::schema::SquaredDifferenceT *>(value) : nullptr;
  }
  const mindspore::schema::SquaredDifferenceT *AsSquaredDifference() const {
    return type == PrimitiveType_SquaredDifference ?
      reinterpret_cast<const mindspore::schema::SquaredDifferenceT *>(value) : nullptr;
  }
  mindspore::schema::StackT *AsStack() {
    return type == PrimitiveType_Stack ?
      reinterpret_cast<mindspore::schema::StackT *>(value) : nullptr;
  }
  const mindspore::schema::StackT *AsStack() const {
    return type == PrimitiveType_Stack ?
      reinterpret_cast<const mindspore::schema::StackT *>(value) : nullptr;
  }
  mindspore::schema::StridedSliceT *AsStridedSlice() {
    return type == PrimitiveType_StridedSlice ?
      reinterpret_cast<mindspore::schema::StridedSliceT *>(value) : nullptr;
  }
  const mindspore::schema::StridedSliceT *AsStridedSlice() const {
    return type == PrimitiveType_StridedSlice ?
      reinterpret_cast<const mindspore::schema::StridedSliceT *>(value) : nullptr;
  }
  mindspore::schema::SubFusionT *AsSubFusion() {
    return type == PrimitiveType_SubFusion ?
      reinterpret_cast<mindspore::schema::SubFusionT *>(value) : nullptr;
  }
  const mindspore::schema::SubFusionT *AsSubFusion() const {
    return type == PrimitiveType_SubFusion ?
      reinterpret_cast<const mindspore::schema::SubFusionT *>(value) : nullptr;
  }
  mindspore::schema::SubGradT *AsSubGrad() {
    return type == PrimitiveType_SubGrad ?
      reinterpret_cast<mindspore::schema::SubGradT *>(value) : nullptr;
  }
  const mindspore::schema::SubGradT *AsSubGrad() const {
    return type == PrimitiveType_SubGrad ?
      reinterpret_cast<const mindspore::schema::SubGradT *>(value) : nullptr;
  }
  mindspore::schema::SwitchT *AsSwitch() {
    return type == PrimitiveType_Switch ?
      reinterpret_cast<mindspore::schema::SwitchT *>(value) : nullptr;
  }
  const mindspore::schema::SwitchT *AsSwitch() const {
    return type == PrimitiveType_Switch ?
      reinterpret_cast<const mindspore::schema::SwitchT *>(value) : nullptr;
  }
  mindspore::schema::TensorListFromTensorT *AsTensorListFromTensor() {
    return type == PrimitiveType_TensorListFromTensor ?
      reinterpret_cast<mindspore::schema::TensorListFromTensorT *>(value) : nullptr;
  }
  const mindspore::schema::TensorListFromTensorT *AsTensorListFromTensor() const {
    return type == PrimitiveType_TensorListFromTensor ?
      reinterpret_cast<const mindspore::schema::TensorListFromTensorT *>(value) : nullptr;
  }
  mindspore::schema::TensorListGetItemT *AsTensorListGetItem() {
    return type == PrimitiveType_TensorListGetItem ?
      reinterpret_cast<mindspore::schema::TensorListGetItemT *>(value) : nullptr;
  }
  const mindspore::schema::TensorListGetItemT *AsTensorListGetItem() const {
    return type == PrimitiveType_TensorListGetItem ?
      reinterpret_cast<const mindspore::schema::TensorListGetItemT *>(value) : nullptr;
  }
  mindspore::schema::TensorListReserveT *AsTensorListReserve() {
    return type == PrimitiveType_TensorListReserve ?
      reinterpret_cast<mindspore::schema::TensorListReserveT *>(value) : nullptr;
  }
  const mindspore::schema::TensorListReserveT *AsTensorListReserve() const {
    return type == PrimitiveType_TensorListReserve ?
      reinterpret_cast<const mindspore::schema::TensorListReserveT *>(value) : nullptr;
  }
  mindspore::schema::TensorListSetItemT *AsTensorListSetItem() {
    return type == PrimitiveType_TensorListSetItem ?
      reinterpret_cast<mindspore::schema::TensorListSetItemT *>(value) : nullptr;
  }
  const mindspore::schema::TensorListSetItemT *AsTensorListSetItem() const {
    return type == PrimitiveType_TensorListSetItem ?
      reinterpret_cast<const mindspore::schema::TensorListSetItemT *>(value) : nullptr;
  }
  mindspore::schema::TensorListStackT *AsTensorListStack() {
    return type == PrimitiveType_TensorListStack ?
      reinterpret_cast<mindspore::schema::TensorListStackT *>(value) : nullptr;
  }
  const mindspore::schema::TensorListStackT *AsTensorListStack() const {
    return type == PrimitiveType_TensorListStack ?
      reinterpret_cast<const mindspore::schema::TensorListStackT *>(value) : nullptr;
  }
  mindspore::schema::TileFusionT *AsTileFusion() {
    return type == PrimitiveType_TileFusion ?
      reinterpret_cast<mindspore::schema::TileFusionT *>(value) : nullptr;
  }
  const mindspore::schema::TileFusionT *AsTileFusion() const {
    return type == PrimitiveType_TileFusion ?
      reinterpret_cast<const mindspore::schema::TileFusionT *>(value) : nullptr;
  }
  mindspore::schema::TopKFusionT *AsTopKFusion() {
    return type == PrimitiveType_TopKFusion ?
      reinterpret_cast<mindspore::schema::TopKFusionT *>(value) : nullptr;
  }
  const mindspore::schema::TopKFusionT *AsTopKFusion() const {
    return type == PrimitiveType_TopKFusion ?
      reinterpret_cast<const mindspore::schema::TopKFusionT *>(value) : nullptr;
  }
  mindspore::schema::TransposeT *AsTranspose() {
    return type == PrimitiveType_Transpose ?
      reinterpret_cast<mindspore::schema::TransposeT *>(value) : nullptr;
  }
  const mindspore::schema::TransposeT *AsTranspose() const {
    return type == PrimitiveType_Transpose ?
      reinterpret_cast<const mindspore::schema::TransposeT *>(value) : nullptr;
  }
  mindspore::schema::UniqueT *AsUnique() {
    return type == PrimitiveType_Unique ?
      reinterpret_cast<mindspore::schema::UniqueT *>(value) : nullptr;
  }
  const mindspore::schema::UniqueT *AsUnique() const {
    return type == PrimitiveType_Unique ?
      reinterpret_cast<const mindspore::schema::UniqueT *>(value) : nullptr;
  }
  mindspore::schema::UnsortedSegmentSumT *AsUnsortedSegmentSum() {
    return type == PrimitiveType_UnsortedSegmentSum ?
      reinterpret_cast<mindspore::schema::UnsortedSegmentSumT *>(value) : nullptr;
  }
  const mindspore::schema::UnsortedSegmentSumT *AsUnsortedSegmentSum() const {
    return type == PrimitiveType_UnsortedSegmentSum ?
      reinterpret_cast<const mindspore::schema::UnsortedSegmentSumT *>(value) : nullptr;
  }
  mindspore::schema::UnsqueezeT *AsUnsqueeze() {
    return type == PrimitiveType_Unsqueeze ?
      reinterpret_cast<mindspore::schema::UnsqueezeT *>(value) : nullptr;
  }
  const mindspore::schema::UnsqueezeT *AsUnsqueeze() const {
    return type == PrimitiveType_Unsqueeze ?
      reinterpret_cast<const mindspore::schema::UnsqueezeT *>(value) : nullptr;
  }
  mindspore::schema::UnstackT *AsUnstack() {
    return type == PrimitiveType_Unstack ?
      reinterpret_cast<mindspore::schema::UnstackT *>(value) : nullptr;
  }
  const mindspore::schema::UnstackT *AsUnstack() const {
    return type == PrimitiveType_Unstack ?
      reinterpret_cast<const mindspore::schema::UnstackT *>(value) : nullptr;
  }
  mindspore::schema::LSTMGradT *AsLSTMGrad() {
    return type == PrimitiveType_LSTMGrad ?
      reinterpret_cast<mindspore::schema::LSTMGradT *>(value) : nullptr;
  }
  const mindspore::schema::LSTMGradT *AsLSTMGrad() const {
    return type == PrimitiveType_LSTMGrad ?
      reinterpret_cast<const mindspore::schema::LSTMGradT *>(value) : nullptr;
  }
  mindspore::schema::WhereT *AsWhere() {
    return type == PrimitiveType_Where ?
      reinterpret_cast<mindspore::schema::WhereT *>(value) : nullptr;
  }
  const mindspore::schema::WhereT *AsWhere() const {
    return type == PrimitiveType_Where ?
      reinterpret_cast<const mindspore::schema::WhereT *>(value) : nullptr;
  }
  mindspore::schema::ZerosLikeT *AsZerosLike() {
    return type == PrimitiveType_ZerosLike ?
      reinterpret_cast<mindspore::schema::ZerosLikeT *>(value) : nullptr;
  }
  const mindspore::schema::ZerosLikeT *AsZerosLike() const {
    return type == PrimitiveType_ZerosLike ?
      reinterpret_cast<const mindspore::schema::ZerosLikeT *>(value) : nullptr;
  }
  mindspore::schema::SelectT *AsSelect() {
    return type == PrimitiveType_Select ?
      reinterpret_cast<mindspore::schema::SelectT *>(value) : nullptr;
  }
  const mindspore::schema::SelectT *AsSelect() const {
    return type == PrimitiveType_Select ?
      reinterpret_cast<const mindspore::schema::SelectT *>(value) : nullptr;
  }
  mindspore::schema::ScatterNdUpdateT *AsScatterNdUpdate() {
    return type == PrimitiveType_ScatterNdUpdate ?
      reinterpret_cast<mindspore::schema::ScatterNdUpdateT *>(value) : nullptr;
  }
  const mindspore::schema::ScatterNdUpdateT *AsScatterNdUpdate() const {
    return type == PrimitiveType_ScatterNdUpdate ?
      reinterpret_cast<const mindspore::schema::ScatterNdUpdateT *>(value) : nullptr;
  }
  mindspore::schema::GRUT *AsGRU() {
    return type == PrimitiveType_GRU ?
      reinterpret_cast<mindspore::schema::GRUT *>(value) : nullptr;
  }
  const mindspore::schema::GRUT *AsGRU() const {
    return type == PrimitiveType_GRU ?
      reinterpret_cast<const mindspore::schema::GRUT *>(value) : nullptr;
  }
  mindspore::schema::NonZeroT *AsNonZero() {
    return type == PrimitiveType_NonZero ?
      reinterpret_cast<mindspore::schema::NonZeroT *>(value) : nullptr;
  }
  const mindspore::schema::NonZeroT *AsNonZero() const {
    return type == PrimitiveType_NonZero ?
      reinterpret_cast<const mindspore::schema::NonZeroT *>(value) : nullptr;
  }
  mindspore::schema::InvertPermutationT *AsInvertPermutation() {
    return type == PrimitiveType_InvertPermutation ?
      reinterpret_cast<mindspore::schema::InvertPermutationT *>(value) : nullptr;
  }
  const mindspore::schema::InvertPermutationT *AsInvertPermutation() const {
    return type == PrimitiveType_InvertPermutation ?
      reinterpret_cast<const mindspore::schema::InvertPermutationT *>(value) : nullptr;
  }
  mindspore::schema::SizeT *AsSize() {
    return type == PrimitiveType_Size ?
      reinterpret_cast<mindspore::schema::SizeT *>(value) : nullptr;
  }
  const mindspore::schema::SizeT *AsSize() const {
    return type == PrimitiveType_Size ?
      reinterpret_cast<const mindspore::schema::SizeT *>(value) : nullptr;
  }
  mindspore::schema::RandomStandardNormalT *AsRandomStandardNormal() {
    return type == PrimitiveType_RandomStandardNormal ?
      reinterpret_cast<mindspore::schema::RandomStandardNormalT *>(value) : nullptr;
  }
  const mindspore::schema::RandomStandardNormalT *AsRandomStandardNormal() const {
    return type == PrimitiveType_RandomStandardNormal ?
      reinterpret_cast<const mindspore::schema::RandomStandardNormalT *>(value) : nullptr;
  }
  mindspore::schema::CropAndResizeT *AsCropAndResize() {
    return type == PrimitiveType_CropAndResize ?
      reinterpret_cast<mindspore::schema::CropAndResizeT *>(value) : nullptr;
  }
  const mindspore::schema::CropAndResizeT *AsCropAndResize() const {
    return type == PrimitiveType_CropAndResize ?
      reinterpret_cast<const mindspore::schema::CropAndResizeT *>(value) : nullptr;
  }
  mindspore::schema::ErfT *AsErf() {
    return type == PrimitiveType_Erf ?
      reinterpret_cast<mindspore::schema::ErfT *>(value) : nullptr;
  }
  const mindspore::schema::ErfT *AsErf() const {
    return type == PrimitiveType_Erf ?
      reinterpret_cast<const mindspore::schema::ErfT *>(value) : nullptr;
  }
  mindspore::schema::StridedSliceGradT *AsStridedSliceGrad() {
    return type == PrimitiveType_StridedSliceGrad ?
      reinterpret_cast<mindspore::schema::StridedSliceGradT *>(value) : nullptr;
  }
  const mindspore::schema::StridedSliceGradT *AsStridedSliceGrad() const {
    return type == PrimitiveType_StridedSliceGrad ?
      reinterpret_cast<const mindspore::schema::StridedSliceGradT *>(value) : nullptr;
  }
  mindspore::schema::IsFiniteT *AsIsFinite() {
    return type == PrimitiveType_IsFinite ?
      reinterpret_cast<mindspore::schema::IsFiniteT *>(value) : nullptr;
  }
  const mindspore::schema::IsFiniteT *AsIsFinite() const {
    return type == PrimitiveType_IsFinite ?
      reinterpret_cast<const mindspore::schema::IsFiniteT *>(value) : nullptr;
  }
  mindspore::schema::LinSpaceT *AsLinSpace() {
    return type == PrimitiveType_LinSpace ?
      reinterpret_cast<mindspore::schema::LinSpaceT *>(value) : nullptr;
  }
  const mindspore::schema::LinSpaceT *AsLinSpace() const {
    return type == PrimitiveType_LinSpace ?
      reinterpret_cast<const mindspore::schema::LinSpaceT *>(value) : nullptr;
  }
  mindspore::schema::UniformRealT *AsUniformReal() {
    return type == PrimitiveType_UniformReal ?
      reinterpret_cast<mindspore::schema::UniformRealT *>(value) : nullptr;
  }
  const mindspore::schema::UniformRealT *AsUniformReal() const {
    return type == PrimitiveType_UniformReal ?
      reinterpret_cast<const mindspore::schema::UniformRealT *>(value) : nullptr;
  }
  mindspore::schema::AbsGradT *AsAbsGrad() {
    return type == PrimitiveType_AbsGrad ?
      reinterpret_cast<mindspore::schema::AbsGradT *>(value) : nullptr;
  }
  const mindspore::schema::AbsGradT *AsAbsGrad() const {
    return type == PrimitiveType_AbsGrad ?
      reinterpret_cast<const mindspore::schema::AbsGradT *>(value) : nullptr;
  }
  mindspore::schema::RsqrtGradT *AsRsqrtGrad() {
    return type == PrimitiveType_RsqrtGrad ?
      reinterpret_cast<mindspore::schema::RsqrtGradT *>(value) : nullptr;
  }
  const mindspore::schema::RsqrtGradT *AsRsqrtGrad() const {
    return type == PrimitiveType_RsqrtGrad ?
      reinterpret_cast<const mindspore::schema::RsqrtGradT *>(value) : nullptr;
  }
  mindspore::schema::SqrtGradT *AsSqrtGrad() {
    return type == PrimitiveType_SqrtGrad ?
      reinterpret_cast<mindspore::schema::SqrtGradT *>(value) : nullptr;
  }
  const mindspore::schema::SqrtGradT *AsSqrtGrad() const {
    return type == PrimitiveType_SqrtGrad ?
      reinterpret_cast<const mindspore::schema::SqrtGradT *>(value) : nullptr;
  }
  mindspore::schema::LayerNormGradT *AsLayerNormGrad() {
    return type == PrimitiveType_LayerNormGrad ?
      reinterpret_cast<mindspore::schema::LayerNormGradT *>(value) : nullptr;
  }
  const mindspore::schema::LayerNormGradT *AsLayerNormGrad() const {
    return type == PrimitiveType_LayerNormGrad ?
      reinterpret_cast<const mindspore::schema::LayerNormGradT *>(value) : nullptr;
  }
  mindspore::schema::ResizeGradT *AsResizeGrad() {
    return type == PrimitiveType_ResizeGrad ?
      reinterpret_cast<mindspore::schema::ResizeGradT *>(value) : nullptr;
  }
  const mindspore::schema::ResizeGradT *AsResizeGrad() const {
    return type == PrimitiveType_ResizeGrad ?
      reinterpret_cast<const mindspore::schema::ResizeGradT *>(value) : nullptr;
  }
  mindspore::schema::SpliceT *AsSplice() {
    return type == PrimitiveType_Splice ?
      reinterpret_cast<mindspore::schema::SpliceT *>(value) : nullptr;
  }
  const mindspore::schema::SpliceT *AsSplice() const {
    return type == PrimitiveType_Splice ?
      reinterpret_cast<const mindspore::schema::SpliceT *>(value) : nullptr;
  }
  mindspore::schema::LogSoftmaxT *AsLogSoftmax() {
    return type == PrimitiveType_LogSoftmax ?
      reinterpret_cast<mindspore::schema::LogSoftmaxT *>(value) : nullptr;
  }
  const mindspore::schema::LogSoftmaxT *AsLogSoftmax() const {
    return type == PrimitiveType_LogSoftmax ?
      reinterpret_cast<const mindspore::schema::LogSoftmaxT *>(value) : nullptr;
  }
  mindspore::schema::CallT *AsCall() {
    return type == PrimitiveType_Call ?
      reinterpret_cast<mindspore::schema::CallT *>(value) : nullptr;
  }
  const mindspore::schema::CallT *AsCall() const {
    return type == PrimitiveType_Call ?
      reinterpret_cast<const mindspore::schema::CallT *>(value) : nullptr;
  }
  mindspore::schema::CustomT *AsCustom() {
    return type == PrimitiveType_Custom ?
      reinterpret_cast<mindspore::schema::CustomT *>(value) : nullptr;
  }
  const mindspore::schema::CustomT *AsCustom() const {
    return type == PrimitiveType_Custom ?
      reinterpret_cast<const mindspore::schema::CustomT *>(value) : nullptr;
  }
  mindspore::schema::CumSumT *AsCumSum() {
    return type == PrimitiveType_CumSum ?
      reinterpret_cast<mindspore::schema::CumSumT *>(value) : nullptr;
  }
  const mindspore::schema::CumSumT *AsCumSum() const {
    return type == PrimitiveType_CumSum ?
      reinterpret_cast<const mindspore::schema::CumSumT *>(value) : nullptr;
  }
  mindspore::schema::SplitWithOverlapT *AsSplitWithOverlap() {
    return type == PrimitiveType_SplitWithOverlap ?
      reinterpret_cast<mindspore::schema::SplitWithOverlapT *>(value) : nullptr;
  }
  const mindspore::schema::SplitWithOverlapT *AsSplitWithOverlap() const {
    return type == PrimitiveType_SplitWithOverlap ?
      reinterpret_cast<const mindspore::schema::SplitWithOverlapT *>(value) : nullptr;
  }
  mindspore::schema::GenOPT *AsGenOP() {
    return type == PrimitiveType_GenOP ?
      reinterpret_cast<mindspore::schema::GenOPT *>(value) : nullptr;
  }
  const mindspore::schema::GenOPT *AsGenOP() const {
    return type == PrimitiveType_GenOP ?
      reinterpret_cast<const mindspore::schema::GenOPT *>(value) : nullptr;
  }
  mindspore::schema::RaggedRangeT *AsRaggedRange() {
    return type == PrimitiveType_RaggedRange ?
      reinterpret_cast<mindspore::schema::RaggedRangeT *>(value) : nullptr;
  }
  const mindspore::schema::RaggedRangeT *AsRaggedRange() const {
    return type == PrimitiveType_RaggedRange ?
      reinterpret_cast<const mindspore::schema::RaggedRangeT *>(value) : nullptr;
  }
  mindspore::schema::GLUT *AsGLU() {
    return type == PrimitiveType_GLU ?
      reinterpret_cast<mindspore::schema::GLUT *>(value) : nullptr;
  }
  const mindspore::schema::GLUT *AsGLU() const {
    return type == PrimitiveType_GLU ?
      reinterpret_cast<const mindspore::schema::GLUT *>(value) : nullptr;
  }
  mindspore::schema::TensorArrayT *AsTensorArray() {
    return type == PrimitiveType_TensorArray ?
      reinterpret_cast<mindspore::schema::TensorArrayT *>(value) : nullptr;
  }
  const mindspore::schema::TensorArrayT *AsTensorArray() const {
    return type == PrimitiveType_TensorArray ?
      reinterpret_cast<const mindspore::schema::TensorArrayT *>(value) : nullptr;
  }
  mindspore::schema::TensorArrayReadT *AsTensorArrayRead() {
    return type == PrimitiveType_TensorArrayRead ?
      reinterpret_cast<mindspore::schema::TensorArrayReadT *>(value) : nullptr;
  }
  const mindspore::schema::TensorArrayReadT *AsTensorArrayRead() const {
    return type == PrimitiveType_TensorArrayRead ?
      reinterpret_cast<const mindspore::schema::TensorArrayReadT *>(value) : nullptr;
  }
  mindspore::schema::TensorArrayWriteT *AsTensorArrayWrite() {
    return type == PrimitiveType_TensorArrayWrite ?
      reinterpret_cast<mindspore::schema::TensorArrayWriteT *>(value) : nullptr;
  }
  const mindspore::schema::TensorArrayWriteT *AsTensorArrayWrite() const {
    return type == PrimitiveType_TensorArrayWrite ?
      reinterpret_cast<const mindspore::schema::TensorArrayWriteT *>(value) : nullptr;
  }
  mindspore::schema::AffineT *AsAffine() {
    return type == PrimitiveType_Affine ?
      reinterpret_cast<mindspore::schema::AffineT *>(value) : nullptr;
  }
  const mindspore::schema::AffineT *AsAffine() const {
    return type == PrimitiveType_Affine ?
      reinterpret_cast<const mindspore::schema::AffineT *>(value) : nullptr;
  }
};

bool VerifyPrimitiveType(flatbuffers::Verifier &verifier, const void *obj, PrimitiveType type);
bool VerifyPrimitiveTypeVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types);

struct AbsT : public flatbuffers::NativeTable {
  typedef Abs TableType;
};

struct Abs FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef AbsT NativeTableType;
  typedef AbsBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return AbsTypeTable();
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  AbsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(AbsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Abs> Pack(flatbuffers::FlatBufferBuilder &_fbb, const AbsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct AbsBuilder {
  typedef Abs Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit AbsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Abs> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Abs>(end);
    return o;
  }
};

inline flatbuffers::Offset<Abs> CreateAbs(
    flatbuffers::FlatBufferBuilder &_fbb) {
  AbsBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<Abs> CreateAbs(flatbuffers::FlatBufferBuilder &_fbb, const AbsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ActivationT : public flatbuffers::NativeTable {
  typedef Activation TableType;
  mindspore::schema::ActivationType activation_type = mindspore::schema::ActivationType_NO_ACTIVATION;
  float alpha = 0.0f;
  float min_val = 0.0f;
  float max_val = 0.0f;
  bool approximate = false;
};

struct Activation FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ActivationT NativeTableType;
  typedef ActivationBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return ActivationTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ACTIVATION_TYPE = 4,
    VT_ALPHA = 6,
    VT_MIN_VAL = 8,
    VT_MAX_VAL = 10,
    VT_APPROXIMATE = 12
  };
  mindspore::schema::ActivationType activation_type() const {
    return static_cast<mindspore::schema::ActivationType>(GetField<int8_t>(VT_ACTIVATION_TYPE, 0));
  }
  bool mutate_activation_type(mindspore::schema::ActivationType _activation_type) {
    return SetField<int8_t>(VT_ACTIVATION_TYPE, static_cast<int8_t>(_activation_type), 0);
  }
  float alpha() const {
    return GetField<float>(VT_ALPHA, 0.0f);
  }
  bool mutate_alpha(float _alpha) {
    return SetField<float>(VT_ALPHA, _alpha, 0.0f);
  }
  float min_val() const {
    return GetField<float>(VT_MIN_VAL, 0.0f);
  }
  bool mutate_min_val(float _min_val) {
    return SetField<float>(VT_MIN_VAL, _min_val, 0.0f);
  }
  float max_val() const {
    return GetField<float>(VT_MAX_VAL, 0.0f);
  }
  bool mutate_max_val(float _max_val) {
    return SetField<float>(VT_MAX_VAL, _max_val, 0.0f);
  }
  bool approximate() const {
    return GetField<uint8_t>(VT_APPROXIMATE, 0) != 0;
  }
  bool mutate_approximate(bool _approximate) {
    return SetField<uint8_t>(VT_APPROXIMATE, static_cast<uint8_t>(_approximate), 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_ACTIVATION_TYPE) &&
           VerifyField<float>(verifier, VT_ALPHA) &&
           VerifyField<float>(verifier, VT_MIN_VAL) &&
           VerifyField<float>(verifier, VT_MAX_VAL) &&
           VerifyField<uint8_t>(verifier, VT_APPROXIMATE) &&
           verifier.EndTable();
  }
  ActivationT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ActivationT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Activation> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ActivationT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ActivationBuilder {
  typedef Activation Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_activation_type(mindspore::schema::ActivationType activation_type) {
    fbb_.AddElement<int8_t>(Activation::VT_ACTIVATION_TYPE, static_cast<int8_t>(activation_type), 0);
  }
  void add_alpha(float alpha) {
    fbb_.AddElement<float>(Activation::VT_ALPHA, alpha, 0.0f);
  }
  void add_min_val(float min_val) {
    fbb_.AddElement<float>(Activation::VT_MIN_VAL, min_val, 0.0f);
  }
  void add_max_val(float max_val) {
    fbb_.AddElement<float>(Activation::VT_MAX_VAL, max_val, 0.0f);
  }
  void add_approximate(bool approximate) {
    fbb_.AddElement<uint8_t>(Activation::VT_APPROXIMATE, static_cast<uint8_t>(approximate), 0);
  }
  explicit ActivationBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Activation> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Activation>(end);
    return o;
  }
};

inline flatbuffers::Offset<Activation> CreateActivation(
    flatbuffers::FlatBufferBuilder &_fbb,
    mindspore::schema::ActivationType activation_type = mindspore::schema::ActivationType_NO_ACTIVATION,
    float alpha = 0.0f,
    float min_val = 0.0f,
    float max_val = 0.0f,
    bool approximate = false) {
  ActivationBuilder builder_(_fbb);
  builder_.add_max_val(max_val);
  builder_.add_min_val(min_val);
  builder_.add_alpha(alpha);
  builder_.add_approximate(approximate);
  builder_.add_activation_type(activation_type);
  return builder_.Finish();
}

flatbuffers::Offset<Activation> CreateActivation(flatbuffers::FlatBufferBuilder &_fbb, const ActivationT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ActivationGradT : public flatbuffers::NativeTable {
  typedef ActivationGrad TableType;
  mindspore::schema::ActivationType activation_type = mindspore::schema::ActivationType_NO_ACTIVATION;
  float alpha = 0.0f;
};

struct ActivationGrad FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ActivationGradT NativeTableType;
  typedef ActivationGradBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return ActivationGradTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ACTIVATION_TYPE = 4,
    VT_ALPHA = 6
  };
  mindspore::schema::ActivationType activation_type() const {
    return static_cast<mindspore::schema::ActivationType>(GetField<int8_t>(VT_ACTIVATION_TYPE, 0));
  }
  bool mutate_activation_type(mindspore::schema::ActivationType _activation_type) {
    return SetField<int8_t>(VT_ACTIVATION_TYPE, static_cast<int8_t>(_activation_type), 0);
  }
  float alpha() const {
    return GetField<float>(VT_ALPHA, 0.0f);
  }
  bool mutate_alpha(float _alpha) {
    return SetField<float>(VT_ALPHA, _alpha, 0.0f);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_ACTIVATION_TYPE) &&
           VerifyField<float>(verifier, VT_ALPHA) &&
           verifier.EndTable();
  }
  ActivationGradT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ActivationGradT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<ActivationGrad> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ActivationGradT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ActivationGradBuilder {
  typedef ActivationGrad Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_activation_type(mindspore::schema::ActivationType activation_type) {
    fbb_.AddElement<int8_t>(ActivationGrad::VT_ACTIVATION_TYPE, static_cast<int8_t>(activation_type), 0);
  }
  void add_alpha(float alpha) {
    fbb_.AddElement<float>(ActivationGrad::VT_ALPHA, alpha, 0.0f);
  }
  explicit ActivationGradBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<ActivationGrad> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ActivationGrad>(end);
    return o;
  }
};

inline flatbuffers::Offset<ActivationGrad> CreateActivationGrad(
    flatbuffers::FlatBufferBuilder &_fbb,
    mindspore::schema::ActivationType activation_type = mindspore::schema::ActivationType_NO_ACTIVATION,
    float alpha = 0.0f) {
  ActivationGradBuilder builder_(_fbb);
  builder_.add_alpha(alpha);
  builder_.add_activation_type(activation_type);
  return builder_.Finish();
}

flatbuffers::Offset<ActivationGrad> CreateActivationGrad(flatbuffers::FlatBufferBuilder &_fbb, const ActivationGradT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct AdamT : public flatbuffers::NativeTable {
  typedef Adam TableType;
  bool use_locking = false;
  bool use_nesterov = false;
};

struct Adam FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef AdamT NativeTableType;
  typedef AdamBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return AdamTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_USE_LOCKING = 4,
    VT_USE_NESTEROV = 6
  };
  bool use_locking() const {
    return GetField<uint8_t>(VT_USE_LOCKING, 0) != 0;
  }
  bool mutate_use_locking(bool _use_locking) {
    return SetField<uint8_t>(VT_USE_LOCKING, static_cast<uint8_t>(_use_locking), 0);
  }
  bool use_nesterov() const {
    return GetField<uint8_t>(VT_USE_NESTEROV, 0) != 0;
  }
  bool mutate_use_nesterov(bool _use_nesterov) {
    return SetField<uint8_t>(VT_USE_NESTEROV, static_cast<uint8_t>(_use_nesterov), 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_USE_LOCKING) &&
           VerifyField<uint8_t>(verifier, VT_USE_NESTEROV) &&
           verifier.EndTable();
  }
  AdamT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(AdamT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Adam> Pack(flatbuffers::FlatBufferBuilder &_fbb, const AdamT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct AdamBuilder {
  typedef Adam Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_use_locking(bool use_locking) {
    fbb_.AddElement<uint8_t>(Adam::VT_USE_LOCKING, static_cast<uint8_t>(use_locking), 0);
  }
  void add_use_nesterov(bool use_nesterov) {
    fbb_.AddElement<uint8_t>(Adam::VT_USE_NESTEROV, static_cast<uint8_t>(use_nesterov), 0);
  }
  explicit AdamBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Adam> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Adam>(end);
    return o;
  }
};

inline flatbuffers::Offset<Adam> CreateAdam(
    flatbuffers::FlatBufferBuilder &_fbb,
    bool use_locking = false,
    bool use_nesterov = false) {
  AdamBuilder builder_(_fbb);
  builder_.add_use_nesterov(use_nesterov);
  builder_.add_use_locking(use_locking);
  return builder_.Finish();
}

flatbuffers::Offset<Adam> CreateAdam(flatbuffers::FlatBufferBuilder &_fbb, const AdamT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct AddFusionT : public flatbuffers::NativeTable {
  typedef AddFusion TableType;
  mindspore::schema::ActivationType activation_type = mindspore::schema::ActivationType_NO_ACTIVATION;
};

struct AddFusion FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef AddFusionT NativeTableType;
  typedef AddFusionBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return AddFusionTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ACTIVATION_TYPE = 4
  };
  mindspore::schema::ActivationType activation_type() const {
    return static_cast<mindspore::schema::ActivationType>(GetField<int8_t>(VT_ACTIVATION_TYPE, 0));
  }
  bool mutate_activation_type(mindspore::schema::ActivationType _activation_type) {
    return SetField<int8_t>(VT_ACTIVATION_TYPE, static_cast<int8_t>(_activation_type), 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_ACTIVATION_TYPE) &&
           verifier.EndTable();
  }
  AddFusionT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(AddFusionT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<AddFusion> Pack(flatbuffers::FlatBufferBuilder &_fbb, const AddFusionT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct AddFusionBuilder {
  typedef AddFusion Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_activation_type(mindspore::schema::ActivationType activation_type) {
    fbb_.AddElement<int8_t>(AddFusion::VT_ACTIVATION_TYPE, static_cast<int8_t>(activation_type), 0);
  }
  explicit AddFusionBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<AddFusion> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<AddFusion>(end);
    return o;
  }
};

inline flatbuffers::Offset<AddFusion> CreateAddFusion(
    flatbuffers::FlatBufferBuilder &_fbb,
    mindspore::schema::ActivationType activation_type = mindspore::schema::ActivationType_NO_ACTIVATION) {
  AddFusionBuilder builder_(_fbb);
  builder_.add_activation_type(activation_type);
  return builder_.Finish();
}

flatbuffers::Offset<AddFusion> CreateAddFusion(flatbuffers::FlatBufferBuilder &_fbb, const AddFusionT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct AdderFusionT : public flatbuffers::NativeTable {
  typedef AdderFusion TableType;
  mindspore::schema::Format format = mindspore::schema::Format_NCHW;
  std::vector<int64_t> kernel_size{};
  std::vector<int64_t> stride{};
  std::vector<int64_t> dilation{};
  mindspore::schema::PadMode pad_mode = mindspore::schema::PadMode_PAD;
  std::vector<int64_t> pad_list{};
  int64_t group = 0;
  int64_t in_channel = 0;
  int64_t out_channel = 0;
  mindspore::schema::ActivationType activation_type = mindspore::schema::ActivationType_NO_ACTIVATION;
};

struct AdderFusion FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef AdderFusionT NativeTableType;
  typedef AdderFusionBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return AdderFusionTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_FORMAT = 4,
    VT_KERNEL_SIZE = 6,
    VT_STRIDE = 8,
    VT_DILATION = 10,
    VT_PAD_MODE = 12,
    VT_PAD_LIST = 14,
    VT_GROUP = 16,
    VT_IN_CHANNEL = 18,
    VT_OUT_CHANNEL = 20,
    VT_ACTIVATION_TYPE = 22
  };
  mindspore::schema::Format format() const {
    return static_cast<mindspore::schema::Format>(GetField<int32_t>(VT_FORMAT, 0));
  }
  bool mutate_format(mindspore::schema::Format _format) {
    return SetField<int32_t>(VT_FORMAT, static_cast<int32_t>(_format), 0);
  }
  const flatbuffers::Vector<int64_t> *kernel_size() const {
    return GetPointer<const flatbuffers::Vector<int64_t> *>(VT_KERNEL_SIZE);
  }
  flatbuffers::Vector<int64_t> *mutable_kernel_size() {
    return GetPointer<flatbuffers::Vector<int64_t> *>(VT_KERNEL_SIZE);
  }
  const flatbuffers::Vector<int64_t> *stride() const {
    return GetPointer<const flatbuffers::Vector<int64_t> *>(VT_STRIDE);
  }
  flatbuffers::Vector<int64_t> *mutable_stride() {
    return GetPointer<flatbuffers::Vector<int64_t> *>(VT_STRIDE);
  }
  const flatbuffers::Vector<int64_t> *dilation() const {
    return GetPointer<const flatbuffers::Vector<int64_t> *>(VT_DILATION);
  }
  flatbuffers::Vector<int64_t> *mutable_dilation() {
    return GetPointer<flatbuffers::Vector<int64_t> *>(VT_DILATION);
  }
  mindspore::schema::PadMode pad_mode() const {
    return static_cast<mindspore::schema::PadMode>(GetField<int8_t>(VT_PAD_MODE, 0));
  }
  bool mutate_pad_mode(mindspore::schema::PadMode _pad_mode) {
    return SetField<int8_t>(VT_PAD_MODE, static_cast<int8_t>(_pad_mode), 0);
  }
  const flatbuffers::Vector<int64_t> *pad_list() const {
    return GetPointer<const flatbuffers::Vector<int64_t> *>(VT_PAD_LIST);
  }
  flatbuffers::Vector<int64_t> *mutable_pad_list() {
    return GetPointer<flatbuffers::Vector<int64_t> *>(VT_PAD_LIST);
  }
  int64_t group() const {
    return GetField<int64_t>(VT_GROUP, 0);
  }
  bool mutate_group(int64_t _group) {
    return SetField<int64_t>(VT_GROUP, _group, 0);
  }
  int64_t in_channel() const {
    return GetField<int64_t>(VT_IN_CHANNEL, 0);
  }
  bool mutate_in_channel(int64_t _in_channel) {
    return SetField<int64_t>(VT_IN_CHANNEL, _in_channel, 0);
  }
  int64_t out_channel() const {
    return GetField<int64_t>(VT_OUT_CHANNEL, 0);
  }
  bool mutate_out_channel(int64_t _out_channel) {
    return SetField<int64_t>(VT_OUT_CHANNEL, _out_channel, 0);
  }
  mindspore::schema::ActivationType activation_type() const {
    return static_cast<mindspore::schema::ActivationType>(GetField<int8_t>(VT_ACTIVATION_TYPE, 0));
  }
  bool mutate_activation_type(mindspore::schema::ActivationType _activation_type) {
    return SetField<int8_t>(VT_ACTIVATION_TYPE, static_cast<int8_t>(_activation_type), 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_FORMAT) &&
           VerifyOffset(verifier, VT_KERNEL_SIZE) &&
           verifier.VerifyVector(kernel_size()) &&
           VerifyOffset(verifier, VT_STRIDE) &&
           verifier.VerifyVector(stride()) &&
           VerifyOffset(verifier, VT_DILATION) &&
           verifier.VerifyVector(dilation()) &&
           VerifyField<int8_t>(verifier, VT_PAD_MODE) &&
           VerifyOffset(verifier, VT_PAD_LIST) &&
           verifier.VerifyVector(pad_list()) &&
           VerifyField<int64_t>(verifier, VT_GROUP) &&
           VerifyField<int64_t>(verifier, VT_IN_CHANNEL) &&
           VerifyField<int64_t>(verifier, VT_OUT_CHANNEL) &&
           VerifyField<int8_t>(verifier, VT_ACTIVATION_TYPE) &&
           verifier.EndTable();
  }
  AdderFusionT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(AdderFusionT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<AdderFusion> Pack(flatbuffers::FlatBufferBuilder &_fbb, const AdderFusionT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct AdderFusionBuilder {
  typedef AdderFusion Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_format(mindspore::schema::Format format) {
    fbb_.AddElement<int32_t>(AdderFusion::VT_FORMAT, static_cast<int32_t>(format), 0);
  }
  void add_kernel_size(flatbuffers::Offset<flatbuffers::Vector<int64_t>> kernel_size) {
    fbb_.AddOffset(AdderFusion::VT_KERNEL_SIZE, kernel_size);
  }
  void add_stride(flatbuffers::Offset<flatbuffers::Vector<int64_t>> stride) {
    fbb_.AddOffset(AdderFusion::VT_STRIDE, stride);
  }
  void add_dilation(flatbuffers::Offset<flatbuffers::Vector<int64_t>> dilation) {
    fbb_.AddOffset(AdderFusion::VT_DILATION, dilation);
  }
  void add_pad_mode(mindspore::schema::PadMode pad_mode) {
    fbb_.AddElement<int8_t>(AdderFusion::VT_PAD_MODE, static_cast<int8_t>(pad_mode), 0);
  }
  void add_pad_list(flatbuffers::Offset<flatbuffers::Vector<int64_t>> pad_list) {
    fbb_.AddOffset(AdderFusion::VT_PAD_LIST, pad_list);
  }
  void add_group(int64_t group) {
    fbb_.AddElement<int64_t>(AdderFusion::VT_GROUP, group, 0);
  }
  void add_in_channel(int64_t in_channel) {
    fbb_.AddElement<int64_t>(AdderFusion::VT_IN_CHANNEL, in_channel, 0);
  }
  void add_out_channel(int64_t out_channel) {
    fbb_.AddElement<int64_t>(AdderFusion::VT_OUT_CHANNEL, out_channel, 0);
  }
  void add_activation_type(mindspore::schema::ActivationType activation_type) {
    fbb_.AddElement<int8_t>(AdderFusion::VT_ACTIVATION_TYPE, static_cast<int8_t>(activation_type), 0);
  }
  explicit AdderFusionBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<AdderFusion> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<AdderFusion>(end);
    return o;
  }
};

inline flatbuffers::Offset<AdderFusion> CreateAdderFusion(
    flatbuffers::FlatBufferBuilder &_fbb,
    mindspore::schema::Format format = mindspore::schema::Format_NCHW,
    flatbuffers::Offset<flatbuffers::Vector<int64_t>> kernel_size = 0,
    flatbuffers::Offset<flatbuffers::Vector<int64_t>> stride = 0,
    flatbuffers::Offset<flatbuffers::Vector<int64_t>> dilation = 0,
    mindspore::schema::PadMode pad_mode = mindspore::schema::PadMode_PAD,
    flatbuffers::Offset<flatbuffers::Vector<int64_t>> pad_list = 0,
    int64_t group = 0,
    int64_t in_channel = 0,
    int64_t out_channel = 0,
    mindspore::schema::ActivationType activation_type = mindspore::schema::ActivationType_NO_ACTIVATION) {
  AdderFusionBuilder builder_(_fbb);
  builder_.add_out_channel(out_channel);
  builder_.add_in_channel(in_channel);
  builder_.add_group(group);
  builder_.add_pad_list(pad_list);
  builder_.add_dilation(dilation);
  builder_.add_stride(stride);
  builder_.add_kernel_size(kernel_size);
  builder_.add_format(format);
  builder_.add_activation_type(activation_type);
  builder_.add_pad_mode(pad_mode);
  return builder_.Finish();
}

inline flatbuffers::Offset<AdderFusion> CreateAdderFusionDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    mindspore::schema::Format format = mindspore::schema::Format_NCHW,
    const std::vector<int64_t> *kernel_size = nullptr,
    const std::vector<int64_t> *stride = nullptr,
    const std::vector<int64_t> *dilation = nullptr,
    mindspore::schema::PadMode pad_mode = mindspore::schema::PadMode_PAD,
    const std::vector<int64_t> *pad_list = nullptr,
    int64_t group = 0,
    int64_t in_channel = 0,
    int64_t out_channel = 0,
    mindspore::schema::ActivationType activation_type = mindspore::schema::ActivationType_NO_ACTIVATION) {
  auto kernel_size__ = kernel_size ? _fbb.CreateVector<int64_t>(*kernel_size) : 0;
  auto stride__ = stride ? _fbb.CreateVector<int64_t>(*stride) : 0;
  auto dilation__ = dilation ? _fbb.CreateVector<int64_t>(*dilation) : 0;
  auto pad_list__ = pad_list ? _fbb.CreateVector<int64_t>(*pad_list) : 0;
  return mindspore::schema::CreateAdderFusion(
      _fbb,
      format,
      kernel_size__,
      stride__,
      dilation__,
      pad_mode,
      pad_list__,
      group,
      in_channel,
      out_channel,
      activation_type);
}

flatbuffers::Offset<AdderFusion> CreateAdderFusion(flatbuffers::FlatBufferBuilder &_fbb, const AdderFusionT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct AddGradT : public flatbuffers::NativeTable {
  typedef AddGrad TableType;
};

struct AddGrad FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef AddGradT NativeTableType;
  typedef AddGradBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return AddGradTypeTable();
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  AddGradT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(AddGradT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<AddGrad> Pack(flatbuffers::FlatBufferBuilder &_fbb, const AddGradT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct AddGradBuilder {
  typedef AddGrad Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit AddGradBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<AddGrad> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<AddGrad>(end);
    return o;
  }
};

inline flatbuffers::Offset<AddGrad> CreateAddGrad(
    flatbuffers::FlatBufferBuilder &_fbb) {
  AddGradBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<AddGrad> CreateAddGrad(flatbuffers::FlatBufferBuilder &_fbb, const AddGradT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct AddNT : public flatbuffers::NativeTable {
  typedef AddN TableType;
};

struct AddN FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef AddNT NativeTableType;
  typedef AddNBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return AddNTypeTable();
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  AddNT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(AddNT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<AddN> Pack(flatbuffers::FlatBufferBuilder &_fbb, const AddNT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct AddNBuilder {
  typedef AddN Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit AddNBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<AddN> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<AddN>(end);
    return o;
  }
};

inline flatbuffers::Offset<AddN> CreateAddN(
    flatbuffers::FlatBufferBuilder &_fbb) {
  AddNBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<AddN> CreateAddN(flatbuffers::FlatBufferBuilder &_fbb, const AddNT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct AllT : public flatbuffers::NativeTable {
  typedef All TableType;
  int64_t keep_dims = 0;
};

struct All FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef AllT NativeTableType;
  typedef AllBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return AllTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_KEEP_DIMS = 4
  };
  int64_t keep_dims() const {
    return GetField<int64_t>(VT_KEEP_DIMS, 0);
  }
  bool mutate_keep_dims(int64_t _keep_dims) {
    return SetField<int64_t>(VT_KEEP_DIMS, _keep_dims, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_KEEP_DIMS) &&
           verifier.EndTable();
  }
  AllT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(AllT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<All> Pack(flatbuffers::FlatBufferBuilder &_fbb, const AllT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct AllBuilder {
  typedef All Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_keep_dims(int64_t keep_dims) {
    fbb_.AddElement<int64_t>(All::VT_KEEP_DIMS, keep_dims, 0);
  }
  explicit AllBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<All> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<All>(end);
    return o;
  }
};

inline flatbuffers::Offset<All> CreateAll(
    flatbuffers::FlatBufferBuilder &_fbb,
    int64_t keep_dims = 0) {
  AllBuilder builder_(_fbb);
  builder_.add_keep_dims(keep_dims);
  return builder_.Finish();
}

flatbuffers::Offset<All> CreateAll(flatbuffers::FlatBufferBuilder &_fbb, const AllT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ApplyMomentumT : public flatbuffers::NativeTable {
  typedef ApplyMomentum TableType;
  bool use_nesterov = false;
  bool use_locking = false;
  float gradient_scale = 0.0f;
};

struct ApplyMomentum FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ApplyMomentumT NativeTableType;
  typedef ApplyMomentumBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return ApplyMomentumTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_USE_NESTEROV = 4,
    VT_USE_LOCKING = 6,
    VT_GRADIENT_SCALE = 8
  };
  bool use_nesterov() const {
    return GetField<uint8_t>(VT_USE_NESTEROV, 0) != 0;
  }
  bool mutate_use_nesterov(bool _use_nesterov) {
    return SetField<uint8_t>(VT_USE_NESTEROV, static_cast<uint8_t>(_use_nesterov), 0);
  }
  bool use_locking() const {
    return GetField<uint8_t>(VT_USE_LOCKING, 0) != 0;
  }
  bool mutate_use_locking(bool _use_locking) {
    return SetField<uint8_t>(VT_USE_LOCKING, static_cast<uint8_t>(_use_locking), 0);
  }
  float gradient_scale() const {
    return GetField<float>(VT_GRADIENT_SCALE, 0.0f);
  }
  bool mutate_gradient_scale(float _gradient_scale) {
    return SetField<float>(VT_GRADIENT_SCALE, _gradient_scale, 0.0f);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_USE_NESTEROV) &&
           VerifyField<uint8_t>(verifier, VT_USE_LOCKING) &&
           VerifyField<float>(verifier, VT_GRADIENT_SCALE) &&
           verifier.EndTable();
  }
  ApplyMomentumT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ApplyMomentumT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<ApplyMomentum> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ApplyMomentumT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ApplyMomentumBuilder {
  typedef ApplyMomentum Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_use_nesterov(bool use_nesterov) {
    fbb_.AddElement<uint8_t>(ApplyMomentum::VT_USE_NESTEROV, static_cast<uint8_t>(use_nesterov), 0);
  }
  void add_use_locking(bool use_locking) {
    fbb_.AddElement<uint8_t>(ApplyMomentum::VT_USE_LOCKING, static_cast<uint8_t>(use_locking), 0);
  }
  void add_gradient_scale(float gradient_scale) {
    fbb_.AddElement<float>(ApplyMomentum::VT_GRADIENT_SCALE, gradient_scale, 0.0f);
  }
  explicit ApplyMomentumBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<ApplyMomentum> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ApplyMomentum>(end);
    return o;
  }
};

inline flatbuffers::Offset<ApplyMomentum> CreateApplyMomentum(
    flatbuffers::FlatBufferBuilder &_fbb,
    bool use_nesterov = false,
    bool use_locking = false,
    float gradient_scale = 0.0f) {
  ApplyMomentumBuilder builder_(_fbb);
  builder_.add_gradient_scale(gradient_scale);
  builder_.add_use_locking(use_locking);
  builder_.add_use_nesterov(use_nesterov);
  return builder_.Finish();
}

flatbuffers::Offset<ApplyMomentum> CreateApplyMomentum(flatbuffers::FlatBufferBuilder &_fbb, const ApplyMomentumT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ArgMaxFusionT : public flatbuffers::NativeTable {
  typedef ArgMaxFusion TableType;
  int64_t axis = 0;
  int64_t top_k = 1LL;
  bool keep_dims = false;
  bool out_max_value = false;
};

struct ArgMaxFusion FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ArgMaxFusionT NativeTableType;
  typedef ArgMaxFusionBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return ArgMaxFusionTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_AXIS = 4,
    VT_TOP_K = 6,
    VT_KEEP_DIMS = 8,
    VT_OUT_MAX_VALUE = 10
  };
  int64_t axis() const {
    return GetField<int64_t>(VT_AXIS, 0);
  }
  bool mutate_axis(int64_t _axis) {
    return SetField<int64_t>(VT_AXIS, _axis, 0);
  }
  int64_t top_k() const {
    return GetField<int64_t>(VT_TOP_K, 1LL);
  }
  bool mutate_top_k(int64_t _top_k) {
    return SetField<int64_t>(VT_TOP_K, _top_k, 1LL);
  }
  bool keep_dims() const {
    return GetField<uint8_t>(VT_KEEP_DIMS, 0) != 0;
  }
  bool mutate_keep_dims(bool _keep_dims) {
    return SetField<uint8_t>(VT_KEEP_DIMS, static_cast<uint8_t>(_keep_dims), 0);
  }
  bool out_max_value() const {
    return GetField<uint8_t>(VT_OUT_MAX_VALUE, 0) != 0;
  }
  bool mutate_out_max_value(bool _out_max_value) {
    return SetField<uint8_t>(VT_OUT_MAX_VALUE, static_cast<uint8_t>(_out_max_value), 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_AXIS) &&
           VerifyField<int64_t>(verifier, VT_TOP_K) &&
           VerifyField<uint8_t>(verifier, VT_KEEP_DIMS) &&
           VerifyField<uint8_t>(verifier, VT_OUT_MAX_VALUE) &&
           verifier.EndTable();
  }
  ArgMaxFusionT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ArgMaxFusionT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<ArgMaxFusion> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ArgMaxFusionT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ArgMaxFusionBuilder {
  typedef ArgMaxFusion Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_axis(int64_t axis) {
    fbb_.AddElement<int64_t>(ArgMaxFusion::VT_AXIS, axis, 0);
  }
  void add_top_k(int64_t top_k) {
    fbb_.AddElement<int64_t>(ArgMaxFusion::VT_TOP_K, top_k, 1LL);
  }
  void add_keep_dims(bool keep_dims) {
    fbb_.AddElement<uint8_t>(ArgMaxFusion::VT_KEEP_DIMS, static_cast<uint8_t>(keep_dims), 0);
  }
  void add_out_max_value(bool out_max_value) {
    fbb_.AddElement<uint8_t>(ArgMaxFusion::VT_OUT_MAX_VALUE, static_cast<uint8_t>(out_max_value), 0);
  }
  explicit ArgMaxFusionBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<ArgMaxFusion> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ArgMaxFusion>(end);
    return o;
  }
};

inline flatbuffers::Offset<ArgMaxFusion> CreateArgMaxFusion(
    flatbuffers::FlatBufferBuilder &_fbb,
    int64_t axis = 0,
    int64_t top_k = 1LL,
    bool keep_dims = false,
    bool out_max_value = false) {
  ArgMaxFusionBuilder builder_(_fbb);
  builder_.add_top_k(top_k);
  builder_.add_axis(axis);
  builder_.add_out_max_value(out_max_value);
  builder_.add_keep_dims(keep_dims);
  return builder_.Finish();
}

flatbuffers::Offset<ArgMaxFusion> CreateArgMaxFusion(flatbuffers::FlatBufferBuilder &_fbb, const ArgMaxFusionT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ArgMinFusionT : public flatbuffers::NativeTable {
  typedef ArgMinFusion TableType;
  int64_t axis = 0;
  int64_t top_k = 0;
  bool keep_dims = false;
  bool out_max_value = false;
};

struct ArgMinFusion FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ArgMinFusionT NativeTableType;
  typedef ArgMinFusionBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return ArgMinFusionTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_AXIS = 4,
    VT_TOP_K = 6,
    VT_KEEP_DIMS = 8,
    VT_OUT_MAX_VALUE = 10
  };
  int64_t axis() const {
    return GetField<int64_t>(VT_AXIS, 0);
  }
  bool mutate_axis(int64_t _axis) {
    return SetField<int64_t>(VT_AXIS, _axis, 0);
  }
  int64_t top_k() const {
    return GetField<int64_t>(VT_TOP_K, 0);
  }
  bool mutate_top_k(int64_t _top_k) {
    return SetField<int64_t>(VT_TOP_K, _top_k, 0);
  }
  bool keep_dims() const {
    return GetField<uint8_t>(VT_KEEP_DIMS, 0) != 0;
  }
  bool mutate_keep_dims(bool _keep_dims) {
    return SetField<uint8_t>(VT_KEEP_DIMS, static_cast<uint8_t>(_keep_dims), 0);
  }
  bool out_max_value() const {
    return GetField<uint8_t>(VT_OUT_MAX_VALUE, 0) != 0;
  }
  bool mutate_out_max_value(bool _out_max_value) {
    return SetField<uint8_t>(VT_OUT_MAX_VALUE, static_cast<uint8_t>(_out_max_value), 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_AXIS) &&
           VerifyField<int64_t>(verifier, VT_TOP_K) &&
           VerifyField<uint8_t>(verifier, VT_KEEP_DIMS) &&
           VerifyField<uint8_t>(verifier, VT_OUT_MAX_VALUE) &&
           verifier.EndTable();
  }
  ArgMinFusionT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ArgMinFusionT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<ArgMinFusion> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ArgMinFusionT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ArgMinFusionBuilder {
  typedef ArgMinFusion Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_axis(int64_t axis) {
    fbb_.AddElement<int64_t>(ArgMinFusion::VT_AXIS, axis, 0);
  }
  void add_top_k(int64_t top_k) {
    fbb_.AddElement<int64_t>(ArgMinFusion::VT_TOP_K, top_k, 0);
  }
  void add_keep_dims(bool keep_dims) {
    fbb_.AddElement<uint8_t>(ArgMinFusion::VT_KEEP_DIMS, static_cast<uint8_t>(keep_dims), 0);
  }
  void add_out_max_value(bool out_max_value) {
    fbb_.AddElement<uint8_t>(ArgMinFusion::VT_OUT_MAX_VALUE, static_cast<uint8_t>(out_max_value), 0);
  }
  explicit ArgMinFusionBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<ArgMinFusion> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ArgMinFusion>(end);
    return o;
  }
};

inline flatbuffers::Offset<ArgMinFusion> CreateArgMinFusion(
    flatbuffers::FlatBufferBuilder &_fbb,
    int64_t axis = 0,
    int64_t top_k = 0,
    bool keep_dims = false,
    bool out_max_value = false) {
  ArgMinFusionBuilder builder_(_fbb);
  builder_.add_top_k(top_k);
  builder_.add_axis(axis);
  builder_.add_out_max_value(out_max_value);
  builder_.add_keep_dims(keep_dims);
  return builder_.Finish();
}

flatbuffers::Offset<ArgMinFusion> CreateArgMinFusion(flatbuffers::FlatBufferBuilder &_fbb, const ArgMinFusionT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct AssertT : public flatbuffers::NativeTable {
  typedef Assert TableType;
  int64_t summarize = 0;
};

struct Assert FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef AssertT NativeTableType;
  typedef AssertBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return AssertTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SUMMARIZE = 4
  };
  int64_t summarize() const {
    return GetField<int64_t>(VT_SUMMARIZE, 0);
  }
  bool mutate_summarize(int64_t _summarize) {
    return SetField<int64_t>(VT_SUMMARIZE, _summarize, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_SUMMARIZE) &&
           verifier.EndTable();
  }
  AssertT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(AssertT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Assert> Pack(flatbuffers::FlatBufferBuilder &_fbb, const AssertT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct AssertBuilder {
  typedef Assert Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_summarize(int64_t summarize) {
    fbb_.AddElement<int64_t>(Assert::VT_SUMMARIZE, summarize, 0);
  }
  explicit AssertBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Assert> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Assert>(end);
    return o;
  }
};

inline flatbuffers::Offset<Assert> CreateAssert(
    flatbuffers::FlatBufferBuilder &_fbb,
    int64_t summarize = 0) {
  AssertBuilder builder_(_fbb);
  builder_.add_summarize(summarize);
  return builder_.Finish();
}

flatbuffers::Offset<Assert> CreateAssert(flatbuffers::FlatBufferBuilder &_fbb, const AssertT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct AssignT : public flatbuffers::NativeTable {
  typedef Assign TableType;
};

struct Assign FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef AssignT NativeTableType;
  typedef AssignBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return AssignTypeTable();
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  AssignT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(AssignT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Assign> Pack(flatbuffers::FlatBufferBuilder &_fbb, const AssignT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct AssignBuilder {
  typedef Assign Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit AssignBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Assign> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Assign>(end);
    return o;
  }
};

inline flatbuffers::Offset<Assign> CreateAssign(
    flatbuffers::FlatBufferBuilder &_fbb) {
  AssignBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<Assign> CreateAssign(flatbuffers::FlatBufferBuilder &_fbb, const AssignT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct AssignAddT : public flatbuffers::NativeTable {
  typedef AssignAdd TableType;
};

struct AssignAdd FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef AssignAddT NativeTableType;
  typedef AssignAddBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return AssignAddTypeTable();
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  AssignAddT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(AssignAddT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<AssignAdd> Pack(flatbuffers::FlatBufferBuilder &_fbb, const AssignAddT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct AssignAddBuilder {
  typedef AssignAdd Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit AssignAddBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<AssignAdd> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<AssignAdd>(end);
    return o;
  }
};

inline flatbuffers::Offset<AssignAdd> CreateAssignAdd(
    flatbuffers::FlatBufferBuilder &_fbb) {
  AssignAddBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<AssignAdd> CreateAssignAdd(flatbuffers::FlatBufferBuilder &_fbb, const AssignAddT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct AudioSpectrogramT : public flatbuffers::NativeTable {
  typedef AudioSpectrogram TableType;
  int64_t window_size = 0;
  int64_t stride = 0;
  bool mag_square = false;
};

struct AudioSpectrogram FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef AudioSpectrogramT NativeTableType;
  typedef AudioSpectrogramBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return AudioSpectrogramTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_WINDOW_SIZE = 4,
    VT_STRIDE = 6,
    VT_MAG_SQUARE = 8
  };
  int64_t window_size() const {
    return GetField<int64_t>(VT_WINDOW_SIZE, 0);
  }
  bool mutate_window_size(int64_t _window_size) {
    return SetField<int64_t>(VT_WINDOW_SIZE, _window_size, 0);
  }
  int64_t stride() const {
    return GetField<int64_t>(VT_STRIDE, 0);
  }
  bool mutate_stride(int64_t _stride) {
    return SetField<int64_t>(VT_STRIDE, _stride, 0);
  }
  bool mag_square() const {
    return GetField<uint8_t>(VT_MAG_SQUARE, 0) != 0;
  }
  bool mutate_mag_square(bool _mag_square) {
    return SetField<uint8_t>(VT_MAG_SQUARE, static_cast<uint8_t>(_mag_square), 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_WINDOW_SIZE) &&
           VerifyField<int64_t>(verifier, VT_STRIDE) &&
           VerifyField<uint8_t>(verifier, VT_MAG_SQUARE) &&
           verifier.EndTable();
  }
  AudioSpectrogramT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(AudioSpectrogramT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<AudioSpectrogram> Pack(flatbuffers::FlatBufferBuilder &_fbb, const AudioSpectrogramT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct AudioSpectrogramBuilder {
  typedef AudioSpectrogram Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_window_size(int64_t window_size) {
    fbb_.AddElement<int64_t>(AudioSpectrogram::VT_WINDOW_SIZE, window_size, 0);
  }
  void add_stride(int64_t stride) {
    fbb_.AddElement<int64_t>(AudioSpectrogram::VT_STRIDE, stride, 0);
  }
  void add_mag_square(bool mag_square) {
    fbb_.AddElement<uint8_t>(AudioSpectrogram::VT_MAG_SQUARE, static_cast<uint8_t>(mag_square), 0);
  }
  explicit AudioSpectrogramBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<AudioSpectrogram> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<AudioSpectrogram>(end);
    return o;
  }
};

inline flatbuffers::Offset<AudioSpectrogram> CreateAudioSpectrogram(
    flatbuffers::FlatBufferBuilder &_fbb,
    int64_t window_size = 0,
    int64_t stride = 0,
    bool mag_square = false) {
  AudioSpectrogramBuilder builder_(_fbb);
  builder_.add_stride(stride);
  builder_.add_window_size(window_size);
  builder_.add_mag_square(mag_square);
  return builder_.Finish();
}

flatbuffers::Offset<AudioSpectrogram> CreateAudioSpectrogram(flatbuffers::FlatBufferBuilder &_fbb, const AudioSpectrogramT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct AvgPoolFusionT : public flatbuffers::NativeTable {
  typedef AvgPoolFusion TableType;
  std::vector<int64_t> kernel_size{};
  std::vector<int64_t> strides{};
  std::vector<int64_t> pad{};
  mindspore::schema::PadMode pad_mode = mindspore::schema::PadMode_PAD;
  mindspore::schema::RoundMode round_mode = mindspore::schema::RoundMode_FLOOR;
  mindspore::schema::Format format = mindspore::schema::Format_NCHW;
  bool global = false;
  mindspore::schema::ActivationType activation_type = mindspore::schema::ActivationType_NO_ACTIVATION;
};

struct AvgPoolFusion FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef AvgPoolFusionT NativeTableType;
  typedef AvgPoolFusionBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return AvgPoolFusionTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_KERNEL_SIZE = 4,
    VT_STRIDES = 6,
    VT_PAD = 8,
    VT_PAD_MODE = 10,
    VT_ROUND_MODE = 12,
    VT_FORMAT = 14,
    VT_GLOBAL = 16,
    VT_ACTIVATION_TYPE = 18
  };
  const flatbuffers::Vector<int64_t> *kernel_size() const {
    return GetPointer<const flatbuffers::Vector<int64_t> *>(VT_KERNEL_SIZE);
  }
  flatbuffers::Vector<int64_t> *mutable_kernel_size() {
    return GetPointer<flatbuffers::Vector<int64_t> *>(VT_KERNEL_SIZE);
  }
  const flatbuffers::Vector<int64_t> *strides() const {
    return GetPointer<const flatbuffers::Vector<int64_t> *>(VT_STRIDES);
  }
  flatbuffers::Vector<int64_t> *mutable_strides() {
    return GetPointer<flatbuffers::Vector<int64_t> *>(VT_STRIDES);
  }
  const flatbuffers::Vector<int64_t> *pad() const {
    return GetPointer<const flatbuffers::Vector<int64_t> *>(VT_PAD);
  }
  flatbuffers::Vector<int64_t> *mutable_pad() {
    return GetPointer<flatbuffers::Vector<int64_t> *>(VT_PAD);
  }
  mindspore::schema::PadMode pad_mode() const {
    return static_cast<mindspore::schema::PadMode>(GetField<int8_t>(VT_PAD_MODE, 0));
  }
  bool mutate_pad_mode(mindspore::schema::PadMode _pad_mode) {
    return SetField<int8_t>(VT_PAD_MODE, static_cast<int8_t>(_pad_mode), 0);
  }
  mindspore::schema::RoundMode round_mode() const {
    return static_cast<mindspore::schema::RoundMode>(GetField<int8_t>(VT_ROUND_MODE, 0));
  }
  bool mutate_round_mode(mindspore::schema::RoundMode _round_mode) {
    return SetField<int8_t>(VT_ROUND_MODE, static_cast<int8_t>(_round_mode), 0);
  }
  mindspore::schema::Format format() const {
    return static_cast<mindspore::schema::Format>(GetField<int32_t>(VT_FORMAT, 0));
  }
  bool mutate_format(mindspore::schema::Format _format) {
    return SetField<int32_t>(VT_FORMAT, static_cast<int32_t>(_format), 0);
  }
  bool global() const {
    return GetField<uint8_t>(VT_GLOBAL, 0) != 0;
  }
  bool mutate_global(bool _global) {
    return SetField<uint8_t>(VT_GLOBAL, static_cast<uint8_t>(_global), 0);
  }
  mindspore::schema::ActivationType activation_type() const {
    return static_cast<mindspore::schema::ActivationType>(GetField<int8_t>(VT_ACTIVATION_TYPE, 0));
  }
  bool mutate_activation_type(mindspore::schema::ActivationType _activation_type) {
    return SetField<int8_t>(VT_ACTIVATION_TYPE, static_cast<int8_t>(_activation_type), 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_KERNEL_SIZE) &&
           verifier.VerifyVector(kernel_size()) &&
           VerifyOffset(verifier, VT_STRIDES) &&
           verifier.VerifyVector(strides()) &&
           VerifyOffset(verifier, VT_PAD) &&
           verifier.VerifyVector(pad()) &&
           VerifyField<int8_t>(verifier, VT_PAD_MODE) &&
           VerifyField<int8_t>(verifier, VT_ROUND_MODE) &&
           VerifyField<int32_t>(verifier, VT_FORMAT) &&
           VerifyField<uint8_t>(verifier, VT_GLOBAL) &&
           VerifyField<int8_t>(verifier, VT_ACTIVATION_TYPE) &&
           verifier.EndTable();
  }
  AvgPoolFusionT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(AvgPoolFusionT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<AvgPoolFusion> Pack(flatbuffers::FlatBufferBuilder &_fbb, const AvgPoolFusionT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct AvgPoolFusionBuilder {
  typedef AvgPoolFusion Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_kernel_size(flatbuffers::Offset<flatbuffers::Vector<int64_t>> kernel_size) {
    fbb_.AddOffset(AvgPoolFusion::VT_KERNEL_SIZE, kernel_size);
  }
  void add_strides(flatbuffers::Offset<flatbuffers::Vector<int64_t>> strides) {
    fbb_.AddOffset(AvgPoolFusion::VT_STRIDES, strides);
  }
  void add_pad(flatbuffers::Offset<flatbuffers::Vector<int64_t>> pad) {
    fbb_.AddOffset(AvgPoolFusion::VT_PAD, pad);
  }
  void add_pad_mode(mindspore::schema::PadMode pad_mode) {
    fbb_.AddElement<int8_t>(AvgPoolFusion::VT_PAD_MODE, static_cast<int8_t>(pad_mode), 0);
  }
  void add_round_mode(mindspore::schema::RoundMode round_mode) {
    fbb_.AddElement<int8_t>(AvgPoolFusion::VT_ROUND_MODE, static_cast<int8_t>(round_mode), 0);
  }
  void add_format(mindspore::schema::Format format) {
    fbb_.AddElement<int32_t>(AvgPoolFusion::VT_FORMAT, static_cast<int32_t>(format), 0);
  }
  void add_global(bool global) {
    fbb_.AddElement<uint8_t>(AvgPoolFusion::VT_GLOBAL, static_cast<uint8_t>(global), 0);
  }
  void add_activation_type(mindspore::schema::ActivationType activation_type) {
    fbb_.AddElement<int8_t>(AvgPoolFusion::VT_ACTIVATION_TYPE, static_cast<int8_t>(activation_type), 0);
  }
  explicit AvgPoolFusionBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<AvgPoolFusion> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<AvgPoolFusion>(end);
    return o;
  }
};

inline flatbuffers::Offset<AvgPoolFusion> CreateAvgPoolFusion(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<int64_t>> kernel_size = 0,
    flatbuffers::Offset<flatbuffers::Vector<int64_t>> strides = 0,
    flatbuffers::Offset<flatbuffers::Vector<int64_t>> pad = 0,
    mindspore::schema::PadMode pad_mode = mindspore::schema::PadMode_PAD,
    mindspore::schema::RoundMode round_mode = mindspore::schema::RoundMode_FLOOR,
    mindspore::schema::Format format = mindspore::schema::Format_NCHW,
    bool global = false,
    mindspore::schema::ActivationType activation_type = mindspore::schema::ActivationType_NO_ACTIVATION) {
  AvgPoolFusionBuilder builder_(_fbb);
  builder_.add_format(format);
  builder_.add_pad(pad);
  builder_.add_strides(strides);
  builder_.add_kernel_size(kernel_size);
  builder_.add_activation_type(activation_type);
  builder_.add_global(global);
  builder_.add_round_mode(round_mode);
  builder_.add_pad_mode(pad_mode);
  return builder_.Finish();
}

inline flatbuffers::Offset<AvgPoolFusion> CreateAvgPoolFusionDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<int64_t> *kernel_size = nullptr,
    const std::vector<int64_t> *strides = nullptr,
    const std::vector<int64_t> *pad = nullptr,
    mindspore::schema::PadMode pad_mode = mindspore::schema::PadMode_PAD,
    mindspore::schema::RoundMode round_mode = mindspore::schema::RoundMode_FLOOR,
    mindspore::schema::Format format = mindspore::schema::Format_NCHW,
    bool global = false,
    mindspore::schema::ActivationType activation_type = mindspore::schema::ActivationType_NO_ACTIVATION) {
  auto kernel_size__ = kernel_size ? _fbb.CreateVector<int64_t>(*kernel_size) : 0;
  auto strides__ = strides ? _fbb.CreateVector<int64_t>(*strides) : 0;
  auto pad__ = pad ? _fbb.CreateVector<int64_t>(*pad) : 0;
  return mindspore::schema::CreateAvgPoolFusion(
      _fbb,
      kernel_size__,
      strides__,
      pad__,
      pad_mode,
      round_mode,
      format,
      global,
      activation_type);
}

flatbuffers::Offset<AvgPoolFusion> CreateAvgPoolFusion(flatbuffers::FlatBufferBuilder &_fbb, const AvgPoolFusionT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct AvgPoolGradT : public flatbuffers::NativeTable {
  typedef AvgPoolGrad TableType;
  std::vector<int64_t> kernel_size{};
  std::vector<int64_t> strides{};
  mindspore::schema::PadMode pad_mode = mindspore::schema::PadMode_PAD;
  mindspore::schema::Format format = mindspore::schema::Format_NCHW;
};

struct AvgPoolGrad FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef AvgPoolGradT NativeTableType;
  typedef AvgPoolGradBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return AvgPoolGradTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_KERNEL_SIZE = 4,
    VT_STRIDES = 6,
    VT_PAD_MODE = 8,
    VT_FORMAT = 10
  };
  const flatbuffers::Vector<int64_t> *kernel_size() const {
    return GetPointer<const flatbuffers::Vector<int64_t> *>(VT_KERNEL_SIZE);
  }
  flatbuffers::Vector<int64_t> *mutable_kernel_size() {
    return GetPointer<flatbuffers::Vector<int64_t> *>(VT_KERNEL_SIZE);
  }
  const flatbuffers::Vector<int64_t> *strides() const {
    return GetPointer<const flatbuffers::Vector<int64_t> *>(VT_STRIDES);
  }
  flatbuffers::Vector<int64_t> *mutable_strides() {
    return GetPointer<flatbuffers::Vector<int64_t> *>(VT_STRIDES);
  }
  mindspore::schema::PadMode pad_mode() const {
    return static_cast<mindspore::schema::PadMode>(GetField<int8_t>(VT_PAD_MODE, 0));
  }
  bool mutate_pad_mode(mindspore::schema::PadMode _pad_mode) {
    return SetField<int8_t>(VT_PAD_MODE, static_cast<int8_t>(_pad_mode), 0);
  }
  mindspore::schema::Format format() const {
    return static_cast<mindspore::schema::Format>(GetField<int32_t>(VT_FORMAT, 0));
  }
  bool mutate_format(mindspore::schema::Format _format) {
    return SetField<int32_t>(VT_FORMAT, static_cast<int32_t>(_format), 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_KERNEL_SIZE) &&
           verifier.VerifyVector(kernel_size()) &&
           VerifyOffset(verifier, VT_STRIDES) &&
           verifier.VerifyVector(strides()) &&
           VerifyField<int8_t>(verifier, VT_PAD_MODE) &&
           VerifyField<int32_t>(verifier, VT_FORMAT) &&
           verifier.EndTable();
  }
  AvgPoolGradT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(AvgPoolGradT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<AvgPoolGrad> Pack(flatbuffers::FlatBufferBuilder &_fbb, const AvgPoolGradT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct AvgPoolGradBuilder {
  typedef AvgPoolGrad Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_kernel_size(flatbuffers::Offset<flatbuffers::Vector<int64_t>> kernel_size) {
    fbb_.AddOffset(AvgPoolGrad::VT_KERNEL_SIZE, kernel_size);
  }
  void add_strides(flatbuffers::Offset<flatbuffers::Vector<int64_t>> strides) {
    fbb_.AddOffset(AvgPoolGrad::VT_STRIDES, strides);
  }
  void add_pad_mode(mindspore::schema::PadMode pad_mode) {
    fbb_.AddElement<int8_t>(AvgPoolGrad::VT_PAD_MODE, static_cast<int8_t>(pad_mode), 0);
  }
  void add_format(mindspore::schema::Format format) {
    fbb_.AddElement<int32_t>(AvgPoolGrad::VT_FORMAT, static_cast<int32_t>(format), 0);
  }
  explicit AvgPoolGradBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<AvgPoolGrad> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<AvgPoolGrad>(end);
    return o;
  }
};

inline flatbuffers::Offset<AvgPoolGrad> CreateAvgPoolGrad(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<int64_t>> kernel_size = 0,
    flatbuffers::Offset<flatbuffers::Vector<int64_t>> strides = 0,
    mindspore::schema::PadMode pad_mode = mindspore::schema::PadMode_PAD,
    mindspore::schema::Format format = mindspore::schema::Format_NCHW) {
  AvgPoolGradBuilder builder_(_fbb);
  builder_.add_format(format);
  builder_.add_strides(strides);
  builder_.add_kernel_size(kernel_size);
  builder_.add_pad_mode(pad_mode);
  return builder_.Finish();
}

inline flatbuffers::Offset<AvgPoolGrad> CreateAvgPoolGradDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<int64_t> *kernel_size = nullptr,
    const std::vector<int64_t> *strides = nullptr,
    mindspore::schema::PadMode pad_mode = mindspore::schema::PadMode_PAD,
    mindspore::schema::Format format = mindspore::schema::Format_NCHW) {
  auto kernel_size__ = kernel_size ? _fbb.CreateVector<int64_t>(*kernel_size) : 0;
  auto strides__ = strides ? _fbb.CreateVector<int64_t>(*strides) : 0;
  return mindspore::schema::CreateAvgPoolGrad(
      _fbb,
      kernel_size__,
      strides__,
      pad_mode,
      format);
}

flatbuffers::Offset<AvgPoolGrad> CreateAvgPoolGrad(flatbuffers::FlatBufferBuilder &_fbb, const AvgPoolGradT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct BatchNormT : public flatbuffers::NativeTable {
  typedef BatchNorm TableType;
  float epsilon = 0.0f;
  mindspore::schema::Format format = mindspore::schema::Format_NCHW;
  bool is_training = false;
};

struct BatchNorm FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef BatchNormT NativeTableType;
  typedef BatchNormBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return BatchNormTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_EPSILON = 4,
    VT_FORMAT = 6,
    VT_IS_TRAINING = 8
  };
  float epsilon() const {
    return GetField<float>(VT_EPSILON, 0.0f);
  }
  bool mutate_epsilon(float _epsilon) {
    return SetField<float>(VT_EPSILON, _epsilon, 0.0f);
  }
  mindspore::schema::Format format() const {
    return static_cast<mindspore::schema::Format>(GetField<int32_t>(VT_FORMAT, 0));
  }
  bool mutate_format(mindspore::schema::Format _format) {
    return SetField<int32_t>(VT_FORMAT, static_cast<int32_t>(_format), 0);
  }
  bool is_training() const {
    return GetField<uint8_t>(VT_IS_TRAINING, 0) != 0;
  }
  bool mutate_is_training(bool _is_training) {
    return SetField<uint8_t>(VT_IS_TRAINING, static_cast<uint8_t>(_is_training), 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<float>(verifier, VT_EPSILON) &&
           VerifyField<int32_t>(verifier, VT_FORMAT) &&
           VerifyField<uint8_t>(verifier, VT_IS_TRAINING) &&
           verifier.EndTable();
  }
  BatchNormT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(BatchNormT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<BatchNorm> Pack(flatbuffers::FlatBufferBuilder &_fbb, const BatchNormT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct BatchNormBuilder {
  typedef BatchNorm Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_epsilon(float epsilon) {
    fbb_.AddElement<float>(BatchNorm::VT_EPSILON, epsilon, 0.0f);
  }
  void add_format(mindspore::schema::Format format) {
    fbb_.AddElement<int32_t>(BatchNorm::VT_FORMAT, static_cast<int32_t>(format), 0);
  }
  void add_is_training(bool is_training) {
    fbb_.AddElement<uint8_t>(BatchNorm::VT_IS_TRAINING, static_cast<uint8_t>(is_training), 0);
  }
  explicit BatchNormBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<BatchNorm> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<BatchNorm>(end);
    return o;
  }
};

inline flatbuffers::Offset<BatchNorm> CreateBatchNorm(
    flatbuffers::FlatBufferBuilder &_fbb,
    float epsilon = 0.0f,
    mindspore::schema::Format format = mindspore::schema::Format_NCHW,
    bool is_training = false) {
  BatchNormBuilder builder_(_fbb);
  builder_.add_format(format);
  builder_.add_epsilon(epsilon);
  builder_.add_is_training(is_training);
  return builder_.Finish();
}

flatbuffers::Offset<BatchNorm> CreateBatchNorm(flatbuffers::FlatBufferBuilder &_fbb, const BatchNormT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct BatchNormGradT : public flatbuffers::NativeTable {
  typedef BatchNormGrad TableType;
  float epsilon = 0.0f;
};

struct BatchNormGrad FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef BatchNormGradT NativeTableType;
  typedef BatchNormGradBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return BatchNormGradTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_EPSILON = 4
  };
  float epsilon() const {
    return GetField<float>(VT_EPSILON, 0.0f);
  }
  bool mutate_epsilon(float _epsilon) {
    return SetField<float>(VT_EPSILON, _epsilon, 0.0f);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<float>(verifier, VT_EPSILON) &&
           verifier.EndTable();
  }
  BatchNormGradT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(BatchNormGradT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<BatchNormGrad> Pack(flatbuffers::FlatBufferBuilder &_fbb, const BatchNormGradT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct BatchNormGradBuilder {
  typedef BatchNormGrad Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_epsilon(float epsilon) {
    fbb_.AddElement<float>(BatchNormGrad::VT_EPSILON, epsilon, 0.0f);
  }
  explicit BatchNormGradBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<BatchNormGrad> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<BatchNormGrad>(end);
    return o;
  }
};

inline flatbuffers::Offset<BatchNormGrad> CreateBatchNormGrad(
    flatbuffers::FlatBufferBuilder &_fbb,
    float epsilon = 0.0f) {
  BatchNormGradBuilder builder_(_fbb);
  builder_.add_epsilon(epsilon);
  return builder_.Finish();
}

flatbuffers::Offset<BatchNormGrad> CreateBatchNormGrad(flatbuffers::FlatBufferBuilder &_fbb, const BatchNormGradT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct BatchToSpaceT : public flatbuffers::NativeTable {
  typedef BatchToSpace TableType;
  std::vector<int64_t> block_size{};
  std::unique_ptr<mindspore::schema::Vec2DT> crops{};
};

struct BatchToSpace FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef BatchToSpaceT NativeTableType;
  typedef BatchToSpaceBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return BatchToSpaceTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_BLOCK_SIZE = 4,
    VT_CROPS = 6
  };
  const flatbuffers::Vector<int64_t> *block_size() const {
    return GetPointer<const flatbuffers::Vector<int64_t> *>(VT_BLOCK_SIZE);
  }
  flatbuffers::Vector<int64_t> *mutable_block_size() {
    return GetPointer<flatbuffers::Vector<int64_t> *>(VT_BLOCK_SIZE);
  }
  const mindspore::schema::Vec2D *crops() const {
    return GetPointer<const mindspore::schema::Vec2D *>(VT_CROPS);
  }
  mindspore::schema::Vec2D *mutable_crops() {
    return GetPointer<mindspore::schema::Vec2D *>(VT_CROPS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_BLOCK_SIZE) &&
           verifier.VerifyVector(block_size()) &&
           VerifyOffset(verifier, VT_CROPS) &&
           verifier.VerifyTable(crops()) &&
           verifier.EndTable();
  }
  BatchToSpaceT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(BatchToSpaceT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<BatchToSpace> Pack(flatbuffers::FlatBufferBuilder &_fbb, const BatchToSpaceT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct BatchToSpaceBuilder {
  typedef BatchToSpace Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_block_size(flatbuffers::Offset<flatbuffers::Vector<int64_t>> block_size) {
    fbb_.AddOffset(BatchToSpace::VT_BLOCK_SIZE, block_size);
  }
  void add_crops(flatbuffers::Offset<mindspore::schema::Vec2D> crops) {
    fbb_.AddOffset(BatchToSpace::VT_CROPS, crops);
  }
  explicit BatchToSpaceBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<BatchToSpace> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<BatchToSpace>(end);
    return o;
  }
};

inline flatbuffers::Offset<BatchToSpace> CreateBatchToSpace(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<int64_t>> block_size = 0,
    flatbuffers::Offset<mindspore::schema::Vec2D> crops = 0) {
  BatchToSpaceBuilder builder_(_fbb);
  builder_.add_crops(crops);
  builder_.add_block_size(block_size);
  return builder_.Finish();
}

inline flatbuffers::Offset<BatchToSpace> CreateBatchToSpaceDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<int64_t> *block_size = nullptr,
    flatbuffers::Offset<mindspore::schema::Vec2D> crops = 0) {
  auto block_size__ = block_size ? _fbb.CreateVector<int64_t>(*block_size) : 0;
  return mindspore::schema::CreateBatchToSpace(
      _fbb,
      block_size__,
      crops);
}

flatbuffers::Offset<BatchToSpace> CreateBatchToSpace(flatbuffers::FlatBufferBuilder &_fbb, const BatchToSpaceT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct BatchToSpaceNDT : public flatbuffers::NativeTable {
  typedef BatchToSpaceND TableType;
  std::vector<int64_t> block_shape{};
  std::unique_ptr<mindspore::schema::Vec2DT> crops{};
};

struct BatchToSpaceND FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef BatchToSpaceNDT NativeTableType;
  typedef BatchToSpaceNDBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return BatchToSpaceNDTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_BLOCK_SHAPE = 4,
    VT_CROPS = 6
  };
  const flatbuffers::Vector<int64_t> *block_shape() const {
    return GetPointer<const flatbuffers::Vector<int64_t> *>(VT_BLOCK_SHAPE);
  }
  flatbuffers::Vector<int64_t> *mutable_block_shape() {
    return GetPointer<flatbuffers::Vector<int64_t> *>(VT_BLOCK_SHAPE);
  }
  const mindspore::schema::Vec2D *crops() const {
    return GetPointer<const mindspore::schema::Vec2D *>(VT_CROPS);
  }
  mindspore::schema::Vec2D *mutable_crops() {
    return GetPointer<mindspore::schema::Vec2D *>(VT_CROPS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_BLOCK_SHAPE) &&
           verifier.VerifyVector(block_shape()) &&
           VerifyOffset(verifier, VT_CROPS) &&
           verifier.VerifyTable(crops()) &&
           verifier.EndTable();
  }
  BatchToSpaceNDT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(BatchToSpaceNDT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<BatchToSpaceND> Pack(flatbuffers::FlatBufferBuilder &_fbb, const BatchToSpaceNDT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct BatchToSpaceNDBuilder {
  typedef BatchToSpaceND Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_block_shape(flatbuffers::Offset<flatbuffers::Vector<int64_t>> block_shape) {
    fbb_.AddOffset(BatchToSpaceND::VT_BLOCK_SHAPE, block_shape);
  }
  void add_crops(flatbuffers::Offset<mindspore::schema::Vec2D> crops) {
    fbb_.AddOffset(BatchToSpaceND::VT_CROPS, crops);
  }
  explicit BatchToSpaceNDBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<BatchToSpaceND> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<BatchToSpaceND>(end);
    return o;
  }
};

inline flatbuffers::Offset<BatchToSpaceND> CreateBatchToSpaceND(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<int64_t>> block_shape = 0,
    flatbuffers::Offset<mindspore::schema::Vec2D> crops = 0) {
  BatchToSpaceNDBuilder builder_(_fbb);
  builder_.add_crops(crops);
  builder_.add_block_shape(block_shape);
  return builder_.Finish();
}

inline flatbuffers::Offset<BatchToSpaceND> CreateBatchToSpaceNDDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<int64_t> *block_shape = nullptr,
    flatbuffers::Offset<mindspore::schema::Vec2D> crops = 0) {
  auto block_shape__ = block_shape ? _fbb.CreateVector<int64_t>(*block_shape) : 0;
  return mindspore::schema::CreateBatchToSpaceND(
      _fbb,
      block_shape__,
      crops);
}

flatbuffers::Offset<BatchToSpaceND> CreateBatchToSpaceND(flatbuffers::FlatBufferBuilder &_fbb, const BatchToSpaceNDT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct BiasAddT : public flatbuffers::NativeTable {
  typedef BiasAdd TableType;
  mindspore::schema::Format format = mindspore::schema::Format_NCHW;
};

struct BiasAdd FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef BiasAddT NativeTableType;
  typedef BiasAddBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return BiasAddTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_FORMAT = 4
  };
  mindspore::schema::Format format() const {
    return static_cast<mindspore::schema::Format>(GetField<int32_t>(VT_FORMAT, 0));
  }
  bool mutate_format(mindspore::schema::Format _format) {
    return SetField<int32_t>(VT_FORMAT, static_cast<int32_t>(_format), 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_FORMAT) &&
           verifier.EndTable();
  }
  BiasAddT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(BiasAddT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<BiasAdd> Pack(flatbuffers::FlatBufferBuilder &_fbb, const BiasAddT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct BiasAddBuilder {
  typedef BiasAdd Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_format(mindspore::schema::Format format) {
    fbb_.AddElement<int32_t>(BiasAdd::VT_FORMAT, static_cast<int32_t>(format), 0);
  }
  explicit BiasAddBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<BiasAdd> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<BiasAdd>(end);
    return o;
  }
};

inline flatbuffers::Offset<BiasAdd> CreateBiasAdd(
    flatbuffers::FlatBufferBuilder &_fbb,
    mindspore::schema::Format format = mindspore::schema::Format_NCHW) {
  BiasAddBuilder builder_(_fbb);
  builder_.add_format(format);
  return builder_.Finish();
}

flatbuffers::Offset<BiasAdd> CreateBiasAdd(flatbuffers::FlatBufferBuilder &_fbb, const BiasAddT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct BinaryCrossEntropyT : public flatbuffers::NativeTable {
  typedef BinaryCrossEntropy TableType;
  mindspore::schema::Reduction reduction = mindspore::schema::Reduction_REDUCTION_SUM;
};

struct BinaryCrossEntropy FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef BinaryCrossEntropyT NativeTableType;
  typedef BinaryCrossEntropyBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return BinaryCrossEntropyTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_REDUCTION = 4
  };
  mindspore::schema::Reduction reduction() const {
    return static_cast<mindspore::schema::Reduction>(GetField<int8_t>(VT_REDUCTION, 0));
  }
  bool mutate_reduction(mindspore::schema::Reduction _reduction) {
    return SetField<int8_t>(VT_REDUCTION, static_cast<int8_t>(_reduction), 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_REDUCTION) &&
           verifier.EndTable();
  }
  BinaryCrossEntropyT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(BinaryCrossEntropyT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<BinaryCrossEntropy> Pack(flatbuffers::FlatBufferBuilder &_fbb, const BinaryCrossEntropyT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct BinaryCrossEntropyBuilder {
  typedef BinaryCrossEntropy Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_reduction(mindspore::schema::Reduction reduction) {
    fbb_.AddElement<int8_t>(BinaryCrossEntropy::VT_REDUCTION, static_cast<int8_t>(reduction), 0);
  }
  explicit BinaryCrossEntropyBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<BinaryCrossEntropy> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<BinaryCrossEntropy>(end);
    return o;
  }
};

inline flatbuffers::Offset<BinaryCrossEntropy> CreateBinaryCrossEntropy(
    flatbuffers::FlatBufferBuilder &_fbb,
    mindspore::schema::Reduction reduction = mindspore::schema::Reduction_REDUCTION_SUM) {
  BinaryCrossEntropyBuilder builder_(_fbb);
  builder_.add_reduction(reduction);
  return builder_.Finish();
}

flatbuffers::Offset<BinaryCrossEntropy> CreateBinaryCrossEntropy(flatbuffers::FlatBufferBuilder &_fbb, const BinaryCrossEntropyT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct BinaryCrossEntropyGradT : public flatbuffers::NativeTable {
  typedef BinaryCrossEntropyGrad TableType;
  mindspore::schema::Reduction reduction = mindspore::schema::Reduction_MEAN;
};

struct BinaryCrossEntropyGrad FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef BinaryCrossEntropyGradT NativeTableType;
  typedef BinaryCrossEntropyGradBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return BinaryCrossEntropyGradTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_REDUCTION = 4
  };
  mindspore::schema::Reduction reduction() const {
    return static_cast<mindspore::schema::Reduction>(GetField<int8_t>(VT_REDUCTION, 1));
  }
  bool mutate_reduction(mindspore::schema::Reduction _reduction) {
    return SetField<int8_t>(VT_REDUCTION, static_cast<int8_t>(_reduction), 1);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_REDUCTION) &&
           verifier.EndTable();
  }
  BinaryCrossEntropyGradT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(BinaryCrossEntropyGradT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<BinaryCrossEntropyGrad> Pack(flatbuffers::FlatBufferBuilder &_fbb, const BinaryCrossEntropyGradT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct BinaryCrossEntropyGradBuilder {
  typedef BinaryCrossEntropyGrad Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_reduction(mindspore::schema::Reduction reduction) {
    fbb_.AddElement<int8_t>(BinaryCrossEntropyGrad::VT_REDUCTION, static_cast<int8_t>(reduction), 1);
  }
  explicit BinaryCrossEntropyGradBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<BinaryCrossEntropyGrad> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<BinaryCrossEntropyGrad>(end);
    return o;
  }
};

inline flatbuffers::Offset<BinaryCrossEntropyGrad> CreateBinaryCrossEntropyGrad(
    flatbuffers::FlatBufferBuilder &_fbb,
    mindspore::schema::Reduction reduction = mindspore::schema::Reduction_MEAN) {
  BinaryCrossEntropyGradBuilder builder_(_fbb);
  builder_.add_reduction(reduction);
  return builder_.Finish();
}

flatbuffers::Offset<BinaryCrossEntropyGrad> CreateBinaryCrossEntropyGrad(flatbuffers::FlatBufferBuilder &_fbb, const BinaryCrossEntropyGradT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct BiasAddGradT : public flatbuffers::NativeTable {
  typedef BiasAddGrad TableType;
};

struct BiasAddGrad FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef BiasAddGradT NativeTableType;
  typedef BiasAddGradBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return BiasAddGradTypeTable();
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  BiasAddGradT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(BiasAddGradT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<BiasAddGrad> Pack(flatbuffers::FlatBufferBuilder &_fbb, const BiasAddGradT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct BiasAddGradBuilder {
  typedef BiasAddGrad Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit BiasAddGradBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<BiasAddGrad> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<BiasAddGrad>(end);
    return o;
  }
};

inline flatbuffers::Offset<BiasAddGrad> CreateBiasAddGrad(
    flatbuffers::FlatBufferBuilder &_fbb) {
  BiasAddGradBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<BiasAddGrad> CreateBiasAddGrad(flatbuffers::FlatBufferBuilder &_fbb, const BiasAddGradT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct BroadcastToT : public flatbuffers::NativeTable {
  typedef BroadcastTo TableType;
  std::vector<int64_t> shape{};
};

struct BroadcastTo FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef BroadcastToT NativeTableType;
  typedef BroadcastToBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return BroadcastToTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SHAPE = 4
  };
  const flatbuffers::Vector<int64_t> *shape() const {
    return GetPointer<const flatbuffers::Vector<int64_t> *>(VT_SHAPE);
  }
  flatbuffers::Vector<int64_t> *mutable_shape() {
    return GetPointer<flatbuffers::Vector<int64_t> *>(VT_SHAPE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_SHAPE) &&
           verifier.VerifyVector(shape()) &&
           verifier.EndTable();
  }
  BroadcastToT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(BroadcastToT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<BroadcastTo> Pack(flatbuffers::FlatBufferBuilder &_fbb, const BroadcastToT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct BroadcastToBuilder {
  typedef BroadcastTo Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_shape(flatbuffers::Offset<flatbuffers::Vector<int64_t>> shape) {
    fbb_.AddOffset(BroadcastTo::VT_SHAPE, shape);
  }
  explicit BroadcastToBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<BroadcastTo> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<BroadcastTo>(end);
    return o;
  }
};

inline flatbuffers::Offset<BroadcastTo> CreateBroadcastTo(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<int64_t>> shape = 0) {
  BroadcastToBuilder builder_(_fbb);
  builder_.add_shape(shape);
  return builder_.Finish();
}

inline flatbuffers::Offset<BroadcastTo> CreateBroadcastToDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<int64_t> *shape = nullptr) {
  auto shape__ = shape ? _fbb.CreateVector<int64_t>(*shape) : 0;
  return mindspore::schema::CreateBroadcastTo(
      _fbb,
      shape__);
}

flatbuffers::Offset<BroadcastTo> CreateBroadcastTo(flatbuffers::FlatBufferBuilder &_fbb, const BroadcastToT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct CastT : public flatbuffers::NativeTable {
  typedef Cast TableType;
};

struct Cast FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef CastT NativeTableType;
  typedef CastBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return CastTypeTable();
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  CastT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(CastT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Cast> Pack(flatbuffers::FlatBufferBuilder &_fbb, const CastT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct CastBuilder {
  typedef Cast Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit CastBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Cast> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Cast>(end);
    return o;
  }
};

inline flatbuffers::Offset<Cast> CreateCast(
    flatbuffers::FlatBufferBuilder &_fbb) {
  CastBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<Cast> CreateCast(flatbuffers::FlatBufferBuilder &_fbb, const CastT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct CeilT : public flatbuffers::NativeTable {
  typedef Ceil TableType;
};

struct Ceil FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef CeilT NativeTableType;
  typedef CeilBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return CeilTypeTable();
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  CeilT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(CeilT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Ceil> Pack(flatbuffers::FlatBufferBuilder &_fbb, const CeilT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct CeilBuilder {
  typedef Ceil Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit CeilBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Ceil> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Ceil>(end);
    return o;
  }
};

inline flatbuffers::Offset<Ceil> CreateCeil(
    flatbuffers::FlatBufferBuilder &_fbb) {
  CeilBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<Ceil> CreateCeil(flatbuffers::FlatBufferBuilder &_fbb, const CeilT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ClipT : public flatbuffers::NativeTable {
  typedef Clip TableType;
  float max = 0.0f;
  float min = 0.0f;
};

struct Clip FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ClipT NativeTableType;
  typedef ClipBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return ClipTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_MAX = 4,
    VT_MIN = 6
  };
  float max() const {
    return GetField<float>(VT_MAX, 0.0f);
  }
  bool mutate_max(float _max) {
    return SetField<float>(VT_MAX, _max, 0.0f);
  }
  float min() const {
    return GetField<float>(VT_MIN, 0.0f);
  }
  bool mutate_min(float _min) {
    return SetField<float>(VT_MIN, _min, 0.0f);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<float>(verifier, VT_MAX) &&
           VerifyField<float>(verifier, VT_MIN) &&
           verifier.EndTable();
  }
  ClipT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ClipT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Clip> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ClipT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ClipBuilder {
  typedef Clip Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_max(float max) {
    fbb_.AddElement<float>(Clip::VT_MAX, max, 0.0f);
  }
  void add_min(float min) {
    fbb_.AddElement<float>(Clip::VT_MIN, min, 0.0f);
  }
  explicit ClipBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Clip> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Clip>(end);
    return o;
  }
};

inline flatbuffers::Offset<Clip> CreateClip(
    flatbuffers::FlatBufferBuilder &_fbb,
    float max = 0.0f,
    float min = 0.0f) {
  ClipBuilder builder_(_fbb);
  builder_.add_min(min);
  builder_.add_max(max);
  return builder_.Finish();
}

flatbuffers::Offset<Clip> CreateClip(flatbuffers::FlatBufferBuilder &_fbb, const ClipT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ConcatT : public flatbuffers::NativeTable {
  typedef Concat TableType;
  int64_t axis = 0;
};

struct Concat FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ConcatT NativeTableType;
  typedef ConcatBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return ConcatTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_AXIS = 4
  };
  int64_t axis() const {
    return GetField<int64_t>(VT_AXIS, 0);
  }
  bool mutate_axis(int64_t _axis) {
    return SetField<int64_t>(VT_AXIS, _axis, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_AXIS) &&
           verifier.EndTable();
  }
  ConcatT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ConcatT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Concat> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ConcatT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ConcatBuilder {
  typedef Concat Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_axis(int64_t axis) {
    fbb_.AddElement<int64_t>(Concat::VT_AXIS, axis, 0);
  }
  explicit ConcatBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Concat> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Concat>(end);
    return o;
  }
};

inline flatbuffers::Offset<Concat> CreateConcat(
    flatbuffers::FlatBufferBuilder &_fbb,
    int64_t axis = 0) {
  ConcatBuilder builder_(_fbb);
  builder_.add_axis(axis);
  return builder_.Finish();
}

flatbuffers::Offset<Concat> CreateConcat(flatbuffers::FlatBufferBuilder &_fbb, const ConcatT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct AttentionT : public flatbuffers::NativeTable {
  typedef Attention TableType;
};

struct Attention FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef AttentionT NativeTableType;
  typedef AttentionBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return AttentionTypeTable();
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  AttentionT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(AttentionT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Attention> Pack(flatbuffers::FlatBufferBuilder &_fbb, const AttentionT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct AttentionBuilder {
  typedef Attention Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit AttentionBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Attention> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Attention>(end);
    return o;
  }
};

inline flatbuffers::Offset<Attention> CreateAttention(
    flatbuffers::FlatBufferBuilder &_fbb) {
  AttentionBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<Attention> CreateAttention(flatbuffers::FlatBufferBuilder &_fbb, const AttentionT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct Conv2DBackpropFilterFusionT : public flatbuffers::NativeTable {
  typedef Conv2DBackpropFilterFusion TableType;
  mindspore::schema::Format format = mindspore::schema::Format_NCHW;
  std::vector<int64_t> kernel_size{};
  std::vector<int64_t> stride{};
  std::vector<int64_t> dilation{};
  mindspore::schema::PadMode pad_mode = mindspore::schema::PadMode_PAD;
  std::vector<int64_t> pad_list{};
  int64_t mode = 0;
  int64_t group = 0;
  int64_t in_channel = 0;
  int64_t out_channel = 0;
  mindspore::schema::ActivationType activation_type = mindspore::schema::ActivationType_NO_ACTIVATION;
};

struct Conv2DBackpropFilterFusion FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef Conv2DBackpropFilterFusionT NativeTableType;
  typedef Conv2DBackpropFilterFusionBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return Conv2DBackpropFilterFusionTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_FORMAT = 4,
    VT_KERNEL_SIZE = 6,
    VT_STRIDE = 8,
    VT_DILATION = 10,
    VT_PAD_MODE = 12,
    VT_PAD_LIST = 14,
    VT_MODE = 16,
    VT_GROUP = 18,
    VT_IN_CHANNEL = 20,
    VT_OUT_CHANNEL = 22,
    VT_ACTIVATION_TYPE = 24
  };
  mindspore::schema::Format format() const {
    return static_cast<mindspore::schema::Format>(GetField<int32_t>(VT_FORMAT, 0));
  }
  bool mutate_format(mindspore::schema::Format _format) {
    return SetField<int32_t>(VT_FORMAT, static_cast<int32_t>(_format), 0);
  }
  const flatbuffers::Vector<int64_t> *kernel_size() const {
    return GetPointer<const flatbuffers::Vector<int64_t> *>(VT_KERNEL_SIZE);
  }
  flatbuffers::Vector<int64_t> *mutable_kernel_size() {
    return GetPointer<flatbuffers::Vector<int64_t> *>(VT_KERNEL_SIZE);
  }
  const flatbuffers::Vector<int64_t> *stride() const {
    return GetPointer<const flatbuffers::Vector<int64_t> *>(VT_STRIDE);
  }
  flatbuffers::Vector<int64_t> *mutable_stride() {
    return GetPointer<flatbuffers::Vector<int64_t> *>(VT_STRIDE);
  }
  const flatbuffers::Vector<int64_t> *dilation() const {
    return GetPointer<const flatbuffers::Vector<int64_t> *>(VT_DILATION);
  }
  flatbuffers::Vector<int64_t> *mutable_dilation() {
    return GetPointer<flatbuffers::Vector<int64_t> *>(VT_DILATION);
  }
  mindspore::schema::PadMode pad_mode() const {
    return static_cast<mindspore::schema::PadMode>(GetField<int8_t>(VT_PAD_MODE, 0));
  }
  bool mutate_pad_mode(mindspore::schema::PadMode _pad_mode) {
    return SetField<int8_t>(VT_PAD_MODE, static_cast<int8_t>(_pad_mode), 0);
  }
  const flatbuffers::Vector<int64_t> *pad_list() const {
    return GetPointer<const flatbuffers::Vector<int64_t> *>(VT_PAD_LIST);
  }
  flatbuffers::Vector<int64_t> *mutable_pad_list() {
    return GetPointer<flatbuffers::Vector<int64_t> *>(VT_PAD_LIST);
  }
  int64_t mode() const {
    return GetField<int64_t>(VT_MODE, 0);
  }
  bool mutate_mode(int64_t _mode) {
    return SetField<int64_t>(VT_MODE, _mode, 0);
  }
  int64_t group() const {
    return GetField<int64_t>(VT_GROUP, 0);
  }
  bool mutate_group(int64_t _group) {
    return SetField<int64_t>(VT_GROUP, _group, 0);
  }
  int64_t in_channel() const {
    return GetField<int64_t>(VT_IN_CHANNEL, 0);
  }
  bool mutate_in_channel(int64_t _in_channel) {
    return SetField<int64_t>(VT_IN_CHANNEL, _in_channel, 0);
  }
  int64_t out_channel() const {
    return GetField<int64_t>(VT_OUT_CHANNEL, 0);
  }
  bool mutate_out_channel(int64_t _out_channel) {
    return SetField<int64_t>(VT_OUT_CHANNEL, _out_channel, 0);
  }
  mindspore::schema::ActivationType activation_type() const {
    return static_cast<mindspore::schema::ActivationType>(GetField<int8_t>(VT_ACTIVATION_TYPE, 0));
  }
  bool mutate_activation_type(mindspore::schema::ActivationType _activation_type) {
    return SetField<int8_t>(VT_ACTIVATION_TYPE, static_cast<int8_t>(_activation_type), 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_FORMAT) &&
           VerifyOffset(verifier, VT_KERNEL_SIZE) &&
           verifier.VerifyVector(kernel_size()) &&
           VerifyOffset(verifier, VT_STRIDE) &&
           verifier.VerifyVector(stride()) &&
           VerifyOffset(verifier, VT_DILATION) &&
           verifier.VerifyVector(dilation()) &&
           VerifyField<int8_t>(verifier, VT_PAD_MODE) &&
           VerifyOffset(verifier, VT_PAD_LIST) &&
           verifier.VerifyVector(pad_list()) &&
           VerifyField<int64_t>(verifier, VT_MODE) &&
           VerifyField<int64_t>(verifier, VT_GROUP) &&
           VerifyField<int64_t>(verifier, VT_IN_CHANNEL) &&
           VerifyField<int64_t>(verifier, VT_OUT_CHANNEL) &&
           VerifyField<int8_t>(verifier, VT_ACTIVATION_TYPE) &&
           verifier.EndTable();
  }
  Conv2DBackpropFilterFusionT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(Conv2DBackpropFilterFusionT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Conv2DBackpropFilterFusion> Pack(flatbuffers::FlatBufferBuilder &_fbb, const Conv2DBackpropFilterFusionT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct Conv2DBackpropFilterFusionBuilder {
  typedef Conv2DBackpropFilterFusion Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_format(mindspore::schema::Format format) {
    fbb_.AddElement<int32_t>(Conv2DBackpropFilterFusion::VT_FORMAT, static_cast<int32_t>(format), 0);
  }
  void add_kernel_size(flatbuffers::Offset<flatbuffers::Vector<int64_t>> kernel_size) {
    fbb_.AddOffset(Conv2DBackpropFilterFusion::VT_KERNEL_SIZE, kernel_size);
  }
  void add_stride(flatbuffers::Offset<flatbuffers::Vector<int64_t>> stride) {
    fbb_.AddOffset(Conv2DBackpropFilterFusion::VT_STRIDE, stride);
  }
  void add_dilation(flatbuffers::Offset<flatbuffers::Vector<int64_t>> dilation) {
    fbb_.AddOffset(Conv2DBackpropFilterFusion::VT_DILATION, dilation);
  }
  void add_pad_mode(mindspore::schema::PadMode pad_mode) {
    fbb_.AddElement<int8_t>(Conv2DBackpropFilterFusion::VT_PAD_MODE, static_cast<int8_t>(pad_mode), 0);
  }
  void add_pad_list(flatbuffers::Offset<flatbuffers::Vector<int64_t>> pad_list) {
    fbb_.AddOffset(Conv2DBackpropFilterFusion::VT_PAD_LIST, pad_list);
  }
  void add_mode(int64_t mode) {
    fbb_.AddElement<int64_t>(Conv2DBackpropFilterFusion::VT_MODE, mode, 0);
  }
  void add_group(int64_t group) {
    fbb_.AddElement<int64_t>(Conv2DBackpropFilterFusion::VT_GROUP, group, 0);
  }
  void add_in_channel(int64_t in_channel) {
    fbb_.AddElement<int64_t>(Conv2DBackpropFilterFusion::VT_IN_CHANNEL, in_channel, 0);
  }
  void add_out_channel(int64_t out_channel) {
    fbb_.AddElement<int64_t>(Conv2DBackpropFilterFusion::VT_OUT_CHANNEL, out_channel, 0);
  }
  void add_activation_type(mindspore::schema::ActivationType activation_type) {
    fbb_.AddElement<int8_t>(Conv2DBackpropFilterFusion::VT_ACTIVATION_TYPE, static_cast<int8_t>(activation_type), 0);
  }
  explicit Conv2DBackpropFilterFusionBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Conv2DBackpropFilterFusion> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Conv2DBackpropFilterFusion>(end);
    return o;
  }
};

inline flatbuffers::Offset<Conv2DBackpropFilterFusion> CreateConv2DBackpropFilterFusion(
    flatbuffers::FlatBufferBuilder &_fbb,
    mindspore::schema::Format format = mindspore::schema::Format_NCHW,
    flatbuffers::Offset<flatbuffers::Vector<int64_t>> kernel_size = 0,
    flatbuffers::Offset<flatbuffers::Vector<int64_t>> stride = 0,
    flatbuffers::Offset<flatbuffers::Vector<int64_t>> dilation = 0,
    mindspore::schema::PadMode pad_mode = mindspore::schema::PadMode_PAD,
    flatbuffers::Offset<flatbuffers::Vector<int64_t>> pad_list = 0,
    int64_t mode = 0,
    int64_t group = 0,
    int64_t in_channel = 0,
    int64_t out_channel = 0,
    mindspore::schema::ActivationType activation_type = mindspore::schema::ActivationType_NO_ACTIVATION) {
  Conv2DBackpropFilterFusionBuilder builder_(_fbb);
  builder_.add_out_channel(out_channel);
  builder_.add_in_channel(in_channel);
  builder_.add_group(group);
  builder_.add_mode(mode);
  builder_.add_pad_list(pad_list);
  builder_.add_dilation(dilation);
  builder_.add_stride(stride);
  builder_.add_kernel_size(kernel_size);
  builder_.add_format(format);
  builder_.add_activation_type(activation_type);
  builder_.add_pad_mode(pad_mode);
  return builder_.Finish();
}

inline flatbuffers::Offset<Conv2DBackpropFilterFusion> CreateConv2DBackpropFilterFusionDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    mindspore::schema::Format format = mindspore::schema::Format_NCHW,
    const std::vector<int64_t> *kernel_size = nullptr,
    const std::vector<int64_t> *stride = nullptr,
    const std::vector<int64_t> *dilation = nullptr,
    mindspore::schema::PadMode pad_mode = mindspore::schema::PadMode_PAD,
    const std::vector<int64_t> *pad_list = nullptr,
    int64_t mode = 0,
    int64_t group = 0,
    int64_t in_channel = 0,
    int64_t out_channel = 0,
    mindspore::schema::ActivationType activation_type = mindspore::schema::ActivationType_NO_ACTIVATION) {
  auto kernel_size__ = kernel_size ? _fbb.CreateVector<int64_t>(*kernel_size) : 0;
  auto stride__ = stride ? _fbb.CreateVector<int64_t>(*stride) : 0;
  auto dilation__ = dilation ? _fbb.CreateVector<int64_t>(*dilation) : 0;
  auto pad_list__ = pad_list ? _fbb.CreateVector<int64_t>(*pad_list) : 0;
  return mindspore::schema::CreateConv2DBackpropFilterFusion(
      _fbb,
      format,
      kernel_size__,
      stride__,
      dilation__,
      pad_mode,
      pad_list__,
      mode,
      group,
      in_channel,
      out_channel,
      activation_type);
}

flatbuffers::Offset<Conv2DBackpropFilterFusion> CreateConv2DBackpropFilterFusion(flatbuffers::FlatBufferBuilder &_fbb, const Conv2DBackpropFilterFusionT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct Conv2DBackpropInputFusionT : public flatbuffers::NativeTable {
  typedef Conv2DBackpropInputFusion TableType;
  mindspore::schema::Format format = mindspore::schema::Format_NCHW;
  std::vector<int64_t> kernel_size{};
  std::vector<int64_t> stride{};
  std::vector<int64_t> dilation{};
  mindspore::schema::PadMode pad_mode = mindspore::schema::PadMode_PAD;
  std::vector<int64_t> pad{};
  std::vector<int64_t> pad_list{};
  int64_t mode = 0;
  int64_t group = 0;
  int64_t in_channel = 0;
  int64_t out_channel = 0;
  mindspore::schema::ActivationType activation_type = mindspore::schema::ActivationType_NO_ACTIVATION;
};

struct Conv2DBackpropInputFusion FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef Conv2DBackpropInputFusionT NativeTableType;
  typedef Conv2DBackpropInputFusionBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return Conv2DBackpropInputFusionTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_FORMAT = 4,
    VT_KERNEL_SIZE = 6,
    VT_STRIDE = 8,
    VT_DILATION = 10,
    VT_PAD_MODE = 12,
    VT_PAD = 14,
    VT_PAD_LIST = 16,
    VT_MODE = 18,
    VT_GROUP = 20,
    VT_IN_CHANNEL = 22,
    VT_OUT_CHANNEL = 24,
    VT_ACTIVATION_TYPE = 26
  };
  mindspore::schema::Format format() const {
    return static_cast<mindspore::schema::Format>(GetField<int32_t>(VT_FORMAT, 0));
  }
  bool mutate_format(mindspore::schema::Format _format) {
    return SetField<int32_t>(VT_FORMAT, static_cast<int32_t>(_format), 0);
  }
  const flatbuffers::Vector<int64_t> *kernel_size() const {
    return GetPointer<const flatbuffers::Vector<int64_t> *>(VT_KERNEL_SIZE);
  }
  flatbuffers::Vector<int64_t> *mutable_kernel_size() {
    return GetPointer<flatbuffers::Vector<int64_t> *>(VT_KERNEL_SIZE);
  }
  const flatbuffers::Vector<int64_t> *stride() const {
    return GetPointer<const flatbuffers::Vector<int64_t> *>(VT_STRIDE);
  }
  flatbuffers::Vector<int64_t> *mutable_stride() {
    return GetPointer<flatbuffers::Vector<int64_t> *>(VT_STRIDE);
  }
  const flatbuffers::Vector<int64_t> *dilation() const {
    return GetPointer<const flatbuffers::Vector<int64_t> *>(VT_DILATION);
  }
  flatbuffers::Vector<int64_t> *mutable_dilation() {
    return GetPointer<flatbuffers::Vector<int64_t> *>(VT_DILATION);
  }
  mindspore::schema::PadMode pad_mode() const {
    return static_cast<mindspore::schema::PadMode>(GetField<int8_t>(VT_PAD_MODE, 0));
  }
  bool mutate_pad_mode(mindspore::schema::PadMode _pad_mode) {
    return SetField<int8_t>(VT_PAD_MODE, static_cast<int8_t>(_pad_mode), 0);
  }
  const flatbuffers::Vector<int64_t> *pad() const {
    return GetPointer<const flatbuffers::Vector<int64_t> *>(VT_PAD);
  }
  flatbuffers::Vector<int64_t> *mutable_pad() {
    return GetPointer<flatbuffers::Vector<int64_t> *>(VT_PAD);
  }
  const flatbuffers::Vector<int64_t> *pad_list() const {
    return GetPointer<const flatbuffers::Vector<int64_t> *>(VT_PAD_LIST);
  }
  flatbuffers::Vector<int64_t> *mutable_pad_list() {
    return GetPointer<flatbuffers::Vector<int64_t> *>(VT_PAD_LIST);
  }
  int64_t mode() const {
    return GetField<int64_t>(VT_MODE, 0);
  }
  bool mutate_mode(int64_t _mode) {
    return SetField<int64_t>(VT_MODE, _mode, 0);
  }
  int64_t group() const {
    return GetField<int64_t>(VT_GROUP, 0);
  }
  bool mutate_group(int64_t _group) {
    return SetField<int64_t>(VT_GROUP, _group, 0);
  }
  int64_t in_channel() const {
    return GetField<int64_t>(VT_IN_CHANNEL, 0);
  }
  bool mutate_in_channel(int64_t _in_channel) {
    return SetField<int64_t>(VT_IN_CHANNEL, _in_channel, 0);
  }
  int64_t out_channel() const {
    return GetField<int64_t>(VT_OUT_CHANNEL, 0);
  }
  bool mutate_out_channel(int64_t _out_channel) {
    return SetField<int64_t>(VT_OUT_CHANNEL, _out_channel, 0);
  }
  mindspore::schema::ActivationType activation_type() const {
    return static_cast<mindspore::schema::ActivationType>(GetField<int8_t>(VT_ACTIVATION_TYPE, 0));
  }
  bool mutate_activation_type(mindspore::schema::ActivationType _activation_type) {
    return SetField<int8_t>(VT_ACTIVATION_TYPE, static_cast<int8_t>(_activation_type), 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_FORMAT) &&
           VerifyOffset(verifier, VT_KERNEL_SIZE) &&
           verifier.VerifyVector(kernel_size()) &&
           VerifyOffset(verifier, VT_STRIDE) &&
           verifier.VerifyVector(stride()) &&
           VerifyOffset(verifier, VT_DILATION) &&
           verifier.VerifyVector(dilation()) &&
           VerifyField<int8_t>(verifier, VT_PAD_MODE) &&
           VerifyOffset(verifier, VT_PAD) &&
           verifier.VerifyVector(pad()) &&
           VerifyOffset(verifier, VT_PAD_LIST) &&
           verifier.VerifyVector(pad_list()) &&
           VerifyField<int64_t>(verifier, VT_MODE) &&
           VerifyField<int64_t>(verifier, VT_GROUP) &&
           VerifyField<int64_t>(verifier, VT_IN_CHANNEL) &&
           VerifyField<int64_t>(verifier, VT_OUT_CHANNEL) &&
           VerifyField<int8_t>(verifier, VT_ACTIVATION_TYPE) &&
           verifier.EndTable();
  }
  Conv2DBackpropInputFusionT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(Conv2DBackpropInputFusionT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Conv2DBackpropInputFusion> Pack(flatbuffers::FlatBufferBuilder &_fbb, const Conv2DBackpropInputFusionT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct Conv2DBackpropInputFusionBuilder {
  typedef Conv2DBackpropInputFusion Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_format(mindspore::schema::Format format) {
    fbb_.AddElement<int32_t>(Conv2DBackpropInputFusion::VT_FORMAT, static_cast<int32_t>(format), 0);
  }
  void add_kernel_size(flatbuffers::Offset<flatbuffers::Vector<int64_t>> kernel_size) {
    fbb_.AddOffset(Conv2DBackpropInputFusion::VT_KERNEL_SIZE, kernel_size);
  }
  void add_stride(flatbuffers::Offset<flatbuffers::Vector<int64_t>> stride) {
    fbb_.AddOffset(Conv2DBackpropInputFusion::VT_STRIDE, stride);
  }
  void add_dilation(flatbuffers::Offset<flatbuffers::Vector<int64_t>> dilation) {
    fbb_.AddOffset(Conv2DBackpropInputFusion::VT_DILATION, dilation);
  }
  void add_pad_mode(mindspore::schema::PadMode pad_mode) {
    fbb_.AddElement<int8_t>(Conv2DBackpropInputFusion::VT_PAD_MODE, static_cast<int8_t>(pad_mode), 0);
  }
  void add_pad(flatbuffers::Offset<flatbuffers::Vector<int64_t>> pad) {
    fbb_.AddOffset(Conv2DBackpropInputFusion::VT_PAD, pad);
  }
  void add_pad_list(flatbuffers::Offset<flatbuffers::Vector<int64_t>> pad_list) {
    fbb_.AddOffset(Conv2DBackpropInputFusion::VT_PAD_LIST, pad_list);
  }
  void add_mode(int64_t mode) {
    fbb_.AddElement<int64_t>(Conv2DBackpropInputFusion::VT_MODE, mode, 0);
  }
  void add_group(int64_t group) {
    fbb_.AddElement<int64_t>(Conv2DBackpropInputFusion::VT_GROUP, group, 0);
  }
  void add_in_channel(int64_t in_channel) {
    fbb_.AddElement<int64_t>(Conv2DBackpropInputFusion::VT_IN_CHANNEL, in_channel, 0);
  }
  void add_out_channel(int64_t out_channel) {
    fbb_.AddElement<int64_t>(Conv2DBackpropInputFusion::VT_OUT_CHANNEL, out_channel, 0);
  }
  void add_activation_type(mindspore::schema::ActivationType activation_type) {
    fbb_.AddElement<int8_t>(Conv2DBackpropInputFusion::VT_ACTIVATION_TYPE, static_cast<int8_t>(activation_type), 0);
  }
  explicit Conv2DBackpropInputFusionBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Conv2DBackpropInputFusion> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Conv2DBackpropInputFusion>(end);
    return o;
  }
};

inline flatbuffers::Offset<Conv2DBackpropInputFusion> CreateConv2DBackpropInputFusion(
    flatbuffers::FlatBufferBuilder &_fbb,
    mindspore::schema::Format format = mindspore::schema::Format_NCHW,
    flatbuffers::Offset<flatbuffers::Vector<int64_t>> kernel_size = 0,
    flatbuffers::Offset<flatbuffers::Vector<int64_t>> stride = 0,
    flatbuffers::Offset<flatbuffers::Vector<int64_t>> dilation = 0,
    mindspore::schema::PadMode pad_mode = mindspore::schema::PadMode_PAD,
    flatbuffers::Offset<flatbuffers::Vector<int64_t>> pad = 0,
    flatbuffers::Offset<flatbuffers::Vector<int64_t>> pad_list = 0,
    int64_t mode = 0,
    int64_t group = 0,
    int64_t in_channel = 0,
    int64_t out_channel = 0,
    mindspore::schema::ActivationType activation_type = mindspore::schema::ActivationType_NO_ACTIVATION) {
  Conv2DBackpropInputFusionBuilder builder_(_fbb);
  builder_.add_out_channel(out_channel);
  builder_.add_in_channel(in_channel);
  builder_.add_group(group);
  builder_.add_mode(mode);
  builder_.add_pad_list(pad_list);
  builder_.add_pad(pad);
  builder_.add_dilation(dilation);
  builder_.add_stride(stride);
  builder_.add_kernel_size(kernel_size);
  builder_.add_format(format);
  builder_.add_activation_type(activation_type);
  builder_.add_pad_mode(pad_mode);
  return builder_.Finish();
}

inline flatbuffers::Offset<Conv2DBackpropInputFusion> CreateConv2DBackpropInputFusionDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    mindspore::schema::Format format = mindspore::schema::Format_NCHW,
    const std::vector<int64_t> *kernel_size = nullptr,
    const std::vector<int64_t> *stride = nullptr,
    const std::vector<int64_t> *dilation = nullptr,
    mindspore::schema::PadMode pad_mode = mindspore::schema::PadMode_PAD,
    const std::vector<int64_t> *pad = nullptr,
    const std::vector<int64_t> *pad_list = nullptr,
    int64_t mode = 0,
    int64_t group = 0,
    int64_t in_channel = 0,
    int64_t out_channel = 0,
    mindspore::schema::ActivationType activation_type = mindspore::schema::ActivationType_NO_ACTIVATION) {
  auto kernel_size__ = kernel_size ? _fbb.CreateVector<int64_t>(*kernel_size) : 0;
  auto stride__ = stride ? _fbb.CreateVector<int64_t>(*stride) : 0;
  auto dilation__ = dilation ? _fbb.CreateVector<int64_t>(*dilation) : 0;
  auto pad__ = pad ? _fbb.CreateVector<int64_t>(*pad) : 0;
  auto pad_list__ = pad_list ? _fbb.CreateVector<int64_t>(*pad_list) : 0;
  return mindspore::schema::CreateConv2DBackpropInputFusion(
      _fbb,
      format,
      kernel_size__,
      stride__,
      dilation__,
      pad_mode,
      pad__,
      pad_list__,
      mode,
      group,
      in_channel,
      out_channel,
      activation_type);
}

flatbuffers::Offset<Conv2DBackpropInputFusion> CreateConv2DBackpropInputFusion(flatbuffers::FlatBufferBuilder &_fbb, const Conv2DBackpropInputFusionT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct Conv2DFusionT : public flatbuffers::NativeTable {
  typedef Conv2DFusion TableType;
  mindspore::schema::Format format = mindspore::schema::Format_NCHW;
  std::vector<int64_t> kernel_size{};
  std::vector<int64_t> stride{};
  std::vector<int64_t> dilation{};
  mindspore::schema::PadMode pad_mode = mindspore::schema::PadMode_PAD;
  std::vector<int64_t> pad_list{};
  int64_t mode = 0;
  int64_t group = 0;
  int64_t in_channel = 0;
  int64_t out_channel = 0;
  mindspore::schema::ActivationType activation_type = mindspore::schema::ActivationType_NO_ACTIVATION;
};

struct Conv2DFusion FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef Conv2DFusionT NativeTableType;
  typedef Conv2DFusionBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return Conv2DFusionTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_FORMAT = 4,
    VT_KERNEL_SIZE = 6,
    VT_STRIDE = 8,
    VT_DILATION = 10,
    VT_PAD_MODE = 12,
    VT_PAD_LIST = 14,
    VT_MODE = 16,
    VT_GROUP = 18,
    VT_IN_CHANNEL = 20,
    VT_OUT_CHANNEL = 22,
    VT_ACTIVATION_TYPE = 24
  };
  mindspore::schema::Format format() const {
    return static_cast<mindspore::schema::Format>(GetField<int32_t>(VT_FORMAT, 0));
  }
  bool mutate_format(mindspore::schema::Format _format) {
    return SetField<int32_t>(VT_FORMAT, static_cast<int32_t>(_format), 0);
  }
  const flatbuffers::Vector<int64_t> *kernel_size() const {
    return GetPointer<const flatbuffers::Vector<int64_t> *>(VT_KERNEL_SIZE);
  }
  flatbuffers::Vector<int64_t> *mutable_kernel_size() {
    return GetPointer<flatbuffers::Vector<int64_t> *>(VT_KERNEL_SIZE);
  }
  const flatbuffers::Vector<int64_t> *stride() const {
    return GetPointer<const flatbuffers::Vector<int64_t> *>(VT_STRIDE);
  }
  flatbuffers::Vector<int64_t> *mutable_stride() {
    return GetPointer<flatbuffers::Vector<int64_t> *>(VT_STRIDE);
  }
  const flatbuffers::Vector<int64_t> *dilation() const {
    return GetPointer<const flatbuffers::Vector<int64_t> *>(VT_DILATION);
  }
  flatbuffers::Vector<int64_t> *mutable_dilation() {
    return GetPointer<flatbuffers::Vector<int64_t> *>(VT_DILATION);
  }
  mindspore::schema::PadMode pad_mode() const {
    return static_cast<mindspore::schema::PadMode>(GetField<int8_t>(VT_PAD_MODE, 0));
  }
  bool mutate_pad_mode(mindspore::schema::PadMode _pad_mode) {
    return SetField<int8_t>(VT_PAD_MODE, static_cast<int8_t>(_pad_mode), 0);
  }
  const flatbuffers::Vector<int64_t> *pad_list() const {
    return GetPointer<const flatbuffers::Vector<int64_t> *>(VT_PAD_LIST);
  }
  flatbuffers::Vector<int64_t> *mutable_pad_list() {
    return GetPointer<flatbuffers::Vector<int64_t> *>(VT_PAD_LIST);
  }
  int64_t mode() const {
    return GetField<int64_t>(VT_MODE, 0);
  }
  bool mutate_mode(int64_t _mode) {
    return SetField<int64_t>(VT_MODE, _mode, 0);
  }
  int64_t group() const {
    return GetField<int64_t>(VT_GROUP, 0);
  }
  bool mutate_group(int64_t _group) {
    return SetField<int64_t>(VT_GROUP, _group, 0);
  }
  int64_t in_channel() const {
    return GetField<int64_t>(VT_IN_CHANNEL, 0);
  }
  bool mutate_in_channel(int64_t _in_channel) {
    return SetField<int64_t>(VT_IN_CHANNEL, _in_channel, 0);
  }
  int64_t out_channel() const {
    return GetField<int64_t>(VT_OUT_CHANNEL, 0);
  }
  bool mutate_out_channel(int64_t _out_channel) {
    return SetField<int64_t>(VT_OUT_CHANNEL, _out_channel, 0);
  }
  mindspore::schema::ActivationType activation_type() const {
    return static_cast<mindspore::schema::ActivationType>(GetField<int8_t>(VT_ACTIVATION_TYPE, 0));
  }
  bool mutate_activation_type(mindspore::schema::ActivationType _activation_type) {
    return SetField<int8_t>(VT_ACTIVATION_TYPE, static_cast<int8_t>(_activation_type), 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_FORMAT) &&
           VerifyOffset(verifier, VT_KERNEL_SIZE) &&
           verifier.VerifyVector(kernel_size()) &&
           VerifyOffset(verifier, VT_STRIDE) &&
           verifier.VerifyVector(stride()) &&
           VerifyOffset(verifier, VT_DILATION) &&
           verifier.VerifyVector(dilation()) &&
           VerifyField<int8_t>(verifier, VT_PAD_MODE) &&
           VerifyOffset(verifier, VT_PAD_LIST) &&
           verifier.VerifyVector(pad_list()) &&
           VerifyField<int64_t>(verifier, VT_MODE) &&
           VerifyField<int64_t>(verifier, VT_GROUP) &&
           VerifyField<int64_t>(verifier, VT_IN_CHANNEL) &&
           VerifyField<int64_t>(verifier, VT_OUT_CHANNEL) &&
           VerifyField<int8_t>(verifier, VT_ACTIVATION_TYPE) &&
           verifier.EndTable();
  }
  Conv2DFusionT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(Conv2DFusionT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Conv2DFusion> Pack(flatbuffers::FlatBufferBuilder &_fbb, const Conv2DFusionT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct Conv2DFusionBuilder {
  typedef Conv2DFusion Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_format(mindspore::schema::Format format) {
    fbb_.AddElement<int32_t>(Conv2DFusion::VT_FORMAT, static_cast<int32_t>(format), 0);
  }
  void add_kernel_size(flatbuffers::Offset<flatbuffers::Vector<int64_t>> kernel_size) {
    fbb_.AddOffset(Conv2DFusion::VT_KERNEL_SIZE, kernel_size);
  }
  void add_stride(flatbuffers::Offset<flatbuffers::Vector<int64_t>> stride) {
    fbb_.AddOffset(Conv2DFusion::VT_STRIDE, stride);
  }
  void add_dilation(flatbuffers::Offset<flatbuffers::Vector<int64_t>> dilation) {
    fbb_.AddOffset(Conv2DFusion::VT_DILATION, dilation);
  }
  void add_pad_mode(mindspore::schema::PadMode pad_mode) {
    fbb_.AddElement<int8_t>(Conv2DFusion::VT_PAD_MODE, static_cast<int8_t>(pad_mode), 0);
  }
  void add_pad_list(flatbuffers::Offset<flatbuffers::Vector<int64_t>> pad_list) {
    fbb_.AddOffset(Conv2DFusion::VT_PAD_LIST, pad_list);
  }
  void add_mode(int64_t mode) {
    fbb_.AddElement<int64_t>(Conv2DFusion::VT_MODE, mode, 0);
  }
  void add_group(int64_t group) {
    fbb_.AddElement<int64_t>(Conv2DFusion::VT_GROUP, group, 0);
  }
  void add_in_channel(int64_t in_channel) {
    fbb_.AddElement<int64_t>(Conv2DFusion::VT_IN_CHANNEL, in_channel, 0);
  }
  void add_out_channel(int64_t out_channel) {
    fbb_.AddElement<int64_t>(Conv2DFusion::VT_OUT_CHANNEL, out_channel, 0);
  }
  void add_activation_type(mindspore::schema::ActivationType activation_type) {
    fbb_.AddElement<int8_t>(Conv2DFusion::VT_ACTIVATION_TYPE, static_cast<int8_t>(activation_type), 0);
  }
  explicit Conv2DFusionBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Conv2DFusion> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Conv2DFusion>(end);
    return o;
  }
};

inline flatbuffers::Offset<Conv2DFusion> CreateConv2DFusion(
    flatbuffers::FlatBufferBuilder &_fbb,
    mindspore::schema::Format format = mindspore::schema::Format_NCHW,
    flatbuffers::Offset<flatbuffers::Vector<int64_t>> kernel_size = 0,
    flatbuffers::Offset<flatbuffers::Vector<int64_t>> stride = 0,
    flatbuffers::Offset<flatbuffers::Vector<int64_t>> dilation = 0,
    mindspore::schema::PadMode pad_mode = mindspore::schema::PadMode_PAD,
    flatbuffers::Offset<flatbuffers::Vector<int64_t>> pad_list = 0,
    int64_t mode = 0,
    int64_t group = 0,
    int64_t in_channel = 0,
    int64_t out_channel = 0,
    mindspore::schema::ActivationType activation_type = mindspore::schema::ActivationType_NO_ACTIVATION) {
  Conv2DFusionBuilder builder_(_fbb);
  builder_.add_out_channel(out_channel);
  builder_.add_in_channel(in_channel);
  builder_.add_group(group);
  builder_.add_mode(mode);
  builder_.add_pad_list(pad_list);
  builder_.add_dilation(dilation);
  builder_.add_stride(stride);
  builder_.add_kernel_size(kernel_size);
  builder_.add_format(format);
  builder_.add_activation_type(activation_type);
  builder_.add_pad_mode(pad_mode);
  return builder_.Finish();
}

inline flatbuffers::Offset<Conv2DFusion> CreateConv2DFusionDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    mindspore::schema::Format format = mindspore::schema::Format_NCHW,
    const std::vector<int64_t> *kernel_size = nullptr,
    const std::vector<int64_t> *stride = nullptr,
    const std::vector<int64_t> *dilation = nullptr,
    mindspore::schema::PadMode pad_mode = mindspore::schema::PadMode_PAD,
    const std::vector<int64_t> *pad_list = nullptr,
    int64_t mode = 0,
    int64_t group = 0,
    int64_t in_channel = 0,
    int64_t out_channel = 0,
    mindspore::schema::ActivationType activation_type = mindspore::schema::ActivationType_NO_ACTIVATION) {
  auto kernel_size__ = kernel_size ? _fbb.CreateVector<int64_t>(*kernel_size) : 0;
  auto stride__ = stride ? _fbb.CreateVector<int64_t>(*stride) : 0;
  auto dilation__ = dilation ? _fbb.CreateVector<int64_t>(*dilation) : 0;
  auto pad_list__ = pad_list ? _fbb.CreateVector<int64_t>(*pad_list) : 0;
  return mindspore::schema::CreateConv2DFusion(
      _fbb,
      format,
      kernel_size__,
      stride__,
      dilation__,
      pad_mode,
      pad_list__,
      mode,
      group,
      in_channel,
      out_channel,
      activation_type);
}

flatbuffers::Offset<Conv2DFusion> CreateConv2DFusion(flatbuffers::FlatBufferBuilder &_fbb, const Conv2DFusionT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct Conv2dTransposeFusionT : public flatbuffers::NativeTable {
  typedef Conv2dTransposeFusion TableType;
  mindspore::schema::Format format = mindspore::schema::Format_NCHW;
  std::vector<int64_t> kernel_size{};
  std::vector<int64_t> stride{};
  std::vector<int64_t> dilation{};
  mindspore::schema::PadMode pad_mode = mindspore::schema::PadMode_PAD;
  std::vector<int64_t> pad{};
  std::vector<int64_t> pad_list{};
  int64_t mode = 0;
  int64_t group = 0;
  int64_t in_channel = 0;
  int64_t out_channel = 0;
  mindspore::schema::ActivationType activation_type = mindspore::schema::ActivationType_NO_ACTIVATION;
  std::vector<int64_t> output_paddings{};
};

struct Conv2dTransposeFusion FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef Conv2dTransposeFusionT NativeTableType;
  typedef Conv2dTransposeFusionBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return Conv2dTransposeFusionTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_FORMAT = 4,
    VT_KERNEL_SIZE = 6,
    VT_STRIDE = 8,
    VT_DILATION = 10,
    VT_PAD_MODE = 12,
    VT_PAD = 14,
    VT_PAD_LIST = 16,
    VT_MODE = 18,
    VT_GROUP = 20,
    VT_IN_CHANNEL = 22,
    VT_OUT_CHANNEL = 24,
    VT_ACTIVATION_TYPE = 26,
    VT_OUTPUT_PADDINGS = 28
  };
  mindspore::schema::Format format() const {
    return static_cast<mindspore::schema::Format>(GetField<int32_t>(VT_FORMAT, 0));
  }
  bool mutate_format(mindspore::schema::Format _format) {
    return SetField<int32_t>(VT_FORMAT, static_cast<int32_t>(_format), 0);
  }
  const flatbuffers::Vector<int64_t> *kernel_size() const {
    return GetPointer<const flatbuffers::Vector<int64_t> *>(VT_KERNEL_SIZE);
  }
  flatbuffers::Vector<int64_t> *mutable_kernel_size() {
    return GetPointer<flatbuffers::Vector<int64_t> *>(VT_KERNEL_SIZE);
  }
  const flatbuffers::Vector<int64_t> *stride() const {
    return GetPointer<const flatbuffers::Vector<int64_t> *>(VT_STRIDE);
  }
  flatbuffers::Vector<int64_t> *mutable_stride() {
    return GetPointer<flatbuffers::Vector<int64_t> *>(VT_STRIDE);
  }
  const flatbuffers::Vector<int64_t> *dilation() const {
    return GetPointer<const flatbuffers::Vector<int64_t> *>(VT_DILATION);
  }
  flatbuffers::Vector<int64_t> *mutable_dilation() {
    return GetPointer<flatbuffers::Vector<int64_t> *>(VT_DILATION);
  }
  mindspore::schema::PadMode pad_mode() const {
    return static_cast<mindspore::schema::PadMode>(GetField<int8_t>(VT_PAD_MODE, 0));
  }
  bool mutate_pad_mode(mindspore::schema::PadMode _pad_mode) {
    return SetField<int8_t>(VT_PAD_MODE, static_cast<int8_t>(_pad_mode), 0);
  }
  const flatbuffers::Vector<int64_t> *pad() const {
    return GetPointer<const flatbuffers::Vector<int64_t> *>(VT_PAD);
  }
  flatbuffers::Vector<int64_t> *mutable_pad() {
    return GetPointer<flatbuffers::Vector<int64_t> *>(VT_PAD);
  }
  const flatbuffers::Vector<int64_t> *pad_list() const {
    return GetPointer<const flatbuffers::Vector<int64_t> *>(VT_PAD_LIST);
  }
  flatbuffers::Vector<int64_t> *mutable_pad_list() {
    return GetPointer<flatbuffers::Vector<int64_t> *>(VT_PAD_LIST);
  }
  int64_t mode() const {
    return GetField<int64_t>(VT_MODE, 0);
  }
  bool mutate_mode(int64_t _mode) {
    return SetField<int64_t>(VT_MODE, _mode, 0);
  }
  int64_t group() const {
    return GetField<int64_t>(VT_GROUP, 0);
  }
  bool mutate_group(int64_t _group) {
    return SetField<int64_t>(VT_GROUP, _group, 0);
  }
  int64_t in_channel() const {
    return GetField<int64_t>(VT_IN_CHANNEL, 0);
  }
  bool mutate_in_channel(int64_t _in_channel) {
    return SetField<int64_t>(VT_IN_CHANNEL, _in_channel, 0);
  }
  int64_t out_channel() const {
    return GetField<int64_t>(VT_OUT_CHANNEL, 0);
  }
  bool mutate_out_channel(int64_t _out_channel) {
    return SetField<int64_t>(VT_OUT_CHANNEL, _out_channel, 0);
  }
  mindspore::schema::ActivationType activation_type() const {
    return static_cast<mindspore::schema::ActivationType>(GetField<int8_t>(VT_ACTIVATION_TYPE, 0));
  }
  bool mutate_activation_type(mindspore::schema::ActivationType _activation_type) {
    return SetField<int8_t>(VT_ACTIVATION_TYPE, static_cast<int8_t>(_activation_type), 0);
  }
  const flatbuffers::Vector<int64_t> *output_paddings() const {
    return GetPointer<const flatbuffers::Vector<int64_t> *>(VT_OUTPUT_PADDINGS);
  }
  flatbuffers::Vector<int64_t> *mutable_output_paddings() {
    return GetPointer<flatbuffers::Vector<int64_t> *>(VT_OUTPUT_PADDINGS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_FORMAT) &&
           VerifyOffset(verifier, VT_KERNEL_SIZE) &&
           verifier.VerifyVector(kernel_size()) &&
           VerifyOffset(verifier, VT_STRIDE) &&
           verifier.VerifyVector(stride()) &&
           VerifyOffset(verifier, VT_DILATION) &&
           verifier.VerifyVector(dilation()) &&
           VerifyField<int8_t>(verifier, VT_PAD_MODE) &&
           VerifyOffset(verifier, VT_PAD) &&
           verifier.VerifyVector(pad()) &&
           VerifyOffset(verifier, VT_PAD_LIST) &&
           verifier.VerifyVector(pad_list()) &&
           VerifyField<int64_t>(verifier, VT_MODE) &&
           VerifyField<int64_t>(verifier, VT_GROUP) &&
           VerifyField<int64_t>(verifier, VT_IN_CHANNEL) &&
           VerifyField<int64_t>(verifier, VT_OUT_CHANNEL) &&
           VerifyField<int8_t>(verifier, VT_ACTIVATION_TYPE) &&
           VerifyOffset(verifier, VT_OUTPUT_PADDINGS) &&
           verifier.VerifyVector(output_paddings()) &&
           verifier.EndTable();
  }
  Conv2dTransposeFusionT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(Conv2dTransposeFusionT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Conv2dTransposeFusion> Pack(flatbuffers::FlatBufferBuilder &_fbb, const Conv2dTransposeFusionT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct Conv2dTransposeFusionBuilder {
  typedef Conv2dTransposeFusion Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_format(mindspore::schema::Format format) {
    fbb_.AddElement<int32_t>(Conv2dTransposeFusion::VT_FORMAT, static_cast<int32_t>(format), 0);
  }
  void add_kernel_size(flatbuffers::Offset<flatbuffers::Vector<int64_t>> kernel_size) {
    fbb_.AddOffset(Conv2dTransposeFusion::VT_KERNEL_SIZE, kernel_size);
  }
  void add_stride(flatbuffers::Offset<flatbuffers::Vector<int64_t>> stride) {
    fbb_.AddOffset(Conv2dTransposeFusion::VT_STRIDE, stride);
  }
  void add_dilation(flatbuffers::Offset<flatbuffers::Vector<int64_t>> dilation) {
    fbb_.AddOffset(Conv2dTransposeFusion::VT_DILATION, dilation);
  }
  void add_pad_mode(mindspore::schema::PadMode pad_mode) {
    fbb_.AddElement<int8_t>(Conv2dTransposeFusion::VT_PAD_MODE, static_cast<int8_t>(pad_mode), 0);
  }
  void add_pad(flatbuffers::Offset<flatbuffers::Vector<int64_t>> pad) {
    fbb_.AddOffset(Conv2dTransposeFusion::VT_PAD, pad);
  }
  void add_pad_list(flatbuffers::Offset<flatbuffers::Vector<int64_t>> pad_list) {
    fbb_.AddOffset(Conv2dTransposeFusion::VT_PAD_LIST, pad_list);
  }
  void add_mode(int64_t mode) {
    fbb_.AddElement<int64_t>(Conv2dTransposeFusion::VT_MODE, mode, 0);
  }
  void add_group(int64_t group) {
    fbb_.AddElement<int64_t>(Conv2dTransposeFusion::VT_GROUP, group, 0);
  }
  void add_in_channel(int64_t in_channel) {
    fbb_.AddElement<int64_t>(Conv2dTransposeFusion::VT_IN_CHANNEL, in_channel, 0);
  }
  void add_out_channel(int64_t out_channel) {
    fbb_.AddElement<int64_t>(Conv2dTransposeFusion::VT_OUT_CHANNEL, out_channel, 0);
  }
  void add_activation_type(mindspore::schema::ActivationType activation_type) {
    fbb_.AddElement<int8_t>(Conv2dTransposeFusion::VT_ACTIVATION_TYPE, static_cast<int8_t>(activation_type), 0);
  }
  void add_output_paddings(flatbuffers::Offset<flatbuffers::Vector<int64_t>> output_paddings) {
    fbb_.AddOffset(Conv2dTransposeFusion::VT_OUTPUT_PADDINGS, output_paddings);
  }
  explicit Conv2dTransposeFusionBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Conv2dTransposeFusion> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Conv2dTransposeFusion>(end);
    return o;
  }
};

inline flatbuffers::Offset<Conv2dTransposeFusion> CreateConv2dTransposeFusion(
    flatbuffers::FlatBufferBuilder &_fbb,
    mindspore::schema::Format format = mindspore::schema::Format_NCHW,
    flatbuffers::Offset<flatbuffers::Vector<int64_t>> kernel_size = 0,
    flatbuffers::Offset<flatbuffers::Vector<int64_t>> stride = 0,
    flatbuffers::Offset<flatbuffers::Vector<int64_t>> dilation = 0,
    mindspore::schema::PadMode pad_mode = mindspore::schema::PadMode_PAD,
    flatbuffers::Offset<flatbuffers::Vector<int64_t>> pad = 0,
    flatbuffers::Offset<flatbuffers::Vector<int64_t>> pad_list = 0,
    int64_t mode = 0,
    int64_t group = 0,
    int64_t in_channel = 0,
    int64_t out_channel = 0,
    mindspore::schema::ActivationType activation_type = mindspore::schema::ActivationType_NO_ACTIVATION,
    flatbuffers::Offset<flatbuffers::Vector<int64_t>> output_paddings = 0) {
  Conv2dTransposeFusionBuilder builder_(_fbb);
  builder_.add_out_channel(out_channel);
  builder_.add_in_channel(in_channel);
  builder_.add_group(group);
  builder_.add_mode(mode);
  builder_.add_output_paddings(output_paddings);
  builder_.add_pad_list(pad_list);
  builder_.add_pad(pad);
  builder_.add_dilation(dilation);
  builder_.add_stride(stride);
  builder_.add_kernel_size(kernel_size);
  builder_.add_format(format);
  builder_.add_activation_type(activation_type);
  builder_.add_pad_mode(pad_mode);
  return builder_.Finish();
}

inline flatbuffers::Offset<Conv2dTransposeFusion> CreateConv2dTransposeFusionDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    mindspore::schema::Format format = mindspore::schema::Format_NCHW,
    const std::vector<int64_t> *kernel_size = nullptr,
    const std::vector<int64_t> *stride = nullptr,
    const std::vector<int64_t> *dilation = nullptr,
    mindspore::schema::PadMode pad_mode = mindspore::schema::PadMode_PAD,
    const std::vector<int64_t> *pad = nullptr,
    const std::vector<int64_t> *pad_list = nullptr,
    int64_t mode = 0,
    int64_t group = 0,
    int64_t in_channel = 0,
    int64_t out_channel = 0,
    mindspore::schema::ActivationType activation_type = mindspore::schema::ActivationType_NO_ACTIVATION,
    const std::vector<int64_t> *output_paddings = nullptr) {
  auto kernel_size__ = kernel_size ? _fbb.CreateVector<int64_t>(*kernel_size) : 0;
  auto stride__ = stride ? _fbb.CreateVector<int64_t>(*stride) : 0;
  auto dilation__ = dilation ? _fbb.CreateVector<int64_t>(*dilation) : 0;
  auto pad__ = pad ? _fbb.CreateVector<int64_t>(*pad) : 0;
  auto pad_list__ = pad_list ? _fbb.CreateVector<int64_t>(*pad_list) : 0;
  auto output_paddings__ = output_paddings ? _fbb.CreateVector<int64_t>(*output_paddings) : 0;
  return mindspore::schema::CreateConv2dTransposeFusion(
      _fbb,
      format,
      kernel_size__,
      stride__,
      dilation__,
      pad_mode,
      pad__,
      pad_list__,
      mode,
      group,
      in_channel,
      out_channel,
      activation_type,
      output_paddings__);
}

flatbuffers::Offset<Conv2dTransposeFusion> CreateConv2dTransposeFusion(flatbuffers::FlatBufferBuilder &_fbb, const Conv2dTransposeFusionT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct CosT : public flatbuffers::NativeTable {
  typedef Cos TableType;
};

struct Cos FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef CosT NativeTableType;
  typedef CosBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return CosTypeTable();
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  CosT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(CosT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Cos> Pack(flatbuffers::FlatBufferBuilder &_fbb, const CosT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct CosBuilder {
  typedef Cos Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit CosBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Cos> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Cos>(end);
    return o;
  }
};

inline flatbuffers::Offset<Cos> CreateCos(
    flatbuffers::FlatBufferBuilder &_fbb) {
  CosBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<Cos> CreateCos(flatbuffers::FlatBufferBuilder &_fbb, const CosT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ConstantOfShapeT : public flatbuffers::NativeTable {
  typedef ConstantOfShape TableType;
  int64_t data_type = 0;
  std::vector<float> value{};
};

struct ConstantOfShape FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ConstantOfShapeT NativeTableType;
  typedef ConstantOfShapeBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return ConstantOfShapeTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_DATA_TYPE = 4,
    VT_VALUE = 6
  };
  int64_t data_type() const {
    return GetField<int64_t>(VT_DATA_TYPE, 0);
  }
  bool mutate_data_type(int64_t _data_type) {
    return SetField<int64_t>(VT_DATA_TYPE, _data_type, 0);
  }
  const flatbuffers::Vector<float> *value() const {
    return GetPointer<const flatbuffers::Vector<float> *>(VT_VALUE);
  }
  flatbuffers::Vector<float> *mutable_value() {
    return GetPointer<flatbuffers::Vector<float> *>(VT_VALUE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_DATA_TYPE) &&
           VerifyOffset(verifier, VT_VALUE) &&
           verifier.VerifyVector(value()) &&
           verifier.EndTable();
  }
  ConstantOfShapeT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ConstantOfShapeT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<ConstantOfShape> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ConstantOfShapeT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ConstantOfShapeBuilder {
  typedef ConstantOfShape Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_data_type(int64_t data_type) {
    fbb_.AddElement<int64_t>(ConstantOfShape::VT_DATA_TYPE, data_type, 0);
  }
  void add_value(flatbuffers::Offset<flatbuffers::Vector<float>> value) {
    fbb_.AddOffset(ConstantOfShape::VT_VALUE, value);
  }
  explicit ConstantOfShapeBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<ConstantOfShape> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ConstantOfShape>(end);
    return o;
  }
};

inline flatbuffers::Offset<ConstantOfShape> CreateConstantOfShape(
    flatbuffers::FlatBufferBuilder &_fbb,
    int64_t data_type = 0,
    flatbuffers::Offset<flatbuffers::Vector<float>> value = 0) {
  ConstantOfShapeBuilder builder_(_fbb);
  builder_.add_data_type(data_type);
  builder_.add_value(value);
  return builder_.Finish();
}

inline flatbuffers::Offset<ConstantOfShape> CreateConstantOfShapeDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int64_t data_type = 0,
    const std::vector<float> *value = nullptr) {
  auto value__ = value ? _fbb.CreateVector<float>(*value) : 0;
  return mindspore::schema::CreateConstantOfShape(
      _fbb,
      data_type,
      value__);
}

flatbuffers::Offset<ConstantOfShape> CreateConstantOfShape(flatbuffers::FlatBufferBuilder &_fbb, const ConstantOfShapeT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct CropT : public flatbuffers::NativeTable {
  typedef Crop TableType;
  int64_t axis = 0;
  std::vector<int64_t> offsets{};
};

struct Crop FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef CropT NativeTableType;
  typedef CropBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return CropTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_AXIS = 4,
    VT_OFFSETS = 6
  };
  int64_t axis() const {
    return GetField<int64_t>(VT_AXIS, 0);
  }
  bool mutate_axis(int64_t _axis) {
    return SetField<int64_t>(VT_AXIS, _axis, 0);
  }
  const flatbuffers::Vector<int64_t> *offsets() const {
    return GetPointer<const flatbuffers::Vector<int64_t> *>(VT_OFFSETS);
  }
  flatbuffers::Vector<int64_t> *mutable_offsets() {
    return GetPointer<flatbuffers::Vector<int64_t> *>(VT_OFFSETS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_AXIS) &&
           VerifyOffset(verifier, VT_OFFSETS) &&
           verifier.VerifyVector(offsets()) &&
           verifier.EndTable();
  }
  CropT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(CropT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Crop> Pack(flatbuffers::FlatBufferBuilder &_fbb, const CropT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct CropBuilder {
  typedef Crop Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_axis(int64_t axis) {
    fbb_.AddElement<int64_t>(Crop::VT_AXIS, axis, 0);
  }
  void add_offsets(flatbuffers::Offset<flatbuffers::Vector<int64_t>> offsets) {
    fbb_.AddOffset(Crop::VT_OFFSETS, offsets);
  }
  explicit CropBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Crop> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Crop>(end);
    return o;
  }
};

inline flatbuffers::Offset<Crop> CreateCrop(
    flatbuffers::FlatBufferBuilder &_fbb,
    int64_t axis = 0,
    flatbuffers::Offset<flatbuffers::Vector<int64_t>> offsets = 0) {
  CropBuilder builder_(_fbb);
  builder_.add_axis(axis);
  builder_.add_offsets(offsets);
  return builder_.Finish();
}

inline flatbuffers::Offset<Crop> CreateCropDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int64_t axis = 0,
    const std::vector<int64_t> *offsets = nullptr) {
  auto offsets__ = offsets ? _fbb.CreateVector<int64_t>(*offsets) : 0;
  return mindspore::schema::CreateCrop(
      _fbb,
      axis,
      offsets__);
}

flatbuffers::Offset<Crop> CreateCrop(flatbuffers::FlatBufferBuilder &_fbb, const CropT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct CustomExtractFeaturesT : public flatbuffers::NativeTable {
  typedef CustomExtractFeatures TableType;
};

struct CustomExtractFeatures FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef CustomExtractFeaturesT NativeTableType;
  typedef CustomExtractFeaturesBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return CustomExtractFeaturesTypeTable();
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  CustomExtractFeaturesT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(CustomExtractFeaturesT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<CustomExtractFeatures> Pack(flatbuffers::FlatBufferBuilder &_fbb, const CustomExtractFeaturesT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct CustomExtractFeaturesBuilder {
  typedef CustomExtractFeatures Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit CustomExtractFeaturesBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<CustomExtractFeatures> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<CustomExtractFeatures>(end);
    return o;
  }
};

inline flatbuffers::Offset<CustomExtractFeatures> CreateCustomExtractFeatures(
    flatbuffers::FlatBufferBuilder &_fbb) {
  CustomExtractFeaturesBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<CustomExtractFeatures> CreateCustomExtractFeatures(flatbuffers::FlatBufferBuilder &_fbb, const CustomExtractFeaturesT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct CustomNormalizeT : public flatbuffers::NativeTable {
  typedef CustomNormalize TableType;
};

struct CustomNormalize FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef CustomNormalizeT NativeTableType;
  typedef CustomNormalizeBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return CustomNormalizeTypeTable();
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  CustomNormalizeT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(CustomNormalizeT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<CustomNormalize> Pack(flatbuffers::FlatBufferBuilder &_fbb, const CustomNormalizeT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct CustomNormalizeBuilder {
  typedef CustomNormalize Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit CustomNormalizeBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<CustomNormalize> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<CustomNormalize>(end);
    return o;
  }
};

inline flatbuffers::Offset<CustomNormalize> CreateCustomNormalize(
    flatbuffers::FlatBufferBuilder &_fbb) {
  CustomNormalizeBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<CustomNormalize> CreateCustomNormalize(flatbuffers::FlatBufferBuilder &_fbb, const CustomNormalizeT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct CustomPredictT : public flatbuffers::NativeTable {
  typedef CustomPredict TableType;
  int64_t output_num = 0;
  float weight_threshold = 0.0f;
};

struct CustomPredict FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef CustomPredictT NativeTableType;
  typedef CustomPredictBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return CustomPredictTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_OUTPUT_NUM = 4,
    VT_WEIGHT_THRESHOLD = 6
  };
  int64_t output_num() const {
    return GetField<int64_t>(VT_OUTPUT_NUM, 0);
  }
  bool mutate_output_num(int64_t _output_num) {
    return SetField<int64_t>(VT_OUTPUT_NUM, _output_num, 0);
  }
  float weight_threshold() const {
    return GetField<float>(VT_WEIGHT_THRESHOLD, 0.0f);
  }
  bool mutate_weight_threshold(float _weight_threshold) {
    return SetField<float>(VT_WEIGHT_THRESHOLD, _weight_threshold, 0.0f);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_OUTPUT_NUM) &&
           VerifyField<float>(verifier, VT_WEIGHT_THRESHOLD) &&
           verifier.EndTable();
  }
  CustomPredictT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(CustomPredictT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<CustomPredict> Pack(flatbuffers::FlatBufferBuilder &_fbb, const CustomPredictT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct CustomPredictBuilder {
  typedef CustomPredict Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_output_num(int64_t output_num) {
    fbb_.AddElement<int64_t>(CustomPredict::VT_OUTPUT_NUM, output_num, 0);
  }
  void add_weight_threshold(float weight_threshold) {
    fbb_.AddElement<float>(CustomPredict::VT_WEIGHT_THRESHOLD, weight_threshold, 0.0f);
  }
  explicit CustomPredictBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<CustomPredict> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<CustomPredict>(end);
    return o;
  }
};

inline flatbuffers::Offset<CustomPredict> CreateCustomPredict(
    flatbuffers::FlatBufferBuilder &_fbb,
    int64_t output_num = 0,
    float weight_threshold = 0.0f) {
  CustomPredictBuilder builder_(_fbb);
  builder_.add_output_num(output_num);
  builder_.add_weight_threshold(weight_threshold);
  return builder_.Finish();
}

flatbuffers::Offset<CustomPredict> CreateCustomPredict(flatbuffers::FlatBufferBuilder &_fbb, const CustomPredictT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct DeConv2DGradFilterT : public flatbuffers::NativeTable {
  typedef DeConv2DGradFilter TableType;
  int64_t in_channel = 0;
  int64_t out_channel = 0;
  std::vector<int64_t> kernel_size{};
  mindspore::schema::PadMode pad_mode = mindspore::schema::PadMode_PAD;
  std::vector<int64_t> pad_list{};
  std::vector<int64_t> stride{};
  std::vector<int64_t> dilation{};
  int64_t group = 0;
  mindspore::schema::Format format = mindspore::schema::Format_NCHW;
  mindspore::schema::ActivationType activation_type = mindspore::schema::ActivationType_NO_ACTIVATION;
};

struct DeConv2DGradFilter FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef DeConv2DGradFilterT NativeTableType;
  typedef DeConv2DGradFilterBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return DeConv2DGradFilterTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_IN_CHANNEL = 4,
    VT_OUT_CHANNEL = 6,
    VT_KERNEL_SIZE = 8,
    VT_PAD_MODE = 10,
    VT_PAD_LIST = 12,
    VT_STRIDE = 14,
    VT_DILATION = 16,
    VT_GROUP = 18,
    VT_FORMAT = 20,
    VT_ACTIVATION_TYPE = 22
  };
  int64_t in_channel() const {
    return GetField<int64_t>(VT_IN_CHANNEL, 0);
  }
  bool mutate_in_channel(int64_t _in_channel) {
    return SetField<int64_t>(VT_IN_CHANNEL, _in_channel, 0);
  }
  int64_t out_channel() const {
    return GetField<int64_t>(VT_OUT_CHANNEL, 0);
  }
  bool mutate_out_channel(int64_t _out_channel) {
    return SetField<int64_t>(VT_OUT_CHANNEL, _out_channel, 0);
  }
  const flatbuffers::Vector<int64_t> *kernel_size() const {
    return GetPointer<const flatbuffers::Vector<int64_t> *>(VT_KERNEL_SIZE);
  }
  flatbuffers::Vector<int64_t> *mutable_kernel_size() {
    return GetPointer<flatbuffers::Vector<int64_t> *>(VT_KERNEL_SIZE);
  }
  mindspore::schema::PadMode pad_mode() const {
    return static_cast<mindspore::schema::PadMode>(GetField<int8_t>(VT_PAD_MODE, 0));
  }
  bool mutate_pad_mode(mindspore::schema::PadMode _pad_mode) {
    return SetField<int8_t>(VT_PAD_MODE, static_cast<int8_t>(_pad_mode), 0);
  }
  const flatbuffers::Vector<int64_t> *pad_list() const {
    return GetPointer<const flatbuffers::Vector<int64_t> *>(VT_PAD_LIST);
  }
  flatbuffers::Vector<int64_t> *mutable_pad_list() {
    return GetPointer<flatbuffers::Vector<int64_t> *>(VT_PAD_LIST);
  }
  const flatbuffers::Vector<int64_t> *stride() const {
    return GetPointer<const flatbuffers::Vector<int64_t> *>(VT_STRIDE);
  }
  flatbuffers::Vector<int64_t> *mutable_stride() {
    return GetPointer<flatbuffers::Vector<int64_t> *>(VT_STRIDE);
  }
  const flatbuffers::Vector<int64_t> *dilation() const {
    return GetPointer<const flatbuffers::Vector<int64_t> *>(VT_DILATION);
  }
  flatbuffers::Vector<int64_t> *mutable_dilation() {
    return GetPointer<flatbuffers::Vector<int64_t> *>(VT_DILATION);
  }
  int64_t group() const {
    return GetField<int64_t>(VT_GROUP, 0);
  }
  bool mutate_group(int64_t _group) {
    return SetField<int64_t>(VT_GROUP, _group, 0);
  }
  mindspore::schema::Format format() const {
    return static_cast<mindspore::schema::Format>(GetField<int32_t>(VT_FORMAT, 0));
  }
  bool mutate_format(mindspore::schema::Format _format) {
    return SetField<int32_t>(VT_FORMAT, static_cast<int32_t>(_format), 0);
  }
  mindspore::schema::ActivationType activation_type() const {
    return static_cast<mindspore::schema::ActivationType>(GetField<int8_t>(VT_ACTIVATION_TYPE, 0));
  }
  bool mutate_activation_type(mindspore::schema::ActivationType _activation_type) {
    return SetField<int8_t>(VT_ACTIVATION_TYPE, static_cast<int8_t>(_activation_type), 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_IN_CHANNEL) &&
           VerifyField<int64_t>(verifier, VT_OUT_CHANNEL) &&
           VerifyOffset(verifier, VT_KERNEL_SIZE) &&
           verifier.VerifyVector(kernel_size()) &&
           VerifyField<int8_t>(verifier, VT_PAD_MODE) &&
           VerifyOffset(verifier, VT_PAD_LIST) &&
           verifier.VerifyVector(pad_list()) &&
           VerifyOffset(verifier, VT_STRIDE) &&
           verifier.VerifyVector(stride()) &&
           VerifyOffset(verifier, VT_DILATION) &&
           verifier.VerifyVector(dilation()) &&
           VerifyField<int64_t>(verifier, VT_GROUP) &&
           VerifyField<int32_t>(verifier, VT_FORMAT) &&
           VerifyField<int8_t>(verifier, VT_ACTIVATION_TYPE) &&
           verifier.EndTable();
  }
  DeConv2DGradFilterT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(DeConv2DGradFilterT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<DeConv2DGradFilter> Pack(flatbuffers::FlatBufferBuilder &_fbb, const DeConv2DGradFilterT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct DeConv2DGradFilterBuilder {
  typedef DeConv2DGradFilter Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_in_channel(int64_t in_channel) {
    fbb_.AddElement<int64_t>(DeConv2DGradFilter::VT_IN_CHANNEL, in_channel, 0);
  }
  void add_out_channel(int64_t out_channel) {
    fbb_.AddElement<int64_t>(DeConv2DGradFilter::VT_OUT_CHANNEL, out_channel, 0);
  }
  void add_kernel_size(flatbuffers::Offset<flatbuffers::Vector<int64_t>> kernel_size) {
    fbb_.AddOffset(DeConv2DGradFilter::VT_KERNEL_SIZE, kernel_size);
  }
  void add_pad_mode(mindspore::schema::PadMode pad_mode) {
    fbb_.AddElement<int8_t>(DeConv2DGradFilter::VT_PAD_MODE, static_cast<int8_t>(pad_mode), 0);
  }
  void add_pad_list(flatbuffers::Offset<flatbuffers::Vector<int64_t>> pad_list) {
    fbb_.AddOffset(DeConv2DGradFilter::VT_PAD_LIST, pad_list);
  }
  void add_stride(flatbuffers::Offset<flatbuffers::Vector<int64_t>> stride) {
    fbb_.AddOffset(DeConv2DGradFilter::VT_STRIDE, stride);
  }
  void add_dilation(flatbuffers::Offset<flatbuffers::Vector<int64_t>> dilation) {
    fbb_.AddOffset(DeConv2DGradFilter::VT_DILATION, dilation);
  }
  void add_group(int64_t group) {
    fbb_.AddElement<int64_t>(DeConv2DGradFilter::VT_GROUP, group, 0);
  }
  void add_format(mindspore::schema::Format format) {
    fbb_.AddElement<int32_t>(DeConv2DGradFilter::VT_FORMAT, static_cast<int32_t>(format), 0);
  }
  void add_activation_type(mindspore::schema::ActivationType activation_type) {
    fbb_.AddElement<int8_t>(DeConv2DGradFilter::VT_ACTIVATION_TYPE, static_cast<int8_t>(activation_type), 0);
  }
  explicit DeConv2DGradFilterBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<DeConv2DGradFilter> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<DeConv2DGradFilter>(end);
    return o;
  }
};

inline flatbuffers::Offset<DeConv2DGradFilter> CreateDeConv2DGradFilter(
    flatbuffers::FlatBufferBuilder &_fbb,
    int64_t in_channel = 0,
    int64_t out_channel = 0,
    flatbuffers::Offset<flatbuffers::Vector<int64_t>> kernel_size = 0,
    mindspore::schema::PadMode pad_mode = mindspore::schema::PadMode_PAD,
    flatbuffers::Offset<flatbuffers::Vector<int64_t>> pad_list = 0,
    flatbuffers::Offset<flatbuffers::Vector<int64_t>> stride = 0,
    flatbuffers::Offset<flatbuffers::Vector<int64_t>> dilation = 0,
    int64_t group = 0,
    mindspore::schema::Format format = mindspore::schema::Format_NCHW,
    mindspore::schema::ActivationType activation_type = mindspore::schema::ActivationType_NO_ACTIVATION) {
  DeConv2DGradFilterBuilder builder_(_fbb);
  builder_.add_group(group);
  builder_.add_out_channel(out_channel);
  builder_.add_in_channel(in_channel);
  builder_.add_format(format);
  builder_.add_dilation(dilation);
  builder_.add_stride(stride);
  builder_.add_pad_list(pad_list);
  builder_.add_kernel_size(kernel_size);
  builder_.add_activation_type(activation_type);
  builder_.add_pad_mode(pad_mode);
  return builder_.Finish();
}

inline flatbuffers::Offset<DeConv2DGradFilter> CreateDeConv2DGradFilterDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int64_t in_channel = 0,
    int64_t out_channel = 0,
    const std::vector<int64_t> *kernel_size = nullptr,
    mindspore::schema::PadMode pad_mode = mindspore::schema::PadMode_PAD,
    const std::vector<int64_t> *pad_list = nullptr,
    const std::vector<int64_t> *stride = nullptr,
    const std::vector<int64_t> *dilation = nullptr,
    int64_t group = 0,
    mindspore::schema::Format format = mindspore::schema::Format_NCHW,
    mindspore::schema::ActivationType activation_type = mindspore::schema::ActivationType_NO_ACTIVATION) {
  auto kernel_size__ = kernel_size ? _fbb.CreateVector<int64_t>(*kernel_size) : 0;
  auto pad_list__ = pad_list ? _fbb.CreateVector<int64_t>(*pad_list) : 0;
  auto stride__ = stride ? _fbb.CreateVector<int64_t>(*stride) : 0;
  auto dilation__ = dilation ? _fbb.CreateVector<int64_t>(*dilation) : 0;
  return mindspore::schema::CreateDeConv2DGradFilter(
      _fbb,
      in_channel,
      out_channel,
      kernel_size__,
      pad_mode,
      pad_list__,
      stride__,
      dilation__,
      group,
      format,
      activation_type);
}

flatbuffers::Offset<DeConv2DGradFilter> CreateDeConv2DGradFilter(flatbuffers::FlatBufferBuilder &_fbb, const DeConv2DGradFilterT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct DependT : public flatbuffers::NativeTable {
  typedef Depend TableType;
};

struct Depend FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef DependT NativeTableType;
  typedef DependBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return DependTypeTable();
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  DependT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(DependT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Depend> Pack(flatbuffers::FlatBufferBuilder &_fbb, const DependT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct DependBuilder {
  typedef Depend Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit DependBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Depend> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Depend>(end);
    return o;
  }
};

inline flatbuffers::Offset<Depend> CreateDepend(
    flatbuffers::FlatBufferBuilder &_fbb) {
  DependBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<Depend> CreateDepend(flatbuffers::FlatBufferBuilder &_fbb, const DependT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct DepthToSpaceT : public flatbuffers::NativeTable {
  typedef DepthToSpace TableType;
  int64_t block_size = 0;
  mindspore::schema::Format format = mindspore::schema::Format_NCHW;
};

struct DepthToSpace FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef DepthToSpaceT NativeTableType;
  typedef DepthToSpaceBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return DepthToSpaceTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_BLOCK_SIZE = 4,
    VT_FORMAT = 6
  };
  int64_t block_size() const {
    return GetField<int64_t>(VT_BLOCK_SIZE, 0);
  }
  bool mutate_block_size(int64_t _block_size) {
    return SetField<int64_t>(VT_BLOCK_SIZE, _block_size, 0);
  }
  mindspore::schema::Format format() const {
    return static_cast<mindspore::schema::Format>(GetField<int32_t>(VT_FORMAT, 0));
  }
  bool mutate_format(mindspore::schema::Format _format) {
    return SetField<int32_t>(VT_FORMAT, static_cast<int32_t>(_format), 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_BLOCK_SIZE) &&
           VerifyField<int32_t>(verifier, VT_FORMAT) &&
           verifier.EndTable();
  }
  DepthToSpaceT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(DepthToSpaceT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<DepthToSpace> Pack(flatbuffers::FlatBufferBuilder &_fbb, const DepthToSpaceT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct DepthToSpaceBuilder {
  typedef DepthToSpace Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_block_size(int64_t block_size) {
    fbb_.AddElement<int64_t>(DepthToSpace::VT_BLOCK_SIZE, block_size, 0);
  }
  void add_format(mindspore::schema::Format format) {
    fbb_.AddElement<int32_t>(DepthToSpace::VT_FORMAT, static_cast<int32_t>(format), 0);
  }
  explicit DepthToSpaceBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<DepthToSpace> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<DepthToSpace>(end);
    return o;
  }
};

inline flatbuffers::Offset<DepthToSpace> CreateDepthToSpace(
    flatbuffers::FlatBufferBuilder &_fbb,
    int64_t block_size = 0,
    mindspore::schema::Format format = mindspore::schema::Format_NCHW) {
  DepthToSpaceBuilder builder_(_fbb);
  builder_.add_block_size(block_size);
  builder_.add_format(format);
  return builder_.Finish();
}

flatbuffers::Offset<DepthToSpace> CreateDepthToSpace(flatbuffers::FlatBufferBuilder &_fbb, const DepthToSpaceT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct DetectionPostProcessT : public flatbuffers::NativeTable {
  typedef DetectionPostProcess TableType;
  mindspore::schema::Format format = mindspore::schema::Format_NCHW;
  int64_t input_size = 0;
  std::vector<float> scale{};
  float nms_iou_threshold = 0.0f;
  float nms_score_threshold = 0.0f;
  int64_t max_detections = 0;
  int64_t detections_per_class = 0;
  int64_t max_classes_per_detection = 0;
  int64_t num_classes = 0;
  bool use_regular_nms = false;
  bool out_quantized = false;
};

struct DetectionPostProcess FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef DetectionPostProcessT NativeTableType;
  typedef DetectionPostProcessBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return DetectionPostProcessTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_FORMAT = 4,
    VT_INPUT_SIZE = 6,
    VT_SCALE = 8,
    VT_NMS_IOU_THRESHOLD = 10,
    VT_NMS_SCORE_THRESHOLD = 12,
    VT_MAX_DETECTIONS = 14,
    VT_DETECTIONS_PER_CLASS = 16,
    VT_MAX_CLASSES_PER_DETECTION = 18,
    VT_NUM_CLASSES = 20,
    VT_USE_REGULAR_NMS = 22,
    VT_OUT_QUANTIZED = 24
  };
  mindspore::schema::Format format() const {
    return static_cast<mindspore::schema::Format>(GetField<int32_t>(VT_FORMAT, 0));
  }
  bool mutate_format(mindspore::schema::Format _format) {
    return SetField<int32_t>(VT_FORMAT, static_cast<int32_t>(_format), 0);
  }
  int64_t input_size() const {
    return GetField<int64_t>(VT_INPUT_SIZE, 0);
  }
  bool mutate_input_size(int64_t _input_size) {
    return SetField<int64_t>(VT_INPUT_SIZE, _input_size, 0);
  }
  const flatbuffers::Vector<float> *scale() const {
    return GetPointer<const flatbuffers::Vector<float> *>(VT_SCALE);
  }
  flatbuffers::Vector<float> *mutable_scale() {
    return GetPointer<flatbuffers::Vector<float> *>(VT_SCALE);
  }
  float nms_iou_threshold() const {
    return GetField<float>(VT_NMS_IOU_THRESHOLD, 0.0f);
  }
  bool mutate_nms_iou_threshold(float _nms_iou_threshold) {
    return SetField<float>(VT_NMS_IOU_THRESHOLD, _nms_iou_threshold, 0.0f);
  }
  float nms_score_threshold() const {
    return GetField<float>(VT_NMS_SCORE_THRESHOLD, 0.0f);
  }
  bool mutate_nms_score_threshold(float _nms_score_threshold) {
    return SetField<float>(VT_NMS_SCORE_THRESHOLD, _nms_score_threshold, 0.0f);
  }
  int64_t max_detections() const {
    return GetField<int64_t>(VT_MAX_DETECTIONS, 0);
  }
  bool mutate_max_detections(int64_t _max_detections) {
    return SetField<int64_t>(VT_MAX_DETECTIONS, _max_detections, 0);
  }
  int64_t detections_per_class() const {
    return GetField<int64_t>(VT_DETECTIONS_PER_CLASS, 0);
  }
  bool mutate_detections_per_class(int64_t _detections_per_class) {
    return SetField<int64_t>(VT_DETECTIONS_PER_CLASS, _detections_per_class, 0);
  }
  int64_t max_classes_per_detection() const {
    return GetField<int64_t>(VT_MAX_CLASSES_PER_DETECTION, 0);
  }
  bool mutate_max_classes_per_detection(int64_t _max_classes_per_detection) {
    return SetField<int64_t>(VT_MAX_CLASSES_PER_DETECTION, _max_classes_per_detection, 0);
  }
  int64_t num_classes() const {
    return GetField<int64_t>(VT_NUM_CLASSES, 0);
  }
  bool mutate_num_classes(int64_t _num_classes) {
    return SetField<int64_t>(VT_NUM_CLASSES, _num_classes, 0);
  }
  bool use_regular_nms() const {
    return GetField<uint8_t>(VT_USE_REGULAR_NMS, 0) != 0;
  }
  bool mutate_use_regular_nms(bool _use_regular_nms) {
    return SetField<uint8_t>(VT_USE_REGULAR_NMS, static_cast<uint8_t>(_use_regular_nms), 0);
  }
  bool out_quantized() const {
    return GetField<uint8_t>(VT_OUT_QUANTIZED, 0) != 0;
  }
  bool mutate_out_quantized(bool _out_quantized) {
    return SetField<uint8_t>(VT_OUT_QUANTIZED, static_cast<uint8_t>(_out_quantized), 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_FORMAT) &&
           VerifyField<int64_t>(verifier, VT_INPUT_SIZE) &&
           VerifyOffset(verifier, VT_SCALE) &&
           verifier.VerifyVector(scale()) &&
           VerifyField<float>(verifier, VT_NMS_IOU_THRESHOLD) &&
           VerifyField<float>(verifier, VT_NMS_SCORE_THRESHOLD) &&
           VerifyField<int64_t>(verifier, VT_MAX_DETECTIONS) &&
           VerifyField<int64_t>(verifier, VT_DETECTIONS_PER_CLASS) &&
           VerifyField<int64_t>(verifier, VT_MAX_CLASSES_PER_DETECTION) &&
           VerifyField<int64_t>(verifier, VT_NUM_CLASSES) &&
           VerifyField<uint8_t>(verifier, VT_USE_REGULAR_NMS) &&
           VerifyField<uint8_t>(verifier, VT_OUT_QUANTIZED) &&
           verifier.EndTable();
  }
  DetectionPostProcessT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(DetectionPostProcessT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<DetectionPostProcess> Pack(flatbuffers::FlatBufferBuilder &_fbb, const DetectionPostProcessT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct DetectionPostProcessBuilder {
  typedef DetectionPostProcess Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_format(mindspore::schema::Format format) {
    fbb_.AddElement<int32_t>(DetectionPostProcess::VT_FORMAT, static_cast<int32_t>(format), 0);
  }
  void add_input_size(int64_t input_size) {
    fbb_.AddElement<int64_t>(DetectionPostProcess::VT_INPUT_SIZE, input_size, 0);
  }
  void add_scale(flatbuffers::Offset<flatbuffers::Vector<float>> scale) {
    fbb_.AddOffset(DetectionPostProcess::VT_SCALE, scale);
  }
  void add_nms_iou_threshold(float nms_iou_threshold) {
    fbb_.AddElement<float>(DetectionPostProcess::VT_NMS_IOU_THRESHOLD, nms_iou_threshold, 0.0f);
  }
  void add_nms_score_threshold(float nms_score_threshold) {
    fbb_.AddElement<float>(DetectionPostProcess::VT_NMS_SCORE_THRESHOLD, nms_score_threshold, 0.0f);
  }
  void add_max_detections(int64_t max_detections) {
    fbb_.AddElement<int64_t>(DetectionPostProcess::VT_MAX_DETECTIONS, max_detections, 0);
  }
  void add_detections_per_class(int64_t detections_per_class) {
    fbb_.AddElement<int64_t>(DetectionPostProcess::VT_DETECTIONS_PER_CLASS, detections_per_class, 0);
  }
  void add_max_classes_per_detection(int64_t max_classes_per_detection) {
    fbb_.AddElement<int64_t>(DetectionPostProcess::VT_MAX_CLASSES_PER_DETECTION, max_classes_per_detection, 0);
  }
  void add_num_classes(int64_t num_classes) {
    fbb_.AddElement<int64_t>(DetectionPostProcess::VT_NUM_CLASSES, num_classes, 0);
  }
  void add_use_regular_nms(bool use_regular_nms) {
    fbb_.AddElement<uint8_t>(DetectionPostProcess::VT_USE_REGULAR_NMS, static_cast<uint8_t>(use_regular_nms), 0);
  }
  void add_out_quantized(bool out_quantized) {
    fbb_.AddElement<uint8_t>(DetectionPostProcess::VT_OUT_QUANTIZED, static_cast<uint8_t>(out_quantized), 0);
  }
  explicit DetectionPostProcessBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<DetectionPostProcess> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<DetectionPostProcess>(end);
    return o;
  }
};

inline flatbuffers::Offset<DetectionPostProcess> CreateDetectionPostProcess(
    flatbuffers::FlatBufferBuilder &_fbb,
    mindspore::schema::Format format = mindspore::schema::Format_NCHW,
    int64_t input_size = 0,
    flatbuffers::Offset<flatbuffers::Vector<float>> scale = 0,
    float nms_iou_threshold = 0.0f,
    float nms_score_threshold = 0.0f,
    int64_t max_detections = 0,
    int64_t detections_per_class = 0,
    int64_t max_classes_per_detection = 0,
    int64_t num_classes = 0,
    bool use_regular_nms = false,
    bool out_quantized = false) {
  DetectionPostProcessBuilder builder_(_fbb);
  builder_.add_num_classes(num_classes);
  builder_.add_max_classes_per_detection(max_classes_per_detection);
  builder_.add_detections_per_class(detections_per_class);
  builder_.add_max_detections(max_detections);
  builder_.add_input_size(input_size);
  builder_.add_nms_score_threshold(nms_score_threshold);
  builder_.add_nms_iou_threshold(nms_iou_threshold);
  builder_.add_scale(scale);
  builder_.add_format(format);
  builder_.add_out_quantized(out_quantized);
  builder_.add_use_regular_nms(use_regular_nms);
  return builder_.Finish();
}

inline flatbuffers::Offset<DetectionPostProcess> CreateDetectionPostProcessDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    mindspore::schema::Format format = mindspore::schema::Format_NCHW,
    int64_t input_size = 0,
    const std::vector<float> *scale = nullptr,
    float nms_iou_threshold = 0.0f,
    float nms_score_threshold = 0.0f,
    int64_t max_detections = 0,
    int64_t detections_per_class = 0,
    int64_t max_classes_per_detection = 0,
    int64_t num_classes = 0,
    bool use_regular_nms = false,
    bool out_quantized = false) {
  auto scale__ = scale ? _fbb.CreateVector<float>(*scale) : 0;
  return mindspore::schema::CreateDetectionPostProcess(
      _fbb,
      format,
      input_size,
      scale__,
      nms_iou_threshold,
      nms_score_threshold,
      max_detections,
      detections_per_class,
      max_classes_per_detection,
      num_classes,
      use_regular_nms,
      out_quantized);
}

flatbuffers::Offset<DetectionPostProcess> CreateDetectionPostProcess(flatbuffers::FlatBufferBuilder &_fbb, const DetectionPostProcessT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct DivFusionT : public flatbuffers::NativeTable {
  typedef DivFusion TableType;
  mindspore::schema::ActivationType activation_type = mindspore::schema::ActivationType_NO_ACTIVATION;
};

struct DivFusion FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef DivFusionT NativeTableType;
  typedef DivFusionBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return DivFusionTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ACTIVATION_TYPE = 4
  };
  mindspore::schema::ActivationType activation_type() const {
    return static_cast<mindspore::schema::ActivationType>(GetField<int8_t>(VT_ACTIVATION_TYPE, 0));
  }
  bool mutate_activation_type(mindspore::schema::ActivationType _activation_type) {
    return SetField<int8_t>(VT_ACTIVATION_TYPE, static_cast<int8_t>(_activation_type), 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_ACTIVATION_TYPE) &&
           verifier.EndTable();
  }
  DivFusionT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(DivFusionT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<DivFusion> Pack(flatbuffers::FlatBufferBuilder &_fbb, const DivFusionT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct DivFusionBuilder {
  typedef DivFusion Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_activation_type(mindspore::schema::ActivationType activation_type) {
    fbb_.AddElement<int8_t>(DivFusion::VT_ACTIVATION_TYPE, static_cast<int8_t>(activation_type), 0);
  }
  explicit DivFusionBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<DivFusion> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<DivFusion>(end);
    return o;
  }
};

inline flatbuffers::Offset<DivFusion> CreateDivFusion(
    flatbuffers::FlatBufferBuilder &_fbb,
    mindspore::schema::ActivationType activation_type = mindspore::schema::ActivationType_NO_ACTIVATION) {
  DivFusionBuilder builder_(_fbb);
  builder_.add_activation_type(activation_type);
  return builder_.Finish();
}

flatbuffers::Offset<DivFusion> CreateDivFusion(flatbuffers::FlatBufferBuilder &_fbb, const DivFusionT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct DivGradT : public flatbuffers::NativeTable {
  typedef DivGrad TableType;
};

struct DivGrad FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef DivGradT NativeTableType;
  typedef DivGradBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return DivGradTypeTable();
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  DivGradT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(DivGradT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<DivGrad> Pack(flatbuffers::FlatBufferBuilder &_fbb, const DivGradT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct DivGradBuilder {
  typedef DivGrad Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit DivGradBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<DivGrad> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<DivGrad>(end);
    return o;
  }
};

inline flatbuffers::Offset<DivGrad> CreateDivGrad(
    flatbuffers::FlatBufferBuilder &_fbb) {
  DivGradBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<DivGrad> CreateDivGrad(flatbuffers::FlatBufferBuilder &_fbb, const DivGradT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct DropoutT : public flatbuffers::NativeTable {
  typedef Dropout TableType;
  float keep_prob = 0.5f;
};

struct Dropout FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef DropoutT NativeTableType;
  typedef DropoutBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return DropoutTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_KEEP_PROB = 4
  };
  float keep_prob() const {
    return GetField<float>(VT_KEEP_PROB, 0.5f);
  }
  bool mutate_keep_prob(float _keep_prob) {
    return SetField<float>(VT_KEEP_PROB, _keep_prob, 0.5f);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<float>(verifier, VT_KEEP_PROB) &&
           verifier.EndTable();
  }
  DropoutT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(DropoutT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Dropout> Pack(flatbuffers::FlatBufferBuilder &_fbb, const DropoutT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct DropoutBuilder {
  typedef Dropout Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_keep_prob(float keep_prob) {
    fbb_.AddElement<float>(Dropout::VT_KEEP_PROB, keep_prob, 0.5f);
  }
  explicit DropoutBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Dropout> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Dropout>(end);
    return o;
  }
};

inline flatbuffers::Offset<Dropout> CreateDropout(
    flatbuffers::FlatBufferBuilder &_fbb,
    float keep_prob = 0.5f) {
  DropoutBuilder builder_(_fbb);
  builder_.add_keep_prob(keep_prob);
  return builder_.Finish();
}

flatbuffers::Offset<Dropout> CreateDropout(flatbuffers::FlatBufferBuilder &_fbb, const DropoutT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct DropoutGradT : public flatbuffers::NativeTable {
  typedef DropoutGrad TableType;
  float keep_prob = 0.0f;
};

struct DropoutGrad FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef DropoutGradT NativeTableType;
  typedef DropoutGradBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return DropoutGradTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_KEEP_PROB = 4
  };
  float keep_prob() const {
    return GetField<float>(VT_KEEP_PROB, 0.0f);
  }
  bool mutate_keep_prob(float _keep_prob) {
    return SetField<float>(VT_KEEP_PROB, _keep_prob, 0.0f);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<float>(verifier, VT_KEEP_PROB) &&
           verifier.EndTable();
  }
  DropoutGradT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(DropoutGradT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<DropoutGrad> Pack(flatbuffers::FlatBufferBuilder &_fbb, const DropoutGradT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct DropoutGradBuilder {
  typedef DropoutGrad Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_keep_prob(float keep_prob) {
    fbb_.AddElement<float>(DropoutGrad::VT_KEEP_PROB, keep_prob, 0.0f);
  }
  explicit DropoutGradBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<DropoutGrad> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<DropoutGrad>(end);
    return o;
  }
};

inline flatbuffers::Offset<DropoutGrad> CreateDropoutGrad(
    flatbuffers::FlatBufferBuilder &_fbb,
    float keep_prob = 0.0f) {
  DropoutGradBuilder builder_(_fbb);
  builder_.add_keep_prob(keep_prob);
  return builder_.Finish();
}

flatbuffers::Offset<DropoutGrad> CreateDropoutGrad(flatbuffers::FlatBufferBuilder &_fbb, const DropoutGradT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct EluT : public flatbuffers::NativeTable {
  typedef Elu TableType;
  float alpha = 0.0f;
};

struct Elu FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef EluT NativeTableType;
  typedef EluBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return EluTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ALPHA = 4
  };
  float alpha() const {
    return GetField<float>(VT_ALPHA, 0.0f);
  }
  bool mutate_alpha(float _alpha) {
    return SetField<float>(VT_ALPHA, _alpha, 0.0f);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<float>(verifier, VT_ALPHA) &&
           verifier.EndTable();
  }
  EluT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(EluT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Elu> Pack(flatbuffers::FlatBufferBuilder &_fbb, const EluT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct EluBuilder {
  typedef Elu Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_alpha(float alpha) {
    fbb_.AddElement<float>(Elu::VT_ALPHA, alpha, 0.0f);
  }
  explicit EluBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Elu> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Elu>(end);
    return o;
  }
};

inline flatbuffers::Offset<Elu> CreateElu(
    flatbuffers::FlatBufferBuilder &_fbb,
    float alpha = 0.0f) {
  EluBuilder builder_(_fbb);
  builder_.add_alpha(alpha);
  return builder_.Finish();
}

flatbuffers::Offset<Elu> CreateElu(flatbuffers::FlatBufferBuilder &_fbb, const EluT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct EltwiseT : public flatbuffers::NativeTable {
  typedef Eltwise TableType;
  mindspore::schema::EltwiseMode mode = mindspore::schema::EltwiseMode_PROD;
};

struct Eltwise FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef EltwiseT NativeTableType;
  typedef EltwiseBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return EltwiseTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_MODE = 4
  };
  mindspore::schema::EltwiseMode mode() const {
    return static_cast<mindspore::schema::EltwiseMode>(GetField<int8_t>(VT_MODE, 0));
  }
  bool mutate_mode(mindspore::schema::EltwiseMode _mode) {
    return SetField<int8_t>(VT_MODE, static_cast<int8_t>(_mode), 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_MODE) &&
           verifier.EndTable();
  }
  EltwiseT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(EltwiseT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Eltwise> Pack(flatbuffers::FlatBufferBuilder &_fbb, const EltwiseT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct EltwiseBuilder {
  typedef Eltwise Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_mode(mindspore::schema::EltwiseMode mode) {
    fbb_.AddElement<int8_t>(Eltwise::VT_MODE, static_cast<int8_t>(mode), 0);
  }
  explicit EltwiseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Eltwise> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Eltwise>(end);
    return o;
  }
};

inline flatbuffers::Offset<Eltwise> CreateEltwise(
    flatbuffers::FlatBufferBuilder &_fbb,
    mindspore::schema::EltwiseMode mode = mindspore::schema::EltwiseMode_PROD) {
  EltwiseBuilder builder_(_fbb);
  builder_.add_mode(mode);
  return builder_.Finish();
}

flatbuffers::Offset<Eltwise> CreateEltwise(flatbuffers::FlatBufferBuilder &_fbb, const EltwiseT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct EqualT : public flatbuffers::NativeTable {
  typedef Equal TableType;
};

struct Equal FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef EqualT NativeTableType;
  typedef EqualBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return EqualTypeTable();
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  EqualT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(EqualT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Equal> Pack(flatbuffers::FlatBufferBuilder &_fbb, const EqualT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct EqualBuilder {
  typedef Equal Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit EqualBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Equal> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Equal>(end);
    return o;
  }
};

inline flatbuffers::Offset<Equal> CreateEqual(
    flatbuffers::FlatBufferBuilder &_fbb) {
  EqualBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<Equal> CreateEqual(flatbuffers::FlatBufferBuilder &_fbb, const EqualT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct EmbeddingLookupFusionT : public flatbuffers::NativeTable {
  typedef EmbeddingLookupFusion TableType;
  float max_norm = 0.0f;
};

struct EmbeddingLookupFusion FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef EmbeddingLookupFusionT NativeTableType;
  typedef EmbeddingLookupFusionBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return EmbeddingLookupFusionTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_MAX_NORM = 4
  };
  float max_norm() const {
    return GetField<float>(VT_MAX_NORM, 0.0f);
  }
  bool mutate_max_norm(float _max_norm) {
    return SetField<float>(VT_MAX_NORM, _max_norm, 0.0f);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<float>(verifier, VT_MAX_NORM) &&
           verifier.EndTable();
  }
  EmbeddingLookupFusionT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(EmbeddingLookupFusionT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<EmbeddingLookupFusion> Pack(flatbuffers::FlatBufferBuilder &_fbb, const EmbeddingLookupFusionT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct EmbeddingLookupFusionBuilder {
  typedef EmbeddingLookupFusion Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_max_norm(float max_norm) {
    fbb_.AddElement<float>(EmbeddingLookupFusion::VT_MAX_NORM, max_norm, 0.0f);
  }
  explicit EmbeddingLookupFusionBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<EmbeddingLookupFusion> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<EmbeddingLookupFusion>(end);
    return o;
  }
};

inline flatbuffers::Offset<EmbeddingLookupFusion> CreateEmbeddingLookupFusion(
    flatbuffers::FlatBufferBuilder &_fbb,
    float max_norm = 0.0f) {
  EmbeddingLookupFusionBuilder builder_(_fbb);
  builder_.add_max_norm(max_norm);
  return builder_.Finish();
}

flatbuffers::Offset<EmbeddingLookupFusion> CreateEmbeddingLookupFusion(flatbuffers::FlatBufferBuilder &_fbb, const EmbeddingLookupFusionT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ExpFusionT : public flatbuffers::NativeTable {
  typedef ExpFusion TableType;
  float base = -1.0f;
  float scale = 1.0f;
  float shift = 0.0f;
};

struct ExpFusion FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ExpFusionT NativeTableType;
  typedef ExpFusionBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return ExpFusionTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_BASE = 4,
    VT_SCALE = 6,
    VT_SHIFT = 8
  };
  float base() const {
    return GetField<float>(VT_BASE, -1.0f);
  }
  bool mutate_base(float _base) {
    return SetField<float>(VT_BASE, _base, -1.0f);
  }
  float scale() const {
    return GetField<float>(VT_SCALE, 1.0f);
  }
  bool mutate_scale(float _scale) {
    return SetField<float>(VT_SCALE, _scale, 1.0f);
  }
  float shift() const {
    return GetField<float>(VT_SHIFT, 0.0f);
  }
  bool mutate_shift(float _shift) {
    return SetField<float>(VT_SHIFT, _shift, 0.0f);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<float>(verifier, VT_BASE) &&
           VerifyField<float>(verifier, VT_SCALE) &&
           VerifyField<float>(verifier, VT_SHIFT) &&
           verifier.EndTable();
  }
  ExpFusionT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ExpFusionT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<ExpFusion> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ExpFusionT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ExpFusionBuilder {
  typedef ExpFusion Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_base(float base) {
    fbb_.AddElement<float>(ExpFusion::VT_BASE, base, -1.0f);
  }
  void add_scale(float scale) {
    fbb_.AddElement<float>(ExpFusion::VT_SCALE, scale, 1.0f);
  }
  void add_shift(float shift) {
    fbb_.AddElement<float>(ExpFusion::VT_SHIFT, shift, 0.0f);
  }
  explicit ExpFusionBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<ExpFusion> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ExpFusion>(end);
    return o;
  }
};

inline flatbuffers::Offset<ExpFusion> CreateExpFusion(
    flatbuffers::FlatBufferBuilder &_fbb,
    float base = -1.0f,
    float scale = 1.0f,
    float shift = 0.0f) {
  ExpFusionBuilder builder_(_fbb);
  builder_.add_shift(shift);
  builder_.add_scale(scale);
  builder_.add_base(base);
  return builder_.Finish();
}

flatbuffers::Offset<ExpFusion> CreateExpFusion(flatbuffers::FlatBufferBuilder &_fbb, const ExpFusionT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ExpandDimsT : public flatbuffers::NativeTable {
  typedef ExpandDims TableType;
};

struct ExpandDims FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ExpandDimsT NativeTableType;
  typedef ExpandDimsBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return ExpandDimsTypeTable();
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  ExpandDimsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ExpandDimsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<ExpandDims> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ExpandDimsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ExpandDimsBuilder {
  typedef ExpandDims Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit ExpandDimsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<ExpandDims> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ExpandDims>(end);
    return o;
  }
};

inline flatbuffers::Offset<ExpandDims> CreateExpandDims(
    flatbuffers::FlatBufferBuilder &_fbb) {
  ExpandDimsBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<ExpandDims> CreateExpandDims(flatbuffers::FlatBufferBuilder &_fbb, const ExpandDimsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct FakeQuantWithMinMaxVarsT : public flatbuffers::NativeTable {
  typedef FakeQuantWithMinMaxVars TableType;
  int64_t num_bits = 0;
  bool narrow_range = false;
};

struct FakeQuantWithMinMaxVars FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef FakeQuantWithMinMaxVarsT NativeTableType;
  typedef FakeQuantWithMinMaxVarsBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return FakeQuantWithMinMaxVarsTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NUM_BITS = 4,
    VT_NARROW_RANGE = 6
  };
  int64_t num_bits() const {
    return GetField<int64_t>(VT_NUM_BITS, 0);
  }
  bool mutate_num_bits(int64_t _num_bits) {
    return SetField<int64_t>(VT_NUM_BITS, _num_bits, 0);
  }
  bool narrow_range() const {
    return GetField<uint8_t>(VT_NARROW_RANGE, 0) != 0;
  }
  bool mutate_narrow_range(bool _narrow_range) {
    return SetField<uint8_t>(VT_NARROW_RANGE, static_cast<uint8_t>(_narrow_range), 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_NUM_BITS) &&
           VerifyField<uint8_t>(verifier, VT_NARROW_RANGE) &&
           verifier.EndTable();
  }
  FakeQuantWithMinMaxVarsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(FakeQuantWithMinMaxVarsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<FakeQuantWithMinMaxVars> Pack(flatbuffers::FlatBufferBuilder &_fbb, const FakeQuantWithMinMaxVarsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct FakeQuantWithMinMaxVarsBuilder {
  typedef FakeQuantWithMinMaxVars Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_num_bits(int64_t num_bits) {
    fbb_.AddElement<int64_t>(FakeQuantWithMinMaxVars::VT_NUM_BITS, num_bits, 0);
  }
  void add_narrow_range(bool narrow_range) {
    fbb_.AddElement<uint8_t>(FakeQuantWithMinMaxVars::VT_NARROW_RANGE, static_cast<uint8_t>(narrow_range), 0);
  }
  explicit FakeQuantWithMinMaxVarsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<FakeQuantWithMinMaxVars> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<FakeQuantWithMinMaxVars>(end);
    return o;
  }
};

inline flatbuffers::Offset<FakeQuantWithMinMaxVars> CreateFakeQuantWithMinMaxVars(
    flatbuffers::FlatBufferBuilder &_fbb,
    int64_t num_bits = 0,
    bool narrow_range = false) {
  FakeQuantWithMinMaxVarsBuilder builder_(_fbb);
  builder_.add_num_bits(num_bits);
  builder_.add_narrow_range(narrow_range);
  return builder_.Finish();
}

flatbuffers::Offset<FakeQuantWithMinMaxVars> CreateFakeQuantWithMinMaxVars(flatbuffers::FlatBufferBuilder &_fbb, const FakeQuantWithMinMaxVarsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct FakeQuantWithMinMaxVarsPerChannelT : public flatbuffers::NativeTable {
  typedef FakeQuantWithMinMaxVarsPerChannel TableType;
  int64_t num_bits = 0;
  bool narrow_range = false;
};

struct FakeQuantWithMinMaxVarsPerChannel FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef FakeQuantWithMinMaxVarsPerChannelT NativeTableType;
  typedef FakeQuantWithMinMaxVarsPerChannelBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return FakeQuantWithMinMaxVarsPerChannelTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NUM_BITS = 4,
    VT_NARROW_RANGE = 6
  };
  int64_t num_bits() const {
    return GetField<int64_t>(VT_NUM_BITS, 0);
  }
  bool mutate_num_bits(int64_t _num_bits) {
    return SetField<int64_t>(VT_NUM_BITS, _num_bits, 0);
  }
  bool narrow_range() const {
    return GetField<uint8_t>(VT_NARROW_RANGE, 0) != 0;
  }
  bool mutate_narrow_range(bool _narrow_range) {
    return SetField<uint8_t>(VT_NARROW_RANGE, static_cast<uint8_t>(_narrow_range), 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_NUM_BITS) &&
           VerifyField<uint8_t>(verifier, VT_NARROW_RANGE) &&
           verifier.EndTable();
  }
  FakeQuantWithMinMaxVarsPerChannelT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(FakeQuantWithMinMaxVarsPerChannelT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<FakeQuantWithMinMaxVarsPerChannel> Pack(flatbuffers::FlatBufferBuilder &_fbb, const FakeQuantWithMinMaxVarsPerChannelT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct FakeQuantWithMinMaxVarsPerChannelBuilder {
  typedef FakeQuantWithMinMaxVarsPerChannel Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_num_bits(int64_t num_bits) {
    fbb_.AddElement<int64_t>(FakeQuantWithMinMaxVarsPerChannel::VT_NUM_BITS, num_bits, 0);
  }
  void add_narrow_range(bool narrow_range) {
    fbb_.AddElement<uint8_t>(FakeQuantWithMinMaxVarsPerChannel::VT_NARROW_RANGE, static_cast<uint8_t>(narrow_range), 0);
  }
  explicit FakeQuantWithMinMaxVarsPerChannelBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<FakeQuantWithMinMaxVarsPerChannel> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<FakeQuantWithMinMaxVarsPerChannel>(end);
    return o;
  }
};

inline flatbuffers::Offset<FakeQuantWithMinMaxVarsPerChannel> CreateFakeQuantWithMinMaxVarsPerChannel(
    flatbuffers::FlatBufferBuilder &_fbb,
    int64_t num_bits = 0,
    bool narrow_range = false) {
  FakeQuantWithMinMaxVarsPerChannelBuilder builder_(_fbb);
  builder_.add_num_bits(num_bits);
  builder_.add_narrow_range(narrow_range);
  return builder_.Finish();
}

flatbuffers::Offset<FakeQuantWithMinMaxVarsPerChannel> CreateFakeQuantWithMinMaxVarsPerChannel(flatbuffers::FlatBufferBuilder &_fbb, const FakeQuantWithMinMaxVarsPerChannelT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct FftRealT : public flatbuffers::NativeTable {
  typedef FftReal TableType;
};

struct FftReal FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef FftRealT NativeTableType;
  typedef FftRealBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return FftRealTypeTable();
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  FftRealT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(FftRealT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<FftReal> Pack(flatbuffers::FlatBufferBuilder &_fbb, const FftRealT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct FftRealBuilder {
  typedef FftReal Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit FftRealBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<FftReal> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<FftReal>(end);
    return o;
  }
};

inline flatbuffers::Offset<FftReal> CreateFftReal(
    flatbuffers::FlatBufferBuilder &_fbb) {
  FftRealBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<FftReal> CreateFftReal(flatbuffers::FlatBufferBuilder &_fbb, const FftRealT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct FftImagT : public flatbuffers::NativeTable {
  typedef FftImag TableType;
};

struct FftImag FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef FftImagT NativeTableType;
  typedef FftImagBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return FftImagTypeTable();
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  FftImagT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(FftImagT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<FftImag> Pack(flatbuffers::FlatBufferBuilder &_fbb, const FftImagT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct FftImagBuilder {
  typedef FftImag Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit FftImagBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<FftImag> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<FftImag>(end);
    return o;
  }
};

inline flatbuffers::Offset<FftImag> CreateFftImag(
    flatbuffers::FlatBufferBuilder &_fbb) {
  FftImagBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<FftImag> CreateFftImag(flatbuffers::FlatBufferBuilder &_fbb, const FftImagT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct FlattenT : public flatbuffers::NativeTable {
  typedef Flatten TableType;
};

struct Flatten FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef FlattenT NativeTableType;
  typedef FlattenBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return FlattenTypeTable();
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  FlattenT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(FlattenT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Flatten> Pack(flatbuffers::FlatBufferBuilder &_fbb, const FlattenT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct FlattenBuilder {
  typedef Flatten Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit FlattenBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Flatten> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Flatten>(end);
    return o;
  }
};

inline flatbuffers::Offset<Flatten> CreateFlatten(
    flatbuffers::FlatBufferBuilder &_fbb) {
  FlattenBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<Flatten> CreateFlatten(flatbuffers::FlatBufferBuilder &_fbb, const FlattenT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct FlattenGradT : public flatbuffers::NativeTable {
  typedef FlattenGrad TableType;
};

struct FlattenGrad FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef FlattenGradT NativeTableType;
  typedef FlattenGradBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return FlattenGradTypeTable();
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  FlattenGradT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(FlattenGradT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<FlattenGrad> Pack(flatbuffers::FlatBufferBuilder &_fbb, const FlattenGradT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct FlattenGradBuilder {
  typedef FlattenGrad Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit FlattenGradBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<FlattenGrad> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<FlattenGrad>(end);
    return o;
  }
};

inline flatbuffers::Offset<FlattenGrad> CreateFlattenGrad(
    flatbuffers::FlatBufferBuilder &_fbb) {
  FlattenGradBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<FlattenGrad> CreateFlattenGrad(flatbuffers::FlatBufferBuilder &_fbb, const FlattenGradT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct FloorT : public flatbuffers::NativeTable {
  typedef Floor TableType;
};

struct Floor FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef FloorT NativeTableType;
  typedef FloorBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return FloorTypeTable();
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  FloorT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(FloorT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Floor> Pack(flatbuffers::FlatBufferBuilder &_fbb, const FloorT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct FloorBuilder {
  typedef Floor Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit FloorBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Floor> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Floor>(end);
    return o;
  }
};

inline flatbuffers::Offset<Floor> CreateFloor(
    flatbuffers::FlatBufferBuilder &_fbb) {
  FloorBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<Floor> CreateFloor(flatbuffers::FlatBufferBuilder &_fbb, const FloorT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct FloorDivT : public flatbuffers::NativeTable {
  typedef FloorDiv TableType;
};

struct FloorDiv FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef FloorDivT NativeTableType;
  typedef FloorDivBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return FloorDivTypeTable();
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  FloorDivT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(FloorDivT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<FloorDiv> Pack(flatbuffers::FlatBufferBuilder &_fbb, const FloorDivT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct FloorDivBuilder {
  typedef FloorDiv Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit FloorDivBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<FloorDiv> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<FloorDiv>(end);
    return o;
  }
};

inline flatbuffers::Offset<FloorDiv> CreateFloorDiv(
    flatbuffers::FlatBufferBuilder &_fbb) {
  FloorDivBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<FloorDiv> CreateFloorDiv(flatbuffers::FlatBufferBuilder &_fbb, const FloorDivT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct FloorModT : public flatbuffers::NativeTable {
  typedef FloorMod TableType;
};

struct FloorMod FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef FloorModT NativeTableType;
  typedef FloorModBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return FloorModTypeTable();
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  FloorModT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(FloorModT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<FloorMod> Pack(flatbuffers::FlatBufferBuilder &_fbb, const FloorModT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct FloorModBuilder {
  typedef FloorMod Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit FloorModBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<FloorMod> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<FloorMod>(end);
    return o;
  }
};

inline flatbuffers::Offset<FloorMod> CreateFloorMod(
    flatbuffers::FlatBufferBuilder &_fbb) {
  FloorModBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<FloorMod> CreateFloorMod(flatbuffers::FlatBufferBuilder &_fbb, const FloorModT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct FillT : public flatbuffers::NativeTable {
  typedef Fill TableType;
};

struct Fill FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef FillT NativeTableType;
  typedef FillBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return FillTypeTable();
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  FillT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(FillT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Fill> Pack(flatbuffers::FlatBufferBuilder &_fbb, const FillT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct FillBuilder {
  typedef Fill Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit FillBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Fill> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Fill>(end);
    return o;
  }
};

inline flatbuffers::Offset<Fill> CreateFill(
    flatbuffers::FlatBufferBuilder &_fbb) {
  FillBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<Fill> CreateFill(flatbuffers::FlatBufferBuilder &_fbb, const FillT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct FullConnectionT : public flatbuffers::NativeTable {
  typedef FullConnection TableType;
  bool has_bias = false;
  bool use_axis = false;
  int64_t axis = 0;
  mindspore::schema::ActivationType activation_type = mindspore::schema::ActivationType_NO_ACTIVATION;
};

struct FullConnection FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef FullConnectionT NativeTableType;
  typedef FullConnectionBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return FullConnectionTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_HAS_BIAS = 4,
    VT_USE_AXIS = 6,
    VT_AXIS = 8,
    VT_ACTIVATION_TYPE = 10
  };
  bool has_bias() const {
    return GetField<uint8_t>(VT_HAS_BIAS, 0) != 0;
  }
  bool mutate_has_bias(bool _has_bias) {
    return SetField<uint8_t>(VT_HAS_BIAS, static_cast<uint8_t>(_has_bias), 0);
  }
  bool use_axis() const {
    return GetField<uint8_t>(VT_USE_AXIS, 0) != 0;
  }
  bool mutate_use_axis(bool _use_axis) {
    return SetField<uint8_t>(VT_USE_AXIS, static_cast<uint8_t>(_use_axis), 0);
  }
  int64_t axis() const {
    return GetField<int64_t>(VT_AXIS, 0);
  }
  bool mutate_axis(int64_t _axis) {
    return SetField<int64_t>(VT_AXIS, _axis, 0);
  }
  mindspore::schema::ActivationType activation_type() const {
    return static_cast<mindspore::schema::ActivationType>(GetField<int8_t>(VT_ACTIVATION_TYPE, 0));
  }
  bool mutate_activation_type(mindspore::schema::ActivationType _activation_type) {
    return SetField<int8_t>(VT_ACTIVATION_TYPE, static_cast<int8_t>(_activation_type), 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_HAS_BIAS) &&
           VerifyField<uint8_t>(verifier, VT_USE_AXIS) &&
           VerifyField<int64_t>(verifier, VT_AXIS) &&
           VerifyField<int8_t>(verifier, VT_ACTIVATION_TYPE) &&
           verifier.EndTable();
  }
  FullConnectionT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(FullConnectionT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<FullConnection> Pack(flatbuffers::FlatBufferBuilder &_fbb, const FullConnectionT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct FullConnectionBuilder {
  typedef FullConnection Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_has_bias(bool has_bias) {
    fbb_.AddElement<uint8_t>(FullConnection::VT_HAS_BIAS, static_cast<uint8_t>(has_bias), 0);
  }
  void add_use_axis(bool use_axis) {
    fbb_.AddElement<uint8_t>(FullConnection::VT_USE_AXIS, static_cast<uint8_t>(use_axis), 0);
  }
  void add_axis(int64_t axis) {
    fbb_.AddElement<int64_t>(FullConnection::VT_AXIS, axis, 0);
  }
  void add_activation_type(mindspore::schema::ActivationType activation_type) {
    fbb_.AddElement<int8_t>(FullConnection::VT_ACTIVATION_TYPE, static_cast<int8_t>(activation_type), 0);
  }
  explicit FullConnectionBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<FullConnection> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<FullConnection>(end);
    return o;
  }
};

inline flatbuffers::Offset<FullConnection> CreateFullConnection(
    flatbuffers::FlatBufferBuilder &_fbb,
    bool has_bias = false,
    bool use_axis = false,
    int64_t axis = 0,
    mindspore::schema::ActivationType activation_type = mindspore::schema::ActivationType_NO_ACTIVATION) {
  FullConnectionBuilder builder_(_fbb);
  builder_.add_axis(axis);
  builder_.add_activation_type(activation_type);
  builder_.add_use_axis(use_axis);
  builder_.add_has_bias(has_bias);
  return builder_.Finish();
}

flatbuffers::Offset<FullConnection> CreateFullConnection(flatbuffers::FlatBufferBuilder &_fbb, const FullConnectionT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct FusedBatchNormT : public flatbuffers::NativeTable {
  typedef FusedBatchNorm TableType;
  float epsilon = 0.0001f;
  float momentum = 0.9f;
  int64_t mode = 0;
};

struct FusedBatchNorm FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef FusedBatchNormT NativeTableType;
  typedef FusedBatchNormBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return FusedBatchNormTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_EPSILON = 4,
    VT_MOMENTUM = 6,
    VT_MODE = 8
  };
  float epsilon() const {
    return GetField<float>(VT_EPSILON, 0.0001f);
  }
  bool mutate_epsilon(float _epsilon) {
    return SetField<float>(VT_EPSILON, _epsilon, 0.0001f);
  }
  float momentum() const {
    return GetField<float>(VT_MOMENTUM, 0.9f);
  }
  bool mutate_momentum(float _momentum) {
    return SetField<float>(VT_MOMENTUM, _momentum, 0.9f);
  }
  int64_t mode() const {
    return GetField<int64_t>(VT_MODE, 0);
  }
  bool mutate_mode(int64_t _mode) {
    return SetField<int64_t>(VT_MODE, _mode, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<float>(verifier, VT_EPSILON) &&
           VerifyField<float>(verifier, VT_MOMENTUM) &&
           VerifyField<int64_t>(verifier, VT_MODE) &&
           verifier.EndTable();
  }
  FusedBatchNormT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(FusedBatchNormT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<FusedBatchNorm> Pack(flatbuffers::FlatBufferBuilder &_fbb, const FusedBatchNormT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct FusedBatchNormBuilder {
  typedef FusedBatchNorm Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_epsilon(float epsilon) {
    fbb_.AddElement<float>(FusedBatchNorm::VT_EPSILON, epsilon, 0.0001f);
  }
  void add_momentum(float momentum) {
    fbb_.AddElement<float>(FusedBatchNorm::VT_MOMENTUM, momentum, 0.9f);
  }
  void add_mode(int64_t mode) {
    fbb_.AddElement<int64_t>(FusedBatchNorm::VT_MODE, mode, 0);
  }
  explicit FusedBatchNormBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<FusedBatchNorm> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<FusedBatchNorm>(end);
    return o;
  }
};

inline flatbuffers::Offset<FusedBatchNorm> CreateFusedBatchNorm(
    flatbuffers::FlatBufferBuilder &_fbb,
    float epsilon = 0.0001f,
    float momentum = 0.9f,
    int64_t mode = 0) {
  FusedBatchNormBuilder builder_(_fbb);
  builder_.add_mode(mode);
  builder_.add_momentum(momentum);
  builder_.add_epsilon(epsilon);
  return builder_.Finish();
}

flatbuffers::Offset<FusedBatchNorm> CreateFusedBatchNorm(flatbuffers::FlatBufferBuilder &_fbb, const FusedBatchNormT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct GatherT : public flatbuffers::NativeTable {
  typedef Gather TableType;
};

struct Gather FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef GatherT NativeTableType;
  typedef GatherBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return GatherTypeTable();
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  GatherT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(GatherT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Gather> Pack(flatbuffers::FlatBufferBuilder &_fbb, const GatherT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct GatherBuilder {
  typedef Gather Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit GatherBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Gather> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Gather>(end);
    return o;
  }
};

inline flatbuffers::Offset<Gather> CreateGather(
    flatbuffers::FlatBufferBuilder &_fbb) {
  GatherBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<Gather> CreateGather(flatbuffers::FlatBufferBuilder &_fbb, const GatherT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct GatherNdT : public flatbuffers::NativeTable {
  typedef GatherNd TableType;
};

struct GatherNd FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef GatherNdT NativeTableType;
  typedef GatherNdBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return GatherNdTypeTable();
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  GatherNdT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(GatherNdT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<GatherNd> Pack(flatbuffers::FlatBufferBuilder &_fbb, const GatherNdT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct GatherNdBuilder {
  typedef GatherNd Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit GatherNdBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<GatherNd> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<GatherNd>(end);
    return o;
  }
};

inline flatbuffers::Offset<GatherNd> CreateGatherNd(
    flatbuffers::FlatBufferBuilder &_fbb) {
  GatherNdBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<GatherNd> CreateGatherNd(flatbuffers::FlatBufferBuilder &_fbb, const GatherNdT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct GreaterT : public flatbuffers::NativeTable {
  typedef Greater TableType;
};

struct Greater FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef GreaterT NativeTableType;
  typedef GreaterBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return GreaterTypeTable();
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  GreaterT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(GreaterT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Greater> Pack(flatbuffers::FlatBufferBuilder &_fbb, const GreaterT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct GreaterBuilder {
  typedef Greater Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit GreaterBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Greater> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Greater>(end);
    return o;
  }
};

inline flatbuffers::Offset<Greater> CreateGreater(
    flatbuffers::FlatBufferBuilder &_fbb) {
  GreaterBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<Greater> CreateGreater(flatbuffers::FlatBufferBuilder &_fbb, const GreaterT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct GreaterEqualT : public flatbuffers::NativeTable {
  typedef GreaterEqual TableType;
};

struct GreaterEqual FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef GreaterEqualT NativeTableType;
  typedef GreaterEqualBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return GreaterEqualTypeTable();
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  GreaterEqualT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(GreaterEqualT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<GreaterEqual> Pack(flatbuffers::FlatBufferBuilder &_fbb, const GreaterEqualT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct GreaterEqualBuilder {
  typedef GreaterEqual Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit GreaterEqualBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<GreaterEqual> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<GreaterEqual>(end);
    return o;
  }
};

inline flatbuffers::Offset<GreaterEqual> CreateGreaterEqual(
    flatbuffers::FlatBufferBuilder &_fbb) {
  GreaterEqualBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<GreaterEqual> CreateGreaterEqual(flatbuffers::FlatBufferBuilder &_fbb, const GreaterEqualT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct HashtableLookupT : public flatbuffers::NativeTable {
  typedef HashtableLookup TableType;
};

struct HashtableLookup FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef HashtableLookupT NativeTableType;
  typedef HashtableLookupBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return HashtableLookupTypeTable();
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  HashtableLookupT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(HashtableLookupT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<HashtableLookup> Pack(flatbuffers::FlatBufferBuilder &_fbb, const HashtableLookupT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct HashtableLookupBuilder {
  typedef HashtableLookup Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit HashtableLookupBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<HashtableLookup> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<HashtableLookup>(end);
    return o;
  }
};

inline flatbuffers::Offset<HashtableLookup> CreateHashtableLookup(
    flatbuffers::FlatBufferBuilder &_fbb) {
  HashtableLookupBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<HashtableLookup> CreateHashtableLookup(flatbuffers::FlatBufferBuilder &_fbb, const HashtableLookupT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct InstanceNormT : public flatbuffers::NativeTable {
  typedef InstanceNorm TableType;
  float epsilon = 0.0f;
};

struct InstanceNorm FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef InstanceNormT NativeTableType;
  typedef InstanceNormBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return InstanceNormTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_EPSILON = 4
  };
  float epsilon() const {
    return GetField<float>(VT_EPSILON, 0.0f);
  }
  bool mutate_epsilon(float _epsilon) {
    return SetField<float>(VT_EPSILON, _epsilon, 0.0f);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<float>(verifier, VT_EPSILON) &&
           verifier.EndTable();
  }
  InstanceNormT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(InstanceNormT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<InstanceNorm> Pack(flatbuffers::FlatBufferBuilder &_fbb, const InstanceNormT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct InstanceNormBuilder {
  typedef InstanceNorm Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_epsilon(float epsilon) {
    fbb_.AddElement<float>(InstanceNorm::VT_EPSILON, epsilon, 0.0f);
  }
  explicit InstanceNormBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<InstanceNorm> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<InstanceNorm>(end);
    return o;
  }
};

inline flatbuffers::Offset<InstanceNorm> CreateInstanceNorm(
    flatbuffers::FlatBufferBuilder &_fbb,
    float epsilon = 0.0f) {
  InstanceNormBuilder builder_(_fbb);
  builder_.add_epsilon(epsilon);
  return builder_.Finish();
}

flatbuffers::Offset<InstanceNorm> CreateInstanceNorm(flatbuffers::FlatBufferBuilder &_fbb, const InstanceNormT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct LayerNormFusionT : public flatbuffers::NativeTable {
  typedef LayerNormFusion TableType;
  int64_t begin_norm_axis = 0;
  float epsilon = 0.00001f;
  bool elementwise_affine = false;
  int64_t begin_params_axis = 0;
};

struct LayerNormFusion FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef LayerNormFusionT NativeTableType;
  typedef LayerNormFusionBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return LayerNormFusionTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_BEGIN_NORM_AXIS = 4,
    VT_EPSILON = 6,
    VT_ELEMENTWISE_AFFINE = 8,
    VT_BEGIN_PARAMS_AXIS = 10
  };
  int64_t begin_norm_axis() const {
    return GetField<int64_t>(VT_BEGIN_NORM_AXIS, 0);
  }
  bool mutate_begin_norm_axis(int64_t _begin_norm_axis) {
    return SetField<int64_t>(VT_BEGIN_NORM_AXIS, _begin_norm_axis, 0);
  }
  float epsilon() const {
    return GetField<float>(VT_EPSILON, 0.00001f);
  }
  bool mutate_epsilon(float _epsilon) {
    return SetField<float>(VT_EPSILON, _epsilon, 0.00001f);
  }
  bool elementwise_affine() const {
    return GetField<uint8_t>(VT_ELEMENTWISE_AFFINE, 0) != 0;
  }
  bool mutate_elementwise_affine(bool _elementwise_affine) {
    return SetField<uint8_t>(VT_ELEMENTWISE_AFFINE, static_cast<uint8_t>(_elementwise_affine), 0);
  }
  int64_t begin_params_axis() const {
    return GetField<int64_t>(VT_BEGIN_PARAMS_AXIS, 0);
  }
  bool mutate_begin_params_axis(int64_t _begin_params_axis) {
    return SetField<int64_t>(VT_BEGIN_PARAMS_AXIS, _begin_params_axis, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_BEGIN_NORM_AXIS) &&
           VerifyField<float>(verifier, VT_EPSILON) &&
           VerifyField<uint8_t>(verifier, VT_ELEMENTWISE_AFFINE) &&
           VerifyField<int64_t>(verifier, VT_BEGIN_PARAMS_AXIS) &&
           verifier.EndTable();
  }
  LayerNormFusionT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(LayerNormFusionT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<LayerNormFusion> Pack(flatbuffers::FlatBufferBuilder &_fbb, const LayerNormFusionT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct LayerNormFusionBuilder {
  typedef LayerNormFusion Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_begin_norm_axis(int64_t begin_norm_axis) {
    fbb_.AddElement<int64_t>(LayerNormFusion::VT_BEGIN_NORM_AXIS, begin_norm_axis, 0);
  }
  void add_epsilon(float epsilon) {
    fbb_.AddElement<float>(LayerNormFusion::VT_EPSILON, epsilon, 0.00001f);
  }
  void add_elementwise_affine(bool elementwise_affine) {
    fbb_.AddElement<uint8_t>(LayerNormFusion::VT_ELEMENTWISE_AFFINE, static_cast<uint8_t>(elementwise_affine), 0);
  }
  void add_begin_params_axis(int64_t begin_params_axis) {
    fbb_.AddElement<int64_t>(LayerNormFusion::VT_BEGIN_PARAMS_AXIS, begin_params_axis, 0);
  }
  explicit LayerNormFusionBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<LayerNormFusion> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<LayerNormFusion>(end);
    return o;
  }
};

inline flatbuffers::Offset<LayerNormFusion> CreateLayerNormFusion(
    flatbuffers::FlatBufferBuilder &_fbb,
    int64_t begin_norm_axis = 0,
    float epsilon = 0.00001f,
    bool elementwise_affine = false,
    int64_t begin_params_axis = 0) {
  LayerNormFusionBuilder builder_(_fbb);
  builder_.add_begin_params_axis(begin_params_axis);
  builder_.add_begin_norm_axis(begin_norm_axis);
  builder_.add_epsilon(epsilon);
  builder_.add_elementwise_affine(elementwise_affine);
  return builder_.Finish();
}

flatbuffers::Offset<LayerNormFusion> CreateLayerNormFusion(flatbuffers::FlatBufferBuilder &_fbb, const LayerNormFusionT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct LeakyReluT : public flatbuffers::NativeTable {
  typedef LeakyRelu TableType;
  float negative_slope = 0.0f;
};

struct LeakyRelu FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef LeakyReluT NativeTableType;
  typedef LeakyReluBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return LeakyReluTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NEGATIVE_SLOPE = 4
  };
  float negative_slope() const {
    return GetField<float>(VT_NEGATIVE_SLOPE, 0.0f);
  }
  bool mutate_negative_slope(float _negative_slope) {
    return SetField<float>(VT_NEGATIVE_SLOPE, _negative_slope, 0.0f);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<float>(verifier, VT_NEGATIVE_SLOPE) &&
           verifier.EndTable();
  }
  LeakyReluT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(LeakyReluT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<LeakyRelu> Pack(flatbuffers::FlatBufferBuilder &_fbb, const LeakyReluT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct LeakyReluBuilder {
  typedef LeakyRelu Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_negative_slope(float negative_slope) {
    fbb_.AddElement<float>(LeakyRelu::VT_NEGATIVE_SLOPE, negative_slope, 0.0f);
  }
  explicit LeakyReluBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<LeakyRelu> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<LeakyRelu>(end);
    return o;
  }
};

inline flatbuffers::Offset<LeakyRelu> CreateLeakyRelu(
    flatbuffers::FlatBufferBuilder &_fbb,
    float negative_slope = 0.0f) {
  LeakyReluBuilder builder_(_fbb);
  builder_.add_negative_slope(negative_slope);
  return builder_.Finish();
}

flatbuffers::Offset<LeakyRelu> CreateLeakyRelu(flatbuffers::FlatBufferBuilder &_fbb, const LeakyReluT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct LessT : public flatbuffers::NativeTable {
  typedef Less TableType;
};

struct Less FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef LessT NativeTableType;
  typedef LessBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return LessTypeTable();
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  LessT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(LessT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Less> Pack(flatbuffers::FlatBufferBuilder &_fbb, const LessT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct LessBuilder {
  typedef Less Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit LessBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Less> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Less>(end);
    return o;
  }
};

inline flatbuffers::Offset<Less> CreateLess(
    flatbuffers::FlatBufferBuilder &_fbb) {
  LessBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<Less> CreateLess(flatbuffers::FlatBufferBuilder &_fbb, const LessT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct LessEqualT : public flatbuffers::NativeTable {
  typedef LessEqual TableType;
};

struct LessEqual FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef LessEqualT NativeTableType;
  typedef LessEqualBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return LessEqualTypeTable();
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  LessEqualT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(LessEqualT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<LessEqual> Pack(flatbuffers::FlatBufferBuilder &_fbb, const LessEqualT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct LessEqualBuilder {
  typedef LessEqual Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit LessEqualBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<LessEqual> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<LessEqual>(end);
    return o;
  }
};

inline flatbuffers::Offset<LessEqual> CreateLessEqual(
    flatbuffers::FlatBufferBuilder &_fbb) {
  LessEqualBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<LessEqual> CreateLessEqual(flatbuffers::FlatBufferBuilder &_fbb, const LessEqualT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct LogT : public flatbuffers::NativeTable {
  typedef Log TableType;
};

struct Log FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef LogT NativeTableType;
  typedef LogBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return LogTypeTable();
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  LogT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(LogT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Log> Pack(flatbuffers::FlatBufferBuilder &_fbb, const LogT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct LogBuilder {
  typedef Log Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit LogBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Log> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Log>(end);
    return o;
  }
};

inline flatbuffers::Offset<Log> CreateLog(
    flatbuffers::FlatBufferBuilder &_fbb) {
  LogBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<Log> CreateLog(flatbuffers::FlatBufferBuilder &_fbb, const LogT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct LogGradT : public flatbuffers::NativeTable {
  typedef LogGrad TableType;
};

struct LogGrad FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef LogGradT NativeTableType;
  typedef LogGradBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return LogGradTypeTable();
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  LogGradT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(LogGradT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<LogGrad> Pack(flatbuffers::FlatBufferBuilder &_fbb, const LogGradT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct LogGradBuilder {
  typedef LogGrad Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit LogGradBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<LogGrad> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<LogGrad>(end);
    return o;
  }
};

inline flatbuffers::Offset<LogGrad> CreateLogGrad(
    flatbuffers::FlatBufferBuilder &_fbb) {
  LogGradBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<LogGrad> CreateLogGrad(flatbuffers::FlatBufferBuilder &_fbb, const LogGradT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct LogicalAndT : public flatbuffers::NativeTable {
  typedef LogicalAnd TableType;
};

struct LogicalAnd FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef LogicalAndT NativeTableType;
  typedef LogicalAndBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return LogicalAndTypeTable();
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  LogicalAndT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(LogicalAndT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<LogicalAnd> Pack(flatbuffers::FlatBufferBuilder &_fbb, const LogicalAndT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct LogicalAndBuilder {
  typedef LogicalAnd Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit LogicalAndBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<LogicalAnd> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<LogicalAnd>(end);
    return o;
  }
};

inline flatbuffers::Offset<LogicalAnd> CreateLogicalAnd(
    flatbuffers::FlatBufferBuilder &_fbb) {
  LogicalAndBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<LogicalAnd> CreateLogicalAnd(flatbuffers::FlatBufferBuilder &_fbb, const LogicalAndT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct LogicalNotT : public flatbuffers::NativeTable {
  typedef LogicalNot TableType;
};

struct LogicalNot FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef LogicalNotT NativeTableType;
  typedef LogicalNotBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return LogicalNotTypeTable();
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  LogicalNotT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(LogicalNotT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<LogicalNot> Pack(flatbuffers::FlatBufferBuilder &_fbb, const LogicalNotT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct LogicalNotBuilder {
  typedef LogicalNot Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit LogicalNotBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<LogicalNot> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<LogicalNot>(end);
    return o;
  }
};

inline flatbuffers::Offset<LogicalNot> CreateLogicalNot(
    flatbuffers::FlatBufferBuilder &_fbb) {
  LogicalNotBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<LogicalNot> CreateLogicalNot(flatbuffers::FlatBufferBuilder &_fbb, const LogicalNotT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct LogicalOrT : public flatbuffers::NativeTable {
  typedef LogicalOr TableType;
};

struct LogicalOr FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef LogicalOrT NativeTableType;
  typedef LogicalOrBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return LogicalOrTypeTable();
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  LogicalOrT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(LogicalOrT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<LogicalOr> Pack(flatbuffers::FlatBufferBuilder &_fbb, const LogicalOrT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct LogicalOrBuilder {
  typedef LogicalOr Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit LogicalOrBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<LogicalOr> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<LogicalOr>(end);
    return o;
  }
};

inline flatbuffers::Offset<LogicalOr> CreateLogicalOr(
    flatbuffers::FlatBufferBuilder &_fbb) {
  LogicalOrBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<LogicalOr> CreateLogicalOr(flatbuffers::FlatBufferBuilder &_fbb, const LogicalOrT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct LpNormalizationT : public flatbuffers::NativeTable {
  typedef LpNormalization TableType;
  int64_t axis = 0;
  int64_t p = 0;
};

struct LpNormalization FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef LpNormalizationT NativeTableType;
  typedef LpNormalizationBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return LpNormalizationTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_AXIS = 4,
    VT_P = 6
  };
  int64_t axis() const {
    return GetField<int64_t>(VT_AXIS, 0);
  }
  bool mutate_axis(int64_t _axis) {
    return SetField<int64_t>(VT_AXIS, _axis, 0);
  }
  int64_t p() const {
    return GetField<int64_t>(VT_P, 0);
  }
  bool mutate_p(int64_t _p) {
    return SetField<int64_t>(VT_P, _p, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_AXIS) &&
           VerifyField<int64_t>(verifier, VT_P) &&
           verifier.EndTable();
  }
  LpNormalizationT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(LpNormalizationT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<LpNormalization> Pack(flatbuffers::FlatBufferBuilder &_fbb, const LpNormalizationT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct LpNormalizationBuilder {
  typedef LpNormalization Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_axis(int64_t axis) {
    fbb_.AddElement<int64_t>(LpNormalization::VT_AXIS, axis, 0);
  }
  void add_p(int64_t p) {
    fbb_.AddElement<int64_t>(LpNormalization::VT_P, p, 0);
  }
  explicit LpNormalizationBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<LpNormalization> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<LpNormalization>(end);
    return o;
  }
};

inline flatbuffers::Offset<LpNormalization> CreateLpNormalization(
    flatbuffers::FlatBufferBuilder &_fbb,
    int64_t axis = 0,
    int64_t p = 0) {
  LpNormalizationBuilder builder_(_fbb);
  builder_.add_p(p);
  builder_.add_axis(axis);
  return builder_.Finish();
}

flatbuffers::Offset<LpNormalization> CreateLpNormalization(flatbuffers::FlatBufferBuilder &_fbb, const LpNormalizationT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct LRNT : public flatbuffers::NativeTable {
  typedef LRN TableType;
  int64_t depth_radius = 0;
  float bias = 0.0f;
  float alpha = 0.0f;
  float beta = 0.0f;
  std::string norm_region{};
};

struct LRN FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef LRNT NativeTableType;
  typedef LRNBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return LRNTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_DEPTH_RADIUS = 4,
    VT_BIAS = 6,
    VT_ALPHA = 8,
    VT_BETA = 10,
    VT_NORM_REGION = 12
  };
  int64_t depth_radius() const {
    return GetField<int64_t>(VT_DEPTH_RADIUS, 0);
  }
  bool mutate_depth_radius(int64_t _depth_radius) {
    return SetField<int64_t>(VT_DEPTH_RADIUS, _depth_radius, 0);
  }
  float bias() const {
    return GetField<float>(VT_BIAS, 0.0f);
  }
  bool mutate_bias(float _bias) {
    return SetField<float>(VT_BIAS, _bias, 0.0f);
  }
  float alpha() const {
    return GetField<float>(VT_ALPHA, 0.0f);
  }
  bool mutate_alpha(float _alpha) {
    return SetField<float>(VT_ALPHA, _alpha, 0.0f);
  }
  float beta() const {
    return GetField<float>(VT_BETA, 0.0f);
  }
  bool mutate_beta(float _beta) {
    return SetField<float>(VT_BETA, _beta, 0.0f);
  }
  const flatbuffers::String *norm_region() const {
    return GetPointer<const flatbuffers::String *>(VT_NORM_REGION);
  }
  flatbuffers::String *mutable_norm_region() {
    return GetPointer<flatbuffers::String *>(VT_NORM_REGION);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_DEPTH_RADIUS) &&
           VerifyField<float>(verifier, VT_BIAS) &&
           VerifyField<float>(verifier, VT_ALPHA) &&
           VerifyField<float>(verifier, VT_BETA) &&
           VerifyOffset(verifier, VT_NORM_REGION) &&
           verifier.VerifyString(norm_region()) &&
           verifier.EndTable();
  }
  LRNT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(LRNT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<LRN> Pack(flatbuffers::FlatBufferBuilder &_fbb, const LRNT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct LRNBuilder {
  typedef LRN Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_depth_radius(int64_t depth_radius) {
    fbb_.AddElement<int64_t>(LRN::VT_DEPTH_RADIUS, depth_radius, 0);
  }
  void add_bias(float bias) {
    fbb_.AddElement<float>(LRN::VT_BIAS, bias, 0.0f);
  }
  void add_alpha(float alpha) {
    fbb_.AddElement<float>(LRN::VT_ALPHA, alpha, 0.0f);
  }
  void add_beta(float beta) {
    fbb_.AddElement<float>(LRN::VT_BETA, beta, 0.0f);
  }
  void add_norm_region(flatbuffers::Offset<flatbuffers::String> norm_region) {
    fbb_.AddOffset(LRN::VT_NORM_REGION, norm_region);
  }
  explicit LRNBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<LRN> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<LRN>(end);
    return o;
  }
};

inline flatbuffers::Offset<LRN> CreateLRN(
    flatbuffers::FlatBufferBuilder &_fbb,
    int64_t depth_radius = 0,
    float bias = 0.0f,
    float alpha = 0.0f,
    float beta = 0.0f,
    flatbuffers::Offset<flatbuffers::String> norm_region = 0) {
  LRNBuilder builder_(_fbb);
  builder_.add_depth_radius(depth_radius);
  builder_.add_norm_region(norm_region);
  builder_.add_beta(beta);
  builder_.add_alpha(alpha);
  builder_.add_bias(bias);
  return builder_.Finish();
}

inline flatbuffers::Offset<LRN> CreateLRNDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int64_t depth_radius = 0,
    float bias = 0.0f,
    float alpha = 0.0f,
    float beta = 0.0f,
    const char *norm_region = nullptr) {
  auto norm_region__ = norm_region ? _fbb.CreateString(norm_region) : 0;
  return mindspore::schema::CreateLRN(
      _fbb,
      depth_radius,
      bias,
      alpha,
      beta,
      norm_region__);
}

flatbuffers::Offset<LRN> CreateLRN(flatbuffers::FlatBufferBuilder &_fbb, const LRNT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct LshProjectionT : public flatbuffers::NativeTable {
  typedef LshProjection TableType;
  mindspore::schema::LshProjectionType type = mindspore::schema::LshProjectionType_UNKNOWN;
};

struct LshProjection FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef LshProjectionT NativeTableType;
  typedef LshProjectionBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return LshProjectionTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TYPE = 4
  };
  mindspore::schema::LshProjectionType type() const {
    return static_cast<mindspore::schema::LshProjectionType>(GetField<int8_t>(VT_TYPE, 0));
  }
  bool mutate_type(mindspore::schema::LshProjectionType _type) {
    return SetField<int8_t>(VT_TYPE, static_cast<int8_t>(_type), 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_TYPE) &&
           verifier.EndTable();
  }
  LshProjectionT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(LshProjectionT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<LshProjection> Pack(flatbuffers::FlatBufferBuilder &_fbb, const LshProjectionT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct LshProjectionBuilder {
  typedef LshProjection Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_type(mindspore::schema::LshProjectionType type) {
    fbb_.AddElement<int8_t>(LshProjection::VT_TYPE, static_cast<int8_t>(type), 0);
  }
  explicit LshProjectionBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<LshProjection> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<LshProjection>(end);
    return o;
  }
};

inline flatbuffers::Offset<LshProjection> CreateLshProjection(
    flatbuffers::FlatBufferBuilder &_fbb,
    mindspore::schema::LshProjectionType type = mindspore::schema::LshProjectionType_UNKNOWN) {
  LshProjectionBuilder builder_(_fbb);
  builder_.add_type(type);
  return builder_.Finish();
}

flatbuffers::Offset<LshProjection> CreateLshProjection(flatbuffers::FlatBufferBuilder &_fbb, const LshProjectionT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct LSTMT : public flatbuffers::NativeTable {
  typedef LSTM TableType;
  bool bidirectional = false;
  bool has_bias = false;
  int64_t input_size = 0;
  int64_t hidden_size = 0;
  int64_t num_layers = 0;
  int64_t num_directions = 0;
  float dropout = 0.0f;
  float zoneout_cell = 0.0f;
  float zoneout_hidden = 0.0f;
};

struct LSTM FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef LSTMT NativeTableType;
  typedef LSTMBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return LSTMTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_BIDIRECTIONAL = 4,
    VT_HAS_BIAS = 6,
    VT_INPUT_SIZE = 8,
    VT_HIDDEN_SIZE = 10,
    VT_NUM_LAYERS = 12,
    VT_NUM_DIRECTIONS = 14,
    VT_DROPOUT = 16,
    VT_ZONEOUT_CELL = 18,
    VT_ZONEOUT_HIDDEN = 20
  };
  bool bidirectional() const {
    return GetField<uint8_t>(VT_BIDIRECTIONAL, 0) != 0;
  }
  bool mutate_bidirectional(bool _bidirectional) {
    return SetField<uint8_t>(VT_BIDIRECTIONAL, static_cast<uint8_t>(_bidirectional), 0);
  }
  bool has_bias() const {
    return GetField<uint8_t>(VT_HAS_BIAS, 0) != 0;
  }
  bool mutate_has_bias(bool _has_bias) {
    return SetField<uint8_t>(VT_HAS_BIAS, static_cast<uint8_t>(_has_bias), 0);
  }
  int64_t input_size() const {
    return GetField<int64_t>(VT_INPUT_SIZE, 0);
  }
  bool mutate_input_size(int64_t _input_size) {
    return SetField<int64_t>(VT_INPUT_SIZE, _input_size, 0);
  }
  int64_t hidden_size() const {
    return GetField<int64_t>(VT_HIDDEN_SIZE, 0);
  }
  bool mutate_hidden_size(int64_t _hidden_size) {
    return SetField<int64_t>(VT_HIDDEN_SIZE, _hidden_size, 0);
  }
  int64_t num_layers() const {
    return GetField<int64_t>(VT_NUM_LAYERS, 0);
  }
  bool mutate_num_layers(int64_t _num_layers) {
    return SetField<int64_t>(VT_NUM_LAYERS, _num_layers, 0);
  }
  int64_t num_directions() const {
    return GetField<int64_t>(VT_NUM_DIRECTIONS, 0);
  }
  bool mutate_num_directions(int64_t _num_directions) {
    return SetField<int64_t>(VT_NUM_DIRECTIONS, _num_directions, 0);
  }
  float dropout() const {
    return GetField<float>(VT_DROPOUT, 0.0f);
  }
  bool mutate_dropout(float _dropout) {
    return SetField<float>(VT_DROPOUT, _dropout, 0.0f);
  }
  float zoneout_cell() const {
    return GetField<float>(VT_ZONEOUT_CELL, 0.0f);
  }
  bool mutate_zoneout_cell(float _zoneout_cell) {
    return SetField<float>(VT_ZONEOUT_CELL, _zoneout_cell, 0.0f);
  }
  float zoneout_hidden() const {
    return GetField<float>(VT_ZONEOUT_HIDDEN, 0.0f);
  }
  bool mutate_zoneout_hidden(float _zoneout_hidden) {
    return SetField<float>(VT_ZONEOUT_HIDDEN, _zoneout_hidden, 0.0f);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_BIDIRECTIONAL) &&
           VerifyField<uint8_t>(verifier, VT_HAS_BIAS) &&
           VerifyField<int64_t>(verifier, VT_INPUT_SIZE) &&
           VerifyField<int64_t>(verifier, VT_HIDDEN_SIZE) &&
           VerifyField<int64_t>(verifier, VT_NUM_LAYERS) &&
           VerifyField<int64_t>(verifier, VT_NUM_DIRECTIONS) &&
           VerifyField<float>(verifier, VT_DROPOUT) &&
           VerifyField<float>(verifier, VT_ZONEOUT_CELL) &&
           VerifyField<float>(verifier, VT_ZONEOUT_HIDDEN) &&
           verifier.EndTable();
  }
  LSTMT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(LSTMT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<LSTM> Pack(flatbuffers::FlatBufferBuilder &_fbb, const LSTMT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct LSTMBuilder {
  typedef LSTM Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_bidirectional(bool bidirectional) {
    fbb_.AddElement<uint8_t>(LSTM::VT_BIDIRECTIONAL, static_cast<uint8_t>(bidirectional), 0);
  }
  void add_has_bias(bool has_bias) {
    fbb_.AddElement<uint8_t>(LSTM::VT_HAS_BIAS, static_cast<uint8_t>(has_bias), 0);
  }
  void add_input_size(int64_t input_size) {
    fbb_.AddElement<int64_t>(LSTM::VT_INPUT_SIZE, input_size, 0);
  }
  void add_hidden_size(int64_t hidden_size) {
    fbb_.AddElement<int64_t>(LSTM::VT_HIDDEN_SIZE, hidden_size, 0);
  }
  void add_num_layers(int64_t num_layers) {
    fbb_.AddElement<int64_t>(LSTM::VT_NUM_LAYERS, num_layers, 0);
  }
  void add_num_directions(int64_t num_directions) {
    fbb_.AddElement<int64_t>(LSTM::VT_NUM_DIRECTIONS, num_directions, 0);
  }
  void add_dropout(float dropout) {
    fbb_.AddElement<float>(LSTM::VT_DROPOUT, dropout, 0.0f);
  }
  void add_zoneout_cell(float zoneout_cell) {
    fbb_.AddElement<float>(LSTM::VT_ZONEOUT_CELL, zoneout_cell, 0.0f);
  }
  void add_zoneout_hidden(float zoneout_hidden) {
    fbb_.AddElement<float>(LSTM::VT_ZONEOUT_HIDDEN, zoneout_hidden, 0.0f);
  }
  explicit LSTMBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<LSTM> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<LSTM>(end);
    return o;
  }
};

inline flatbuffers::Offset<LSTM> CreateLSTM(
    flatbuffers::FlatBufferBuilder &_fbb,
    bool bidirectional = false,
    bool has_bias = false,
    int64_t input_size = 0,
    int64_t hidden_size = 0,
    int64_t num_layers = 0,
    int64_t num_directions = 0,
    float dropout = 0.0f,
    float zoneout_cell = 0.0f,
    float zoneout_hidden = 0.0f) {
  LSTMBuilder builder_(_fbb);
  builder_.add_num_directions(num_directions);
  builder_.add_num_layers(num_layers);
  builder_.add_hidden_size(hidden_size);
  builder_.add_input_size(input_size);
  builder_.add_zoneout_hidden(zoneout_hidden);
  builder_.add_zoneout_cell(zoneout_cell);
  builder_.add_dropout(dropout);
  builder_.add_has_bias(has_bias);
  builder_.add_bidirectional(bidirectional);
  return builder_.Finish();
}

flatbuffers::Offset<LSTM> CreateLSTM(flatbuffers::FlatBufferBuilder &_fbb, const LSTMT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct LSTMGradT : public flatbuffers::NativeTable {
  typedef LSTMGrad TableType;
  bool bidirectional = false;
  bool has_bias = false;
  int64_t input_size = 0;
  int64_t hidden_size = 0;
  int64_t num_layers = 0;
  int64_t num_directions = 0;
  float dropout = 0.0f;
  float zoneout_cell = 0.0f;
  float zoneout_hidden = 0.0f;
};

struct LSTMGrad FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef LSTMGradT NativeTableType;
  typedef LSTMGradBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return LSTMGradTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_BIDIRECTIONAL = 4,
    VT_HAS_BIAS = 6,
    VT_INPUT_SIZE = 8,
    VT_HIDDEN_SIZE = 10,
    VT_NUM_LAYERS = 12,
    VT_NUM_DIRECTIONS = 14,
    VT_DROPOUT = 16,
    VT_ZONEOUT_CELL = 18,
    VT_ZONEOUT_HIDDEN = 20
  };
  bool bidirectional() const {
    return GetField<uint8_t>(VT_BIDIRECTIONAL, 0) != 0;
  }
  bool mutate_bidirectional(bool _bidirectional) {
    return SetField<uint8_t>(VT_BIDIRECTIONAL, static_cast<uint8_t>(_bidirectional), 0);
  }
  bool has_bias() const {
    return GetField<uint8_t>(VT_HAS_BIAS, 0) != 0;
  }
  bool mutate_has_bias(bool _has_bias) {
    return SetField<uint8_t>(VT_HAS_BIAS, static_cast<uint8_t>(_has_bias), 0);
  }
  int64_t input_size() const {
    return GetField<int64_t>(VT_INPUT_SIZE, 0);
  }
  bool mutate_input_size(int64_t _input_size) {
    return SetField<int64_t>(VT_INPUT_SIZE, _input_size, 0);
  }
  int64_t hidden_size() const {
    return GetField<int64_t>(VT_HIDDEN_SIZE, 0);
  }
  bool mutate_hidden_size(int64_t _hidden_size) {
    return SetField<int64_t>(VT_HIDDEN_SIZE, _hidden_size, 0);
  }
  int64_t num_layers() const {
    return GetField<int64_t>(VT_NUM_LAYERS, 0);
  }
  bool mutate_num_layers(int64_t _num_layers) {
    return SetField<int64_t>(VT_NUM_LAYERS, _num_layers, 0);
  }
  int64_t num_directions() const {
    return GetField<int64_t>(VT_NUM_DIRECTIONS, 0);
  }
  bool mutate_num_directions(int64_t _num_directions) {
    return SetField<int64_t>(VT_NUM_DIRECTIONS, _num_directions, 0);
  }
  float dropout() const {
    return GetField<float>(VT_DROPOUT, 0.0f);
  }
  bool mutate_dropout(float _dropout) {
    return SetField<float>(VT_DROPOUT, _dropout, 0.0f);
  }
  float zoneout_cell() const {
    return GetField<float>(VT_ZONEOUT_CELL, 0.0f);
  }
  bool mutate_zoneout_cell(float _zoneout_cell) {
    return SetField<float>(VT_ZONEOUT_CELL, _zoneout_cell, 0.0f);
  }
  float zoneout_hidden() const {
    return GetField<float>(VT_ZONEOUT_HIDDEN, 0.0f);
  }
  bool mutate_zoneout_hidden(float _zoneout_hidden) {
    return SetField<float>(VT_ZONEOUT_HIDDEN, _zoneout_hidden, 0.0f);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_BIDIRECTIONAL) &&
           VerifyField<uint8_t>(verifier, VT_HAS_BIAS) &&
           VerifyField<int64_t>(verifier, VT_INPUT_SIZE) &&
           VerifyField<int64_t>(verifier, VT_HIDDEN_SIZE) &&
           VerifyField<int64_t>(verifier, VT_NUM_LAYERS) &&
           VerifyField<int64_t>(verifier, VT_NUM_DIRECTIONS) &&
           VerifyField<float>(verifier, VT_DROPOUT) &&
           VerifyField<float>(verifier, VT_ZONEOUT_CELL) &&
           VerifyField<float>(verifier, VT_ZONEOUT_HIDDEN) &&
           verifier.EndTable();
  }
  LSTMGradT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(LSTMGradT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<LSTMGrad> Pack(flatbuffers::FlatBufferBuilder &_fbb, const LSTMGradT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct LSTMGradBuilder {
  typedef LSTMGrad Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_bidirectional(bool bidirectional) {
    fbb_.AddElement<uint8_t>(LSTMGrad::VT_BIDIRECTIONAL, static_cast<uint8_t>(bidirectional), 0);
  }
  void add_has_bias(bool has_bias) {
    fbb_.AddElement<uint8_t>(LSTMGrad::VT_HAS_BIAS, static_cast<uint8_t>(has_bias), 0);
  }
  void add_input_size(int64_t input_size) {
    fbb_.AddElement<int64_t>(LSTMGrad::VT_INPUT_SIZE, input_size, 0);
  }
  void add_hidden_size(int64_t hidden_size) {
    fbb_.AddElement<int64_t>(LSTMGrad::VT_HIDDEN_SIZE, hidden_size, 0);
  }
  void add_num_layers(int64_t num_layers) {
    fbb_.AddElement<int64_t>(LSTMGrad::VT_NUM_LAYERS, num_layers, 0);
  }
  void add_num_directions(int64_t num_directions) {
    fbb_.AddElement<int64_t>(LSTMGrad::VT_NUM_DIRECTIONS, num_directions, 0);
  }
  void add_dropout(float dropout) {
    fbb_.AddElement<float>(LSTMGrad::VT_DROPOUT, dropout, 0.0f);
  }
  void add_zoneout_cell(float zoneout_cell) {
    fbb_.AddElement<float>(LSTMGrad::VT_ZONEOUT_CELL, zoneout_cell, 0.0f);
  }
  void add_zoneout_hidden(float zoneout_hidden) {
    fbb_.AddElement<float>(LSTMGrad::VT_ZONEOUT_HIDDEN, zoneout_hidden, 0.0f);
  }
  explicit LSTMGradBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<LSTMGrad> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<LSTMGrad>(end);
    return o;
  }
};

inline flatbuffers::Offset<LSTMGrad> CreateLSTMGrad(
    flatbuffers::FlatBufferBuilder &_fbb,
    bool bidirectional = false,
    bool has_bias = false,
    int64_t input_size = 0,
    int64_t hidden_size = 0,
    int64_t num_layers = 0,
    int64_t num_directions = 0,
    float dropout = 0.0f,
    float zoneout_cell = 0.0f,
    float zoneout_hidden = 0.0f) {
  LSTMGradBuilder builder_(_fbb);
  builder_.add_num_directions(num_directions);
  builder_.add_num_layers(num_layers);
  builder_.add_hidden_size(hidden_size);
  builder_.add_input_size(input_size);
  builder_.add_zoneout_hidden(zoneout_hidden);
  builder_.add_zoneout_cell(zoneout_cell);
  builder_.add_dropout(dropout);
  builder_.add_has_bias(has_bias);
  builder_.add_bidirectional(bidirectional);
  return builder_.Finish();
}

flatbuffers::Offset<LSTMGrad> CreateLSTMGrad(flatbuffers::FlatBufferBuilder &_fbb, const LSTMGradT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct L2NormalizeFusionT : public flatbuffers::NativeTable {
  typedef L2NormalizeFusion TableType;
  std::vector<int64_t> axis{};
  float epsilon = 0.0f;
  mindspore::schema::ActivationType activation_type = mindspore::schema::ActivationType_NO_ACTIVATION;
};

struct L2NormalizeFusion FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef L2NormalizeFusionT NativeTableType;
  typedef L2NormalizeFusionBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return L2NormalizeFusionTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_AXIS = 4,
    VT_EPSILON = 6,
    VT_ACTIVATION_TYPE = 8
  };
  const flatbuffers::Vector<int64_t> *axis() const {
    return GetPointer<const flatbuffers::Vector<int64_t> *>(VT_AXIS);
  }
  flatbuffers::Vector<int64_t> *mutable_axis() {
    return GetPointer<flatbuffers::Vector<int64_t> *>(VT_AXIS);
  }
  float epsilon() const {
    return GetField<float>(VT_EPSILON, 0.0f);
  }
  bool mutate_epsilon(float _epsilon) {
    return SetField<float>(VT_EPSILON, _epsilon, 0.0f);
  }
  mindspore::schema::ActivationType activation_type() const {
    return static_cast<mindspore::schema::ActivationType>(GetField<int8_t>(VT_ACTIVATION_TYPE, 0));
  }
  bool mutate_activation_type(mindspore::schema::ActivationType _activation_type) {
    return SetField<int8_t>(VT_ACTIVATION_TYPE, static_cast<int8_t>(_activation_type), 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_AXIS) &&
           verifier.VerifyVector(axis()) &&
           VerifyField<float>(verifier, VT_EPSILON) &&
           VerifyField<int8_t>(verifier, VT_ACTIVATION_TYPE) &&
           verifier.EndTable();
  }
  L2NormalizeFusionT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(L2NormalizeFusionT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<L2NormalizeFusion> Pack(flatbuffers::FlatBufferBuilder &_fbb, const L2NormalizeFusionT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct L2NormalizeFusionBuilder {
  typedef L2NormalizeFusion Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_axis(flatbuffers::Offset<flatbuffers::Vector<int64_t>> axis) {
    fbb_.AddOffset(L2NormalizeFusion::VT_AXIS, axis);
  }
  void add_epsilon(float epsilon) {
    fbb_.AddElement<float>(L2NormalizeFusion::VT_EPSILON, epsilon, 0.0f);
  }
  void add_activation_type(mindspore::schema::ActivationType activation_type) {
    fbb_.AddElement<int8_t>(L2NormalizeFusion::VT_ACTIVATION_TYPE, static_cast<int8_t>(activation_type), 0);
  }
  explicit L2NormalizeFusionBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<L2NormalizeFusion> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<L2NormalizeFusion>(end);
    return o;
  }
};

inline flatbuffers::Offset<L2NormalizeFusion> CreateL2NormalizeFusion(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<int64_t>> axis = 0,
    float epsilon = 0.0f,
    mindspore::schema::ActivationType activation_type = mindspore::schema::ActivationType_NO_ACTIVATION) {
  L2NormalizeFusionBuilder builder_(_fbb);
  builder_.add_epsilon(epsilon);
  builder_.add_axis(axis);
  builder_.add_activation_type(activation_type);
  return builder_.Finish();
}

inline flatbuffers::Offset<L2NormalizeFusion> CreateL2NormalizeFusionDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<int64_t> *axis = nullptr,
    float epsilon = 0.0f,
    mindspore::schema::ActivationType activation_type = mindspore::schema::ActivationType_NO_ACTIVATION) {
  auto axis__ = axis ? _fbb.CreateVector<int64_t>(*axis) : 0;
  return mindspore::schema::CreateL2NormalizeFusion(
      _fbb,
      axis__,
      epsilon,
      activation_type);
}

flatbuffers::Offset<L2NormalizeFusion> CreateL2NormalizeFusion(flatbuffers::FlatBufferBuilder &_fbb, const L2NormalizeFusionT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct MatMulFusionT : public flatbuffers::NativeTable {
  typedef MatMulFusion TableType;
  bool transpose_a = false;
  bool transpose_b = false;
  mindspore::schema::ActivationType activation_type = mindspore::schema::ActivationType_NO_ACTIVATION;
};

struct MatMulFusion FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef MatMulFusionT NativeTableType;
  typedef MatMulFusionBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return MatMulFusionTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TRANSPOSE_A = 4,
    VT_TRANSPOSE_B = 6,
    VT_ACTIVATION_TYPE = 8
  };
  bool transpose_a() const {
    return GetField<uint8_t>(VT_TRANSPOSE_A, 0) != 0;
  }
  bool mutate_transpose_a(bool _transpose_a) {
    return SetField<uint8_t>(VT_TRANSPOSE_A, static_cast<uint8_t>(_transpose_a), 0);
  }
  bool transpose_b() const {
    return GetField<uint8_t>(VT_TRANSPOSE_B, 0) != 0;
  }
  bool mutate_transpose_b(bool _transpose_b) {
    return SetField<uint8_t>(VT_TRANSPOSE_B, static_cast<uint8_t>(_transpose_b), 0);
  }
  mindspore::schema::ActivationType activation_type() const {
    return static_cast<mindspore::schema::ActivationType>(GetField<int8_t>(VT_ACTIVATION_TYPE, 0));
  }
  bool mutate_activation_type(mindspore::schema::ActivationType _activation_type) {
    return SetField<int8_t>(VT_ACTIVATION_TYPE, static_cast<int8_t>(_activation_type), 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_TRANSPOSE_A) &&
           VerifyField<uint8_t>(verifier, VT_TRANSPOSE_B) &&
           VerifyField<int8_t>(verifier, VT_ACTIVATION_TYPE) &&
           verifier.EndTable();
  }
  MatMulFusionT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(MatMulFusionT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<MatMulFusion> Pack(flatbuffers::FlatBufferBuilder &_fbb, const MatMulFusionT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct MatMulFusionBuilder {
  typedef MatMulFusion Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_transpose_a(bool transpose_a) {
    fbb_.AddElement<uint8_t>(MatMulFusion::VT_TRANSPOSE_A, static_cast<uint8_t>(transpose_a), 0);
  }
  void add_transpose_b(bool transpose_b) {
    fbb_.AddElement<uint8_t>(MatMulFusion::VT_TRANSPOSE_B, static_cast<uint8_t>(transpose_b), 0);
  }
  void add_activation_type(mindspore::schema::ActivationType activation_type) {
    fbb_.AddElement<int8_t>(MatMulFusion::VT_ACTIVATION_TYPE, static_cast<int8_t>(activation_type), 0);
  }
  explicit MatMulFusionBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<MatMulFusion> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<MatMulFusion>(end);
    return o;
  }
};

inline flatbuffers::Offset<MatMulFusion> CreateMatMulFusion(
    flatbuffers::FlatBufferBuilder &_fbb,
    bool transpose_a = false,
    bool transpose_b = false,
    mindspore::schema::ActivationType activation_type = mindspore::schema::ActivationType_NO_ACTIVATION) {
  MatMulFusionBuilder builder_(_fbb);
  builder_.add_activation_type(activation_type);
  builder_.add_transpose_b(transpose_b);
  builder_.add_transpose_a(transpose_a);
  return builder_.Finish();
}

flatbuffers::Offset<MatMulFusion> CreateMatMulFusion(flatbuffers::FlatBufferBuilder &_fbb, const MatMulFusionT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct MaximumT : public flatbuffers::NativeTable {
  typedef Maximum TableType;
};

struct Maximum FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef MaximumT NativeTableType;
  typedef MaximumBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return MaximumTypeTable();
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  MaximumT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(MaximumT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Maximum> Pack(flatbuffers::FlatBufferBuilder &_fbb, const MaximumT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct MaximumBuilder {
  typedef Maximum Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit MaximumBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Maximum> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Maximum>(end);
    return o;
  }
};

inline flatbuffers::Offset<Maximum> CreateMaximum(
    flatbuffers::FlatBufferBuilder &_fbb) {
  MaximumBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<Maximum> CreateMaximum(flatbuffers::FlatBufferBuilder &_fbb, const MaximumT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct MaximumGradT : public flatbuffers::NativeTable {
  typedef MaximumGrad TableType;
  bool grad_x = false;
  bool grad_y = false;
};

struct MaximumGrad FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef MaximumGradT NativeTableType;
  typedef MaximumGradBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return MaximumGradTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_GRAD_X = 4,
    VT_GRAD_Y = 6
  };
  bool grad_x() const {
    return GetField<uint8_t>(VT_GRAD_X, 0) != 0;
  }
  bool mutate_grad_x(bool _grad_x) {
    return SetField<uint8_t>(VT_GRAD_X, static_cast<uint8_t>(_grad_x), 0);
  }
  bool grad_y() const {
    return GetField<uint8_t>(VT_GRAD_Y, 0) != 0;
  }
  bool mutate_grad_y(bool _grad_y) {
    return SetField<uint8_t>(VT_GRAD_Y, static_cast<uint8_t>(_grad_y), 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_GRAD_X) &&
           VerifyField<uint8_t>(verifier, VT_GRAD_Y) &&
           verifier.EndTable();
  }
  MaximumGradT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(MaximumGradT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<MaximumGrad> Pack(flatbuffers::FlatBufferBuilder &_fbb, const MaximumGradT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct MaximumGradBuilder {
  typedef MaximumGrad Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_grad_x(bool grad_x) {
    fbb_.AddElement<uint8_t>(MaximumGrad::VT_GRAD_X, static_cast<uint8_t>(grad_x), 0);
  }
  void add_grad_y(bool grad_y) {
    fbb_.AddElement<uint8_t>(MaximumGrad::VT_GRAD_Y, static_cast<uint8_t>(grad_y), 0);
  }
  explicit MaximumGradBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<MaximumGrad> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<MaximumGrad>(end);
    return o;
  }
};

inline flatbuffers::Offset<MaximumGrad> CreateMaximumGrad(
    flatbuffers::FlatBufferBuilder &_fbb,
    bool grad_x = false,
    bool grad_y = false) {
  MaximumGradBuilder builder_(_fbb);
  builder_.add_grad_y(grad_y);
  builder_.add_grad_x(grad_x);
  return builder_.Finish();
}

flatbuffers::Offset<MaximumGrad> CreateMaximumGrad(flatbuffers::FlatBufferBuilder &_fbb, const MaximumGradT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct MaxPoolFusionT : public flatbuffers::NativeTable {
  typedef MaxPoolFusion TableType;
  std::vector<int64_t> kernel_size{};
  std::vector<int64_t> strides{};
  std::vector<int64_t> pad{};
  mindspore::schema::PadMode pad_mode = mindspore::schema::PadMode_PAD;
  mindspore::schema::RoundMode round_mode = mindspore::schema::RoundMode_FLOOR;
  mindspore::schema::Format format = mindspore::schema::Format_NCHW;
  bool global = false;
  mindspore::schema::ActivationType activation_type = mindspore::schema::ActivationType_NO_ACTIVATION;
};

struct MaxPoolFusion FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef MaxPoolFusionT NativeTableType;
  typedef MaxPoolFusionBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return MaxPoolFusionTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_KERNEL_SIZE = 4,
    VT_STRIDES = 6,
    VT_PAD = 8,
    VT_PAD_MODE = 10,
    VT_ROUND_MODE = 12,
    VT_FORMAT = 14,
    VT_GLOBAL = 16,
    VT_ACTIVATION_TYPE = 18
  };
  const flatbuffers::Vector<int64_t> *kernel_size() const {
    return GetPointer<const flatbuffers::Vector<int64_t> *>(VT_KERNEL_SIZE);
  }
  flatbuffers::Vector<int64_t> *mutable_kernel_size() {
    return GetPointer<flatbuffers::Vector<int64_t> *>(VT_KERNEL_SIZE);
  }
  const flatbuffers::Vector<int64_t> *strides() const {
    return GetPointer<const flatbuffers::Vector<int64_t> *>(VT_STRIDES);
  }
  flatbuffers::Vector<int64_t> *mutable_strides() {
    return GetPointer<flatbuffers::Vector<int64_t> *>(VT_STRIDES);
  }
  const flatbuffers::Vector<int64_t> *pad() const {
    return GetPointer<const flatbuffers::Vector<int64_t> *>(VT_PAD);
  }
  flatbuffers::Vector<int64_t> *mutable_pad() {
    return GetPointer<flatbuffers::Vector<int64_t> *>(VT_PAD);
  }
  mindspore::schema::PadMode pad_mode() const {
    return static_cast<mindspore::schema::PadMode>(GetField<int8_t>(VT_PAD_MODE, 0));
  }
  bool mutate_pad_mode(mindspore::schema::PadMode _pad_mode) {
    return SetField<int8_t>(VT_PAD_MODE, static_cast<int8_t>(_pad_mode), 0);
  }
  mindspore::schema::RoundMode round_mode() const {
    return static_cast<mindspore::schema::RoundMode>(GetField<int8_t>(VT_ROUND_MODE, 0));
  }
  bool mutate_round_mode(mindspore::schema::RoundMode _round_mode) {
    return SetField<int8_t>(VT_ROUND_MODE, static_cast<int8_t>(_round_mode), 0);
  }
  mindspore::schema::Format format() const {
    return static_cast<mindspore::schema::Format>(GetField<int32_t>(VT_FORMAT, 0));
  }
  bool mutate_format(mindspore::schema::Format _format) {
    return SetField<int32_t>(VT_FORMAT, static_cast<int32_t>(_format), 0);
  }
  bool global() const {
    return GetField<uint8_t>(VT_GLOBAL, 0) != 0;
  }
  bool mutate_global(bool _global) {
    return SetField<uint8_t>(VT_GLOBAL, static_cast<uint8_t>(_global), 0);
  }
  mindspore::schema::ActivationType activation_type() const {
    return static_cast<mindspore::schema::ActivationType>(GetField<int8_t>(VT_ACTIVATION_TYPE, 0));
  }
  bool mutate_activation_type(mindspore::schema::ActivationType _activation_type) {
    return SetField<int8_t>(VT_ACTIVATION_TYPE, static_cast<int8_t>(_activation_type), 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_KERNEL_SIZE) &&
           verifier.VerifyVector(kernel_size()) &&
           VerifyOffset(verifier, VT_STRIDES) &&
           verifier.VerifyVector(strides()) &&
           VerifyOffset(verifier, VT_PAD) &&
           verifier.VerifyVector(pad()) &&
           VerifyField<int8_t>(verifier, VT_PAD_MODE) &&
           VerifyField<int8_t>(verifier, VT_ROUND_MODE) &&
           VerifyField<int32_t>(verifier, VT_FORMAT) &&
           VerifyField<uint8_t>(verifier, VT_GLOBAL) &&
           VerifyField<int8_t>(verifier, VT_ACTIVATION_TYPE) &&
           verifier.EndTable();
  }
  MaxPoolFusionT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(MaxPoolFusionT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<MaxPoolFusion> Pack(flatbuffers::FlatBufferBuilder &_fbb, const MaxPoolFusionT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct MaxPoolFusionBuilder {
  typedef MaxPoolFusion Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_kernel_size(flatbuffers::Offset<flatbuffers::Vector<int64_t>> kernel_size) {
    fbb_.AddOffset(MaxPoolFusion::VT_KERNEL_SIZE, kernel_size);
  }
  void add_strides(flatbuffers::Offset<flatbuffers::Vector<int64_t>> strides) {
    fbb_.AddOffset(MaxPoolFusion::VT_STRIDES, strides);
  }
  void add_pad(flatbuffers::Offset<flatbuffers::Vector<int64_t>> pad) {
    fbb_.AddOffset(MaxPoolFusion::VT_PAD, pad);
  }
  void add_pad_mode(mindspore::schema::PadMode pad_mode) {
    fbb_.AddElement<int8_t>(MaxPoolFusion::VT_PAD_MODE, static_cast<int8_t>(pad_mode), 0);
  }
  void add_round_mode(mindspore::schema::RoundMode round_mode) {
    fbb_.AddElement<int8_t>(MaxPoolFusion::VT_ROUND_MODE, static_cast<int8_t>(round_mode), 0);
  }
  void add_format(mindspore::schema::Format format) {
    fbb_.AddElement<int32_t>(MaxPoolFusion::VT_FORMAT, static_cast<int32_t>(format), 0);
  }
  void add_global(bool global) {
    fbb_.AddElement<uint8_t>(MaxPoolFusion::VT_GLOBAL, static_cast<uint8_t>(global), 0);
  }
  void add_activation_type(mindspore::schema::ActivationType activation_type) {
    fbb_.AddElement<int8_t>(MaxPoolFusion::VT_ACTIVATION_TYPE, static_cast<int8_t>(activation_type), 0);
  }
  explicit MaxPoolFusionBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<MaxPoolFusion> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<MaxPoolFusion>(end);
    return o;
  }
};

inline flatbuffers::Offset<MaxPoolFusion> CreateMaxPoolFusion(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<int64_t>> kernel_size = 0,
    flatbuffers::Offset<flatbuffers::Vector<int64_t>> strides = 0,
    flatbuffers::Offset<flatbuffers::Vector<int64_t>> pad = 0,
    mindspore::schema::PadMode pad_mode = mindspore::schema::PadMode_PAD,
    mindspore::schema::RoundMode round_mode = mindspore::schema::RoundMode_FLOOR,
    mindspore::schema::Format format = mindspore::schema::Format_NCHW,
    bool global = false,
    mindspore::schema::ActivationType activation_type = mindspore::schema::ActivationType_NO_ACTIVATION) {
  MaxPoolFusionBuilder builder_(_fbb);
  builder_.add_format(format);
  builder_.add_pad(pad);
  builder_.add_strides(strides);
  builder_.add_kernel_size(kernel_size);
  builder_.add_activation_type(activation_type);
  builder_.add_global(global);
  builder_.add_round_mode(round_mode);
  builder_.add_pad_mode(pad_mode);
  return builder_.Finish();
}

inline flatbuffers::Offset<MaxPoolFusion> CreateMaxPoolFusionDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<int64_t> *kernel_size = nullptr,
    const std::vector<int64_t> *strides = nullptr,
    const std::vector<int64_t> *pad = nullptr,
    mindspore::schema::PadMode pad_mode = mindspore::schema::PadMode_PAD,
    mindspore::schema::RoundMode round_mode = mindspore::schema::RoundMode_FLOOR,
    mindspore::schema::Format format = mindspore::schema::Format_NCHW,
    bool global = false,
    mindspore::schema::ActivationType activation_type = mindspore::schema::ActivationType_NO_ACTIVATION) {
  auto kernel_size__ = kernel_size ? _fbb.CreateVector<int64_t>(*kernel_size) : 0;
  auto strides__ = strides ? _fbb.CreateVector<int64_t>(*strides) : 0;
  auto pad__ = pad ? _fbb.CreateVector<int64_t>(*pad) : 0;
  return mindspore::schema::CreateMaxPoolFusion(
      _fbb,
      kernel_size__,
      strides__,
      pad__,
      pad_mode,
      round_mode,
      format,
      global,
      activation_type);
}

flatbuffers::Offset<MaxPoolFusion> CreateMaxPoolFusion(flatbuffers::FlatBufferBuilder &_fbb, const MaxPoolFusionT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct MaxPoolGradT : public flatbuffers::NativeTable {
  typedef MaxPoolGrad TableType;
  std::vector<int64_t> kernel_size{};
  std::vector<int64_t> strides{};
  mindspore::schema::PadMode pad_mode = mindspore::schema::PadMode_PAD;
  mindspore::schema::Format format = mindspore::schema::Format_NCHW;
};

struct MaxPoolGrad FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef MaxPoolGradT NativeTableType;
  typedef MaxPoolGradBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return MaxPoolGradTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_KERNEL_SIZE = 4,
    VT_STRIDES = 6,
    VT_PAD_MODE = 8,
    VT_FORMAT = 10
  };
  const flatbuffers::Vector<int64_t> *kernel_size() const {
    return GetPointer<const flatbuffers::Vector<int64_t> *>(VT_KERNEL_SIZE);
  }
  flatbuffers::Vector<int64_t> *mutable_kernel_size() {
    return GetPointer<flatbuffers::Vector<int64_t> *>(VT_KERNEL_SIZE);
  }
  const flatbuffers::Vector<int64_t> *strides() const {
    return GetPointer<const flatbuffers::Vector<int64_t> *>(VT_STRIDES);
  }
  flatbuffers::Vector<int64_t> *mutable_strides() {
    return GetPointer<flatbuffers::Vector<int64_t> *>(VT_STRIDES);
  }
  mindspore::schema::PadMode pad_mode() const {
    return static_cast<mindspore::schema::PadMode>(GetField<int8_t>(VT_PAD_MODE, 0));
  }
  bool mutate_pad_mode(mindspore::schema::PadMode _pad_mode) {
    return SetField<int8_t>(VT_PAD_MODE, static_cast<int8_t>(_pad_mode), 0);
  }
  mindspore::schema::Format format() const {
    return static_cast<mindspore::schema::Format>(GetField<int32_t>(VT_FORMAT, 0));
  }
  bool mutate_format(mindspore::schema::Format _format) {
    return SetField<int32_t>(VT_FORMAT, static_cast<int32_t>(_format), 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_KERNEL_SIZE) &&
           verifier.VerifyVector(kernel_size()) &&
           VerifyOffset(verifier, VT_STRIDES) &&
           verifier.VerifyVector(strides()) &&
           VerifyField<int8_t>(verifier, VT_PAD_MODE) &&
           VerifyField<int32_t>(verifier, VT_FORMAT) &&
           verifier.EndTable();
  }
  MaxPoolGradT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(MaxPoolGradT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<MaxPoolGrad> Pack(flatbuffers::FlatBufferBuilder &_fbb, const MaxPoolGradT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct MaxPoolGradBuilder {
  typedef MaxPoolGrad Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_kernel_size(flatbuffers::Offset<flatbuffers::Vector<int64_t>> kernel_size) {
    fbb_.AddOffset(MaxPoolGrad::VT_KERNEL_SIZE, kernel_size);
  }
  void add_strides(flatbuffers::Offset<flatbuffers::Vector<int64_t>> strides) {
    fbb_.AddOffset(MaxPoolGrad::VT_STRIDES, strides);
  }
  void add_pad_mode(mindspore::schema::PadMode pad_mode) {
    fbb_.AddElement<int8_t>(MaxPoolGrad::VT_PAD_MODE, static_cast<int8_t>(pad_mode), 0);
  }
  void add_format(mindspore::schema::Format format) {
    fbb_.AddElement<int32_t>(MaxPoolGrad::VT_FORMAT, static_cast<int32_t>(format), 0);
  }
  explicit MaxPoolGradBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<MaxPoolGrad> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<MaxPoolGrad>(end);
    return o;
  }
};

inline flatbuffers::Offset<MaxPoolGrad> CreateMaxPoolGrad(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<int64_t>> kernel_size = 0,
    flatbuffers::Offset<flatbuffers::Vector<int64_t>> strides = 0,
    mindspore::schema::PadMode pad_mode = mindspore::schema::PadMode_PAD,
    mindspore::schema::Format format = mindspore::schema::Format_NCHW) {
  MaxPoolGradBuilder builder_(_fbb);
  builder_.add_format(format);
  builder_.add_strides(strides);
  builder_.add_kernel_size(kernel_size);
  builder_.add_pad_mode(pad_mode);
  return builder_.Finish();
}

inline flatbuffers::Offset<MaxPoolGrad> CreateMaxPoolGradDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<int64_t> *kernel_size = nullptr,
    const std::vector<int64_t> *strides = nullptr,
    mindspore::schema::PadMode pad_mode = mindspore::schema::PadMode_PAD,
    mindspore::schema::Format format = mindspore::schema::Format_NCHW) {
  auto kernel_size__ = kernel_size ? _fbb.CreateVector<int64_t>(*kernel_size) : 0;
  auto strides__ = strides ? _fbb.CreateVector<int64_t>(*strides) : 0;
  return mindspore::schema::CreateMaxPoolGrad(
      _fbb,
      kernel_size__,
      strides__,
      pad_mode,
      format);
}

flatbuffers::Offset<MaxPoolGrad> CreateMaxPoolGrad(flatbuffers::FlatBufferBuilder &_fbb, const MaxPoolGradT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct MergeT : public flatbuffers::NativeTable {
  typedef Merge TableType;
};

struct Merge FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef MergeT NativeTableType;
  typedef MergeBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return MergeTypeTable();
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  MergeT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(MergeT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Merge> Pack(flatbuffers::FlatBufferBuilder &_fbb, const MergeT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct MergeBuilder {
  typedef Merge Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit MergeBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Merge> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Merge>(end);
    return o;
  }
};

inline flatbuffers::Offset<Merge> CreateMerge(
    flatbuffers::FlatBufferBuilder &_fbb) {
  MergeBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<Merge> CreateMerge(flatbuffers::FlatBufferBuilder &_fbb, const MergeT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct MfccT : public flatbuffers::NativeTable {
  typedef Mfcc TableType;
  float freq_upper_limit = 0.0f;
  float freq_lower_limit = 0.0f;
  int64_t filter_bank_channel_num = 0;
  int64_t dct_coeff_num = 0;
};

struct Mfcc FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef MfccT NativeTableType;
  typedef MfccBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return MfccTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_FREQ_UPPER_LIMIT = 4,
    VT_FREQ_LOWER_LIMIT = 6,
    VT_FILTER_BANK_CHANNEL_NUM = 8,
    VT_DCT_COEFF_NUM = 10
  };
  float freq_upper_limit() const {
    return GetField<float>(VT_FREQ_UPPER_LIMIT, 0.0f);
  }
  bool mutate_freq_upper_limit(float _freq_upper_limit) {
    return SetField<float>(VT_FREQ_UPPER_LIMIT, _freq_upper_limit, 0.0f);
  }
  float freq_lower_limit() const {
    return GetField<float>(VT_FREQ_LOWER_LIMIT, 0.0f);
  }
  bool mutate_freq_lower_limit(float _freq_lower_limit) {
    return SetField<float>(VT_FREQ_LOWER_LIMIT, _freq_lower_limit, 0.0f);
  }
  int64_t filter_bank_channel_num() const {
    return GetField<int64_t>(VT_FILTER_BANK_CHANNEL_NUM, 0);
  }
  bool mutate_filter_bank_channel_num(int64_t _filter_bank_channel_num) {
    return SetField<int64_t>(VT_FILTER_BANK_CHANNEL_NUM, _filter_bank_channel_num, 0);
  }
  int64_t dct_coeff_num() const {
    return GetField<int64_t>(VT_DCT_COEFF_NUM, 0);
  }
  bool mutate_dct_coeff_num(int64_t _dct_coeff_num) {
    return SetField<int64_t>(VT_DCT_COEFF_NUM, _dct_coeff_num, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<float>(verifier, VT_FREQ_UPPER_LIMIT) &&
           VerifyField<float>(verifier, VT_FREQ_LOWER_LIMIT) &&
           VerifyField<int64_t>(verifier, VT_FILTER_BANK_CHANNEL_NUM) &&
           VerifyField<int64_t>(verifier, VT_DCT_COEFF_NUM) &&
           verifier.EndTable();
  }
  MfccT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(MfccT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Mfcc> Pack(flatbuffers::FlatBufferBuilder &_fbb, const MfccT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct MfccBuilder {
  typedef Mfcc Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_freq_upper_limit(float freq_upper_limit) {
    fbb_.AddElement<float>(Mfcc::VT_FREQ_UPPER_LIMIT, freq_upper_limit, 0.0f);
  }
  void add_freq_lower_limit(float freq_lower_limit) {
    fbb_.AddElement<float>(Mfcc::VT_FREQ_LOWER_LIMIT, freq_lower_limit, 0.0f);
  }
  void add_filter_bank_channel_num(int64_t filter_bank_channel_num) {
    fbb_.AddElement<int64_t>(Mfcc::VT_FILTER_BANK_CHANNEL_NUM, filter_bank_channel_num, 0);
  }
  void add_dct_coeff_num(int64_t dct_coeff_num) {
    fbb_.AddElement<int64_t>(Mfcc::VT_DCT_COEFF_NUM, dct_coeff_num, 0);
  }
  explicit MfccBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Mfcc> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Mfcc>(end);
    return o;
  }
};

inline flatbuffers::Offset<Mfcc> CreateMfcc(
    flatbuffers::FlatBufferBuilder &_fbb,
    float freq_upper_limit = 0.0f,
    float freq_lower_limit = 0.0f,
    int64_t filter_bank_channel_num = 0,
    int64_t dct_coeff_num = 0) {
  MfccBuilder builder_(_fbb);
  builder_.add_dct_coeff_num(dct_coeff_num);
  builder_.add_filter_bank_channel_num(filter_bank_channel_num);
  builder_.add_freq_lower_limit(freq_lower_limit);
  builder_.add_freq_upper_limit(freq_upper_limit);
  return builder_.Finish();
}

flatbuffers::Offset<Mfcc> CreateMfcc(flatbuffers::FlatBufferBuilder &_fbb, const MfccT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct MinimumT : public flatbuffers::NativeTable {
  typedef Minimum TableType;
};

struct Minimum FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef MinimumT NativeTableType;
  typedef MinimumBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return MinimumTypeTable();
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  MinimumT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(MinimumT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Minimum> Pack(flatbuffers::FlatBufferBuilder &_fbb, const MinimumT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct MinimumBuilder {
  typedef Minimum Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit MinimumBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Minimum> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Minimum>(end);
    return o;
  }
};

inline flatbuffers::Offset<Minimum> CreateMinimum(
    flatbuffers::FlatBufferBuilder &_fbb) {
  MinimumBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<Minimum> CreateMinimum(flatbuffers::FlatBufferBuilder &_fbb, const MinimumT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct MinimumGradT : public flatbuffers::NativeTable {
  typedef MinimumGrad TableType;
  bool grad_x = false;
  bool grad_y = false;
};

struct MinimumGrad FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef MinimumGradT NativeTableType;
  typedef MinimumGradBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return MinimumGradTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_GRAD_X = 4,
    VT_GRAD_Y = 6
  };
  bool grad_x() const {
    return GetField<uint8_t>(VT_GRAD_X, 0) != 0;
  }
  bool mutate_grad_x(bool _grad_x) {
    return SetField<uint8_t>(VT_GRAD_X, static_cast<uint8_t>(_grad_x), 0);
  }
  bool grad_y() const {
    return GetField<uint8_t>(VT_GRAD_Y, 0) != 0;
  }
  bool mutate_grad_y(bool _grad_y) {
    return SetField<uint8_t>(VT_GRAD_Y, static_cast<uint8_t>(_grad_y), 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_GRAD_X) &&
           VerifyField<uint8_t>(verifier, VT_GRAD_Y) &&
           verifier.EndTable();
  }
  MinimumGradT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(MinimumGradT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<MinimumGrad> Pack(flatbuffers::FlatBufferBuilder &_fbb, const MinimumGradT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct MinimumGradBuilder {
  typedef MinimumGrad Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_grad_x(bool grad_x) {
    fbb_.AddElement<uint8_t>(MinimumGrad::VT_GRAD_X, static_cast<uint8_t>(grad_x), 0);
  }
  void add_grad_y(bool grad_y) {
    fbb_.AddElement<uint8_t>(MinimumGrad::VT_GRAD_Y, static_cast<uint8_t>(grad_y), 0);
  }
  explicit MinimumGradBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<MinimumGrad> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<MinimumGrad>(end);
    return o;
  }
};

inline flatbuffers::Offset<MinimumGrad> CreateMinimumGrad(
    flatbuffers::FlatBufferBuilder &_fbb,
    bool grad_x = false,
    bool grad_y = false) {
  MinimumGradBuilder builder_(_fbb);
  builder_.add_grad_y(grad_y);
  builder_.add_grad_x(grad_x);
  return builder_.Finish();
}

flatbuffers::Offset<MinimumGrad> CreateMinimumGrad(flatbuffers::FlatBufferBuilder &_fbb, const MinimumGradT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ModT : public flatbuffers::NativeTable {
  typedef Mod TableType;
};

struct Mod FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ModT NativeTableType;
  typedef ModBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return ModTypeTable();
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  ModT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ModT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Mod> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ModT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ModBuilder {
  typedef Mod Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit ModBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Mod> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Mod>(end);
    return o;
  }
};

inline flatbuffers::Offset<Mod> CreateMod(
    flatbuffers::FlatBufferBuilder &_fbb) {
  ModBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<Mod> CreateMod(flatbuffers::FlatBufferBuilder &_fbb, const ModT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct MulFusionT : public flatbuffers::NativeTable {
  typedef MulFusion TableType;
  mindspore::schema::ActivationType activation_type = mindspore::schema::ActivationType_NO_ACTIVATION;
};

struct MulFusion FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef MulFusionT NativeTableType;
  typedef MulFusionBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return MulFusionTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ACTIVATION_TYPE = 4
  };
  mindspore::schema::ActivationType activation_type() const {
    return static_cast<mindspore::schema::ActivationType>(GetField<int8_t>(VT_ACTIVATION_TYPE, 0));
  }
  bool mutate_activation_type(mindspore::schema::ActivationType _activation_type) {
    return SetField<int8_t>(VT_ACTIVATION_TYPE, static_cast<int8_t>(_activation_type), 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_ACTIVATION_TYPE) &&
           verifier.EndTable();
  }
  MulFusionT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(MulFusionT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<MulFusion> Pack(flatbuffers::FlatBufferBuilder &_fbb, const MulFusionT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct MulFusionBuilder {
  typedef MulFusion Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_activation_type(mindspore::schema::ActivationType activation_type) {
    fbb_.AddElement<int8_t>(MulFusion::VT_ACTIVATION_TYPE, static_cast<int8_t>(activation_type), 0);
  }
  explicit MulFusionBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<MulFusion> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<MulFusion>(end);
    return o;
  }
};

inline flatbuffers::Offset<MulFusion> CreateMulFusion(
    flatbuffers::FlatBufferBuilder &_fbb,
    mindspore::schema::ActivationType activation_type = mindspore::schema::ActivationType_NO_ACTIVATION) {
  MulFusionBuilder builder_(_fbb);
  builder_.add_activation_type(activation_type);
  return builder_.Finish();
}

flatbuffers::Offset<MulFusion> CreateMulFusion(flatbuffers::FlatBufferBuilder &_fbb, const MulFusionT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct MulGradT : public flatbuffers::NativeTable {
  typedef MulGrad TableType;
};

struct MulGrad FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef MulGradT NativeTableType;
  typedef MulGradBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return MulGradTypeTable();
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  MulGradT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(MulGradT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<MulGrad> Pack(flatbuffers::FlatBufferBuilder &_fbb, const MulGradT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct MulGradBuilder {
  typedef MulGrad Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit MulGradBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<MulGrad> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<MulGrad>(end);
    return o;
  }
};

inline flatbuffers::Offset<MulGrad> CreateMulGrad(
    flatbuffers::FlatBufferBuilder &_fbb) {
  MulGradBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<MulGrad> CreateMulGrad(flatbuffers::FlatBufferBuilder &_fbb, const MulGradT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct NegT : public flatbuffers::NativeTable {
  typedef Neg TableType;
};

struct Neg FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef NegT NativeTableType;
  typedef NegBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return NegTypeTable();
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  NegT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(NegT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Neg> Pack(flatbuffers::FlatBufferBuilder &_fbb, const NegT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct NegBuilder {
  typedef Neg Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit NegBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Neg> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Neg>(end);
    return o;
  }
};

inline flatbuffers::Offset<Neg> CreateNeg(
    flatbuffers::FlatBufferBuilder &_fbb) {
  NegBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<Neg> CreateNeg(flatbuffers::FlatBufferBuilder &_fbb, const NegT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct NegGradT : public flatbuffers::NativeTable {
  typedef NegGrad TableType;
};

struct NegGrad FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef NegGradT NativeTableType;
  typedef NegGradBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return NegGradTypeTable();
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  NegGradT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(NegGradT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<NegGrad> Pack(flatbuffers::FlatBufferBuilder &_fbb, const NegGradT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct NegGradBuilder {
  typedef NegGrad Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit NegGradBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<NegGrad> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<NegGrad>(end);
    return o;
  }
};

inline flatbuffers::Offset<NegGrad> CreateNegGrad(
    flatbuffers::FlatBufferBuilder &_fbb) {
  NegGradBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<NegGrad> CreateNegGrad(flatbuffers::FlatBufferBuilder &_fbb, const NegGradT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct NotEqualT : public flatbuffers::NativeTable {
  typedef NotEqual TableType;
};

struct NotEqual FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef NotEqualT NativeTableType;
  typedef NotEqualBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return NotEqualTypeTable();
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  NotEqualT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(NotEqualT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<NotEqual> Pack(flatbuffers::FlatBufferBuilder &_fbb, const NotEqualT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct NotEqualBuilder {
  typedef NotEqual Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit NotEqualBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<NotEqual> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<NotEqual>(end);
    return o;
  }
};

inline flatbuffers::Offset<NotEqual> CreateNotEqual(
    flatbuffers::FlatBufferBuilder &_fbb) {
  NotEqualBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<NotEqual> CreateNotEqual(flatbuffers::FlatBufferBuilder &_fbb, const NotEqualT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct NonMaxSuppressionT : public flatbuffers::NativeTable {
  typedef NonMaxSuppression TableType;
  int64_t center_point_box = 0;
};

struct NonMaxSuppression FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef NonMaxSuppressionT NativeTableType;
  typedef NonMaxSuppressionBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return NonMaxSuppressionTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_CENTER_POINT_BOX = 4
  };
  int64_t center_point_box() const {
    return GetField<int64_t>(VT_CENTER_POINT_BOX, 0);
  }
  bool mutate_center_point_box(int64_t _center_point_box) {
    return SetField<int64_t>(VT_CENTER_POINT_BOX, _center_point_box, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_CENTER_POINT_BOX) &&
           verifier.EndTable();
  }
  NonMaxSuppressionT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(NonMaxSuppressionT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<NonMaxSuppression> Pack(flatbuffers::FlatBufferBuilder &_fbb, const NonMaxSuppressionT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct NonMaxSuppressionBuilder {
  typedef NonMaxSuppression Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_center_point_box(int64_t center_point_box) {
    fbb_.AddElement<int64_t>(NonMaxSuppression::VT_CENTER_POINT_BOX, center_point_box, 0);
  }
  explicit NonMaxSuppressionBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<NonMaxSuppression> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<NonMaxSuppression>(end);
    return o;
  }
};

inline flatbuffers::Offset<NonMaxSuppression> CreateNonMaxSuppression(
    flatbuffers::FlatBufferBuilder &_fbb,
    int64_t center_point_box = 0) {
  NonMaxSuppressionBuilder builder_(_fbb);
  builder_.add_center_point_box(center_point_box);
  return builder_.Finish();
}

flatbuffers::Offset<NonMaxSuppression> CreateNonMaxSuppression(flatbuffers::FlatBufferBuilder &_fbb, const NonMaxSuppressionT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct OneHotT : public flatbuffers::NativeTable {
  typedef OneHot TableType;
  int64_t axis = 0;
};

struct OneHot FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef OneHotT NativeTableType;
  typedef OneHotBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return OneHotTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_AXIS = 4
  };
  int64_t axis() const {
    return GetField<int64_t>(VT_AXIS, 0);
  }
  bool mutate_axis(int64_t _axis) {
    return SetField<int64_t>(VT_AXIS, _axis, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_AXIS) &&
           verifier.EndTable();
  }
  OneHotT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(OneHotT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<OneHot> Pack(flatbuffers::FlatBufferBuilder &_fbb, const OneHotT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct OneHotBuilder {
  typedef OneHot Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_axis(int64_t axis) {
    fbb_.AddElement<int64_t>(OneHot::VT_AXIS, axis, 0);
  }
  explicit OneHotBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<OneHot> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<OneHot>(end);
    return o;
  }
};

inline flatbuffers::Offset<OneHot> CreateOneHot(
    flatbuffers::FlatBufferBuilder &_fbb,
    int64_t axis = 0) {
  OneHotBuilder builder_(_fbb);
  builder_.add_axis(axis);
  return builder_.Finish();
}

flatbuffers::Offset<OneHot> CreateOneHot(flatbuffers::FlatBufferBuilder &_fbb, const OneHotT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct OnesLikeT : public flatbuffers::NativeTable {
  typedef OnesLike TableType;
};

struct OnesLike FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef OnesLikeT NativeTableType;
  typedef OnesLikeBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return OnesLikeTypeTable();
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  OnesLikeT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(OnesLikeT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<OnesLike> Pack(flatbuffers::FlatBufferBuilder &_fbb, const OnesLikeT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct OnesLikeBuilder {
  typedef OnesLike Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit OnesLikeBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<OnesLike> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<OnesLike>(end);
    return o;
  }
};

inline flatbuffers::Offset<OnesLike> CreateOnesLike(
    flatbuffers::FlatBufferBuilder &_fbb) {
  OnesLikeBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<OnesLike> CreateOnesLike(flatbuffers::FlatBufferBuilder &_fbb, const OnesLikeT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct PadFusionT : public flatbuffers::NativeTable {
  typedef PadFusion TableType;
  std::unique_ptr<mindspore::schema::Vec2DT> paddings{};
  mindspore::schema::PaddingMode padding_mode = mindspore::schema::PaddingMode_CONSTANT;
  float constant_value = 0.0f;
};

struct PadFusion FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef PadFusionT NativeTableType;
  typedef PadFusionBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return PadFusionTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_PADDINGS = 4,
    VT_PADDING_MODE = 6,
    VT_CONSTANT_VALUE = 8
  };
  const mindspore::schema::Vec2D *paddings() const {
    return GetPointer<const mindspore::schema::Vec2D *>(VT_PADDINGS);
  }
  mindspore::schema::Vec2D *mutable_paddings() {
    return GetPointer<mindspore::schema::Vec2D *>(VT_PADDINGS);
  }
  mindspore::schema::PaddingMode padding_mode() const {
    return static_cast<mindspore::schema::PaddingMode>(GetField<int8_t>(VT_PADDING_MODE, 0));
  }
  bool mutate_padding_mode(mindspore::schema::PaddingMode _padding_mode) {
    return SetField<int8_t>(VT_PADDING_MODE, static_cast<int8_t>(_padding_mode), 0);
  }
  float constant_value() const {
    return GetField<float>(VT_CONSTANT_VALUE, 0.0f);
  }
  bool mutate_constant_value(float _constant_value) {
    return SetField<float>(VT_CONSTANT_VALUE, _constant_value, 0.0f);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_PADDINGS) &&
           verifier.VerifyTable(paddings()) &&
           VerifyField<int8_t>(verifier, VT_PADDING_MODE) &&
           VerifyField<float>(verifier, VT_CONSTANT_VALUE) &&
           verifier.EndTable();
  }
  PadFusionT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(PadFusionT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<PadFusion> Pack(flatbuffers::FlatBufferBuilder &_fbb, const PadFusionT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct PadFusionBuilder {
  typedef PadFusion Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_paddings(flatbuffers::Offset<mindspore::schema::Vec2D> paddings) {
    fbb_.AddOffset(PadFusion::VT_PADDINGS, paddings);
  }
  void add_padding_mode(mindspore::schema::PaddingMode padding_mode) {
    fbb_.AddElement<int8_t>(PadFusion::VT_PADDING_MODE, static_cast<int8_t>(padding_mode), 0);
  }
  void add_constant_value(float constant_value) {
    fbb_.AddElement<float>(PadFusion::VT_CONSTANT_VALUE, constant_value, 0.0f);
  }
  explicit PadFusionBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<PadFusion> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<PadFusion>(end);
    return o;
  }
};

inline flatbuffers::Offset<PadFusion> CreatePadFusion(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<mindspore::schema::Vec2D> paddings = 0,
    mindspore::schema::PaddingMode padding_mode = mindspore::schema::PaddingMode_CONSTANT,
    float constant_value = 0.0f) {
  PadFusionBuilder builder_(_fbb);
  builder_.add_constant_value(constant_value);
  builder_.add_paddings(paddings);
  builder_.add_padding_mode(padding_mode);
  return builder_.Finish();
}

flatbuffers::Offset<PadFusion> CreatePadFusion(flatbuffers::FlatBufferBuilder &_fbb, const PadFusionT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct PartialFusionT : public flatbuffers::NativeTable {
  typedef PartialFusion TableType;
  int64_t sub_graph_index = 0;
};

struct PartialFusion FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef PartialFusionT NativeTableType;
  typedef PartialFusionBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return PartialFusionTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SUB_GRAPH_INDEX = 4
  };
  int64_t sub_graph_index() const {
    return GetField<int64_t>(VT_SUB_GRAPH_INDEX, 0);
  }
  bool mutate_sub_graph_index(int64_t _sub_graph_index) {
    return SetField<int64_t>(VT_SUB_GRAPH_INDEX, _sub_graph_index, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_SUB_GRAPH_INDEX) &&
           verifier.EndTable();
  }
  PartialFusionT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(PartialFusionT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<PartialFusion> Pack(flatbuffers::FlatBufferBuilder &_fbb, const PartialFusionT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct PartialFusionBuilder {
  typedef PartialFusion Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_sub_graph_index(int64_t sub_graph_index) {
    fbb_.AddElement<int64_t>(PartialFusion::VT_SUB_GRAPH_INDEX, sub_graph_index, 0);
  }
  explicit PartialFusionBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<PartialFusion> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<PartialFusion>(end);
    return o;
  }
};

inline flatbuffers::Offset<PartialFusion> CreatePartialFusion(
    flatbuffers::FlatBufferBuilder &_fbb,
    int64_t sub_graph_index = 0) {
  PartialFusionBuilder builder_(_fbb);
  builder_.add_sub_graph_index(sub_graph_index);
  return builder_.Finish();
}

flatbuffers::Offset<PartialFusion> CreatePartialFusion(flatbuffers::FlatBufferBuilder &_fbb, const PartialFusionT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct PowerGradT : public flatbuffers::NativeTable {
  typedef PowerGrad TableType;
  float power = 0.0f;
  float scale = 0.0f;
  float shift = 0.0f;
};

struct PowerGrad FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef PowerGradT NativeTableType;
  typedef PowerGradBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return PowerGradTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_POWER = 4,
    VT_SCALE = 6,
    VT_SHIFT = 8
  };
  float power() const {
    return GetField<float>(VT_POWER, 0.0f);
  }
  bool mutate_power(float _power) {
    return SetField<float>(VT_POWER, _power, 0.0f);
  }
  float scale() const {
    return GetField<float>(VT_SCALE, 0.0f);
  }
  bool mutate_scale(float _scale) {
    return SetField<float>(VT_SCALE, _scale, 0.0f);
  }
  float shift() const {
    return GetField<float>(VT_SHIFT, 0.0f);
  }
  bool mutate_shift(float _shift) {
    return SetField<float>(VT_SHIFT, _shift, 0.0f);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<float>(verifier, VT_POWER) &&
           VerifyField<float>(verifier, VT_SCALE) &&
           VerifyField<float>(verifier, VT_SHIFT) &&
           verifier.EndTable();
  }
  PowerGradT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(PowerGradT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<PowerGrad> Pack(flatbuffers::FlatBufferBuilder &_fbb, const PowerGradT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct PowerGradBuilder {
  typedef PowerGrad Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_power(float power) {
    fbb_.AddElement<float>(PowerGrad::VT_POWER, power, 0.0f);
  }
  void add_scale(float scale) {
    fbb_.AddElement<float>(PowerGrad::VT_SCALE, scale, 0.0f);
  }
  void add_shift(float shift) {
    fbb_.AddElement<float>(PowerGrad::VT_SHIFT, shift, 0.0f);
  }
  explicit PowerGradBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<PowerGrad> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<PowerGrad>(end);
    return o;
  }
};

inline flatbuffers::Offset<PowerGrad> CreatePowerGrad(
    flatbuffers::FlatBufferBuilder &_fbb,
    float power = 0.0f,
    float scale = 0.0f,
    float shift = 0.0f) {
  PowerGradBuilder builder_(_fbb);
  builder_.add_shift(shift);
  builder_.add_scale(scale);
  builder_.add_power(power);
  return builder_.Finish();
}

flatbuffers::Offset<PowerGrad> CreatePowerGrad(flatbuffers::FlatBufferBuilder &_fbb, const PowerGradT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct PowFusionT : public flatbuffers::NativeTable {
  typedef PowFusion TableType;
  float scale = 1.0f;
  float shift = 0.0f;
};

struct PowFusion FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef PowFusionT NativeTableType;
  typedef PowFusionBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return PowFusionTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SCALE = 4,
    VT_SHIFT = 6
  };
  float scale() const {
    return GetField<float>(VT_SCALE, 1.0f);
  }
  bool mutate_scale(float _scale) {
    return SetField<float>(VT_SCALE, _scale, 1.0f);
  }
  float shift() const {
    return GetField<float>(VT_SHIFT, 0.0f);
  }
  bool mutate_shift(float _shift) {
    return SetField<float>(VT_SHIFT, _shift, 0.0f);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<float>(verifier, VT_SCALE) &&
           VerifyField<float>(verifier, VT_SHIFT) &&
           verifier.EndTable();
  }
  PowFusionT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(PowFusionT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<PowFusion> Pack(flatbuffers::FlatBufferBuilder &_fbb, const PowFusionT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct PowFusionBuilder {
  typedef PowFusion Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_scale(float scale) {
    fbb_.AddElement<float>(PowFusion::VT_SCALE, scale, 1.0f);
  }
  void add_shift(float shift) {
    fbb_.AddElement<float>(PowFusion::VT_SHIFT, shift, 0.0f);
  }
  explicit PowFusionBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<PowFusion> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<PowFusion>(end);
    return o;
  }
};

inline flatbuffers::Offset<PowFusion> CreatePowFusion(
    flatbuffers::FlatBufferBuilder &_fbb,
    float scale = 1.0f,
    float shift = 0.0f) {
  PowFusionBuilder builder_(_fbb);
  builder_.add_shift(shift);
  builder_.add_scale(scale);
  return builder_.Finish();
}

flatbuffers::Offset<PowFusion> CreatePowFusion(flatbuffers::FlatBufferBuilder &_fbb, const PowFusionT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct PriorBoxT : public flatbuffers::NativeTable {
  typedef PriorBox TableType;
  std::vector<int64_t> min_sizes{};
  std::vector<int64_t> max_sizes{};
  std::vector<float> aspect_ratios{};
  std::vector<float> variances{};
  int64_t image_size_w = 0;
  int64_t image_size_h = 0;
  float step_w = 0.0f;
  float step_h = 0.0f;
  bool clip = false;
  bool flip = false;
  float offset = 0.0f;
};

struct PriorBox FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef PriorBoxT NativeTableType;
  typedef PriorBoxBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return PriorBoxTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_MIN_SIZES = 4,
    VT_MAX_SIZES = 6,
    VT_ASPECT_RATIOS = 8,
    VT_VARIANCES = 10,
    VT_IMAGE_SIZE_W = 12,
    VT_IMAGE_SIZE_H = 14,
    VT_STEP_W = 16,
    VT_STEP_H = 18,
    VT_CLIP = 20,
    VT_FLIP = 22,
    VT_OFFSET = 24
  };
  const flatbuffers::Vector<int64_t> *min_sizes() const {
    return GetPointer<const flatbuffers::Vector<int64_t> *>(VT_MIN_SIZES);
  }
  flatbuffers::Vector<int64_t> *mutable_min_sizes() {
    return GetPointer<flatbuffers::Vector<int64_t> *>(VT_MIN_SIZES);
  }
  const flatbuffers::Vector<int64_t> *max_sizes() const {
    return GetPointer<const flatbuffers::Vector<int64_t> *>(VT_MAX_SIZES);
  }
  flatbuffers::Vector<int64_t> *mutable_max_sizes() {
    return GetPointer<flatbuffers::Vector<int64_t> *>(VT_MAX_SIZES);
  }
  const flatbuffers::Vector<float> *aspect_ratios() const {
    return GetPointer<const flatbuffers::Vector<float> *>(VT_ASPECT_RATIOS);
  }
  flatbuffers::Vector<float> *mutable_aspect_ratios() {
    return GetPointer<flatbuffers::Vector<float> *>(VT_ASPECT_RATIOS);
  }
  const flatbuffers::Vector<float> *variances() const {
    return GetPointer<const flatbuffers::Vector<float> *>(VT_VARIANCES);
  }
  flatbuffers::Vector<float> *mutable_variances() {
    return GetPointer<flatbuffers::Vector<float> *>(VT_VARIANCES);
  }
  int64_t image_size_w() const {
    return GetField<int64_t>(VT_IMAGE_SIZE_W, 0);
  }
  bool mutate_image_size_w(int64_t _image_size_w) {
    return SetField<int64_t>(VT_IMAGE_SIZE_W, _image_size_w, 0);
  }
  int64_t image_size_h() const {
    return GetField<int64_t>(VT_IMAGE_SIZE_H, 0);
  }
  bool mutate_image_size_h(int64_t _image_size_h) {
    return SetField<int64_t>(VT_IMAGE_SIZE_H, _image_size_h, 0);
  }
  float step_w() const {
    return GetField<float>(VT_STEP_W, 0.0f);
  }
  bool mutate_step_w(float _step_w) {
    return SetField<float>(VT_STEP_W, _step_w, 0.0f);
  }
  float step_h() const {
    return GetField<float>(VT_STEP_H, 0.0f);
  }
  bool mutate_step_h(float _step_h) {
    return SetField<float>(VT_STEP_H, _step_h, 0.0f);
  }
  bool clip() const {
    return GetField<uint8_t>(VT_CLIP, 0) != 0;
  }
  bool mutate_clip(bool _clip) {
    return SetField<uint8_t>(VT_CLIP, static_cast<uint8_t>(_clip), 0);
  }
  bool flip() const {
    return GetField<uint8_t>(VT_FLIP, 0) != 0;
  }
  bool mutate_flip(bool _flip) {
    return SetField<uint8_t>(VT_FLIP, static_cast<uint8_t>(_flip), 0);
  }
  float offset() const {
    return GetField<float>(VT_OFFSET, 0.0f);
  }
  bool mutate_offset(float _offset) {
    return SetField<float>(VT_OFFSET, _offset, 0.0f);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_MIN_SIZES) &&
           verifier.VerifyVector(min_sizes()) &&
           VerifyOffset(verifier, VT_MAX_SIZES) &&
           verifier.VerifyVector(max_sizes()) &&
           VerifyOffset(verifier, VT_ASPECT_RATIOS) &&
           verifier.VerifyVector(aspect_ratios()) &&
           VerifyOffset(verifier, VT_VARIANCES) &&
           verifier.VerifyVector(variances()) &&
           VerifyField<int64_t>(verifier, VT_IMAGE_SIZE_W) &&
           VerifyField<int64_t>(verifier, VT_IMAGE_SIZE_H) &&
           VerifyField<float>(verifier, VT_STEP_W) &&
           VerifyField<float>(verifier, VT_STEP_H) &&
           VerifyField<uint8_t>(verifier, VT_CLIP) &&
           VerifyField<uint8_t>(verifier, VT_FLIP) &&
           VerifyField<float>(verifier, VT_OFFSET) &&
           verifier.EndTable();
  }
  PriorBoxT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(PriorBoxT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<PriorBox> Pack(flatbuffers::FlatBufferBuilder &_fbb, const PriorBoxT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct PriorBoxBuilder {
  typedef PriorBox Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_min_sizes(flatbuffers::Offset<flatbuffers::Vector<int64_t>> min_sizes) {
    fbb_.AddOffset(PriorBox::VT_MIN_SIZES, min_sizes);
  }
  void add_max_sizes(flatbuffers::Offset<flatbuffers::Vector<int64_t>> max_sizes) {
    fbb_.AddOffset(PriorBox::VT_MAX_SIZES, max_sizes);
  }
  void add_aspect_ratios(flatbuffers::Offset<flatbuffers::Vector<float>> aspect_ratios) {
    fbb_.AddOffset(PriorBox::VT_ASPECT_RATIOS, aspect_ratios);
  }
  void add_variances(flatbuffers::Offset<flatbuffers::Vector<float>> variances) {
    fbb_.AddOffset(PriorBox::VT_VARIANCES, variances);
  }
  void add_image_size_w(int64_t image_size_w) {
    fbb_.AddElement<int64_t>(PriorBox::VT_IMAGE_SIZE_W, image_size_w, 0);
  }
  void add_image_size_h(int64_t image_size_h) {
    fbb_.AddElement<int64_t>(PriorBox::VT_IMAGE_SIZE_H, image_size_h, 0);
  }
  void add_step_w(float step_w) {
    fbb_.AddElement<float>(PriorBox::VT_STEP_W, step_w, 0.0f);
  }
  void add_step_h(float step_h) {
    fbb_.AddElement<float>(PriorBox::VT_STEP_H, step_h, 0.0f);
  }
  void add_clip(bool clip) {
    fbb_.AddElement<uint8_t>(PriorBox::VT_CLIP, static_cast<uint8_t>(clip), 0);
  }
  void add_flip(bool flip) {
    fbb_.AddElement<uint8_t>(PriorBox::VT_FLIP, static_cast<uint8_t>(flip), 0);
  }
  void add_offset(float offset) {
    fbb_.AddElement<float>(PriorBox::VT_OFFSET, offset, 0.0f);
  }
  explicit PriorBoxBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<PriorBox> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<PriorBox>(end);
    return o;
  }
};

inline flatbuffers::Offset<PriorBox> CreatePriorBox(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<int64_t>> min_sizes = 0,
    flatbuffers::Offset<flatbuffers::Vector<int64_t>> max_sizes = 0,
    flatbuffers::Offset<flatbuffers::Vector<float>> aspect_ratios = 0,
    flatbuffers::Offset<flatbuffers::Vector<float>> variances = 0,
    int64_t image_size_w = 0,
    int64_t image_size_h = 0,
    float step_w = 0.0f,
    float step_h = 0.0f,
    bool clip = false,
    bool flip = false,
    float offset = 0.0f) {
  PriorBoxBuilder builder_(_fbb);
  builder_.add_image_size_h(image_size_h);
  builder_.add_image_size_w(image_size_w);
  builder_.add_offset(offset);
  builder_.add_step_h(step_h);
  builder_.add_step_w(step_w);
  builder_.add_variances(variances);
  builder_.add_aspect_ratios(aspect_ratios);
  builder_.add_max_sizes(max_sizes);
  builder_.add_min_sizes(min_sizes);
  builder_.add_flip(flip);
  builder_.add_clip(clip);
  return builder_.Finish();
}

inline flatbuffers::Offset<PriorBox> CreatePriorBoxDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<int64_t> *min_sizes = nullptr,
    const std::vector<int64_t> *max_sizes = nullptr,
    const std::vector<float> *aspect_ratios = nullptr,
    const std::vector<float> *variances = nullptr,
    int64_t image_size_w = 0,
    int64_t image_size_h = 0,
    float step_w = 0.0f,
    float step_h = 0.0f,
    bool clip = false,
    bool flip = false,
    float offset = 0.0f) {
  auto min_sizes__ = min_sizes ? _fbb.CreateVector<int64_t>(*min_sizes) : 0;
  auto max_sizes__ = max_sizes ? _fbb.CreateVector<int64_t>(*max_sizes) : 0;
  auto aspect_ratios__ = aspect_ratios ? _fbb.CreateVector<float>(*aspect_ratios) : 0;
  auto variances__ = variances ? _fbb.CreateVector<float>(*variances) : 0;
  return mindspore::schema::CreatePriorBox(
      _fbb,
      min_sizes__,
      max_sizes__,
      aspect_ratios__,
      variances__,
      image_size_w,
      image_size_h,
      step_w,
      step_h,
      clip,
      flip,
      offset);
}

flatbuffers::Offset<PriorBox> CreatePriorBox(flatbuffers::FlatBufferBuilder &_fbb, const PriorBoxT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct PReLUFusionT : public flatbuffers::NativeTable {
  typedef PReLUFusion TableType;
  bool channel_shared = false;
};

struct PReLUFusion FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef PReLUFusionT NativeTableType;
  typedef PReLUFusionBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return PReLUFusionTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_CHANNEL_SHARED = 4
  };
  bool channel_shared() const {
    return GetField<uint8_t>(VT_CHANNEL_SHARED, 0) != 0;
  }
  bool mutate_channel_shared(bool _channel_shared) {
    return SetField<uint8_t>(VT_CHANNEL_SHARED, static_cast<uint8_t>(_channel_shared), 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_CHANNEL_SHARED) &&
           verifier.EndTable();
  }
  PReLUFusionT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(PReLUFusionT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<PReLUFusion> Pack(flatbuffers::FlatBufferBuilder &_fbb, const PReLUFusionT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct PReLUFusionBuilder {
  typedef PReLUFusion Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_channel_shared(bool channel_shared) {
    fbb_.AddElement<uint8_t>(PReLUFusion::VT_CHANNEL_SHARED, static_cast<uint8_t>(channel_shared), 0);
  }
  explicit PReLUFusionBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<PReLUFusion> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<PReLUFusion>(end);
    return o;
  }
};

inline flatbuffers::Offset<PReLUFusion> CreatePReLUFusion(
    flatbuffers::FlatBufferBuilder &_fbb,
    bool channel_shared = false) {
  PReLUFusionBuilder builder_(_fbb);
  builder_.add_channel_shared(channel_shared);
  return builder_.Finish();
}

flatbuffers::Offset<PReLUFusion> CreatePReLUFusion(flatbuffers::FlatBufferBuilder &_fbb, const PReLUFusionT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct RankT : public flatbuffers::NativeTable {
  typedef Rank TableType;
};

struct Rank FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef RankT NativeTableType;
  typedef RankBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return RankTypeTable();
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  RankT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(RankT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Rank> Pack(flatbuffers::FlatBufferBuilder &_fbb, const RankT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct RankBuilder {
  typedef Rank Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit RankBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Rank> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Rank>(end);
    return o;
  }
};

inline flatbuffers::Offset<Rank> CreateRank(
    flatbuffers::FlatBufferBuilder &_fbb) {
  RankBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<Rank> CreateRank(flatbuffers::FlatBufferBuilder &_fbb, const RankT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct RangeT : public flatbuffers::NativeTable {
  typedef Range TableType;
  int64_t d_type = 0;
  int64_t start = 0;
  int64_t limit = 0;
  int64_t delta = 1LL;
};

struct Range FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef RangeT NativeTableType;
  typedef RangeBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return RangeTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_D_TYPE = 4,
    VT_START = 6,
    VT_LIMIT = 8,
    VT_DELTA = 10
  };
  int64_t d_type() const {
    return GetField<int64_t>(VT_D_TYPE, 0);
  }
  bool mutate_d_type(int64_t _d_type) {
    return SetField<int64_t>(VT_D_TYPE, _d_type, 0);
  }
  int64_t start() const {
    return GetField<int64_t>(VT_START, 0);
  }
  bool mutate_start(int64_t _start) {
    return SetField<int64_t>(VT_START, _start, 0);
  }
  int64_t limit() const {
    return GetField<int64_t>(VT_LIMIT, 0);
  }
  bool mutate_limit(int64_t _limit) {
    return SetField<int64_t>(VT_LIMIT, _limit, 0);
  }
  int64_t delta() const {
    return GetField<int64_t>(VT_DELTA, 1LL);
  }
  bool mutate_delta(int64_t _delta) {
    return SetField<int64_t>(VT_DELTA, _delta, 1LL);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_D_TYPE) &&
           VerifyField<int64_t>(verifier, VT_START) &&
           VerifyField<int64_t>(verifier, VT_LIMIT) &&
           VerifyField<int64_t>(verifier, VT_DELTA) &&
           verifier.EndTable();
  }
  RangeT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(RangeT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Range> Pack(flatbuffers::FlatBufferBuilder &_fbb, const RangeT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct RangeBuilder {
  typedef Range Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_d_type(int64_t d_type) {
    fbb_.AddElement<int64_t>(Range::VT_D_TYPE, d_type, 0);
  }
  void add_start(int64_t start) {
    fbb_.AddElement<int64_t>(Range::VT_START, start, 0);
  }
  void add_limit(int64_t limit) {
    fbb_.AddElement<int64_t>(Range::VT_LIMIT, limit, 0);
  }
  void add_delta(int64_t delta) {
    fbb_.AddElement<int64_t>(Range::VT_DELTA, delta, 1LL);
  }
  explicit RangeBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Range> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Range>(end);
    return o;
  }
};

inline flatbuffers::Offset<Range> CreateRange(
    flatbuffers::FlatBufferBuilder &_fbb,
    int64_t d_type = 0,
    int64_t start = 0,
    int64_t limit = 0,
    int64_t delta = 1LL) {
  RangeBuilder builder_(_fbb);
  builder_.add_delta(delta);
  builder_.add_limit(limit);
  builder_.add_start(start);
  builder_.add_d_type(d_type);
  return builder_.Finish();
}

flatbuffers::Offset<Range> CreateRange(flatbuffers::FlatBufferBuilder &_fbb, const RangeT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ReciprocalT : public flatbuffers::NativeTable {
  typedef Reciprocal TableType;
};

struct Reciprocal FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ReciprocalT NativeTableType;
  typedef ReciprocalBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return ReciprocalTypeTable();
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  ReciprocalT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ReciprocalT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Reciprocal> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ReciprocalT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ReciprocalBuilder {
  typedef Reciprocal Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit ReciprocalBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Reciprocal> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Reciprocal>(end);
    return o;
  }
};

inline flatbuffers::Offset<Reciprocal> CreateReciprocal(
    flatbuffers::FlatBufferBuilder &_fbb) {
  ReciprocalBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<Reciprocal> CreateReciprocal(flatbuffers::FlatBufferBuilder &_fbb, const ReciprocalT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct RealDivT : public flatbuffers::NativeTable {
  typedef RealDiv TableType;
};

struct RealDiv FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef RealDivT NativeTableType;
  typedef RealDivBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return RealDivTypeTable();
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  RealDivT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(RealDivT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<RealDiv> Pack(flatbuffers::FlatBufferBuilder &_fbb, const RealDivT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct RealDivBuilder {
  typedef RealDiv Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit RealDivBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<RealDiv> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<RealDiv>(end);
    return o;
  }
};

inline flatbuffers::Offset<RealDiv> CreateRealDiv(
    flatbuffers::FlatBufferBuilder &_fbb) {
  RealDivBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<RealDiv> CreateRealDiv(flatbuffers::FlatBufferBuilder &_fbb, const RealDivT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ReduceFusionT : public flatbuffers::NativeTable {
  typedef ReduceFusion TableType;
  bool keep_dims = false;
  mindspore::schema::ReduceMode mode = mindspore::schema::ReduceMode_ReduceMean;
  bool reduce_to_end = false;
  float coeff = 0.0f;
};

struct ReduceFusion FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ReduceFusionT NativeTableType;
  typedef ReduceFusionBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return ReduceFusionTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_KEEP_DIMS = 4,
    VT_MODE = 6,
    VT_REDUCE_TO_END = 8,
    VT_COEFF = 10
  };
  bool keep_dims() const {
    return GetField<uint8_t>(VT_KEEP_DIMS, 0) != 0;
  }
  bool mutate_keep_dims(bool _keep_dims) {
    return SetField<uint8_t>(VT_KEEP_DIMS, static_cast<uint8_t>(_keep_dims), 0);
  }
  mindspore::schema::ReduceMode mode() const {
    return static_cast<mindspore::schema::ReduceMode>(GetField<int8_t>(VT_MODE, 0));
  }
  bool mutate_mode(mindspore::schema::ReduceMode _mode) {
    return SetField<int8_t>(VT_MODE, static_cast<int8_t>(_mode), 0);
  }
  bool reduce_to_end() const {
    return GetField<uint8_t>(VT_REDUCE_TO_END, 0) != 0;
  }
  bool mutate_reduce_to_end(bool _reduce_to_end) {
    return SetField<uint8_t>(VT_REDUCE_TO_END, static_cast<uint8_t>(_reduce_to_end), 0);
  }
  float coeff() const {
    return GetField<float>(VT_COEFF, 0.0f);
  }
  bool mutate_coeff(float _coeff) {
    return SetField<float>(VT_COEFF, _coeff, 0.0f);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_KEEP_DIMS) &&
           VerifyField<int8_t>(verifier, VT_MODE) &&
           VerifyField<uint8_t>(verifier, VT_REDUCE_TO_END) &&
           VerifyField<float>(verifier, VT_COEFF) &&
           verifier.EndTable();
  }
  ReduceFusionT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ReduceFusionT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<ReduceFusion> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ReduceFusionT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ReduceFusionBuilder {
  typedef ReduceFusion Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_keep_dims(bool keep_dims) {
    fbb_.AddElement<uint8_t>(ReduceFusion::VT_KEEP_DIMS, static_cast<uint8_t>(keep_dims), 0);
  }
  void add_mode(mindspore::schema::ReduceMode mode) {
    fbb_.AddElement<int8_t>(ReduceFusion::VT_MODE, static_cast<int8_t>(mode), 0);
  }
  void add_reduce_to_end(bool reduce_to_end) {
    fbb_.AddElement<uint8_t>(ReduceFusion::VT_REDUCE_TO_END, static_cast<uint8_t>(reduce_to_end), 0);
  }
  void add_coeff(float coeff) {
    fbb_.AddElement<float>(ReduceFusion::VT_COEFF, coeff, 0.0f);
  }
  explicit ReduceFusionBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<ReduceFusion> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ReduceFusion>(end);
    return o;
  }
};

inline flatbuffers::Offset<ReduceFusion> CreateReduceFusion(
    flatbuffers::FlatBufferBuilder &_fbb,
    bool keep_dims = false,
    mindspore::schema::ReduceMode mode = mindspore::schema::ReduceMode_ReduceMean,
    bool reduce_to_end = false,
    float coeff = 0.0f) {
  ReduceFusionBuilder builder_(_fbb);
  builder_.add_coeff(coeff);
  builder_.add_reduce_to_end(reduce_to_end);
  builder_.add_mode(mode);
  builder_.add_keep_dims(keep_dims);
  return builder_.Finish();
}

flatbuffers::Offset<ReduceFusion> CreateReduceFusion(flatbuffers::FlatBufferBuilder &_fbb, const ReduceFusionT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ReshapeT : public flatbuffers::NativeTable {
  typedef Reshape TableType;
};

struct Reshape FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ReshapeT NativeTableType;
  typedef ReshapeBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return ReshapeTypeTable();
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  ReshapeT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ReshapeT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Reshape> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ReshapeT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ReshapeBuilder {
  typedef Reshape Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit ReshapeBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Reshape> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Reshape>(end);
    return o;
  }
};

inline flatbuffers::Offset<Reshape> CreateReshape(
    flatbuffers::FlatBufferBuilder &_fbb) {
  ReshapeBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<Reshape> CreateReshape(flatbuffers::FlatBufferBuilder &_fbb, const ReshapeT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ResizeT : public flatbuffers::NativeTable {
  typedef Resize TableType;
  mindspore::schema::Format format = mindspore::schema::Format_NCHW;
  mindspore::schema::ResizeMethod method = mindspore::schema::ResizeMethod_LINEAR;
  int64_t new_height = 0;
  int64_t new_width = 0;
  bool preserve_aspect_ratio = false;
  mindspore::schema::CoordinateTransformMode coordinate_transform_mode = mindspore::schema::CoordinateTransformMode_ASYMMETRIC;
  float cubic_coeff = 0.0f;
  int64_t exclude_outside = 0;
  float extrapolation_value = 0.0f;
  mindspore::schema::NearestMode nearest_mode = mindspore::schema::NearestMode_NORMAL;
};

struct Resize FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ResizeT NativeTableType;
  typedef ResizeBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return ResizeTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_FORMAT = 4,
    VT_METHOD = 6,
    VT_NEW_HEIGHT = 8,
    VT_NEW_WIDTH = 10,
    VT_PRESERVE_ASPECT_RATIO = 12,
    VT_COORDINATE_TRANSFORM_MODE = 14,
    VT_CUBIC_COEFF = 16,
    VT_EXCLUDE_OUTSIDE = 18,
    VT_EXTRAPOLATION_VALUE = 20,
    VT_NEAREST_MODE = 22
  };
  mindspore::schema::Format format() const {
    return static_cast<mindspore::schema::Format>(GetField<int32_t>(VT_FORMAT, 0));
  }
  bool mutate_format(mindspore::schema::Format _format) {
    return SetField<int32_t>(VT_FORMAT, static_cast<int32_t>(_format), 0);
  }
  mindspore::schema::ResizeMethod method() const {
    return static_cast<mindspore::schema::ResizeMethod>(GetField<int8_t>(VT_METHOD, 0));
  }
  bool mutate_method(mindspore::schema::ResizeMethod _method) {
    return SetField<int8_t>(VT_METHOD, static_cast<int8_t>(_method), 0);
  }
  int64_t new_height() const {
    return GetField<int64_t>(VT_NEW_HEIGHT, 0);
  }
  bool mutate_new_height(int64_t _new_height) {
    return SetField<int64_t>(VT_NEW_HEIGHT, _new_height, 0);
  }
  int64_t new_width() const {
    return GetField<int64_t>(VT_NEW_WIDTH, 0);
  }
  bool mutate_new_width(int64_t _new_width) {
    return SetField<int64_t>(VT_NEW_WIDTH, _new_width, 0);
  }
  bool preserve_aspect_ratio() const {
    return GetField<uint8_t>(VT_PRESERVE_ASPECT_RATIO, 0) != 0;
  }
  bool mutate_preserve_aspect_ratio(bool _preserve_aspect_ratio) {
    return SetField<uint8_t>(VT_PRESERVE_ASPECT_RATIO, static_cast<uint8_t>(_preserve_aspect_ratio), 0);
  }
  mindspore::schema::CoordinateTransformMode coordinate_transform_mode() const {
    return static_cast<mindspore::schema::CoordinateTransformMode>(GetField<int8_t>(VT_COORDINATE_TRANSFORM_MODE, 0));
  }
  bool mutate_coordinate_transform_mode(mindspore::schema::CoordinateTransformMode _coordinate_transform_mode) {
    return SetField<int8_t>(VT_COORDINATE_TRANSFORM_MODE, static_cast<int8_t>(_coordinate_transform_mode), 0);
  }
  float cubic_coeff() const {
    return GetField<float>(VT_CUBIC_COEFF, 0.0f);
  }
  bool mutate_cubic_coeff(float _cubic_coeff) {
    return SetField<float>(VT_CUBIC_COEFF, _cubic_coeff, 0.0f);
  }
  int64_t exclude_outside() const {
    return GetField<int64_t>(VT_EXCLUDE_OUTSIDE, 0);
  }
  bool mutate_exclude_outside(int64_t _exclude_outside) {
    return SetField<int64_t>(VT_EXCLUDE_OUTSIDE, _exclude_outside, 0);
  }
  float extrapolation_value() const {
    return GetField<float>(VT_EXTRAPOLATION_VALUE, 0.0f);
  }
  bool mutate_extrapolation_value(float _extrapolation_value) {
    return SetField<float>(VT_EXTRAPOLATION_VALUE, _extrapolation_value, 0.0f);
  }
  mindspore::schema::NearestMode nearest_mode() const {
    return static_cast<mindspore::schema::NearestMode>(GetField<int8_t>(VT_NEAREST_MODE, 0));
  }
  bool mutate_nearest_mode(mindspore::schema::NearestMode _nearest_mode) {
    return SetField<int8_t>(VT_NEAREST_MODE, static_cast<int8_t>(_nearest_mode), 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_FORMAT) &&
           VerifyField<int8_t>(verifier, VT_METHOD) &&
           VerifyField<int64_t>(verifier, VT_NEW_HEIGHT) &&
           VerifyField<int64_t>(verifier, VT_NEW_WIDTH) &&
           VerifyField<uint8_t>(verifier, VT_PRESERVE_ASPECT_RATIO) &&
           VerifyField<int8_t>(verifier, VT_COORDINATE_TRANSFORM_MODE) &&
           VerifyField<float>(verifier, VT_CUBIC_COEFF) &&
           VerifyField<int64_t>(verifier, VT_EXCLUDE_OUTSIDE) &&
           VerifyField<float>(verifier, VT_EXTRAPOLATION_VALUE) &&
           VerifyField<int8_t>(verifier, VT_NEAREST_MODE) &&
           verifier.EndTable();
  }
  ResizeT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ResizeT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Resize> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ResizeT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ResizeBuilder {
  typedef Resize Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_format(mindspore::schema::Format format) {
    fbb_.AddElement<int32_t>(Resize::VT_FORMAT, static_cast<int32_t>(format), 0);
  }
  void add_method(mindspore::schema::ResizeMethod method) {
    fbb_.AddElement<int8_t>(Resize::VT_METHOD, static_cast<int8_t>(method), 0);
  }
  void add_new_height(int64_t new_height) {
    fbb_.AddElement<int64_t>(Resize::VT_NEW_HEIGHT, new_height, 0);
  }
  void add_new_width(int64_t new_width) {
    fbb_.AddElement<int64_t>(Resize::VT_NEW_WIDTH, new_width, 0);
  }
  void add_preserve_aspect_ratio(bool preserve_aspect_ratio) {
    fbb_.AddElement<uint8_t>(Resize::VT_PRESERVE_ASPECT_RATIO, static_cast<uint8_t>(preserve_aspect_ratio), 0);
  }
  void add_coordinate_transform_mode(mindspore::schema::CoordinateTransformMode coordinate_transform_mode) {
    fbb_.AddElement<int8_t>(Resize::VT_COORDINATE_TRANSFORM_MODE, static_cast<int8_t>(coordinate_transform_mode), 0);
  }
  void add_cubic_coeff(float cubic_coeff) {
    fbb_.AddElement<float>(Resize::VT_CUBIC_COEFF, cubic_coeff, 0.0f);
  }
  void add_exclude_outside(int64_t exclude_outside) {
    fbb_.AddElement<int64_t>(Resize::VT_EXCLUDE_OUTSIDE, exclude_outside, 0);
  }
  void add_extrapolation_value(float extrapolation_value) {
    fbb_.AddElement<float>(Resize::VT_EXTRAPOLATION_VALUE, extrapolation_value, 0.0f);
  }
  void add_nearest_mode(mindspore::schema::NearestMode nearest_mode) {
    fbb_.AddElement<int8_t>(Resize::VT_NEAREST_MODE, static_cast<int8_t>(nearest_mode), 0);
  }
  explicit ResizeBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Resize> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Resize>(end);
    return o;
  }
};

inline flatbuffers::Offset<Resize> CreateResize(
    flatbuffers::FlatBufferBuilder &_fbb,
    mindspore::schema::Format format = mindspore::schema::Format_NCHW,
    mindspore::schema::ResizeMethod method = mindspore::schema::ResizeMethod_LINEAR,
    int64_t new_height = 0,
    int64_t new_width = 0,
    bool preserve_aspect_ratio = false,
    mindspore::schema::CoordinateTransformMode coordinate_transform_mode = mindspore::schema::CoordinateTransformMode_ASYMMETRIC,
    float cubic_coeff = 0.0f,
    int64_t exclude_outside = 0,
    float extrapolation_value = 0.0f,
    mindspore::schema::NearestMode nearest_mode = mindspore::schema::NearestMode_NORMAL) {
  ResizeBuilder builder_(_fbb);
  builder_.add_exclude_outside(exclude_outside);
  builder_.add_new_width(new_width);
  builder_.add_new_height(new_height);
  builder_.add_extrapolation_value(extrapolation_value);
  builder_.add_cubic_coeff(cubic_coeff);
  builder_.add_format(format);
  builder_.add_nearest_mode(nearest_mode);
  builder_.add_coordinate_transform_mode(coordinate_transform_mode);
  builder_.add_preserve_aspect_ratio(preserve_aspect_ratio);
  builder_.add_method(method);
  return builder_.Finish();
}

flatbuffers::Offset<Resize> CreateResize(flatbuffers::FlatBufferBuilder &_fbb, const ResizeT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ReverseSequenceT : public flatbuffers::NativeTable {
  typedef ReverseSequence TableType;
  int64_t seq_dim = 0;
  int64_t batch_dim = 0;
};

struct ReverseSequence FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ReverseSequenceT NativeTableType;
  typedef ReverseSequenceBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return ReverseSequenceTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SEQ_DIM = 4,
    VT_BATCH_DIM = 6
  };
  int64_t seq_dim() const {
    return GetField<int64_t>(VT_SEQ_DIM, 0);
  }
  bool mutate_seq_dim(int64_t _seq_dim) {
    return SetField<int64_t>(VT_SEQ_DIM, _seq_dim, 0);
  }
  int64_t batch_dim() const {
    return GetField<int64_t>(VT_BATCH_DIM, 0);
  }
  bool mutate_batch_dim(int64_t _batch_dim) {
    return SetField<int64_t>(VT_BATCH_DIM, _batch_dim, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_SEQ_DIM) &&
           VerifyField<int64_t>(verifier, VT_BATCH_DIM) &&
           verifier.EndTable();
  }
  ReverseSequenceT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ReverseSequenceT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<ReverseSequence> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ReverseSequenceT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ReverseSequenceBuilder {
  typedef ReverseSequence Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_seq_dim(int64_t seq_dim) {
    fbb_.AddElement<int64_t>(ReverseSequence::VT_SEQ_DIM, seq_dim, 0);
  }
  void add_batch_dim(int64_t batch_dim) {
    fbb_.AddElement<int64_t>(ReverseSequence::VT_BATCH_DIM, batch_dim, 0);
  }
  explicit ReverseSequenceBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<ReverseSequence> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ReverseSequence>(end);
    return o;
  }
};

inline flatbuffers::Offset<ReverseSequence> CreateReverseSequence(
    flatbuffers::FlatBufferBuilder &_fbb,
    int64_t seq_dim = 0,
    int64_t batch_dim = 0) {
  ReverseSequenceBuilder builder_(_fbb);
  builder_.add_batch_dim(batch_dim);
  builder_.add_seq_dim(seq_dim);
  return builder_.Finish();
}

flatbuffers::Offset<ReverseSequence> CreateReverseSequence(flatbuffers::FlatBufferBuilder &_fbb, const ReverseSequenceT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ReverseV2T : public flatbuffers::NativeTable {
  typedef ReverseV2 TableType;
  std::vector<int64_t> axis{};
};

struct ReverseV2 FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ReverseV2T NativeTableType;
  typedef ReverseV2Builder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return ReverseV2TypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_AXIS = 4
  };
  const flatbuffers::Vector<int64_t> *axis() const {
    return GetPointer<const flatbuffers::Vector<int64_t> *>(VT_AXIS);
  }
  flatbuffers::Vector<int64_t> *mutable_axis() {
    return GetPointer<flatbuffers::Vector<int64_t> *>(VT_AXIS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_AXIS) &&
           verifier.VerifyVector(axis()) &&
           verifier.EndTable();
  }
  ReverseV2T *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ReverseV2T *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<ReverseV2> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ReverseV2T* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ReverseV2Builder {
  typedef ReverseV2 Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_axis(flatbuffers::Offset<flatbuffers::Vector<int64_t>> axis) {
    fbb_.AddOffset(ReverseV2::VT_AXIS, axis);
  }
  explicit ReverseV2Builder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<ReverseV2> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ReverseV2>(end);
    return o;
  }
};

inline flatbuffers::Offset<ReverseV2> CreateReverseV2(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<int64_t>> axis = 0) {
  ReverseV2Builder builder_(_fbb);
  builder_.add_axis(axis);
  return builder_.Finish();
}

inline flatbuffers::Offset<ReverseV2> CreateReverseV2Direct(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<int64_t> *axis = nullptr) {
  auto axis__ = axis ? _fbb.CreateVector<int64_t>(*axis) : 0;
  return mindspore::schema::CreateReverseV2(
      _fbb,
      axis__);
}

flatbuffers::Offset<ReverseV2> CreateReverseV2(flatbuffers::FlatBufferBuilder &_fbb, const ReverseV2T *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct RfftT : public flatbuffers::NativeTable {
  typedef Rfft TableType;
  int64_t fft_length = 0;
};

struct Rfft FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef RfftT NativeTableType;
  typedef RfftBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return RfftTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_FFT_LENGTH = 4
  };
  int64_t fft_length() const {
    return GetField<int64_t>(VT_FFT_LENGTH, 0);
  }
  bool mutate_fft_length(int64_t _fft_length) {
    return SetField<int64_t>(VT_FFT_LENGTH, _fft_length, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_FFT_LENGTH) &&
           verifier.EndTable();
  }
  RfftT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(RfftT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Rfft> Pack(flatbuffers::FlatBufferBuilder &_fbb, const RfftT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct RfftBuilder {
  typedef Rfft Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_fft_length(int64_t fft_length) {
    fbb_.AddElement<int64_t>(Rfft::VT_FFT_LENGTH, fft_length, 0);
  }
  explicit RfftBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Rfft> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Rfft>(end);
    return o;
  }
};

inline flatbuffers::Offset<Rfft> CreateRfft(
    flatbuffers::FlatBufferBuilder &_fbb,
    int64_t fft_length = 0) {
  RfftBuilder builder_(_fbb);
  builder_.add_fft_length(fft_length);
  return builder_.Finish();
}

flatbuffers::Offset<Rfft> CreateRfft(flatbuffers::FlatBufferBuilder &_fbb, const RfftT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ROIPoolingT : public flatbuffers::NativeTable {
  typedef ROIPooling TableType;
  int64_t pooled_h = 0;
  int64_t pooled_w = 0;
  float scale = 0.0f;
};

struct ROIPooling FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ROIPoolingT NativeTableType;
  typedef ROIPoolingBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return ROIPoolingTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_POOLED_H = 4,
    VT_POOLED_W = 6,
    VT_SCALE = 8
  };
  int64_t pooled_h() const {
    return GetField<int64_t>(VT_POOLED_H, 0);
  }
  bool mutate_pooled_h(int64_t _pooled_h) {
    return SetField<int64_t>(VT_POOLED_H, _pooled_h, 0);
  }
  int64_t pooled_w() const {
    return GetField<int64_t>(VT_POOLED_W, 0);
  }
  bool mutate_pooled_w(int64_t _pooled_w) {
    return SetField<int64_t>(VT_POOLED_W, _pooled_w, 0);
  }
  float scale() const {
    return GetField<float>(VT_SCALE, 0.0f);
  }
  bool mutate_scale(float _scale) {
    return SetField<float>(VT_SCALE, _scale, 0.0f);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_POOLED_H) &&
           VerifyField<int64_t>(verifier, VT_POOLED_W) &&
           VerifyField<float>(verifier, VT_SCALE) &&
           verifier.EndTable();
  }
  ROIPoolingT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ROIPoolingT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<ROIPooling> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ROIPoolingT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ROIPoolingBuilder {
  typedef ROIPooling Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_pooled_h(int64_t pooled_h) {
    fbb_.AddElement<int64_t>(ROIPooling::VT_POOLED_H, pooled_h, 0);
  }
  void add_pooled_w(int64_t pooled_w) {
    fbb_.AddElement<int64_t>(ROIPooling::VT_POOLED_W, pooled_w, 0);
  }
  void add_scale(float scale) {
    fbb_.AddElement<float>(ROIPooling::VT_SCALE, scale, 0.0f);
  }
  explicit ROIPoolingBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<ROIPooling> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ROIPooling>(end);
    return o;
  }
};

inline flatbuffers::Offset<ROIPooling> CreateROIPooling(
    flatbuffers::FlatBufferBuilder &_fbb,
    int64_t pooled_h = 0,
    int64_t pooled_w = 0,
    float scale = 0.0f) {
  ROIPoolingBuilder builder_(_fbb);
  builder_.add_pooled_w(pooled_w);
  builder_.add_pooled_h(pooled_h);
  builder_.add_scale(scale);
  return builder_.Finish();
}

flatbuffers::Offset<ROIPooling> CreateROIPooling(flatbuffers::FlatBufferBuilder &_fbb, const ROIPoolingT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct RoundT : public flatbuffers::NativeTable {
  typedef Round TableType;
};

struct Round FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef RoundT NativeTableType;
  typedef RoundBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return RoundTypeTable();
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  RoundT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(RoundT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Round> Pack(flatbuffers::FlatBufferBuilder &_fbb, const RoundT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct RoundBuilder {
  typedef Round Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit RoundBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Round> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Round>(end);
    return o;
  }
};

inline flatbuffers::Offset<Round> CreateRound(
    flatbuffers::FlatBufferBuilder &_fbb) {
  RoundBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<Round> CreateRound(flatbuffers::FlatBufferBuilder &_fbb, const RoundT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct RsqrtT : public flatbuffers::NativeTable {
  typedef Rsqrt TableType;
};

struct Rsqrt FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef RsqrtT NativeTableType;
  typedef RsqrtBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return RsqrtTypeTable();
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  RsqrtT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(RsqrtT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Rsqrt> Pack(flatbuffers::FlatBufferBuilder &_fbb, const RsqrtT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct RsqrtBuilder {
  typedef Rsqrt Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit RsqrtBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Rsqrt> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Rsqrt>(end);
    return o;
  }
};

inline flatbuffers::Offset<Rsqrt> CreateRsqrt(
    flatbuffers::FlatBufferBuilder &_fbb) {
  RsqrtBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<Rsqrt> CreateRsqrt(flatbuffers::FlatBufferBuilder &_fbb, const RsqrtT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct QuantDTypeCastT : public flatbuffers::NativeTable {
  typedef QuantDTypeCast TableType;
  int64_t src_t = 0;
  int64_t dst_t = 0;
};

struct QuantDTypeCast FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef QuantDTypeCastT NativeTableType;
  typedef QuantDTypeCastBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return QuantDTypeCastTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SRC_T = 4,
    VT_DST_T = 6
  };
  int64_t src_t() const {
    return GetField<int64_t>(VT_SRC_T, 0);
  }
  bool mutate_src_t(int64_t _src_t) {
    return SetField<int64_t>(VT_SRC_T, _src_t, 0);
  }
  int64_t dst_t() const {
    return GetField<int64_t>(VT_DST_T, 0);
  }
  bool mutate_dst_t(int64_t _dst_t) {
    return SetField<int64_t>(VT_DST_T, _dst_t, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_SRC_T) &&
           VerifyField<int64_t>(verifier, VT_DST_T) &&
           verifier.EndTable();
  }
  QuantDTypeCastT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(QuantDTypeCastT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<QuantDTypeCast> Pack(flatbuffers::FlatBufferBuilder &_fbb, const QuantDTypeCastT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct QuantDTypeCastBuilder {
  typedef QuantDTypeCast Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_src_t(int64_t src_t) {
    fbb_.AddElement<int64_t>(QuantDTypeCast::VT_SRC_T, src_t, 0);
  }
  void add_dst_t(int64_t dst_t) {
    fbb_.AddElement<int64_t>(QuantDTypeCast::VT_DST_T, dst_t, 0);
  }
  explicit QuantDTypeCastBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<QuantDTypeCast> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<QuantDTypeCast>(end);
    return o;
  }
};

inline flatbuffers::Offset<QuantDTypeCast> CreateQuantDTypeCast(
    flatbuffers::FlatBufferBuilder &_fbb,
    int64_t src_t = 0,
    int64_t dst_t = 0) {
  QuantDTypeCastBuilder builder_(_fbb);
  builder_.add_dst_t(dst_t);
  builder_.add_src_t(src_t);
  return builder_.Finish();
}

flatbuffers::Offset<QuantDTypeCast> CreateQuantDTypeCast(flatbuffers::FlatBufferBuilder &_fbb, const QuantDTypeCastT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ScaleFusionT : public flatbuffers::NativeTable {
  typedef ScaleFusion TableType;
  int64_t axis = 0;
  mindspore::schema::ActivationType activation_type = mindspore::schema::ActivationType_NO_ACTIVATION;
};

struct ScaleFusion FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ScaleFusionT NativeTableType;
  typedef ScaleFusionBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return ScaleFusionTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_AXIS = 4,
    VT_ACTIVATION_TYPE = 6
  };
  int64_t axis() const {
    return GetField<int64_t>(VT_AXIS, 0);
  }
  bool mutate_axis(int64_t _axis) {
    return SetField<int64_t>(VT_AXIS, _axis, 0);
  }
  mindspore::schema::ActivationType activation_type() const {
    return static_cast<mindspore::schema::ActivationType>(GetField<int8_t>(VT_ACTIVATION_TYPE, 0));
  }
  bool mutate_activation_type(mindspore::schema::ActivationType _activation_type) {
    return SetField<int8_t>(VT_ACTIVATION_TYPE, static_cast<int8_t>(_activation_type), 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_AXIS) &&
           VerifyField<int8_t>(verifier, VT_ACTIVATION_TYPE) &&
           verifier.EndTable();
  }
  ScaleFusionT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ScaleFusionT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<ScaleFusion> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ScaleFusionT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ScaleFusionBuilder {
  typedef ScaleFusion Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_axis(int64_t axis) {
    fbb_.AddElement<int64_t>(ScaleFusion::VT_AXIS, axis, 0);
  }
  void add_activation_type(mindspore::schema::ActivationType activation_type) {
    fbb_.AddElement<int8_t>(ScaleFusion::VT_ACTIVATION_TYPE, static_cast<int8_t>(activation_type), 0);
  }
  explicit ScaleFusionBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<ScaleFusion> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ScaleFusion>(end);
    return o;
  }
};

inline flatbuffers::Offset<ScaleFusion> CreateScaleFusion(
    flatbuffers::FlatBufferBuilder &_fbb,
    int64_t axis = 0,
    mindspore::schema::ActivationType activation_type = mindspore::schema::ActivationType_NO_ACTIVATION) {
  ScaleFusionBuilder builder_(_fbb);
  builder_.add_axis(axis);
  builder_.add_activation_type(activation_type);
  return builder_.Finish();
}

flatbuffers::Offset<ScaleFusion> CreateScaleFusion(flatbuffers::FlatBufferBuilder &_fbb, const ScaleFusionT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ScatterNdT : public flatbuffers::NativeTable {
  typedef ScatterNd TableType;
};

struct ScatterNd FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ScatterNdT NativeTableType;
  typedef ScatterNdBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return ScatterNdTypeTable();
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  ScatterNdT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ScatterNdT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<ScatterNd> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ScatterNdT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ScatterNdBuilder {
  typedef ScatterNd Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit ScatterNdBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<ScatterNd> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ScatterNd>(end);
    return o;
  }
};

inline flatbuffers::Offset<ScatterNd> CreateScatterNd(
    flatbuffers::FlatBufferBuilder &_fbb) {
  ScatterNdBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<ScatterNd> CreateScatterNd(flatbuffers::FlatBufferBuilder &_fbb, const ScatterNdT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct SGDT : public flatbuffers::NativeTable {
  typedef SGD TableType;
  bool nesterov = false;
  float dampening = 0.0f;
  float weight_decay = 0.0f;
};

struct SGD FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef SGDT NativeTableType;
  typedef SGDBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return SGDTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NESTEROV = 4,
    VT_DAMPENING = 6,
    VT_WEIGHT_DECAY = 8
  };
  bool nesterov() const {
    return GetField<uint8_t>(VT_NESTEROV, 0) != 0;
  }
  bool mutate_nesterov(bool _nesterov) {
    return SetField<uint8_t>(VT_NESTEROV, static_cast<uint8_t>(_nesterov), 0);
  }
  float dampening() const {
    return GetField<float>(VT_DAMPENING, 0.0f);
  }
  bool mutate_dampening(float _dampening) {
    return SetField<float>(VT_DAMPENING, _dampening, 0.0f);
  }
  float weight_decay() const {
    return GetField<float>(VT_WEIGHT_DECAY, 0.0f);
  }
  bool mutate_weight_decay(float _weight_decay) {
    return SetField<float>(VT_WEIGHT_DECAY, _weight_decay, 0.0f);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_NESTEROV) &&
           VerifyField<float>(verifier, VT_DAMPENING) &&
           VerifyField<float>(verifier, VT_WEIGHT_DECAY) &&
           verifier.EndTable();
  }
  SGDT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(SGDT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<SGD> Pack(flatbuffers::FlatBufferBuilder &_fbb, const SGDT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct SGDBuilder {
  typedef SGD Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_nesterov(bool nesterov) {
    fbb_.AddElement<uint8_t>(SGD::VT_NESTEROV, static_cast<uint8_t>(nesterov), 0);
  }
  void add_dampening(float dampening) {
    fbb_.AddElement<float>(SGD::VT_DAMPENING, dampening, 0.0f);
  }
  void add_weight_decay(float weight_decay) {
    fbb_.AddElement<float>(SGD::VT_WEIGHT_DECAY, weight_decay, 0.0f);
  }
  explicit SGDBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<SGD> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SGD>(end);
    return o;
  }
};

inline flatbuffers::Offset<SGD> CreateSGD(
    flatbuffers::FlatBufferBuilder &_fbb,
    bool nesterov = false,
    float dampening = 0.0f,
    float weight_decay = 0.0f) {
  SGDBuilder builder_(_fbb);
  builder_.add_weight_decay(weight_decay);
  builder_.add_dampening(dampening);
  builder_.add_nesterov(nesterov);
  return builder_.Finish();
}

flatbuffers::Offset<SGD> CreateSGD(flatbuffers::FlatBufferBuilder &_fbb, const SGDT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ShapeT : public flatbuffers::NativeTable {
  typedef Shape TableType;
};

struct Shape FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ShapeT NativeTableType;
  typedef ShapeBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return ShapeTypeTable();
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  ShapeT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ShapeT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Shape> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ShapeT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ShapeBuilder {
  typedef Shape Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit ShapeBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Shape> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Shape>(end);
    return o;
  }
};

inline flatbuffers::Offset<Shape> CreateShape(
    flatbuffers::FlatBufferBuilder &_fbb) {
  ShapeBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<Shape> CreateShape(flatbuffers::FlatBufferBuilder &_fbb, const ShapeT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct SigmoidCrossEntropyWithLogitsT : public flatbuffers::NativeTable {
  typedef SigmoidCrossEntropyWithLogits TableType;
};

struct SigmoidCrossEntropyWithLogits FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef SigmoidCrossEntropyWithLogitsT NativeTableType;
  typedef SigmoidCrossEntropyWithLogitsBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return SigmoidCrossEntropyWithLogitsTypeTable();
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  SigmoidCrossEntropyWithLogitsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(SigmoidCrossEntropyWithLogitsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<SigmoidCrossEntropyWithLogits> Pack(flatbuffers::FlatBufferBuilder &_fbb, const SigmoidCrossEntropyWithLogitsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct SigmoidCrossEntropyWithLogitsBuilder {
  typedef SigmoidCrossEntropyWithLogits Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit SigmoidCrossEntropyWithLogitsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<SigmoidCrossEntropyWithLogits> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SigmoidCrossEntropyWithLogits>(end);
    return o;
  }
};

inline flatbuffers::Offset<SigmoidCrossEntropyWithLogits> CreateSigmoidCrossEntropyWithLogits(
    flatbuffers::FlatBufferBuilder &_fbb) {
  SigmoidCrossEntropyWithLogitsBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<SigmoidCrossEntropyWithLogits> CreateSigmoidCrossEntropyWithLogits(flatbuffers::FlatBufferBuilder &_fbb, const SigmoidCrossEntropyWithLogitsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct SigmoidCrossEntropyWithLogitsGradT : public flatbuffers::NativeTable {
  typedef SigmoidCrossEntropyWithLogitsGrad TableType;
};

struct SigmoidCrossEntropyWithLogitsGrad FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef SigmoidCrossEntropyWithLogitsGradT NativeTableType;
  typedef SigmoidCrossEntropyWithLogitsGradBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return SigmoidCrossEntropyWithLogitsGradTypeTable();
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  SigmoidCrossEntropyWithLogitsGradT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(SigmoidCrossEntropyWithLogitsGradT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<SigmoidCrossEntropyWithLogitsGrad> Pack(flatbuffers::FlatBufferBuilder &_fbb, const SigmoidCrossEntropyWithLogitsGradT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct SigmoidCrossEntropyWithLogitsGradBuilder {
  typedef SigmoidCrossEntropyWithLogitsGrad Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit SigmoidCrossEntropyWithLogitsGradBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<SigmoidCrossEntropyWithLogitsGrad> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SigmoidCrossEntropyWithLogitsGrad>(end);
    return o;
  }
};

inline flatbuffers::Offset<SigmoidCrossEntropyWithLogitsGrad> CreateSigmoidCrossEntropyWithLogitsGrad(
    flatbuffers::FlatBufferBuilder &_fbb) {
  SigmoidCrossEntropyWithLogitsGradBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<SigmoidCrossEntropyWithLogitsGrad> CreateSigmoidCrossEntropyWithLogitsGrad(flatbuffers::FlatBufferBuilder &_fbb, const SigmoidCrossEntropyWithLogitsGradT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct SinT : public flatbuffers::NativeTable {
  typedef Sin TableType;
};

struct Sin FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef SinT NativeTableType;
  typedef SinBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return SinTypeTable();
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  SinT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(SinT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Sin> Pack(flatbuffers::FlatBufferBuilder &_fbb, const SinT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct SinBuilder {
  typedef Sin Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit SinBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Sin> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Sin>(end);
    return o;
  }
};

inline flatbuffers::Offset<Sin> CreateSin(
    flatbuffers::FlatBufferBuilder &_fbb) {
  SinBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<Sin> CreateSin(flatbuffers::FlatBufferBuilder &_fbb, const SinT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct SkipGramT : public flatbuffers::NativeTable {
  typedef SkipGram TableType;
  bool include_all_grams = false;
  int64_t max_skip_size = 0;
  int64_t ngram_size = 0;
};

struct SkipGram FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef SkipGramT NativeTableType;
  typedef SkipGramBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return SkipGramTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_INCLUDE_ALL_GRAMS = 4,
    VT_MAX_SKIP_SIZE = 6,
    VT_NGRAM_SIZE = 8
  };
  bool include_all_grams() const {
    return GetField<uint8_t>(VT_INCLUDE_ALL_GRAMS, 0) != 0;
  }
  bool mutate_include_all_grams(bool _include_all_grams) {
    return SetField<uint8_t>(VT_INCLUDE_ALL_GRAMS, static_cast<uint8_t>(_include_all_grams), 0);
  }
  int64_t max_skip_size() const {
    return GetField<int64_t>(VT_MAX_SKIP_SIZE, 0);
  }
  bool mutate_max_skip_size(int64_t _max_skip_size) {
    return SetField<int64_t>(VT_MAX_SKIP_SIZE, _max_skip_size, 0);
  }
  int64_t ngram_size() const {
    return GetField<int64_t>(VT_NGRAM_SIZE, 0);
  }
  bool mutate_ngram_size(int64_t _ngram_size) {
    return SetField<int64_t>(VT_NGRAM_SIZE, _ngram_size, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_INCLUDE_ALL_GRAMS) &&
           VerifyField<int64_t>(verifier, VT_MAX_SKIP_SIZE) &&
           VerifyField<int64_t>(verifier, VT_NGRAM_SIZE) &&
           verifier.EndTable();
  }
  SkipGramT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(SkipGramT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<SkipGram> Pack(flatbuffers::FlatBufferBuilder &_fbb, const SkipGramT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct SkipGramBuilder {
  typedef SkipGram Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_include_all_grams(bool include_all_grams) {
    fbb_.AddElement<uint8_t>(SkipGram::VT_INCLUDE_ALL_GRAMS, static_cast<uint8_t>(include_all_grams), 0);
  }
  void add_max_skip_size(int64_t max_skip_size) {
    fbb_.AddElement<int64_t>(SkipGram::VT_MAX_SKIP_SIZE, max_skip_size, 0);
  }
  void add_ngram_size(int64_t ngram_size) {
    fbb_.AddElement<int64_t>(SkipGram::VT_NGRAM_SIZE, ngram_size, 0);
  }
  explicit SkipGramBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<SkipGram> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SkipGram>(end);
    return o;
  }
};

inline flatbuffers::Offset<SkipGram> CreateSkipGram(
    flatbuffers::FlatBufferBuilder &_fbb,
    bool include_all_grams = false,
    int64_t max_skip_size = 0,
    int64_t ngram_size = 0) {
  SkipGramBuilder builder_(_fbb);
  builder_.add_ngram_size(ngram_size);
  builder_.add_max_skip_size(max_skip_size);
  builder_.add_include_all_grams(include_all_grams);
  return builder_.Finish();
}

flatbuffers::Offset<SkipGram> CreateSkipGram(flatbuffers::FlatBufferBuilder &_fbb, const SkipGramT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct SliceFusionT : public flatbuffers::NativeTable {
  typedef SliceFusion TableType;
  std::vector<int64_t> axes{};
};

struct SliceFusion FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef SliceFusionT NativeTableType;
  typedef SliceFusionBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return SliceFusionTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_AXES = 4
  };
  const flatbuffers::Vector<int64_t> *axes() const {
    return GetPointer<const flatbuffers::Vector<int64_t> *>(VT_AXES);
  }
  flatbuffers::Vector<int64_t> *mutable_axes() {
    return GetPointer<flatbuffers::Vector<int64_t> *>(VT_AXES);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_AXES) &&
           verifier.VerifyVector(axes()) &&
           verifier.EndTable();
  }
  SliceFusionT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(SliceFusionT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<SliceFusion> Pack(flatbuffers::FlatBufferBuilder &_fbb, const SliceFusionT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct SliceFusionBuilder {
  typedef SliceFusion Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_axes(flatbuffers::Offset<flatbuffers::Vector<int64_t>> axes) {
    fbb_.AddOffset(SliceFusion::VT_AXES, axes);
  }
  explicit SliceFusionBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<SliceFusion> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SliceFusion>(end);
    return o;
  }
};

inline flatbuffers::Offset<SliceFusion> CreateSliceFusion(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<int64_t>> axes = 0) {
  SliceFusionBuilder builder_(_fbb);
  builder_.add_axes(axes);
  return builder_.Finish();
}

inline flatbuffers::Offset<SliceFusion> CreateSliceFusionDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<int64_t> *axes = nullptr) {
  auto axes__ = axes ? _fbb.CreateVector<int64_t>(*axes) : 0;
  return mindspore::schema::CreateSliceFusion(
      _fbb,
      axes__);
}

flatbuffers::Offset<SliceFusion> CreateSliceFusion(flatbuffers::FlatBufferBuilder &_fbb, const SliceFusionT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct SmoothL1LossT : public flatbuffers::NativeTable {
  typedef SmoothL1Loss TableType;
  float beta = 0.0f;
};

struct SmoothL1Loss FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef SmoothL1LossT NativeTableType;
  typedef SmoothL1LossBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return SmoothL1LossTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_BETA = 4
  };
  float beta() const {
    return GetField<float>(VT_BETA, 0.0f);
  }
  bool mutate_beta(float _beta) {
    return SetField<float>(VT_BETA, _beta, 0.0f);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<float>(verifier, VT_BETA) &&
           verifier.EndTable();
  }
  SmoothL1LossT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(SmoothL1LossT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<SmoothL1Loss> Pack(flatbuffers::FlatBufferBuilder &_fbb, const SmoothL1LossT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct SmoothL1LossBuilder {
  typedef SmoothL1Loss Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_beta(float beta) {
    fbb_.AddElement<float>(SmoothL1Loss::VT_BETA, beta, 0.0f);
  }
  explicit SmoothL1LossBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<SmoothL1Loss> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SmoothL1Loss>(end);
    return o;
  }
};

inline flatbuffers::Offset<SmoothL1Loss> CreateSmoothL1Loss(
    flatbuffers::FlatBufferBuilder &_fbb,
    float beta = 0.0f) {
  SmoothL1LossBuilder builder_(_fbb);
  builder_.add_beta(beta);
  return builder_.Finish();
}

flatbuffers::Offset<SmoothL1Loss> CreateSmoothL1Loss(flatbuffers::FlatBufferBuilder &_fbb, const SmoothL1LossT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct SmoothL1LossGradT : public flatbuffers::NativeTable {
  typedef SmoothL1LossGrad TableType;
  float beta = 0.0f;
};

struct SmoothL1LossGrad FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef SmoothL1LossGradT NativeTableType;
  typedef SmoothL1LossGradBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return SmoothL1LossGradTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_BETA = 4
  };
  float beta() const {
    return GetField<float>(VT_BETA, 0.0f);
  }
  bool mutate_beta(float _beta) {
    return SetField<float>(VT_BETA, _beta, 0.0f);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<float>(verifier, VT_BETA) &&
           verifier.EndTable();
  }
  SmoothL1LossGradT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(SmoothL1LossGradT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<SmoothL1LossGrad> Pack(flatbuffers::FlatBufferBuilder &_fbb, const SmoothL1LossGradT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct SmoothL1LossGradBuilder {
  typedef SmoothL1LossGrad Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_beta(float beta) {
    fbb_.AddElement<float>(SmoothL1LossGrad::VT_BETA, beta, 0.0f);
  }
  explicit SmoothL1LossGradBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<SmoothL1LossGrad> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SmoothL1LossGrad>(end);
    return o;
  }
};

inline flatbuffers::Offset<SmoothL1LossGrad> CreateSmoothL1LossGrad(
    flatbuffers::FlatBufferBuilder &_fbb,
    float beta = 0.0f) {
  SmoothL1LossGradBuilder builder_(_fbb);
  builder_.add_beta(beta);
  return builder_.Finish();
}

flatbuffers::Offset<SmoothL1LossGrad> CreateSmoothL1LossGrad(flatbuffers::FlatBufferBuilder &_fbb, const SmoothL1LossGradT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct SoftmaxT : public flatbuffers::NativeTable {
  typedef Softmax TableType;
  std::vector<int64_t> axis{};
};

struct Softmax FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef SoftmaxT NativeTableType;
  typedef SoftmaxBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return SoftmaxTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_AXIS = 4
  };
  const flatbuffers::Vector<int64_t> *axis() const {
    return GetPointer<const flatbuffers::Vector<int64_t> *>(VT_AXIS);
  }
  flatbuffers::Vector<int64_t> *mutable_axis() {
    return GetPointer<flatbuffers::Vector<int64_t> *>(VT_AXIS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_AXIS) &&
           verifier.VerifyVector(axis()) &&
           verifier.EndTable();
  }
  SoftmaxT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(SoftmaxT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Softmax> Pack(flatbuffers::FlatBufferBuilder &_fbb, const SoftmaxT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct SoftmaxBuilder {
  typedef Softmax Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_axis(flatbuffers::Offset<flatbuffers::Vector<int64_t>> axis) {
    fbb_.AddOffset(Softmax::VT_AXIS, axis);
  }
  explicit SoftmaxBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Softmax> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Softmax>(end);
    return o;
  }
};

inline flatbuffers::Offset<Softmax> CreateSoftmax(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<int64_t>> axis = 0) {
  SoftmaxBuilder builder_(_fbb);
  builder_.add_axis(axis);
  return builder_.Finish();
}

inline flatbuffers::Offset<Softmax> CreateSoftmaxDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<int64_t> *axis = nullptr) {
  auto axis__ = axis ? _fbb.CreateVector<int64_t>(*axis) : 0;
  return mindspore::schema::CreateSoftmax(
      _fbb,
      axis__);
}

flatbuffers::Offset<Softmax> CreateSoftmax(flatbuffers::FlatBufferBuilder &_fbb, const SoftmaxT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct SoftmaxCrossEntropyWithLogitsT : public flatbuffers::NativeTable {
  typedef SoftmaxCrossEntropyWithLogits TableType;
};

struct SoftmaxCrossEntropyWithLogits FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef SoftmaxCrossEntropyWithLogitsT NativeTableType;
  typedef SoftmaxCrossEntropyWithLogitsBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return SoftmaxCrossEntropyWithLogitsTypeTable();
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  SoftmaxCrossEntropyWithLogitsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(SoftmaxCrossEntropyWithLogitsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<SoftmaxCrossEntropyWithLogits> Pack(flatbuffers::FlatBufferBuilder &_fbb, const SoftmaxCrossEntropyWithLogitsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct SoftmaxCrossEntropyWithLogitsBuilder {
  typedef SoftmaxCrossEntropyWithLogits Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit SoftmaxCrossEntropyWithLogitsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<SoftmaxCrossEntropyWithLogits> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SoftmaxCrossEntropyWithLogits>(end);
    return o;
  }
};

inline flatbuffers::Offset<SoftmaxCrossEntropyWithLogits> CreateSoftmaxCrossEntropyWithLogits(
    flatbuffers::FlatBufferBuilder &_fbb) {
  SoftmaxCrossEntropyWithLogitsBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<SoftmaxCrossEntropyWithLogits> CreateSoftmaxCrossEntropyWithLogits(flatbuffers::FlatBufferBuilder &_fbb, const SoftmaxCrossEntropyWithLogitsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct SpaceToBatchT : public flatbuffers::NativeTable {
  typedef SpaceToBatch TableType;
  std::vector<int64_t> block_size{};
  std::unique_ptr<mindspore::schema::Vec2DT> paddings{};
};

struct SpaceToBatch FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef SpaceToBatchT NativeTableType;
  typedef SpaceToBatchBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return SpaceToBatchTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_BLOCK_SIZE = 4,
    VT_PADDINGS = 6
  };
  const flatbuffers::Vector<int64_t> *block_size() const {
    return GetPointer<const flatbuffers::Vector<int64_t> *>(VT_BLOCK_SIZE);
  }
  flatbuffers::Vector<int64_t> *mutable_block_size() {
    return GetPointer<flatbuffers::Vector<int64_t> *>(VT_BLOCK_SIZE);
  }
  const mindspore::schema::Vec2D *paddings() const {
    return GetPointer<const mindspore::schema::Vec2D *>(VT_PADDINGS);
  }
  mindspore::schema::Vec2D *mutable_paddings() {
    return GetPointer<mindspore::schema::Vec2D *>(VT_PADDINGS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_BLOCK_SIZE) &&
           verifier.VerifyVector(block_size()) &&
           VerifyOffset(verifier, VT_PADDINGS) &&
           verifier.VerifyTable(paddings()) &&
           verifier.EndTable();
  }
  SpaceToBatchT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(SpaceToBatchT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<SpaceToBatch> Pack(flatbuffers::FlatBufferBuilder &_fbb, const SpaceToBatchT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct SpaceToBatchBuilder {
  typedef SpaceToBatch Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_block_size(flatbuffers::Offset<flatbuffers::Vector<int64_t>> block_size) {
    fbb_.AddOffset(SpaceToBatch::VT_BLOCK_SIZE, block_size);
  }
  void add_paddings(flatbuffers::Offset<mindspore::schema::Vec2D> paddings) {
    fbb_.AddOffset(SpaceToBatch::VT_PADDINGS, paddings);
  }
  explicit SpaceToBatchBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<SpaceToBatch> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SpaceToBatch>(end);
    return o;
  }
};

inline flatbuffers::Offset<SpaceToBatch> CreateSpaceToBatch(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<int64_t>> block_size = 0,
    flatbuffers::Offset<mindspore::schema::Vec2D> paddings = 0) {
  SpaceToBatchBuilder builder_(_fbb);
  builder_.add_paddings(paddings);
  builder_.add_block_size(block_size);
  return builder_.Finish();
}

inline flatbuffers::Offset<SpaceToBatch> CreateSpaceToBatchDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<int64_t> *block_size = nullptr,
    flatbuffers::Offset<mindspore::schema::Vec2D> paddings = 0) {
  auto block_size__ = block_size ? _fbb.CreateVector<int64_t>(*block_size) : 0;
  return mindspore::schema::CreateSpaceToBatch(
      _fbb,
      block_size__,
      paddings);
}

flatbuffers::Offset<SpaceToBatch> CreateSpaceToBatch(flatbuffers::FlatBufferBuilder &_fbb, const SpaceToBatchT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct SpaceToBatchNDT : public flatbuffers::NativeTable {
  typedef SpaceToBatchND TableType;
  std::vector<int64_t> block_shape{};
  std::unique_ptr<mindspore::schema::Vec2DT> paddings{};
};

struct SpaceToBatchND FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef SpaceToBatchNDT NativeTableType;
  typedef SpaceToBatchNDBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return SpaceToBatchNDTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_BLOCK_SHAPE = 4,
    VT_PADDINGS = 6
  };
  const flatbuffers::Vector<int64_t> *block_shape() const {
    return GetPointer<const flatbuffers::Vector<int64_t> *>(VT_BLOCK_SHAPE);
  }
  flatbuffers::Vector<int64_t> *mutable_block_shape() {
    return GetPointer<flatbuffers::Vector<int64_t> *>(VT_BLOCK_SHAPE);
  }
  const mindspore::schema::Vec2D *paddings() const {
    return GetPointer<const mindspore::schema::Vec2D *>(VT_PADDINGS);
  }
  mindspore::schema::Vec2D *mutable_paddings() {
    return GetPointer<mindspore::schema::Vec2D *>(VT_PADDINGS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_BLOCK_SHAPE) &&
           verifier.VerifyVector(block_shape()) &&
           VerifyOffset(verifier, VT_PADDINGS) &&
           verifier.VerifyTable(paddings()) &&
           verifier.EndTable();
  }
  SpaceToBatchNDT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(SpaceToBatchNDT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<SpaceToBatchND> Pack(flatbuffers::FlatBufferBuilder &_fbb, const SpaceToBatchNDT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct SpaceToBatchNDBuilder {
  typedef SpaceToBatchND Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_block_shape(flatbuffers::Offset<flatbuffers::Vector<int64_t>> block_shape) {
    fbb_.AddOffset(SpaceToBatchND::VT_BLOCK_SHAPE, block_shape);
  }
  void add_paddings(flatbuffers::Offset<mindspore::schema::Vec2D> paddings) {
    fbb_.AddOffset(SpaceToBatchND::VT_PADDINGS, paddings);
  }
  explicit SpaceToBatchNDBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<SpaceToBatchND> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SpaceToBatchND>(end);
    return o;
  }
};

inline flatbuffers::Offset<SpaceToBatchND> CreateSpaceToBatchND(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<int64_t>> block_shape = 0,
    flatbuffers::Offset<mindspore::schema::Vec2D> paddings = 0) {
  SpaceToBatchNDBuilder builder_(_fbb);
  builder_.add_paddings(paddings);
  builder_.add_block_shape(block_shape);
  return builder_.Finish();
}

inline flatbuffers::Offset<SpaceToBatchND> CreateSpaceToBatchNDDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<int64_t> *block_shape = nullptr,
    flatbuffers::Offset<mindspore::schema::Vec2D> paddings = 0) {
  auto block_shape__ = block_shape ? _fbb.CreateVector<int64_t>(*block_shape) : 0;
  return mindspore::schema::CreateSpaceToBatchND(
      _fbb,
      block_shape__,
      paddings);
}

flatbuffers::Offset<SpaceToBatchND> CreateSpaceToBatchND(flatbuffers::FlatBufferBuilder &_fbb, const SpaceToBatchNDT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct SpaceToDepthT : public flatbuffers::NativeTable {
  typedef SpaceToDepth TableType;
  int64_t block_size = 0;
  mindspore::schema::Format format = mindspore::schema::Format_NCHW;
};

struct SpaceToDepth FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef SpaceToDepthT NativeTableType;
  typedef SpaceToDepthBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return SpaceToDepthTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_BLOCK_SIZE = 4,
    VT_FORMAT = 6
  };
  int64_t block_size() const {
    return GetField<int64_t>(VT_BLOCK_SIZE, 0);
  }
  bool mutate_block_size(int64_t _block_size) {
    return SetField<int64_t>(VT_BLOCK_SIZE, _block_size, 0);
  }
  mindspore::schema::Format format() const {
    return static_cast<mindspore::schema::Format>(GetField<int32_t>(VT_FORMAT, 0));
  }
  bool mutate_format(mindspore::schema::Format _format) {
    return SetField<int32_t>(VT_FORMAT, static_cast<int32_t>(_format), 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_BLOCK_SIZE) &&
           VerifyField<int32_t>(verifier, VT_FORMAT) &&
           verifier.EndTable();
  }
  SpaceToDepthT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(SpaceToDepthT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<SpaceToDepth> Pack(flatbuffers::FlatBufferBuilder &_fbb, const SpaceToDepthT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct SpaceToDepthBuilder {
  typedef SpaceToDepth Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_block_size(int64_t block_size) {
    fbb_.AddElement<int64_t>(SpaceToDepth::VT_BLOCK_SIZE, block_size, 0);
  }
  void add_format(mindspore::schema::Format format) {
    fbb_.AddElement<int32_t>(SpaceToDepth::VT_FORMAT, static_cast<int32_t>(format), 0);
  }
  explicit SpaceToDepthBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<SpaceToDepth> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SpaceToDepth>(end);
    return o;
  }
};

inline flatbuffers::Offset<SpaceToDepth> CreateSpaceToDepth(
    flatbuffers::FlatBufferBuilder &_fbb,
    int64_t block_size = 0,
    mindspore::schema::Format format = mindspore::schema::Format_NCHW) {
  SpaceToDepthBuilder builder_(_fbb);
  builder_.add_block_size(block_size);
  builder_.add_format(format);
  return builder_.Finish();
}

flatbuffers::Offset<SpaceToDepth> CreateSpaceToDepth(flatbuffers::FlatBufferBuilder &_fbb, const SpaceToDepthT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct SparseSoftmaxCrossEntropyWithLogitsT : public flatbuffers::NativeTable {
  typedef SparseSoftmaxCrossEntropyWithLogits TableType;
  bool is_grad = false;
};

struct SparseSoftmaxCrossEntropyWithLogits FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef SparseSoftmaxCrossEntropyWithLogitsT NativeTableType;
  typedef SparseSoftmaxCrossEntropyWithLogitsBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return SparseSoftmaxCrossEntropyWithLogitsTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_IS_GRAD = 4
  };
  bool is_grad() const {
    return GetField<uint8_t>(VT_IS_GRAD, 0) != 0;
  }
  bool mutate_is_grad(bool _is_grad) {
    return SetField<uint8_t>(VT_IS_GRAD, static_cast<uint8_t>(_is_grad), 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_IS_GRAD) &&
           verifier.EndTable();
  }
  SparseSoftmaxCrossEntropyWithLogitsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(SparseSoftmaxCrossEntropyWithLogitsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<SparseSoftmaxCrossEntropyWithLogits> Pack(flatbuffers::FlatBufferBuilder &_fbb, const SparseSoftmaxCrossEntropyWithLogitsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct SparseSoftmaxCrossEntropyWithLogitsBuilder {
  typedef SparseSoftmaxCrossEntropyWithLogits Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_is_grad(bool is_grad) {
    fbb_.AddElement<uint8_t>(SparseSoftmaxCrossEntropyWithLogits::VT_IS_GRAD, static_cast<uint8_t>(is_grad), 0);
  }
  explicit SparseSoftmaxCrossEntropyWithLogitsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<SparseSoftmaxCrossEntropyWithLogits> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SparseSoftmaxCrossEntropyWithLogits>(end);
    return o;
  }
};

inline flatbuffers::Offset<SparseSoftmaxCrossEntropyWithLogits> CreateSparseSoftmaxCrossEntropyWithLogits(
    flatbuffers::FlatBufferBuilder &_fbb,
    bool is_grad = false) {
  SparseSoftmaxCrossEntropyWithLogitsBuilder builder_(_fbb);
  builder_.add_is_grad(is_grad);
  return builder_.Finish();
}

flatbuffers::Offset<SparseSoftmaxCrossEntropyWithLogits> CreateSparseSoftmaxCrossEntropyWithLogits(flatbuffers::FlatBufferBuilder &_fbb, const SparseSoftmaxCrossEntropyWithLogitsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct SparseToDenseT : public flatbuffers::NativeTable {
  typedef SparseToDense TableType;
};

struct SparseToDense FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef SparseToDenseT NativeTableType;
  typedef SparseToDenseBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return SparseToDenseTypeTable();
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  SparseToDenseT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(SparseToDenseT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<SparseToDense> Pack(flatbuffers::FlatBufferBuilder &_fbb, const SparseToDenseT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct SparseToDenseBuilder {
  typedef SparseToDense Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit SparseToDenseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<SparseToDense> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SparseToDense>(end);
    return o;
  }
};

inline flatbuffers::Offset<SparseToDense> CreateSparseToDense(
    flatbuffers::FlatBufferBuilder &_fbb) {
  SparseToDenseBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<SparseToDense> CreateSparseToDense(flatbuffers::FlatBufferBuilder &_fbb, const SparseToDenseT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct SplitT : public flatbuffers::NativeTable {
  typedef Split TableType;
  int64_t output_num = 0;
  std::vector<int64_t> size_splits{};
  int64_t axis = 0;
};

struct Split FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef SplitT NativeTableType;
  typedef SplitBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return SplitTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_OUTPUT_NUM = 4,
    VT_SIZE_SPLITS = 6,
    VT_AXIS = 8
  };
  int64_t output_num() const {
    return GetField<int64_t>(VT_OUTPUT_NUM, 0);
  }
  bool mutate_output_num(int64_t _output_num) {
    return SetField<int64_t>(VT_OUTPUT_NUM, _output_num, 0);
  }
  const flatbuffers::Vector<int64_t> *size_splits() const {
    return GetPointer<const flatbuffers::Vector<int64_t> *>(VT_SIZE_SPLITS);
  }
  flatbuffers::Vector<int64_t> *mutable_size_splits() {
    return GetPointer<flatbuffers::Vector<int64_t> *>(VT_SIZE_SPLITS);
  }
  int64_t axis() const {
    return GetField<int64_t>(VT_AXIS, 0);
  }
  bool mutate_axis(int64_t _axis) {
    return SetField<int64_t>(VT_AXIS, _axis, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_OUTPUT_NUM) &&
           VerifyOffset(verifier, VT_SIZE_SPLITS) &&
           verifier.VerifyVector(size_splits()) &&
           VerifyField<int64_t>(verifier, VT_AXIS) &&
           verifier.EndTable();
  }
  SplitT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(SplitT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Split> Pack(flatbuffers::FlatBufferBuilder &_fbb, const SplitT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct SplitBuilder {
  typedef Split Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_output_num(int64_t output_num) {
    fbb_.AddElement<int64_t>(Split::VT_OUTPUT_NUM, output_num, 0);
  }
  void add_size_splits(flatbuffers::Offset<flatbuffers::Vector<int64_t>> size_splits) {
    fbb_.AddOffset(Split::VT_SIZE_SPLITS, size_splits);
  }
  void add_axis(int64_t axis) {
    fbb_.AddElement<int64_t>(Split::VT_AXIS, axis, 0);
  }
  explicit SplitBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Split> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Split>(end);
    return o;
  }
};

inline flatbuffers::Offset<Split> CreateSplit(
    flatbuffers::FlatBufferBuilder &_fbb,
    int64_t output_num = 0,
    flatbuffers::Offset<flatbuffers::Vector<int64_t>> size_splits = 0,
    int64_t axis = 0) {
  SplitBuilder builder_(_fbb);
  builder_.add_axis(axis);
  builder_.add_output_num(output_num);
  builder_.add_size_splits(size_splits);
  return builder_.Finish();
}

inline flatbuffers::Offset<Split> CreateSplitDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int64_t output_num = 0,
    const std::vector<int64_t> *size_splits = nullptr,
    int64_t axis = 0) {
  auto size_splits__ = size_splits ? _fbb.CreateVector<int64_t>(*size_splits) : 0;
  return mindspore::schema::CreateSplit(
      _fbb,
      output_num,
      size_splits__,
      axis);
}

flatbuffers::Offset<Split> CreateSplit(flatbuffers::FlatBufferBuilder &_fbb, const SplitT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct SqrtT : public flatbuffers::NativeTable {
  typedef Sqrt TableType;
};

struct Sqrt FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef SqrtT NativeTableType;
  typedef SqrtBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return SqrtTypeTable();
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  SqrtT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(SqrtT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Sqrt> Pack(flatbuffers::FlatBufferBuilder &_fbb, const SqrtT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct SqrtBuilder {
  typedef Sqrt Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit SqrtBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Sqrt> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Sqrt>(end);
    return o;
  }
};

inline flatbuffers::Offset<Sqrt> CreateSqrt(
    flatbuffers::FlatBufferBuilder &_fbb) {
  SqrtBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<Sqrt> CreateSqrt(flatbuffers::FlatBufferBuilder &_fbb, const SqrtT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct SqueezeT : public flatbuffers::NativeTable {
  typedef Squeeze TableType;
  std::vector<int64_t> axis{};
};

struct Squeeze FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef SqueezeT NativeTableType;
  typedef SqueezeBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return SqueezeTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_AXIS = 4
  };
  const flatbuffers::Vector<int64_t> *axis() const {
    return GetPointer<const flatbuffers::Vector<int64_t> *>(VT_AXIS);
  }
  flatbuffers::Vector<int64_t> *mutable_axis() {
    return GetPointer<flatbuffers::Vector<int64_t> *>(VT_AXIS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_AXIS) &&
           verifier.VerifyVector(axis()) &&
           verifier.EndTable();
  }
  SqueezeT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(SqueezeT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Squeeze> Pack(flatbuffers::FlatBufferBuilder &_fbb, const SqueezeT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct SqueezeBuilder {
  typedef Squeeze Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_axis(flatbuffers::Offset<flatbuffers::Vector<int64_t>> axis) {
    fbb_.AddOffset(Squeeze::VT_AXIS, axis);
  }
  explicit SqueezeBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Squeeze> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Squeeze>(end);
    return o;
  }
};

inline flatbuffers::Offset<Squeeze> CreateSqueeze(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<int64_t>> axis = 0) {
  SqueezeBuilder builder_(_fbb);
  builder_.add_axis(axis);
  return builder_.Finish();
}

inline flatbuffers::Offset<Squeeze> CreateSqueezeDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<int64_t> *axis = nullptr) {
  auto axis__ = axis ? _fbb.CreateVector<int64_t>(*axis) : 0;
  return mindspore::schema::CreateSqueeze(
      _fbb,
      axis__);
}

flatbuffers::Offset<Squeeze> CreateSqueeze(flatbuffers::FlatBufferBuilder &_fbb, const SqueezeT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct SquareT : public flatbuffers::NativeTable {
  typedef Square TableType;
};

struct Square FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef SquareT NativeTableType;
  typedef SquareBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return SquareTypeTable();
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  SquareT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(SquareT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Square> Pack(flatbuffers::FlatBufferBuilder &_fbb, const SquareT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct SquareBuilder {
  typedef Square Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit SquareBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Square> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Square>(end);
    return o;
  }
};

inline flatbuffers::Offset<Square> CreateSquare(
    flatbuffers::FlatBufferBuilder &_fbb) {
  SquareBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<Square> CreateSquare(flatbuffers::FlatBufferBuilder &_fbb, const SquareT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct SquaredDifferenceT : public flatbuffers::NativeTable {
  typedef SquaredDifference TableType;
};

struct SquaredDifference FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef SquaredDifferenceT NativeTableType;
  typedef SquaredDifferenceBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return SquaredDifferenceTypeTable();
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  SquaredDifferenceT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(SquaredDifferenceT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<SquaredDifference> Pack(flatbuffers::FlatBufferBuilder &_fbb, const SquaredDifferenceT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct SquaredDifferenceBuilder {
  typedef SquaredDifference Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit SquaredDifferenceBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<SquaredDifference> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SquaredDifference>(end);
    return o;
  }
};

inline flatbuffers::Offset<SquaredDifference> CreateSquaredDifference(
    flatbuffers::FlatBufferBuilder &_fbb) {
  SquaredDifferenceBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<SquaredDifference> CreateSquaredDifference(flatbuffers::FlatBufferBuilder &_fbb, const SquaredDifferenceT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct StackT : public flatbuffers::NativeTable {
  typedef Stack TableType;
  int64_t axis = 0;
};

struct Stack FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef StackT NativeTableType;
  typedef StackBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return StackTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_AXIS = 4
  };
  int64_t axis() const {
    return GetField<int64_t>(VT_AXIS, 0);
  }
  bool mutate_axis(int64_t _axis) {
    return SetField<int64_t>(VT_AXIS, _axis, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_AXIS) &&
           verifier.EndTable();
  }
  StackT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(StackT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Stack> Pack(flatbuffers::FlatBufferBuilder &_fbb, const StackT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct StackBuilder {
  typedef Stack Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_axis(int64_t axis) {
    fbb_.AddElement<int64_t>(Stack::VT_AXIS, axis, 0);
  }
  explicit StackBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Stack> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Stack>(end);
    return o;
  }
};

inline flatbuffers::Offset<Stack> CreateStack(
    flatbuffers::FlatBufferBuilder &_fbb,
    int64_t axis = 0) {
  StackBuilder builder_(_fbb);
  builder_.add_axis(axis);
  return builder_.Finish();
}

flatbuffers::Offset<Stack> CreateStack(flatbuffers::FlatBufferBuilder &_fbb, const StackT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct StridedSliceT : public flatbuffers::NativeTable {
  typedef StridedSlice TableType;
  int64_t begin_mask = 0;
  int64_t end_mask = 0;
  int64_t ellipsis_mask = 0;
  int64_t new_axis_mask = 0;
  int64_t shrink_axis_mask = 0;
};

struct StridedSlice FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef StridedSliceT NativeTableType;
  typedef StridedSliceBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return StridedSliceTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_BEGIN_MASK = 4,
    VT_END_MASK = 6,
    VT_ELLIPSIS_MASK = 8,
    VT_NEW_AXIS_MASK = 10,
    VT_SHRINK_AXIS_MASK = 12
  };
  int64_t begin_mask() const {
    return GetField<int64_t>(VT_BEGIN_MASK, 0);
  }
  bool mutate_begin_mask(int64_t _begin_mask) {
    return SetField<int64_t>(VT_BEGIN_MASK, _begin_mask, 0);
  }
  int64_t end_mask() const {
    return GetField<int64_t>(VT_END_MASK, 0);
  }
  bool mutate_end_mask(int64_t _end_mask) {
    return SetField<int64_t>(VT_END_MASK, _end_mask, 0);
  }
  int64_t ellipsis_mask() const {
    return GetField<int64_t>(VT_ELLIPSIS_MASK, 0);
  }
  bool mutate_ellipsis_mask(int64_t _ellipsis_mask) {
    return SetField<int64_t>(VT_ELLIPSIS_MASK, _ellipsis_mask, 0);
  }
  int64_t new_axis_mask() const {
    return GetField<int64_t>(VT_NEW_AXIS_MASK, 0);
  }
  bool mutate_new_axis_mask(int64_t _new_axis_mask) {
    return SetField<int64_t>(VT_NEW_AXIS_MASK, _new_axis_mask, 0);
  }
  int64_t shrink_axis_mask() const {
    return GetField<int64_t>(VT_SHRINK_AXIS_MASK, 0);
  }
  bool mutate_shrink_axis_mask(int64_t _shrink_axis_mask) {
    return SetField<int64_t>(VT_SHRINK_AXIS_MASK, _shrink_axis_mask, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_BEGIN_MASK) &&
           VerifyField<int64_t>(verifier, VT_END_MASK) &&
           VerifyField<int64_t>(verifier, VT_ELLIPSIS_MASK) &&
           VerifyField<int64_t>(verifier, VT_NEW_AXIS_MASK) &&
           VerifyField<int64_t>(verifier, VT_SHRINK_AXIS_MASK) &&
           verifier.EndTable();
  }
  StridedSliceT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(StridedSliceT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<StridedSlice> Pack(flatbuffers::FlatBufferBuilder &_fbb, const StridedSliceT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct StridedSliceBuilder {
  typedef StridedSlice Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_begin_mask(int64_t begin_mask) {
    fbb_.AddElement<int64_t>(StridedSlice::VT_BEGIN_MASK, begin_mask, 0);
  }
  void add_end_mask(int64_t end_mask) {
    fbb_.AddElement<int64_t>(StridedSlice::VT_END_MASK, end_mask, 0);
  }
  void add_ellipsis_mask(int64_t ellipsis_mask) {
    fbb_.AddElement<int64_t>(StridedSlice::VT_ELLIPSIS_MASK, ellipsis_mask, 0);
  }
  void add_new_axis_mask(int64_t new_axis_mask) {
    fbb_.AddElement<int64_t>(StridedSlice::VT_NEW_AXIS_MASK, new_axis_mask, 0);
  }
  void add_shrink_axis_mask(int64_t shrink_axis_mask) {
    fbb_.AddElement<int64_t>(StridedSlice::VT_SHRINK_AXIS_MASK, shrink_axis_mask, 0);
  }
  explicit StridedSliceBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<StridedSlice> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<StridedSlice>(end);
    return o;
  }
};

inline flatbuffers::Offset<StridedSlice> CreateStridedSlice(
    flatbuffers::FlatBufferBuilder &_fbb,
    int64_t begin_mask = 0,
    int64_t end_mask = 0,
    int64_t ellipsis_mask = 0,
    int64_t new_axis_mask = 0,
    int64_t shrink_axis_mask = 0) {
  StridedSliceBuilder builder_(_fbb);
  builder_.add_shrink_axis_mask(shrink_axis_mask);
  builder_.add_new_axis_mask(new_axis_mask);
  builder_.add_ellipsis_mask(ellipsis_mask);
  builder_.add_end_mask(end_mask);
  builder_.add_begin_mask(begin_mask);
  return builder_.Finish();
}

flatbuffers::Offset<StridedSlice> CreateStridedSlice(flatbuffers::FlatBufferBuilder &_fbb, const StridedSliceT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct SubFusionT : public flatbuffers::NativeTable {
  typedef SubFusion TableType;
  mindspore::schema::ActivationType activation_type = mindspore::schema::ActivationType_NO_ACTIVATION;
};

struct SubFusion FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef SubFusionT NativeTableType;
  typedef SubFusionBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return SubFusionTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ACTIVATION_TYPE = 4
  };
  mindspore::schema::ActivationType activation_type() const {
    return static_cast<mindspore::schema::ActivationType>(GetField<int8_t>(VT_ACTIVATION_TYPE, 0));
  }
  bool mutate_activation_type(mindspore::schema::ActivationType _activation_type) {
    return SetField<int8_t>(VT_ACTIVATION_TYPE, static_cast<int8_t>(_activation_type), 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_ACTIVATION_TYPE) &&
           verifier.EndTable();
  }
  SubFusionT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(SubFusionT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<SubFusion> Pack(flatbuffers::FlatBufferBuilder &_fbb, const SubFusionT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct SubFusionBuilder {
  typedef SubFusion Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_activation_type(mindspore::schema::ActivationType activation_type) {
    fbb_.AddElement<int8_t>(SubFusion::VT_ACTIVATION_TYPE, static_cast<int8_t>(activation_type), 0);
  }
  explicit SubFusionBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<SubFusion> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SubFusion>(end);
    return o;
  }
};

inline flatbuffers::Offset<SubFusion> CreateSubFusion(
    flatbuffers::FlatBufferBuilder &_fbb,
    mindspore::schema::ActivationType activation_type = mindspore::schema::ActivationType_NO_ACTIVATION) {
  SubFusionBuilder builder_(_fbb);
  builder_.add_activation_type(activation_type);
  return builder_.Finish();
}

flatbuffers::Offset<SubFusion> CreateSubFusion(flatbuffers::FlatBufferBuilder &_fbb, const SubFusionT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct SubGradT : public flatbuffers::NativeTable {
  typedef SubGrad TableType;
};

struct SubGrad FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef SubGradT NativeTableType;
  typedef SubGradBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return SubGradTypeTable();
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  SubGradT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(SubGradT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<SubGrad> Pack(flatbuffers::FlatBufferBuilder &_fbb, const SubGradT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct SubGradBuilder {
  typedef SubGrad Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit SubGradBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<SubGrad> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SubGrad>(end);
    return o;
  }
};

inline flatbuffers::Offset<SubGrad> CreateSubGrad(
    flatbuffers::FlatBufferBuilder &_fbb) {
  SubGradBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<SubGrad> CreateSubGrad(flatbuffers::FlatBufferBuilder &_fbb, const SubGradT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct SwitchT : public flatbuffers::NativeTable {
  typedef Switch TableType;
};

struct Switch FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef SwitchT NativeTableType;
  typedef SwitchBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return SwitchTypeTable();
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  SwitchT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(SwitchT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Switch> Pack(flatbuffers::FlatBufferBuilder &_fbb, const SwitchT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct SwitchBuilder {
  typedef Switch Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit SwitchBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Switch> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Switch>(end);
    return o;
  }
};

inline flatbuffers::Offset<Switch> CreateSwitch(
    flatbuffers::FlatBufferBuilder &_fbb) {
  SwitchBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<Switch> CreateSwitch(flatbuffers::FlatBufferBuilder &_fbb, const SwitchT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct TensorListFromTensorT : public flatbuffers::NativeTable {
  typedef TensorListFromTensor TableType;
  int64_t element_dtype = 0;
  int64_t shape_type = 0;
};

struct TensorListFromTensor FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef TensorListFromTensorT NativeTableType;
  typedef TensorListFromTensorBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return TensorListFromTensorTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ELEMENT_DTYPE = 4,
    VT_SHAPE_TYPE = 6
  };
  int64_t element_dtype() const {
    return GetField<int64_t>(VT_ELEMENT_DTYPE, 0);
  }
  bool mutate_element_dtype(int64_t _element_dtype) {
    return SetField<int64_t>(VT_ELEMENT_DTYPE, _element_dtype, 0);
  }
  int64_t shape_type() const {
    return GetField<int64_t>(VT_SHAPE_TYPE, 0);
  }
  bool mutate_shape_type(int64_t _shape_type) {
    return SetField<int64_t>(VT_SHAPE_TYPE, _shape_type, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_ELEMENT_DTYPE) &&
           VerifyField<int64_t>(verifier, VT_SHAPE_TYPE) &&
           verifier.EndTable();
  }
  TensorListFromTensorT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(TensorListFromTensorT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<TensorListFromTensor> Pack(flatbuffers::FlatBufferBuilder &_fbb, const TensorListFromTensorT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct TensorListFromTensorBuilder {
  typedef TensorListFromTensor Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_element_dtype(int64_t element_dtype) {
    fbb_.AddElement<int64_t>(TensorListFromTensor::VT_ELEMENT_DTYPE, element_dtype, 0);
  }
  void add_shape_type(int64_t shape_type) {
    fbb_.AddElement<int64_t>(TensorListFromTensor::VT_SHAPE_TYPE, shape_type, 0);
  }
  explicit TensorListFromTensorBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<TensorListFromTensor> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<TensorListFromTensor>(end);
    return o;
  }
};

inline flatbuffers::Offset<TensorListFromTensor> CreateTensorListFromTensor(
    flatbuffers::FlatBufferBuilder &_fbb,
    int64_t element_dtype = 0,
    int64_t shape_type = 0) {
  TensorListFromTensorBuilder builder_(_fbb);
  builder_.add_shape_type(shape_type);
  builder_.add_element_dtype(element_dtype);
  return builder_.Finish();
}

flatbuffers::Offset<TensorListFromTensor> CreateTensorListFromTensor(flatbuffers::FlatBufferBuilder &_fbb, const TensorListFromTensorT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct TensorListGetItemT : public flatbuffers::NativeTable {
  typedef TensorListGetItem TableType;
  int64_t element_dtype = 0;
};

struct TensorListGetItem FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef TensorListGetItemT NativeTableType;
  typedef TensorListGetItemBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return TensorListGetItemTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ELEMENT_DTYPE = 4
  };
  int64_t element_dtype() const {
    return GetField<int64_t>(VT_ELEMENT_DTYPE, 0);
  }
  bool mutate_element_dtype(int64_t _element_dtype) {
    return SetField<int64_t>(VT_ELEMENT_DTYPE, _element_dtype, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_ELEMENT_DTYPE) &&
           verifier.EndTable();
  }
  TensorListGetItemT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(TensorListGetItemT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<TensorListGetItem> Pack(flatbuffers::FlatBufferBuilder &_fbb, const TensorListGetItemT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct TensorListGetItemBuilder {
  typedef TensorListGetItem Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_element_dtype(int64_t element_dtype) {
    fbb_.AddElement<int64_t>(TensorListGetItem::VT_ELEMENT_DTYPE, element_dtype, 0);
  }
  explicit TensorListGetItemBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<TensorListGetItem> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<TensorListGetItem>(end);
    return o;
  }
};

inline flatbuffers::Offset<TensorListGetItem> CreateTensorListGetItem(
    flatbuffers::FlatBufferBuilder &_fbb,
    int64_t element_dtype = 0) {
  TensorListGetItemBuilder builder_(_fbb);
  builder_.add_element_dtype(element_dtype);
  return builder_.Finish();
}

flatbuffers::Offset<TensorListGetItem> CreateTensorListGetItem(flatbuffers::FlatBufferBuilder &_fbb, const TensorListGetItemT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct TensorListReserveT : public flatbuffers::NativeTable {
  typedef TensorListReserve TableType;
  int64_t element_dtype = 0;
  int64_t shape_type = 0;
};

struct TensorListReserve FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef TensorListReserveT NativeTableType;
  typedef TensorListReserveBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return TensorListReserveTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ELEMENT_DTYPE = 4,
    VT_SHAPE_TYPE = 6
  };
  int64_t element_dtype() const {
    return GetField<int64_t>(VT_ELEMENT_DTYPE, 0);
  }
  bool mutate_element_dtype(int64_t _element_dtype) {
    return SetField<int64_t>(VT_ELEMENT_DTYPE, _element_dtype, 0);
  }
  int64_t shape_type() const {
    return GetField<int64_t>(VT_SHAPE_TYPE, 0);
  }
  bool mutate_shape_type(int64_t _shape_type) {
    return SetField<int64_t>(VT_SHAPE_TYPE, _shape_type, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_ELEMENT_DTYPE) &&
           VerifyField<int64_t>(verifier, VT_SHAPE_TYPE) &&
           verifier.EndTable();
  }
  TensorListReserveT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(TensorListReserveT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<TensorListReserve> Pack(flatbuffers::FlatBufferBuilder &_fbb, const TensorListReserveT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct TensorListReserveBuilder {
  typedef TensorListReserve Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_element_dtype(int64_t element_dtype) {
    fbb_.AddElement<int64_t>(TensorListReserve::VT_ELEMENT_DTYPE, element_dtype, 0);
  }
  void add_shape_type(int64_t shape_type) {
    fbb_.AddElement<int64_t>(TensorListReserve::VT_SHAPE_TYPE, shape_type, 0);
  }
  explicit TensorListReserveBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<TensorListReserve> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<TensorListReserve>(end);
    return o;
  }
};

inline flatbuffers::Offset<TensorListReserve> CreateTensorListReserve(
    flatbuffers::FlatBufferBuilder &_fbb,
    int64_t element_dtype = 0,
    int64_t shape_type = 0) {
  TensorListReserveBuilder builder_(_fbb);
  builder_.add_shape_type(shape_type);
  builder_.add_element_dtype(element_dtype);
  return builder_.Finish();
}

flatbuffers::Offset<TensorListReserve> CreateTensorListReserve(flatbuffers::FlatBufferBuilder &_fbb, const TensorListReserveT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct TensorListSetItemT : public flatbuffers::NativeTable {
  typedef TensorListSetItem TableType;
  int64_t element_dtype = 0;
};

struct TensorListSetItem FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef TensorListSetItemT NativeTableType;
  typedef TensorListSetItemBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return TensorListSetItemTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ELEMENT_DTYPE = 4
  };
  int64_t element_dtype() const {
    return GetField<int64_t>(VT_ELEMENT_DTYPE, 0);
  }
  bool mutate_element_dtype(int64_t _element_dtype) {
    return SetField<int64_t>(VT_ELEMENT_DTYPE, _element_dtype, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_ELEMENT_DTYPE) &&
           verifier.EndTable();
  }
  TensorListSetItemT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(TensorListSetItemT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<TensorListSetItem> Pack(flatbuffers::FlatBufferBuilder &_fbb, const TensorListSetItemT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct TensorListSetItemBuilder {
  typedef TensorListSetItem Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_element_dtype(int64_t element_dtype) {
    fbb_.AddElement<int64_t>(TensorListSetItem::VT_ELEMENT_DTYPE, element_dtype, 0);
  }
  explicit TensorListSetItemBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<TensorListSetItem> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<TensorListSetItem>(end);
    return o;
  }
};

inline flatbuffers::Offset<TensorListSetItem> CreateTensorListSetItem(
    flatbuffers::FlatBufferBuilder &_fbb,
    int64_t element_dtype = 0) {
  TensorListSetItemBuilder builder_(_fbb);
  builder_.add_element_dtype(element_dtype);
  return builder_.Finish();
}

flatbuffers::Offset<TensorListSetItem> CreateTensorListSetItem(flatbuffers::FlatBufferBuilder &_fbb, const TensorListSetItemT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct TensorListStackT : public flatbuffers::NativeTable {
  typedef TensorListStack TableType;
  int64_t num_elements = 0;
  int64_t element_dtype = 0;
};

struct TensorListStack FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef TensorListStackT NativeTableType;
  typedef TensorListStackBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return TensorListStackTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NUM_ELEMENTS = 4,
    VT_ELEMENT_DTYPE = 6
  };
  int64_t num_elements() const {
    return GetField<int64_t>(VT_NUM_ELEMENTS, 0);
  }
  bool mutate_num_elements(int64_t _num_elements) {
    return SetField<int64_t>(VT_NUM_ELEMENTS, _num_elements, 0);
  }
  int64_t element_dtype() const {
    return GetField<int64_t>(VT_ELEMENT_DTYPE, 0);
  }
  bool mutate_element_dtype(int64_t _element_dtype) {
    return SetField<int64_t>(VT_ELEMENT_DTYPE, _element_dtype, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_NUM_ELEMENTS) &&
           VerifyField<int64_t>(verifier, VT_ELEMENT_DTYPE) &&
           verifier.EndTable();
  }
  TensorListStackT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(TensorListStackT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<TensorListStack> Pack(flatbuffers::FlatBufferBuilder &_fbb, const TensorListStackT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct TensorListStackBuilder {
  typedef TensorListStack Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_num_elements(int64_t num_elements) {
    fbb_.AddElement<int64_t>(TensorListStack::VT_NUM_ELEMENTS, num_elements, 0);
  }
  void add_element_dtype(int64_t element_dtype) {
    fbb_.AddElement<int64_t>(TensorListStack::VT_ELEMENT_DTYPE, element_dtype, 0);
  }
  explicit TensorListStackBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<TensorListStack> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<TensorListStack>(end);
    return o;
  }
};

inline flatbuffers::Offset<TensorListStack> CreateTensorListStack(
    flatbuffers::FlatBufferBuilder &_fbb,
    int64_t num_elements = 0,
    int64_t element_dtype = 0) {
  TensorListStackBuilder builder_(_fbb);
  builder_.add_element_dtype(element_dtype);
  builder_.add_num_elements(num_elements);
  return builder_.Finish();
}

flatbuffers::Offset<TensorListStack> CreateTensorListStack(flatbuffers::FlatBufferBuilder &_fbb, const TensorListStackT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct TileFusionT : public flatbuffers::NativeTable {
  typedef TileFusion TableType;
  std::vector<int64_t> dims{};
};

struct TileFusion FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef TileFusionT NativeTableType;
  typedef TileFusionBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return TileFusionTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_DIMS = 4
  };
  const flatbuffers::Vector<int64_t> *dims() const {
    return GetPointer<const flatbuffers::Vector<int64_t> *>(VT_DIMS);
  }
  flatbuffers::Vector<int64_t> *mutable_dims() {
    return GetPointer<flatbuffers::Vector<int64_t> *>(VT_DIMS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_DIMS) &&
           verifier.VerifyVector(dims()) &&
           verifier.EndTable();
  }
  TileFusionT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(TileFusionT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<TileFusion> Pack(flatbuffers::FlatBufferBuilder &_fbb, const TileFusionT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct TileFusionBuilder {
  typedef TileFusion Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_dims(flatbuffers::Offset<flatbuffers::Vector<int64_t>> dims) {
    fbb_.AddOffset(TileFusion::VT_DIMS, dims);
  }
  explicit TileFusionBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<TileFusion> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<TileFusion>(end);
    return o;
  }
};

inline flatbuffers::Offset<TileFusion> CreateTileFusion(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<int64_t>> dims = 0) {
  TileFusionBuilder builder_(_fbb);
  builder_.add_dims(dims);
  return builder_.Finish();
}

inline flatbuffers::Offset<TileFusion> CreateTileFusionDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<int64_t> *dims = nullptr) {
  auto dims__ = dims ? _fbb.CreateVector<int64_t>(*dims) : 0;
  return mindspore::schema::CreateTileFusion(
      _fbb,
      dims__);
}

flatbuffers::Offset<TileFusion> CreateTileFusion(flatbuffers::FlatBufferBuilder &_fbb, const TileFusionT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct TopKFusionT : public flatbuffers::NativeTable {
  typedef TopKFusion TableType;
  bool sorted = true;
  int64_t axis = 0;
  int64_t largest = 0;
};

struct TopKFusion FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef TopKFusionT NativeTableType;
  typedef TopKFusionBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return TopKFusionTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SORTED = 4,
    VT_AXIS = 6,
    VT_LARGEST = 8
  };
  bool sorted() const {
    return GetField<uint8_t>(VT_SORTED, 1) != 0;
  }
  bool mutate_sorted(bool _sorted) {
    return SetField<uint8_t>(VT_SORTED, static_cast<uint8_t>(_sorted), 1);
  }
  int64_t axis() const {
    return GetField<int64_t>(VT_AXIS, 0);
  }
  bool mutate_axis(int64_t _axis) {
    return SetField<int64_t>(VT_AXIS, _axis, 0);
  }
  int64_t largest() const {
    return GetField<int64_t>(VT_LARGEST, 0);
  }
  bool mutate_largest(int64_t _largest) {
    return SetField<int64_t>(VT_LARGEST, _largest, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_SORTED) &&
           VerifyField<int64_t>(verifier, VT_AXIS) &&
           VerifyField<int64_t>(verifier, VT_LARGEST) &&
           verifier.EndTable();
  }
  TopKFusionT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(TopKFusionT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<TopKFusion> Pack(flatbuffers::FlatBufferBuilder &_fbb, const TopKFusionT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct TopKFusionBuilder {
  typedef TopKFusion Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_sorted(bool sorted) {
    fbb_.AddElement<uint8_t>(TopKFusion::VT_SORTED, static_cast<uint8_t>(sorted), 1);
  }
  void add_axis(int64_t axis) {
    fbb_.AddElement<int64_t>(TopKFusion::VT_AXIS, axis, 0);
  }
  void add_largest(int64_t largest) {
    fbb_.AddElement<int64_t>(TopKFusion::VT_LARGEST, largest, 0);
  }
  explicit TopKFusionBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<TopKFusion> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<TopKFusion>(end);
    return o;
  }
};

inline flatbuffers::Offset<TopKFusion> CreateTopKFusion(
    flatbuffers::FlatBufferBuilder &_fbb,
    bool sorted = true,
    int64_t axis = 0,
    int64_t largest = 0) {
  TopKFusionBuilder builder_(_fbb);
  builder_.add_largest(largest);
  builder_.add_axis(axis);
  builder_.add_sorted(sorted);
  return builder_.Finish();
}

flatbuffers::Offset<TopKFusion> CreateTopKFusion(flatbuffers::FlatBufferBuilder &_fbb, const TopKFusionT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct TransposeT : public flatbuffers::NativeTable {
  typedef Transpose TableType;
};

struct Transpose FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef TransposeT NativeTableType;
  typedef TransposeBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return TransposeTypeTable();
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  TransposeT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(TransposeT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Transpose> Pack(flatbuffers::FlatBufferBuilder &_fbb, const TransposeT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct TransposeBuilder {
  typedef Transpose Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit TransposeBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Transpose> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Transpose>(end);
    return o;
  }
};

inline flatbuffers::Offset<Transpose> CreateTranspose(
    flatbuffers::FlatBufferBuilder &_fbb) {
  TransposeBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<Transpose> CreateTranspose(flatbuffers::FlatBufferBuilder &_fbb, const TransposeT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct UniqueT : public flatbuffers::NativeTable {
  typedef Unique TableType;
};

struct Unique FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef UniqueT NativeTableType;
  typedef UniqueBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return UniqueTypeTable();
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  UniqueT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(UniqueT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Unique> Pack(flatbuffers::FlatBufferBuilder &_fbb, const UniqueT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct UniqueBuilder {
  typedef Unique Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit UniqueBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Unique> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Unique>(end);
    return o;
  }
};

inline flatbuffers::Offset<Unique> CreateUnique(
    flatbuffers::FlatBufferBuilder &_fbb) {
  UniqueBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<Unique> CreateUnique(flatbuffers::FlatBufferBuilder &_fbb, const UniqueT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct UnsortedSegmentSumT : public flatbuffers::NativeTable {
  typedef UnsortedSegmentSum TableType;
};

struct UnsortedSegmentSum FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef UnsortedSegmentSumT NativeTableType;
  typedef UnsortedSegmentSumBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return UnsortedSegmentSumTypeTable();
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  UnsortedSegmentSumT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(UnsortedSegmentSumT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<UnsortedSegmentSum> Pack(flatbuffers::FlatBufferBuilder &_fbb, const UnsortedSegmentSumT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct UnsortedSegmentSumBuilder {
  typedef UnsortedSegmentSum Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit UnsortedSegmentSumBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<UnsortedSegmentSum> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<UnsortedSegmentSum>(end);
    return o;
  }
};

inline flatbuffers::Offset<UnsortedSegmentSum> CreateUnsortedSegmentSum(
    flatbuffers::FlatBufferBuilder &_fbb) {
  UnsortedSegmentSumBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<UnsortedSegmentSum> CreateUnsortedSegmentSum(flatbuffers::FlatBufferBuilder &_fbb, const UnsortedSegmentSumT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct UnsqueezeT : public flatbuffers::NativeTable {
  typedef Unsqueeze TableType;
  std::vector<int64_t> axis{};
};

struct Unsqueeze FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef UnsqueezeT NativeTableType;
  typedef UnsqueezeBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return UnsqueezeTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_AXIS = 4
  };
  const flatbuffers::Vector<int64_t> *axis() const {
    return GetPointer<const flatbuffers::Vector<int64_t> *>(VT_AXIS);
  }
  flatbuffers::Vector<int64_t> *mutable_axis() {
    return GetPointer<flatbuffers::Vector<int64_t> *>(VT_AXIS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_AXIS) &&
           verifier.VerifyVector(axis()) &&
           verifier.EndTable();
  }
  UnsqueezeT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(UnsqueezeT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Unsqueeze> Pack(flatbuffers::FlatBufferBuilder &_fbb, const UnsqueezeT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct UnsqueezeBuilder {
  typedef Unsqueeze Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_axis(flatbuffers::Offset<flatbuffers::Vector<int64_t>> axis) {
    fbb_.AddOffset(Unsqueeze::VT_AXIS, axis);
  }
  explicit UnsqueezeBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Unsqueeze> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Unsqueeze>(end);
    return o;
  }
};

inline flatbuffers::Offset<Unsqueeze> CreateUnsqueeze(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<int64_t>> axis = 0) {
  UnsqueezeBuilder builder_(_fbb);
  builder_.add_axis(axis);
  return builder_.Finish();
}

inline flatbuffers::Offset<Unsqueeze> CreateUnsqueezeDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<int64_t> *axis = nullptr) {
  auto axis__ = axis ? _fbb.CreateVector<int64_t>(*axis) : 0;
  return mindspore::schema::CreateUnsqueeze(
      _fbb,
      axis__);
}

flatbuffers::Offset<Unsqueeze> CreateUnsqueeze(flatbuffers::FlatBufferBuilder &_fbb, const UnsqueezeT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct UnstackT : public flatbuffers::NativeTable {
  typedef Unstack TableType;
  int64_t axis = 0;
};

struct Unstack FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef UnstackT NativeTableType;
  typedef UnstackBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return UnstackTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_AXIS = 4
  };
  int64_t axis() const {
    return GetField<int64_t>(VT_AXIS, 0);
  }
  bool mutate_axis(int64_t _axis) {
    return SetField<int64_t>(VT_AXIS, _axis, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_AXIS) &&
           verifier.EndTable();
  }
  UnstackT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(UnstackT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Unstack> Pack(flatbuffers::FlatBufferBuilder &_fbb, const UnstackT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct UnstackBuilder {
  typedef Unstack Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_axis(int64_t axis) {
    fbb_.AddElement<int64_t>(Unstack::VT_AXIS, axis, 0);
  }
  explicit UnstackBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Unstack> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Unstack>(end);
    return o;
  }
};

inline flatbuffers::Offset<Unstack> CreateUnstack(
    flatbuffers::FlatBufferBuilder &_fbb,
    int64_t axis = 0) {
  UnstackBuilder builder_(_fbb);
  builder_.add_axis(axis);
  return builder_.Finish();
}

flatbuffers::Offset<Unstack> CreateUnstack(flatbuffers::FlatBufferBuilder &_fbb, const UnstackT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct WhereT : public flatbuffers::NativeTable {
  typedef Where TableType;
};

struct Where FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef WhereT NativeTableType;
  typedef WhereBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return WhereTypeTable();
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  WhereT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(WhereT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Where> Pack(flatbuffers::FlatBufferBuilder &_fbb, const WhereT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct WhereBuilder {
  typedef Where Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit WhereBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Where> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Where>(end);
    return o;
  }
};

inline flatbuffers::Offset<Where> CreateWhere(
    flatbuffers::FlatBufferBuilder &_fbb) {
  WhereBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<Where> CreateWhere(flatbuffers::FlatBufferBuilder &_fbb, const WhereT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ZerosLikeT : public flatbuffers::NativeTable {
  typedef ZerosLike TableType;
};

struct ZerosLike FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ZerosLikeT NativeTableType;
  typedef ZerosLikeBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return ZerosLikeTypeTable();
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  ZerosLikeT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ZerosLikeT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<ZerosLike> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ZerosLikeT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ZerosLikeBuilder {
  typedef ZerosLike Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit ZerosLikeBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<ZerosLike> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ZerosLike>(end);
    return o;
  }
};

inline flatbuffers::Offset<ZerosLike> CreateZerosLike(
    flatbuffers::FlatBufferBuilder &_fbb) {
  ZerosLikeBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<ZerosLike> CreateZerosLike(flatbuffers::FlatBufferBuilder &_fbb, const ZerosLikeT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct SelectT : public flatbuffers::NativeTable {
  typedef Select TableType;
};

struct Select FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef SelectT NativeTableType;
  typedef SelectBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return SelectTypeTable();
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  SelectT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(SelectT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Select> Pack(flatbuffers::FlatBufferBuilder &_fbb, const SelectT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct SelectBuilder {
  typedef Select Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit SelectBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Select> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Select>(end);
    return o;
  }
};

inline flatbuffers::Offset<Select> CreateSelect(
    flatbuffers::FlatBufferBuilder &_fbb) {
  SelectBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<Select> CreateSelect(flatbuffers::FlatBufferBuilder &_fbb, const SelectT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct GRUT : public flatbuffers::NativeTable {
  typedef GRU TableType;
  bool bidirectional = false;
};

struct GRU FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef GRUT NativeTableType;
  typedef GRUBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return GRUTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_BIDIRECTIONAL = 4
  };
  bool bidirectional() const {
    return GetField<uint8_t>(VT_BIDIRECTIONAL, 0) != 0;
  }
  bool mutate_bidirectional(bool _bidirectional) {
    return SetField<uint8_t>(VT_BIDIRECTIONAL, static_cast<uint8_t>(_bidirectional), 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_BIDIRECTIONAL) &&
           verifier.EndTable();
  }
  GRUT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(GRUT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<GRU> Pack(flatbuffers::FlatBufferBuilder &_fbb, const GRUT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct GRUBuilder {
  typedef GRU Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_bidirectional(bool bidirectional) {
    fbb_.AddElement<uint8_t>(GRU::VT_BIDIRECTIONAL, static_cast<uint8_t>(bidirectional), 0);
  }
  explicit GRUBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<GRU> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<GRU>(end);
    return o;
  }
};

inline flatbuffers::Offset<GRU> CreateGRU(
    flatbuffers::FlatBufferBuilder &_fbb,
    bool bidirectional = false) {
  GRUBuilder builder_(_fbb);
  builder_.add_bidirectional(bidirectional);
  return builder_.Finish();
}

flatbuffers::Offset<GRU> CreateGRU(flatbuffers::FlatBufferBuilder &_fbb, const GRUT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct NonZeroT : public flatbuffers::NativeTable {
  typedef NonZero TableType;
};

struct NonZero FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef NonZeroT NativeTableType;
  typedef NonZeroBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return NonZeroTypeTable();
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  NonZeroT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(NonZeroT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<NonZero> Pack(flatbuffers::FlatBufferBuilder &_fbb, const NonZeroT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct NonZeroBuilder {
  typedef NonZero Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit NonZeroBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<NonZero> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<NonZero>(end);
    return o;
  }
};

inline flatbuffers::Offset<NonZero> CreateNonZero(
    flatbuffers::FlatBufferBuilder &_fbb) {
  NonZeroBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<NonZero> CreateNonZero(flatbuffers::FlatBufferBuilder &_fbb, const NonZeroT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct InvertPermutationT : public flatbuffers::NativeTable {
  typedef InvertPermutation TableType;
};

struct InvertPermutation FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef InvertPermutationT NativeTableType;
  typedef InvertPermutationBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return InvertPermutationTypeTable();
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  InvertPermutationT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(InvertPermutationT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<InvertPermutation> Pack(flatbuffers::FlatBufferBuilder &_fbb, const InvertPermutationT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct InvertPermutationBuilder {
  typedef InvertPermutation Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit InvertPermutationBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<InvertPermutation> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<InvertPermutation>(end);
    return o;
  }
};

inline flatbuffers::Offset<InvertPermutation> CreateInvertPermutation(
    flatbuffers::FlatBufferBuilder &_fbb) {
  InvertPermutationBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<InvertPermutation> CreateInvertPermutation(flatbuffers::FlatBufferBuilder &_fbb, const InvertPermutationT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct SizeT : public flatbuffers::NativeTable {
  typedef Size TableType;
};

struct Size FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef SizeT NativeTableType;
  typedef SizeBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return SizeTypeTable();
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  SizeT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(SizeT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Size> Pack(flatbuffers::FlatBufferBuilder &_fbb, const SizeT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct SizeBuilder {
  typedef Size Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit SizeBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Size> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Size>(end);
    return o;
  }
};

inline flatbuffers::Offset<Size> CreateSize(
    flatbuffers::FlatBufferBuilder &_fbb) {
  SizeBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<Size> CreateSize(flatbuffers::FlatBufferBuilder &_fbb, const SizeT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct RandomStandardNormalT : public flatbuffers::NativeTable {
  typedef RandomStandardNormal TableType;
  int64_t seed = 0;
  int64_t seed2 = 0;
};

struct RandomStandardNormal FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef RandomStandardNormalT NativeTableType;
  typedef RandomStandardNormalBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return RandomStandardNormalTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SEED = 4,
    VT_SEED2 = 6
  };
  int64_t seed() const {
    return GetField<int64_t>(VT_SEED, 0);
  }
  bool mutate_seed(int64_t _seed) {
    return SetField<int64_t>(VT_SEED, _seed, 0);
  }
  int64_t seed2() const {
    return GetField<int64_t>(VT_SEED2, 0);
  }
  bool mutate_seed2(int64_t _seed2) {
    return SetField<int64_t>(VT_SEED2, _seed2, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_SEED) &&
           VerifyField<int64_t>(verifier, VT_SEED2) &&
           verifier.EndTable();
  }
  RandomStandardNormalT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(RandomStandardNormalT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<RandomStandardNormal> Pack(flatbuffers::FlatBufferBuilder &_fbb, const RandomStandardNormalT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct RandomStandardNormalBuilder {
  typedef RandomStandardNormal Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_seed(int64_t seed) {
    fbb_.AddElement<int64_t>(RandomStandardNormal::VT_SEED, seed, 0);
  }
  void add_seed2(int64_t seed2) {
    fbb_.AddElement<int64_t>(RandomStandardNormal::VT_SEED2, seed2, 0);
  }
  explicit RandomStandardNormalBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<RandomStandardNormal> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<RandomStandardNormal>(end);
    return o;
  }
};

inline flatbuffers::Offset<RandomStandardNormal> CreateRandomStandardNormal(
    flatbuffers::FlatBufferBuilder &_fbb,
    int64_t seed = 0,
    int64_t seed2 = 0) {
  RandomStandardNormalBuilder builder_(_fbb);
  builder_.add_seed2(seed2);
  builder_.add_seed(seed);
  return builder_.Finish();
}

flatbuffers::Offset<RandomStandardNormal> CreateRandomStandardNormal(flatbuffers::FlatBufferBuilder &_fbb, const RandomStandardNormalT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct CropAndResizeT : public flatbuffers::NativeTable {
  typedef CropAndResize TableType;
  mindspore::schema::ResizeMethod method = mindspore::schema::ResizeMethod_LINEAR;
  float extrapolation_value = 0.0f;
};

struct CropAndResize FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef CropAndResizeT NativeTableType;
  typedef CropAndResizeBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return CropAndResizeTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_METHOD = 4,
    VT_EXTRAPOLATION_VALUE = 6
  };
  mindspore::schema::ResizeMethod method() const {
    return static_cast<mindspore::schema::ResizeMethod>(GetField<int8_t>(VT_METHOD, 0));
  }
  bool mutate_method(mindspore::schema::ResizeMethod _method) {
    return SetField<int8_t>(VT_METHOD, static_cast<int8_t>(_method), 0);
  }
  float extrapolation_value() const {
    return GetField<float>(VT_EXTRAPOLATION_VALUE, 0.0f);
  }
  bool mutate_extrapolation_value(float _extrapolation_value) {
    return SetField<float>(VT_EXTRAPOLATION_VALUE, _extrapolation_value, 0.0f);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_METHOD) &&
           VerifyField<float>(verifier, VT_EXTRAPOLATION_VALUE) &&
           verifier.EndTable();
  }
  CropAndResizeT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(CropAndResizeT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<CropAndResize> Pack(flatbuffers::FlatBufferBuilder &_fbb, const CropAndResizeT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct CropAndResizeBuilder {
  typedef CropAndResize Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_method(mindspore::schema::ResizeMethod method) {
    fbb_.AddElement<int8_t>(CropAndResize::VT_METHOD, static_cast<int8_t>(method), 0);
  }
  void add_extrapolation_value(float extrapolation_value) {
    fbb_.AddElement<float>(CropAndResize::VT_EXTRAPOLATION_VALUE, extrapolation_value, 0.0f);
  }
  explicit CropAndResizeBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<CropAndResize> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<CropAndResize>(end);
    return o;
  }
};

inline flatbuffers::Offset<CropAndResize> CreateCropAndResize(
    flatbuffers::FlatBufferBuilder &_fbb,
    mindspore::schema::ResizeMethod method = mindspore::schema::ResizeMethod_LINEAR,
    float extrapolation_value = 0.0f) {
  CropAndResizeBuilder builder_(_fbb);
  builder_.add_extrapolation_value(extrapolation_value);
  builder_.add_method(method);
  return builder_.Finish();
}

flatbuffers::Offset<CropAndResize> CreateCropAndResize(flatbuffers::FlatBufferBuilder &_fbb, const CropAndResizeT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ErfT : public flatbuffers::NativeTable {
  typedef Erf TableType;
};

struct Erf FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ErfT NativeTableType;
  typedef ErfBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return ErfTypeTable();
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  ErfT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ErfT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Erf> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ErfT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ErfBuilder {
  typedef Erf Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit ErfBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Erf> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Erf>(end);
    return o;
  }
};

inline flatbuffers::Offset<Erf> CreateErf(
    flatbuffers::FlatBufferBuilder &_fbb) {
  ErfBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<Erf> CreateErf(flatbuffers::FlatBufferBuilder &_fbb, const ErfT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct StridedSliceGradT : public flatbuffers::NativeTable {
  typedef StridedSliceGrad TableType;
  int64_t begin_mask = 0;
  int64_t end_mask = 0;
  int64_t ellipsis_mask = 0;
  int64_t new_axis_mask = 0;
  int64_t shrink_axis_mask = 0;
};

struct StridedSliceGrad FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef StridedSliceGradT NativeTableType;
  typedef StridedSliceGradBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return StridedSliceGradTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_BEGIN_MASK = 4,
    VT_END_MASK = 6,
    VT_ELLIPSIS_MASK = 8,
    VT_NEW_AXIS_MASK = 10,
    VT_SHRINK_AXIS_MASK = 12
  };
  int64_t begin_mask() const {
    return GetField<int64_t>(VT_BEGIN_MASK, 0);
  }
  bool mutate_begin_mask(int64_t _begin_mask) {
    return SetField<int64_t>(VT_BEGIN_MASK, _begin_mask, 0);
  }
  int64_t end_mask() const {
    return GetField<int64_t>(VT_END_MASK, 0);
  }
  bool mutate_end_mask(int64_t _end_mask) {
    return SetField<int64_t>(VT_END_MASK, _end_mask, 0);
  }
  int64_t ellipsis_mask() const {
    return GetField<int64_t>(VT_ELLIPSIS_MASK, 0);
  }
  bool mutate_ellipsis_mask(int64_t _ellipsis_mask) {
    return SetField<int64_t>(VT_ELLIPSIS_MASK, _ellipsis_mask, 0);
  }
  int64_t new_axis_mask() const {
    return GetField<int64_t>(VT_NEW_AXIS_MASK, 0);
  }
  bool mutate_new_axis_mask(int64_t _new_axis_mask) {
    return SetField<int64_t>(VT_NEW_AXIS_MASK, _new_axis_mask, 0);
  }
  int64_t shrink_axis_mask() const {
    return GetField<int64_t>(VT_SHRINK_AXIS_MASK, 0);
  }
  bool mutate_shrink_axis_mask(int64_t _shrink_axis_mask) {
    return SetField<int64_t>(VT_SHRINK_AXIS_MASK, _shrink_axis_mask, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_BEGIN_MASK) &&
           VerifyField<int64_t>(verifier, VT_END_MASK) &&
           VerifyField<int64_t>(verifier, VT_ELLIPSIS_MASK) &&
           VerifyField<int64_t>(verifier, VT_NEW_AXIS_MASK) &&
           VerifyField<int64_t>(verifier, VT_SHRINK_AXIS_MASK) &&
           verifier.EndTable();
  }
  StridedSliceGradT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(StridedSliceGradT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<StridedSliceGrad> Pack(flatbuffers::FlatBufferBuilder &_fbb, const StridedSliceGradT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct StridedSliceGradBuilder {
  typedef StridedSliceGrad Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_begin_mask(int64_t begin_mask) {
    fbb_.AddElement<int64_t>(StridedSliceGrad::VT_BEGIN_MASK, begin_mask, 0);
  }
  void add_end_mask(int64_t end_mask) {
    fbb_.AddElement<int64_t>(StridedSliceGrad::VT_END_MASK, end_mask, 0);
  }
  void add_ellipsis_mask(int64_t ellipsis_mask) {
    fbb_.AddElement<int64_t>(StridedSliceGrad::VT_ELLIPSIS_MASK, ellipsis_mask, 0);
  }
  void add_new_axis_mask(int64_t new_axis_mask) {
    fbb_.AddElement<int64_t>(StridedSliceGrad::VT_NEW_AXIS_MASK, new_axis_mask, 0);
  }
  void add_shrink_axis_mask(int64_t shrink_axis_mask) {
    fbb_.AddElement<int64_t>(StridedSliceGrad::VT_SHRINK_AXIS_MASK, shrink_axis_mask, 0);
  }
  explicit StridedSliceGradBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<StridedSliceGrad> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<StridedSliceGrad>(end);
    return o;
  }
};

inline flatbuffers::Offset<StridedSliceGrad> CreateStridedSliceGrad(
    flatbuffers::FlatBufferBuilder &_fbb,
    int64_t begin_mask = 0,
    int64_t end_mask = 0,
    int64_t ellipsis_mask = 0,
    int64_t new_axis_mask = 0,
    int64_t shrink_axis_mask = 0) {
  StridedSliceGradBuilder builder_(_fbb);
  builder_.add_shrink_axis_mask(shrink_axis_mask);
  builder_.add_new_axis_mask(new_axis_mask);
  builder_.add_ellipsis_mask(ellipsis_mask);
  builder_.add_end_mask(end_mask);
  builder_.add_begin_mask(begin_mask);
  return builder_.Finish();
}

flatbuffers::Offset<StridedSliceGrad> CreateStridedSliceGrad(flatbuffers::FlatBufferBuilder &_fbb, const StridedSliceGradT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct IsFiniteT : public flatbuffers::NativeTable {
  typedef IsFinite TableType;
};

struct IsFinite FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef IsFiniteT NativeTableType;
  typedef IsFiniteBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return IsFiniteTypeTable();
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  IsFiniteT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(IsFiniteT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<IsFinite> Pack(flatbuffers::FlatBufferBuilder &_fbb, const IsFiniteT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct IsFiniteBuilder {
  typedef IsFinite Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit IsFiniteBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<IsFinite> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<IsFinite>(end);
    return o;
  }
};

inline flatbuffers::Offset<IsFinite> CreateIsFinite(
    flatbuffers::FlatBufferBuilder &_fbb) {
  IsFiniteBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<IsFinite> CreateIsFinite(flatbuffers::FlatBufferBuilder &_fbb, const IsFiniteT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct LinSpaceT : public flatbuffers::NativeTable {
  typedef LinSpace TableType;
};

struct LinSpace FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef LinSpaceT NativeTableType;
  typedef LinSpaceBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return LinSpaceTypeTable();
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  LinSpaceT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(LinSpaceT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<LinSpace> Pack(flatbuffers::FlatBufferBuilder &_fbb, const LinSpaceT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct LinSpaceBuilder {
  typedef LinSpace Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit LinSpaceBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<LinSpace> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<LinSpace>(end);
    return o;
  }
};

inline flatbuffers::Offset<LinSpace> CreateLinSpace(
    flatbuffers::FlatBufferBuilder &_fbb) {
  LinSpaceBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<LinSpace> CreateLinSpace(flatbuffers::FlatBufferBuilder &_fbb, const LinSpaceT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct UniformRealT : public flatbuffers::NativeTable {
  typedef UniformReal TableType;
  int64_t seed = 0;
  int64_t seed2 = 0;
};

struct UniformReal FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef UniformRealT NativeTableType;
  typedef UniformRealBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return UniformRealTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SEED = 4,
    VT_SEED2 = 6
  };
  int64_t seed() const {
    return GetField<int64_t>(VT_SEED, 0);
  }
  bool mutate_seed(int64_t _seed) {
    return SetField<int64_t>(VT_SEED, _seed, 0);
  }
  int64_t seed2() const {
    return GetField<int64_t>(VT_SEED2, 0);
  }
  bool mutate_seed2(int64_t _seed2) {
    return SetField<int64_t>(VT_SEED2, _seed2, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_SEED) &&
           VerifyField<int64_t>(verifier, VT_SEED2) &&
           verifier.EndTable();
  }
  UniformRealT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(UniformRealT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<UniformReal> Pack(flatbuffers::FlatBufferBuilder &_fbb, const UniformRealT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct UniformRealBuilder {
  typedef UniformReal Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_seed(int64_t seed) {
    fbb_.AddElement<int64_t>(UniformReal::VT_SEED, seed, 0);
  }
  void add_seed2(int64_t seed2) {
    fbb_.AddElement<int64_t>(UniformReal::VT_SEED2, seed2, 0);
  }
  explicit UniformRealBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<UniformReal> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<UniformReal>(end);
    return o;
  }
};

inline flatbuffers::Offset<UniformReal> CreateUniformReal(
    flatbuffers::FlatBufferBuilder &_fbb,
    int64_t seed = 0,
    int64_t seed2 = 0) {
  UniformRealBuilder builder_(_fbb);
  builder_.add_seed2(seed2);
  builder_.add_seed(seed);
  return builder_.Finish();
}

flatbuffers::Offset<UniformReal> CreateUniformReal(flatbuffers::FlatBufferBuilder &_fbb, const UniformRealT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct AbsGradT : public flatbuffers::NativeTable {
  typedef AbsGrad TableType;
};

struct AbsGrad FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef AbsGradT NativeTableType;
  typedef AbsGradBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return AbsGradTypeTable();
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  AbsGradT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(AbsGradT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<AbsGrad> Pack(flatbuffers::FlatBufferBuilder &_fbb, const AbsGradT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct AbsGradBuilder {
  typedef AbsGrad Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit AbsGradBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<AbsGrad> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<AbsGrad>(end);
    return o;
  }
};

inline flatbuffers::Offset<AbsGrad> CreateAbsGrad(
    flatbuffers::FlatBufferBuilder &_fbb) {
  AbsGradBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<AbsGrad> CreateAbsGrad(flatbuffers::FlatBufferBuilder &_fbb, const AbsGradT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct RsqrtGradT : public flatbuffers::NativeTable {
  typedef RsqrtGrad TableType;
};

struct RsqrtGrad FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef RsqrtGradT NativeTableType;
  typedef RsqrtGradBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return RsqrtGradTypeTable();
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  RsqrtGradT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(RsqrtGradT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<RsqrtGrad> Pack(flatbuffers::FlatBufferBuilder &_fbb, const RsqrtGradT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct RsqrtGradBuilder {
  typedef RsqrtGrad Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit RsqrtGradBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<RsqrtGrad> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<RsqrtGrad>(end);
    return o;
  }
};

inline flatbuffers::Offset<RsqrtGrad> CreateRsqrtGrad(
    flatbuffers::FlatBufferBuilder &_fbb) {
  RsqrtGradBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<RsqrtGrad> CreateRsqrtGrad(flatbuffers::FlatBufferBuilder &_fbb, const RsqrtGradT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct SqrtGradT : public flatbuffers::NativeTable {
  typedef SqrtGrad TableType;
};

struct SqrtGrad FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef SqrtGradT NativeTableType;
  typedef SqrtGradBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return SqrtGradTypeTable();
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  SqrtGradT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(SqrtGradT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<SqrtGrad> Pack(flatbuffers::FlatBufferBuilder &_fbb, const SqrtGradT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct SqrtGradBuilder {
  typedef SqrtGrad Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit SqrtGradBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<SqrtGrad> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SqrtGrad>(end);
    return o;
  }
};

inline flatbuffers::Offset<SqrtGrad> CreateSqrtGrad(
    flatbuffers::FlatBufferBuilder &_fbb) {
  SqrtGradBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<SqrtGrad> CreateSqrtGrad(flatbuffers::FlatBufferBuilder &_fbb, const SqrtGradT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct LayerNormGradT : public flatbuffers::NativeTable {
  typedef LayerNormGrad TableType;
  int64_t begin_norm_axis = 0;
  int64_t begin_params_axis = 0;
};

struct LayerNormGrad FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef LayerNormGradT NativeTableType;
  typedef LayerNormGradBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return LayerNormGradTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_BEGIN_NORM_AXIS = 4,
    VT_BEGIN_PARAMS_AXIS = 6
  };
  int64_t begin_norm_axis() const {
    return GetField<int64_t>(VT_BEGIN_NORM_AXIS, 0);
  }
  bool mutate_begin_norm_axis(int64_t _begin_norm_axis) {
    return SetField<int64_t>(VT_BEGIN_NORM_AXIS, _begin_norm_axis, 0);
  }
  int64_t begin_params_axis() const {
    return GetField<int64_t>(VT_BEGIN_PARAMS_AXIS, 0);
  }
  bool mutate_begin_params_axis(int64_t _begin_params_axis) {
    return SetField<int64_t>(VT_BEGIN_PARAMS_AXIS, _begin_params_axis, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_BEGIN_NORM_AXIS) &&
           VerifyField<int64_t>(verifier, VT_BEGIN_PARAMS_AXIS) &&
           verifier.EndTable();
  }
  LayerNormGradT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(LayerNormGradT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<LayerNormGrad> Pack(flatbuffers::FlatBufferBuilder &_fbb, const LayerNormGradT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct LayerNormGradBuilder {
  typedef LayerNormGrad Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_begin_norm_axis(int64_t begin_norm_axis) {
    fbb_.AddElement<int64_t>(LayerNormGrad::VT_BEGIN_NORM_AXIS, begin_norm_axis, 0);
  }
  void add_begin_params_axis(int64_t begin_params_axis) {
    fbb_.AddElement<int64_t>(LayerNormGrad::VT_BEGIN_PARAMS_AXIS, begin_params_axis, 0);
  }
  explicit LayerNormGradBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<LayerNormGrad> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<LayerNormGrad>(end);
    return o;
  }
};

inline flatbuffers::Offset<LayerNormGrad> CreateLayerNormGrad(
    flatbuffers::FlatBufferBuilder &_fbb,
    int64_t begin_norm_axis = 0,
    int64_t begin_params_axis = 0) {
  LayerNormGradBuilder builder_(_fbb);
  builder_.add_begin_params_axis(begin_params_axis);
  builder_.add_begin_norm_axis(begin_norm_axis);
  return builder_.Finish();
}

flatbuffers::Offset<LayerNormGrad> CreateLayerNormGrad(flatbuffers::FlatBufferBuilder &_fbb, const LayerNormGradT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ResizeGradT : public flatbuffers::NativeTable {
  typedef ResizeGrad TableType;
  mindspore::schema::ResizeMethod method = mindspore::schema::ResizeMethod_LINEAR;
  bool align_corners = false;
};

struct ResizeGrad FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ResizeGradT NativeTableType;
  typedef ResizeGradBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return ResizeGradTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_METHOD = 4,
    VT_ALIGN_CORNERS = 6
  };
  mindspore::schema::ResizeMethod method() const {
    return static_cast<mindspore::schema::ResizeMethod>(GetField<int8_t>(VT_METHOD, 0));
  }
  bool mutate_method(mindspore::schema::ResizeMethod _method) {
    return SetField<int8_t>(VT_METHOD, static_cast<int8_t>(_method), 0);
  }
  bool align_corners() const {
    return GetField<uint8_t>(VT_ALIGN_CORNERS, 0) != 0;
  }
  bool mutate_align_corners(bool _align_corners) {
    return SetField<uint8_t>(VT_ALIGN_CORNERS, static_cast<uint8_t>(_align_corners), 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_METHOD) &&
           VerifyField<uint8_t>(verifier, VT_ALIGN_CORNERS) &&
           verifier.EndTable();
  }
  ResizeGradT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ResizeGradT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<ResizeGrad> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ResizeGradT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ResizeGradBuilder {
  typedef ResizeGrad Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_method(mindspore::schema::ResizeMethod method) {
    fbb_.AddElement<int8_t>(ResizeGrad::VT_METHOD, static_cast<int8_t>(method), 0);
  }
  void add_align_corners(bool align_corners) {
    fbb_.AddElement<uint8_t>(ResizeGrad::VT_ALIGN_CORNERS, static_cast<uint8_t>(align_corners), 0);
  }
  explicit ResizeGradBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<ResizeGrad> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ResizeGrad>(end);
    return o;
  }
};

inline flatbuffers::Offset<ResizeGrad> CreateResizeGrad(
    flatbuffers::FlatBufferBuilder &_fbb,
    mindspore::schema::ResizeMethod method = mindspore::schema::ResizeMethod_LINEAR,
    bool align_corners = false) {
  ResizeGradBuilder builder_(_fbb);
  builder_.add_align_corners(align_corners);
  builder_.add_method(method);
  return builder_.Finish();
}

flatbuffers::Offset<ResizeGrad> CreateResizeGrad(flatbuffers::FlatBufferBuilder &_fbb, const ResizeGradT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct SpliceT : public flatbuffers::NativeTable {
  typedef Splice TableType;
  std::vector<int64_t> context{};
  std::vector<int64_t> forward_indexes{};
  int64_t output_dim = 0;
};

struct Splice FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef SpliceT NativeTableType;
  typedef SpliceBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return SpliceTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_CONTEXT = 4,
    VT_FORWARD_INDEXES = 6,
    VT_OUTPUT_DIM = 8
  };
  const flatbuffers::Vector<int64_t> *context() const {
    return GetPointer<const flatbuffers::Vector<int64_t> *>(VT_CONTEXT);
  }
  flatbuffers::Vector<int64_t> *mutable_context() {
    return GetPointer<flatbuffers::Vector<int64_t> *>(VT_CONTEXT);
  }
  const flatbuffers::Vector<int64_t> *forward_indexes() const {
    return GetPointer<const flatbuffers::Vector<int64_t> *>(VT_FORWARD_INDEXES);
  }
  flatbuffers::Vector<int64_t> *mutable_forward_indexes() {
    return GetPointer<flatbuffers::Vector<int64_t> *>(VT_FORWARD_INDEXES);
  }
  int64_t output_dim() const {
    return GetField<int64_t>(VT_OUTPUT_DIM, 0);
  }
  bool mutate_output_dim(int64_t _output_dim) {
    return SetField<int64_t>(VT_OUTPUT_DIM, _output_dim, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_CONTEXT) &&
           verifier.VerifyVector(context()) &&
           VerifyOffset(verifier, VT_FORWARD_INDEXES) &&
           verifier.VerifyVector(forward_indexes()) &&
           VerifyField<int64_t>(verifier, VT_OUTPUT_DIM) &&
           verifier.EndTable();
  }
  SpliceT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(SpliceT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Splice> Pack(flatbuffers::FlatBufferBuilder &_fbb, const SpliceT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct SpliceBuilder {
  typedef Splice Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_context(flatbuffers::Offset<flatbuffers::Vector<int64_t>> context) {
    fbb_.AddOffset(Splice::VT_CONTEXT, context);
  }
  void add_forward_indexes(flatbuffers::Offset<flatbuffers::Vector<int64_t>> forward_indexes) {
    fbb_.AddOffset(Splice::VT_FORWARD_INDEXES, forward_indexes);
  }
  void add_output_dim(int64_t output_dim) {
    fbb_.AddElement<int64_t>(Splice::VT_OUTPUT_DIM, output_dim, 0);
  }
  explicit SpliceBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Splice> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Splice>(end);
    return o;
  }
};

inline flatbuffers::Offset<Splice> CreateSplice(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<int64_t>> context = 0,
    flatbuffers::Offset<flatbuffers::Vector<int64_t>> forward_indexes = 0,
    int64_t output_dim = 0) {
  SpliceBuilder builder_(_fbb);
  builder_.add_output_dim(output_dim);
  builder_.add_forward_indexes(forward_indexes);
  builder_.add_context(context);
  return builder_.Finish();
}

inline flatbuffers::Offset<Splice> CreateSpliceDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<int64_t> *context = nullptr,
    const std::vector<int64_t> *forward_indexes = nullptr,
    int64_t output_dim = 0) {
  auto context__ = context ? _fbb.CreateVector<int64_t>(*context) : 0;
  auto forward_indexes__ = forward_indexes ? _fbb.CreateVector<int64_t>(*forward_indexes) : 0;
  return mindspore::schema::CreateSplice(
      _fbb,
      context__,
      forward_indexes__,
      output_dim);
}

flatbuffers::Offset<Splice> CreateSplice(flatbuffers::FlatBufferBuilder &_fbb, const SpliceT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct LogSoftmaxT : public flatbuffers::NativeTable {
  typedef LogSoftmax TableType;
  int64_t axis = 0;
};

struct LogSoftmax FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef LogSoftmaxT NativeTableType;
  typedef LogSoftmaxBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return LogSoftmaxTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_AXIS = 4
  };
  int64_t axis() const {
    return GetField<int64_t>(VT_AXIS, 0);
  }
  bool mutate_axis(int64_t _axis) {
    return SetField<int64_t>(VT_AXIS, _axis, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_AXIS) &&
           verifier.EndTable();
  }
  LogSoftmaxT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(LogSoftmaxT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<LogSoftmax> Pack(flatbuffers::FlatBufferBuilder &_fbb, const LogSoftmaxT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct LogSoftmaxBuilder {
  typedef LogSoftmax Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_axis(int64_t axis) {
    fbb_.AddElement<int64_t>(LogSoftmax::VT_AXIS, axis, 0);
  }
  explicit LogSoftmaxBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<LogSoftmax> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<LogSoftmax>(end);
    return o;
  }
};

inline flatbuffers::Offset<LogSoftmax> CreateLogSoftmax(
    flatbuffers::FlatBufferBuilder &_fbb,
    int64_t axis = 0) {
  LogSoftmaxBuilder builder_(_fbb);
  builder_.add_axis(axis);
  return builder_.Finish();
}

flatbuffers::Offset<LogSoftmax> CreateLogSoftmax(flatbuffers::FlatBufferBuilder &_fbb, const LogSoftmaxT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct CallT : public flatbuffers::NativeTable {
  typedef Call TableType;
};

struct Call FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef CallT NativeTableType;
  typedef CallBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return CallTypeTable();
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  CallT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(CallT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Call> Pack(flatbuffers::FlatBufferBuilder &_fbb, const CallT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct CallBuilder {
  typedef Call Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit CallBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Call> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Call>(end);
    return o;
  }
};

inline flatbuffers::Offset<Call> CreateCall(
    flatbuffers::FlatBufferBuilder &_fbb) {
  CallBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<Call> CreateCall(flatbuffers::FlatBufferBuilder &_fbb, const CallT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct CumSumT : public flatbuffers::NativeTable {
  typedef CumSum TableType;
  bool exclusive = false;
  bool reverse = false;
};

struct CumSum FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef CumSumT NativeTableType;
  typedef CumSumBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return CumSumTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_EXCLUSIVE = 4,
    VT_REVERSE = 6
  };
  bool exclusive() const {
    return GetField<uint8_t>(VT_EXCLUSIVE, 0) != 0;
  }
  bool mutate_exclusive(bool _exclusive) {
    return SetField<uint8_t>(VT_EXCLUSIVE, static_cast<uint8_t>(_exclusive), 0);
  }
  bool reverse() const {
    return GetField<uint8_t>(VT_REVERSE, 0) != 0;
  }
  bool mutate_reverse(bool _reverse) {
    return SetField<uint8_t>(VT_REVERSE, static_cast<uint8_t>(_reverse), 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_EXCLUSIVE) &&
           VerifyField<uint8_t>(verifier, VT_REVERSE) &&
           verifier.EndTable();
  }
  CumSumT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(CumSumT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<CumSum> Pack(flatbuffers::FlatBufferBuilder &_fbb, const CumSumT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct CumSumBuilder {
  typedef CumSum Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_exclusive(bool exclusive) {
    fbb_.AddElement<uint8_t>(CumSum::VT_EXCLUSIVE, static_cast<uint8_t>(exclusive), 0);
  }
  void add_reverse(bool reverse) {
    fbb_.AddElement<uint8_t>(CumSum::VT_REVERSE, static_cast<uint8_t>(reverse), 0);
  }
  explicit CumSumBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<CumSum> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<CumSum>(end);
    return o;
  }
};

inline flatbuffers::Offset<CumSum> CreateCumSum(
    flatbuffers::FlatBufferBuilder &_fbb,
    bool exclusive = false,
    bool reverse = false) {
  CumSumBuilder builder_(_fbb);
  builder_.add_reverse(reverse);
  builder_.add_exclusive(exclusive);
  return builder_.Finish();
}

flatbuffers::Offset<CumSum> CreateCumSum(flatbuffers::FlatBufferBuilder &_fbb, const CumSumT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct CustomT : public flatbuffers::NativeTable {
  typedef Custom TableType;
  std::string type{};
  std::vector<std::unique_ptr<mindspore::schema::AttributeT>> attr{};
};

struct Custom FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef CustomT NativeTableType;
  typedef CustomBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return CustomTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TYPE = 4,
    VT_ATTR = 6
  };
  const flatbuffers::String *type() const {
    return GetPointer<const flatbuffers::String *>(VT_TYPE);
  }
  flatbuffers::String *mutable_type() {
    return GetPointer<flatbuffers::String *>(VT_TYPE);
  }
  const flatbuffers::Vector<flatbuffers::Offset<mindspore::schema::Attribute>> *attr() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<mindspore::schema::Attribute>> *>(VT_ATTR);
  }
  flatbuffers::Vector<flatbuffers::Offset<mindspore::schema::Attribute>> *mutable_attr() {
    return GetPointer<flatbuffers::Vector<flatbuffers::Offset<mindspore::schema::Attribute>> *>(VT_ATTR);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_TYPE) &&
           verifier.VerifyString(type()) &&
           VerifyOffset(verifier, VT_ATTR) &&
           verifier.VerifyVector(attr()) &&
           verifier.VerifyVectorOfTables(attr()) &&
           verifier.EndTable();
  }
  CustomT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(CustomT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Custom> Pack(flatbuffers::FlatBufferBuilder &_fbb, const CustomT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct CustomBuilder {
  typedef Custom Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_type(flatbuffers::Offset<flatbuffers::String> type) {
    fbb_.AddOffset(Custom::VT_TYPE, type);
  }
  void add_attr(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<mindspore::schema::Attribute>>> attr) {
    fbb_.AddOffset(Custom::VT_ATTR, attr);
  }
  explicit CustomBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Custom> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Custom>(end);
    return o;
  }
};

inline flatbuffers::Offset<Custom> CreateCustom(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> type = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<mindspore::schema::Attribute>>> attr = 0) {
  CustomBuilder builder_(_fbb);
  builder_.add_attr(attr);
  builder_.add_type(type);
  return builder_.Finish();
}

inline flatbuffers::Offset<Custom> CreateCustomDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *type = nullptr,
    const std::vector<flatbuffers::Offset<mindspore::schema::Attribute>> *attr = nullptr) {
  auto type__ = type ? _fbb.CreateString(type) : 0;
  auto attr__ = attr ? _fbb.CreateVector<flatbuffers::Offset<mindspore::schema::Attribute>>(*attr) : 0;
  return mindspore::schema::CreateCustom(
      _fbb,
      type__,
      attr__);
}

flatbuffers::Offset<Custom> CreateCustom(flatbuffers::FlatBufferBuilder &_fbb, const CustomT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct SplitWithOverlapT : public flatbuffers::NativeTable {
  typedef SplitWithOverlap TableType;
  int64_t split_dim = 0;
  int64_t number_split = 0;
  std::vector<int64_t> ratio{};
  std::vector<int64_t> extend_top{};
  std::vector<int64_t> extend_bottom{};
};

struct SplitWithOverlap FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef SplitWithOverlapT NativeTableType;
  typedef SplitWithOverlapBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return SplitWithOverlapTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SPLIT_DIM = 4,
    VT_NUMBER_SPLIT = 6,
    VT_RATIO = 8,
    VT_EXTEND_TOP = 10,
    VT_EXTEND_BOTTOM = 12
  };
  int64_t split_dim() const {
    return GetField<int64_t>(VT_SPLIT_DIM, 0);
  }
  bool mutate_split_dim(int64_t _split_dim) {
    return SetField<int64_t>(VT_SPLIT_DIM, _split_dim, 0);
  }
  int64_t number_split() const {
    return GetField<int64_t>(VT_NUMBER_SPLIT, 0);
  }
  bool mutate_number_split(int64_t _number_split) {
    return SetField<int64_t>(VT_NUMBER_SPLIT, _number_split, 0);
  }
  const flatbuffers::Vector<int64_t> *ratio() const {
    return GetPointer<const flatbuffers::Vector<int64_t> *>(VT_RATIO);
  }
  flatbuffers::Vector<int64_t> *mutable_ratio() {
    return GetPointer<flatbuffers::Vector<int64_t> *>(VT_RATIO);
  }
  const flatbuffers::Vector<int64_t> *extend_top() const {
    return GetPointer<const flatbuffers::Vector<int64_t> *>(VT_EXTEND_TOP);
  }
  flatbuffers::Vector<int64_t> *mutable_extend_top() {
    return GetPointer<flatbuffers::Vector<int64_t> *>(VT_EXTEND_TOP);
  }
  const flatbuffers::Vector<int64_t> *extend_bottom() const {
    return GetPointer<const flatbuffers::Vector<int64_t> *>(VT_EXTEND_BOTTOM);
  }
  flatbuffers::Vector<int64_t> *mutable_extend_bottom() {
    return GetPointer<flatbuffers::Vector<int64_t> *>(VT_EXTEND_BOTTOM);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_SPLIT_DIM) &&
           VerifyField<int64_t>(verifier, VT_NUMBER_SPLIT) &&
           VerifyOffset(verifier, VT_RATIO) &&
           verifier.VerifyVector(ratio()) &&
           VerifyOffset(verifier, VT_EXTEND_TOP) &&
           verifier.VerifyVector(extend_top()) &&
           VerifyOffset(verifier, VT_EXTEND_BOTTOM) &&
           verifier.VerifyVector(extend_bottom()) &&
           verifier.EndTable();
  }
  SplitWithOverlapT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(SplitWithOverlapT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<SplitWithOverlap> Pack(flatbuffers::FlatBufferBuilder &_fbb, const SplitWithOverlapT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct SplitWithOverlapBuilder {
  typedef SplitWithOverlap Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_split_dim(int64_t split_dim) {
    fbb_.AddElement<int64_t>(SplitWithOverlap::VT_SPLIT_DIM, split_dim, 0);
  }
  void add_number_split(int64_t number_split) {
    fbb_.AddElement<int64_t>(SplitWithOverlap::VT_NUMBER_SPLIT, number_split, 0);
  }
  void add_ratio(flatbuffers::Offset<flatbuffers::Vector<int64_t>> ratio) {
    fbb_.AddOffset(SplitWithOverlap::VT_RATIO, ratio);
  }
  void add_extend_top(flatbuffers::Offset<flatbuffers::Vector<int64_t>> extend_top) {
    fbb_.AddOffset(SplitWithOverlap::VT_EXTEND_TOP, extend_top);
  }
  void add_extend_bottom(flatbuffers::Offset<flatbuffers::Vector<int64_t>> extend_bottom) {
    fbb_.AddOffset(SplitWithOverlap::VT_EXTEND_BOTTOM, extend_bottom);
  }
  explicit SplitWithOverlapBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<SplitWithOverlap> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SplitWithOverlap>(end);
    return o;
  }
};

inline flatbuffers::Offset<SplitWithOverlap> CreateSplitWithOverlap(
    flatbuffers::FlatBufferBuilder &_fbb,
    int64_t split_dim = 0,
    int64_t number_split = 0,
    flatbuffers::Offset<flatbuffers::Vector<int64_t>> ratio = 0,
    flatbuffers::Offset<flatbuffers::Vector<int64_t>> extend_top = 0,
    flatbuffers::Offset<flatbuffers::Vector<int64_t>> extend_bottom = 0) {
  SplitWithOverlapBuilder builder_(_fbb);
  builder_.add_number_split(number_split);
  builder_.add_split_dim(split_dim);
  builder_.add_extend_bottom(extend_bottom);
  builder_.add_extend_top(extend_top);
  builder_.add_ratio(ratio);
  return builder_.Finish();
}

inline flatbuffers::Offset<SplitWithOverlap> CreateSplitWithOverlapDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int64_t split_dim = 0,
    int64_t number_split = 0,
    const std::vector<int64_t> *ratio = nullptr,
    const std::vector<int64_t> *extend_top = nullptr,
    const std::vector<int64_t> *extend_bottom = nullptr) {
  auto ratio__ = ratio ? _fbb.CreateVector<int64_t>(*ratio) : 0;
  auto extend_top__ = extend_top ? _fbb.CreateVector<int64_t>(*extend_top) : 0;
  auto extend_bottom__ = extend_bottom ? _fbb.CreateVector<int64_t>(*extend_bottom) : 0;
  return mindspore::schema::CreateSplitWithOverlap(
      _fbb,
      split_dim,
      number_split,
      ratio__,
      extend_top__,
      extend_bottom__);
}

flatbuffers::Offset<SplitWithOverlap> CreateSplitWithOverlap(flatbuffers::FlatBufferBuilder &_fbb, const SplitWithOverlapT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct GenOPT : public flatbuffers::NativeTable {
  typedef GenOP TableType;
  mindspore::schema::ActivationType activation_type = mindspore::schema::ActivationType_NO_ACTIVATION;
  float alpha = 0.0f;
  float min_val = 0.0f;
  float max_val = 0.0f;
  bool is_training = false;
  mindspore::schema::Format format = mindspore::schema::Format_NCHW;
  std::vector<int64_t> kernel_size{};
  std::vector<int64_t> stride{};
  std::vector<int64_t> dilation{};
  mindspore::schema::PadMode pad_mode = mindspore::schema::PadMode_PAD;
  std::vector<int64_t> pad_list{};
  int64_t mode = 0;
  int64_t group = 0;
  int64_t in_channel = 0;
  int64_t out_channel = 0;
  mindspore::schema::EltwiseMode eltwise_mode = mindspore::schema::EltwiseMode_PROD;
  bool has_bias = false;
  bool use_axis = false;
  int64_t axis = 0;
  float epsilon = 0.0001f;
  float momentum = 0.9f;
  bool transpose_a = false;
  bool transpose_b = false;
  std::vector<int64_t> pad{};
  mindspore::schema::RoundMode round_mode = mindspore::schema::RoundMode_FLOOR;
  bool global = false;
  bool channel_shared = false;
  std::vector<int64_t> axes{};
  bool keep_dims = false;
  mindspore::schema::ReduceMode reduce_mode = mindspore::schema::ReduceMode_ReduceMean;
  bool reduce_to_end = false;
  float coeff = 0.0f;
};

struct GenOP FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef GenOPT NativeTableType;
  typedef GenOPBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return GenOPTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ACTIVATION_TYPE = 4,
    VT_ALPHA = 6,
    VT_MIN_VAL = 8,
    VT_MAX_VAL = 10,
    VT_IS_TRAINING = 12,
    VT_FORMAT = 14,
    VT_KERNEL_SIZE = 16,
    VT_STRIDE = 18,
    VT_DILATION = 20,
    VT_PAD_MODE = 22,
    VT_PAD_LIST = 24,
    VT_MODE = 26,
    VT_GROUP = 28,
    VT_IN_CHANNEL = 30,
    VT_OUT_CHANNEL = 32,
    VT_ELTWISE_MODE = 34,
    VT_HAS_BIAS = 36,
    VT_USE_AXIS = 38,
    VT_AXIS = 40,
    VT_EPSILON = 42,
    VT_MOMENTUM = 44,
    VT_TRANSPOSE_A = 46,
    VT_TRANSPOSE_B = 48,
    VT_PAD = 50,
    VT_ROUND_MODE = 52,
    VT_GLOBAL = 54,
    VT_CHANNEL_SHARED = 56,
    VT_AXES = 58,
    VT_KEEP_DIMS = 60,
    VT_REDUCE_MODE = 62,
    VT_REDUCE_TO_END = 64,
    VT_COEFF = 66
  };
  mindspore::schema::ActivationType activation_type() const {
    return static_cast<mindspore::schema::ActivationType>(GetField<int8_t>(VT_ACTIVATION_TYPE, 0));
  }
  bool mutate_activation_type(mindspore::schema::ActivationType _activation_type) {
    return SetField<int8_t>(VT_ACTIVATION_TYPE, static_cast<int8_t>(_activation_type), 0);
  }
  float alpha() const {
    return GetField<float>(VT_ALPHA, 0.0f);
  }
  bool mutate_alpha(float _alpha) {
    return SetField<float>(VT_ALPHA, _alpha, 0.0f);
  }
  float min_val() const {
    return GetField<float>(VT_MIN_VAL, 0.0f);
  }
  bool mutate_min_val(float _min_val) {
    return SetField<float>(VT_MIN_VAL, _min_val, 0.0f);
  }
  float max_val() const {
    return GetField<float>(VT_MAX_VAL, 0.0f);
  }
  bool mutate_max_val(float _max_val) {
    return SetField<float>(VT_MAX_VAL, _max_val, 0.0f);
  }
  bool is_training() const {
    return GetField<uint8_t>(VT_IS_TRAINING, 0) != 0;
  }
  bool mutate_is_training(bool _is_training) {
    return SetField<uint8_t>(VT_IS_TRAINING, static_cast<uint8_t>(_is_training), 0);
  }
  mindspore::schema::Format format() const {
    return static_cast<mindspore::schema::Format>(GetField<int32_t>(VT_FORMAT, 0));
  }
  bool mutate_format(mindspore::schema::Format _format) {
    return SetField<int32_t>(VT_FORMAT, static_cast<int32_t>(_format), 0);
  }
  const flatbuffers::Vector<int64_t> *kernel_size() const {
    return GetPointer<const flatbuffers::Vector<int64_t> *>(VT_KERNEL_SIZE);
  }
  flatbuffers::Vector<int64_t> *mutable_kernel_size() {
    return GetPointer<flatbuffers::Vector<int64_t> *>(VT_KERNEL_SIZE);
  }
  const flatbuffers::Vector<int64_t> *stride() const {
    return GetPointer<const flatbuffers::Vector<int64_t> *>(VT_STRIDE);
  }
  flatbuffers::Vector<int64_t> *mutable_stride() {
    return GetPointer<flatbuffers::Vector<int64_t> *>(VT_STRIDE);
  }
  const flatbuffers::Vector<int64_t> *dilation() const {
    return GetPointer<const flatbuffers::Vector<int64_t> *>(VT_DILATION);
  }
  flatbuffers::Vector<int64_t> *mutable_dilation() {
    return GetPointer<flatbuffers::Vector<int64_t> *>(VT_DILATION);
  }
  mindspore::schema::PadMode pad_mode() const {
    return static_cast<mindspore::schema::PadMode>(GetField<int8_t>(VT_PAD_MODE, 0));
  }
  bool mutate_pad_mode(mindspore::schema::PadMode _pad_mode) {
    return SetField<int8_t>(VT_PAD_MODE, static_cast<int8_t>(_pad_mode), 0);
  }
  const flatbuffers::Vector<int64_t> *pad_list() const {
    return GetPointer<const flatbuffers::Vector<int64_t> *>(VT_PAD_LIST);
  }
  flatbuffers::Vector<int64_t> *mutable_pad_list() {
    return GetPointer<flatbuffers::Vector<int64_t> *>(VT_PAD_LIST);
  }
  int64_t mode() const {
    return GetField<int64_t>(VT_MODE, 0);
  }
  bool mutate_mode(int64_t _mode) {
    return SetField<int64_t>(VT_MODE, _mode, 0);
  }
  int64_t group() const {
    return GetField<int64_t>(VT_GROUP, 0);
  }
  bool mutate_group(int64_t _group) {
    return SetField<int64_t>(VT_GROUP, _group, 0);
  }
  int64_t in_channel() const {
    return GetField<int64_t>(VT_IN_CHANNEL, 0);
  }
  bool mutate_in_channel(int64_t _in_channel) {
    return SetField<int64_t>(VT_IN_CHANNEL, _in_channel, 0);
  }
  int64_t out_channel() const {
    return GetField<int64_t>(VT_OUT_CHANNEL, 0);
  }
  bool mutate_out_channel(int64_t _out_channel) {
    return SetField<int64_t>(VT_OUT_CHANNEL, _out_channel, 0);
  }
  mindspore::schema::EltwiseMode eltwise_mode() const {
    return static_cast<mindspore::schema::EltwiseMode>(GetField<int8_t>(VT_ELTWISE_MODE, 0));
  }
  bool mutate_eltwise_mode(mindspore::schema::EltwiseMode _eltwise_mode) {
    return SetField<int8_t>(VT_ELTWISE_MODE, static_cast<int8_t>(_eltwise_mode), 0);
  }
  bool has_bias() const {
    return GetField<uint8_t>(VT_HAS_BIAS, 0) != 0;
  }
  bool mutate_has_bias(bool _has_bias) {
    return SetField<uint8_t>(VT_HAS_BIAS, static_cast<uint8_t>(_has_bias), 0);
  }
  bool use_axis() const {
    return GetField<uint8_t>(VT_USE_AXIS, 0) != 0;
  }
  bool mutate_use_axis(bool _use_axis) {
    return SetField<uint8_t>(VT_USE_AXIS, static_cast<uint8_t>(_use_axis), 0);
  }
  int64_t axis() const {
    return GetField<int64_t>(VT_AXIS, 0);
  }
  bool mutate_axis(int64_t _axis) {
    return SetField<int64_t>(VT_AXIS, _axis, 0);
  }
  float epsilon() const {
    return GetField<float>(VT_EPSILON, 0.0001f);
  }
  bool mutate_epsilon(float _epsilon) {
    return SetField<float>(VT_EPSILON, _epsilon, 0.0001f);
  }
  float momentum() const {
    return GetField<float>(VT_MOMENTUM, 0.9f);
  }
  bool mutate_momentum(float _momentum) {
    return SetField<float>(VT_MOMENTUM, _momentum, 0.9f);
  }
  bool transpose_a() const {
    return GetField<uint8_t>(VT_TRANSPOSE_A, 0) != 0;
  }
  bool mutate_transpose_a(bool _transpose_a) {
    return SetField<uint8_t>(VT_TRANSPOSE_A, static_cast<uint8_t>(_transpose_a), 0);
  }
  bool transpose_b() const {
    return GetField<uint8_t>(VT_TRANSPOSE_B, 0) != 0;
  }
  bool mutate_transpose_b(bool _transpose_b) {
    return SetField<uint8_t>(VT_TRANSPOSE_B, static_cast<uint8_t>(_transpose_b), 0);
  }
  const flatbuffers::Vector<int64_t> *pad() const {
    return GetPointer<const flatbuffers::Vector<int64_t> *>(VT_PAD);
  }
  flatbuffers::Vector<int64_t> *mutable_pad() {
    return GetPointer<flatbuffers::Vector<int64_t> *>(VT_PAD);
  }
  mindspore::schema::RoundMode round_mode() const {
    return static_cast<mindspore::schema::RoundMode>(GetField<int8_t>(VT_ROUND_MODE, 0));
  }
  bool mutate_round_mode(mindspore::schema::RoundMode _round_mode) {
    return SetField<int8_t>(VT_ROUND_MODE, static_cast<int8_t>(_round_mode), 0);
  }
  bool global() const {
    return GetField<uint8_t>(VT_GLOBAL, 0) != 0;
  }
  bool mutate_global(bool _global) {
    return SetField<uint8_t>(VT_GLOBAL, static_cast<uint8_t>(_global), 0);
  }
  bool channel_shared() const {
    return GetField<uint8_t>(VT_CHANNEL_SHARED, 0) != 0;
  }
  bool mutate_channel_shared(bool _channel_shared) {
    return SetField<uint8_t>(VT_CHANNEL_SHARED, static_cast<uint8_t>(_channel_shared), 0);
  }
  const flatbuffers::Vector<int64_t> *axes() const {
    return GetPointer<const flatbuffers::Vector<int64_t> *>(VT_AXES);
  }
  flatbuffers::Vector<int64_t> *mutable_axes() {
    return GetPointer<flatbuffers::Vector<int64_t> *>(VT_AXES);
  }
  bool keep_dims() const {
    return GetField<uint8_t>(VT_KEEP_DIMS, 0) != 0;
  }
  bool mutate_keep_dims(bool _keep_dims) {
    return SetField<uint8_t>(VT_KEEP_DIMS, static_cast<uint8_t>(_keep_dims), 0);
  }
  mindspore::schema::ReduceMode reduce_mode() const {
    return static_cast<mindspore::schema::ReduceMode>(GetField<int8_t>(VT_REDUCE_MODE, 0));
  }
  bool mutate_reduce_mode(mindspore::schema::ReduceMode _reduce_mode) {
    return SetField<int8_t>(VT_REDUCE_MODE, static_cast<int8_t>(_reduce_mode), 0);
  }
  bool reduce_to_end() const {
    return GetField<uint8_t>(VT_REDUCE_TO_END, 0) != 0;
  }
  bool mutate_reduce_to_end(bool _reduce_to_end) {
    return SetField<uint8_t>(VT_REDUCE_TO_END, static_cast<uint8_t>(_reduce_to_end), 0);
  }
  float coeff() const {
    return GetField<float>(VT_COEFF, 0.0f);
  }
  bool mutate_coeff(float _coeff) {
    return SetField<float>(VT_COEFF, _coeff, 0.0f);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_ACTIVATION_TYPE) &&
           VerifyField<float>(verifier, VT_ALPHA) &&
           VerifyField<float>(verifier, VT_MIN_VAL) &&
           VerifyField<float>(verifier, VT_MAX_VAL) &&
           VerifyField<uint8_t>(verifier, VT_IS_TRAINING) &&
           VerifyField<int32_t>(verifier, VT_FORMAT) &&
           VerifyOffset(verifier, VT_KERNEL_SIZE) &&
           verifier.VerifyVector(kernel_size()) &&
           VerifyOffset(verifier, VT_STRIDE) &&
           verifier.VerifyVector(stride()) &&
           VerifyOffset(verifier, VT_DILATION) &&
           verifier.VerifyVector(dilation()) &&
           VerifyField<int8_t>(verifier, VT_PAD_MODE) &&
           VerifyOffset(verifier, VT_PAD_LIST) &&
           verifier.VerifyVector(pad_list()) &&
           VerifyField<int64_t>(verifier, VT_MODE) &&
           VerifyField<int64_t>(verifier, VT_GROUP) &&
           VerifyField<int64_t>(verifier, VT_IN_CHANNEL) &&
           VerifyField<int64_t>(verifier, VT_OUT_CHANNEL) &&
           VerifyField<int8_t>(verifier, VT_ELTWISE_MODE) &&
           VerifyField<uint8_t>(verifier, VT_HAS_BIAS) &&
           VerifyField<uint8_t>(verifier, VT_USE_AXIS) &&
           VerifyField<int64_t>(verifier, VT_AXIS) &&
           VerifyField<float>(verifier, VT_EPSILON) &&
           VerifyField<float>(verifier, VT_MOMENTUM) &&
           VerifyField<uint8_t>(verifier, VT_TRANSPOSE_A) &&
           VerifyField<uint8_t>(verifier, VT_TRANSPOSE_B) &&
           VerifyOffset(verifier, VT_PAD) &&
           verifier.VerifyVector(pad()) &&
           VerifyField<int8_t>(verifier, VT_ROUND_MODE) &&
           VerifyField<uint8_t>(verifier, VT_GLOBAL) &&
           VerifyField<uint8_t>(verifier, VT_CHANNEL_SHARED) &&
           VerifyOffset(verifier, VT_AXES) &&
           verifier.VerifyVector(axes()) &&
           VerifyField<uint8_t>(verifier, VT_KEEP_DIMS) &&
           VerifyField<int8_t>(verifier, VT_REDUCE_MODE) &&
           VerifyField<uint8_t>(verifier, VT_REDUCE_TO_END) &&
           VerifyField<float>(verifier, VT_COEFF) &&
           verifier.EndTable();
  }
  GenOPT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(GenOPT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<GenOP> Pack(flatbuffers::FlatBufferBuilder &_fbb, const GenOPT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct GenOPBuilder {
  typedef GenOP Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_activation_type(mindspore::schema::ActivationType activation_type) {
    fbb_.AddElement<int8_t>(GenOP::VT_ACTIVATION_TYPE, static_cast<int8_t>(activation_type), 0);
  }
  void add_alpha(float alpha) {
    fbb_.AddElement<float>(GenOP::VT_ALPHA, alpha, 0.0f);
  }
  void add_min_val(float min_val) {
    fbb_.AddElement<float>(GenOP::VT_MIN_VAL, min_val, 0.0f);
  }
  void add_max_val(float max_val) {
    fbb_.AddElement<float>(GenOP::VT_MAX_VAL, max_val, 0.0f);
  }
  void add_is_training(bool is_training) {
    fbb_.AddElement<uint8_t>(GenOP::VT_IS_TRAINING, static_cast<uint8_t>(is_training), 0);
  }
  void add_format(mindspore::schema::Format format) {
    fbb_.AddElement<int32_t>(GenOP::VT_FORMAT, static_cast<int32_t>(format), 0);
  }
  void add_kernel_size(flatbuffers::Offset<flatbuffers::Vector<int64_t>> kernel_size) {
    fbb_.AddOffset(GenOP::VT_KERNEL_SIZE, kernel_size);
  }
  void add_stride(flatbuffers::Offset<flatbuffers::Vector<int64_t>> stride) {
    fbb_.AddOffset(GenOP::VT_STRIDE, stride);
  }
  void add_dilation(flatbuffers::Offset<flatbuffers::Vector<int64_t>> dilation) {
    fbb_.AddOffset(GenOP::VT_DILATION, dilation);
  }
  void add_pad_mode(mindspore::schema::PadMode pad_mode) {
    fbb_.AddElement<int8_t>(GenOP::VT_PAD_MODE, static_cast<int8_t>(pad_mode), 0);
  }
  void add_pad_list(flatbuffers::Offset<flatbuffers::Vector<int64_t>> pad_list) {
    fbb_.AddOffset(GenOP::VT_PAD_LIST, pad_list);
  }
  void add_mode(int64_t mode) {
    fbb_.AddElement<int64_t>(GenOP::VT_MODE, mode, 0);
  }
  void add_group(int64_t group) {
    fbb_.AddElement<int64_t>(GenOP::VT_GROUP, group, 0);
  }
  void add_in_channel(int64_t in_channel) {
    fbb_.AddElement<int64_t>(GenOP::VT_IN_CHANNEL, in_channel, 0);
  }
  void add_out_channel(int64_t out_channel) {
    fbb_.AddElement<int64_t>(GenOP::VT_OUT_CHANNEL, out_channel, 0);
  }
  void add_eltwise_mode(mindspore::schema::EltwiseMode eltwise_mode) {
    fbb_.AddElement<int8_t>(GenOP::VT_ELTWISE_MODE, static_cast<int8_t>(eltwise_mode), 0);
  }
  void add_has_bias(bool has_bias) {
    fbb_.AddElement<uint8_t>(GenOP::VT_HAS_BIAS, static_cast<uint8_t>(has_bias), 0);
  }
  void add_use_axis(bool use_axis) {
    fbb_.AddElement<uint8_t>(GenOP::VT_USE_AXIS, static_cast<uint8_t>(use_axis), 0);
  }
  void add_axis(int64_t axis) {
    fbb_.AddElement<int64_t>(GenOP::VT_AXIS, axis, 0);
  }
  void add_epsilon(float epsilon) {
    fbb_.AddElement<float>(GenOP::VT_EPSILON, epsilon, 0.0001f);
  }
  void add_momentum(float momentum) {
    fbb_.AddElement<float>(GenOP::VT_MOMENTUM, momentum, 0.9f);
  }
  void add_transpose_a(bool transpose_a) {
    fbb_.AddElement<uint8_t>(GenOP::VT_TRANSPOSE_A, static_cast<uint8_t>(transpose_a), 0);
  }
  void add_transpose_b(bool transpose_b) {
    fbb_.AddElement<uint8_t>(GenOP::VT_TRANSPOSE_B, static_cast<uint8_t>(transpose_b), 0);
  }
  void add_pad(flatbuffers::Offset<flatbuffers::Vector<int64_t>> pad) {
    fbb_.AddOffset(GenOP::VT_PAD, pad);
  }
  void add_round_mode(mindspore::schema::RoundMode round_mode) {
    fbb_.AddElement<int8_t>(GenOP::VT_ROUND_MODE, static_cast<int8_t>(round_mode), 0);
  }
  void add_global(bool global) {
    fbb_.AddElement<uint8_t>(GenOP::VT_GLOBAL, static_cast<uint8_t>(global), 0);
  }
  void add_channel_shared(bool channel_shared) {
    fbb_.AddElement<uint8_t>(GenOP::VT_CHANNEL_SHARED, static_cast<uint8_t>(channel_shared), 0);
  }
  void add_axes(flatbuffers::Offset<flatbuffers::Vector<int64_t>> axes) {
    fbb_.AddOffset(GenOP::VT_AXES, axes);
  }
  void add_keep_dims(bool keep_dims) {
    fbb_.AddElement<uint8_t>(GenOP::VT_KEEP_DIMS, static_cast<uint8_t>(keep_dims), 0);
  }
  void add_reduce_mode(mindspore::schema::ReduceMode reduce_mode) {
    fbb_.AddElement<int8_t>(GenOP::VT_REDUCE_MODE, static_cast<int8_t>(reduce_mode), 0);
  }
  void add_reduce_to_end(bool reduce_to_end) {
    fbb_.AddElement<uint8_t>(GenOP::VT_REDUCE_TO_END, static_cast<uint8_t>(reduce_to_end), 0);
  }
  void add_coeff(float coeff) {
    fbb_.AddElement<float>(GenOP::VT_COEFF, coeff, 0.0f);
  }
  explicit GenOPBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<GenOP> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<GenOP>(end);
    return o;
  }
};

inline flatbuffers::Offset<GenOP> CreateGenOP(
    flatbuffers::FlatBufferBuilder &_fbb,
    mindspore::schema::ActivationType activation_type = mindspore::schema::ActivationType_NO_ACTIVATION,
    float alpha = 0.0f,
    float min_val = 0.0f,
    float max_val = 0.0f,
    bool is_training = false,
    mindspore::schema::Format format = mindspore::schema::Format_NCHW,
    flatbuffers::Offset<flatbuffers::Vector<int64_t>> kernel_size = 0,
    flatbuffers::Offset<flatbuffers::Vector<int64_t>> stride = 0,
    flatbuffers::Offset<flatbuffers::Vector<int64_t>> dilation = 0,
    mindspore::schema::PadMode pad_mode = mindspore::schema::PadMode_PAD,
    flatbuffers::Offset<flatbuffers::Vector<int64_t>> pad_list = 0,
    int64_t mode = 0,
    int64_t group = 0,
    int64_t in_channel = 0,
    int64_t out_channel = 0,
    mindspore::schema::EltwiseMode eltwise_mode = mindspore::schema::EltwiseMode_PROD,
    bool has_bias = false,
    bool use_axis = false,
    int64_t axis = 0,
    float epsilon = 0.0001f,
    float momentum = 0.9f,
    bool transpose_a = false,
    bool transpose_b = false,
    flatbuffers::Offset<flatbuffers::Vector<int64_t>> pad = 0,
    mindspore::schema::RoundMode round_mode = mindspore::schema::RoundMode_FLOOR,
    bool global = false,
    bool channel_shared = false,
    flatbuffers::Offset<flatbuffers::Vector<int64_t>> axes = 0,
    bool keep_dims = false,
    mindspore::schema::ReduceMode reduce_mode = mindspore::schema::ReduceMode_ReduceMean,
    bool reduce_to_end = false,
    float coeff = 0.0f) {
  GenOPBuilder builder_(_fbb);
  builder_.add_axis(axis);
  builder_.add_out_channel(out_channel);
  builder_.add_in_channel(in_channel);
  builder_.add_group(group);
  builder_.add_mode(mode);
  builder_.add_coeff(coeff);
  builder_.add_axes(axes);
  builder_.add_pad(pad);
  builder_.add_momentum(momentum);
  builder_.add_epsilon(epsilon);
  builder_.add_pad_list(pad_list);
  builder_.add_dilation(dilation);
  builder_.add_stride(stride);
  builder_.add_kernel_size(kernel_size);
  builder_.add_format(format);
  builder_.add_max_val(max_val);
  builder_.add_min_val(min_val);
  builder_.add_alpha(alpha);
  builder_.add_reduce_to_end(reduce_to_end);
  builder_.add_reduce_mode(reduce_mode);
  builder_.add_keep_dims(keep_dims);
  builder_.add_channel_shared(channel_shared);
  builder_.add_global(global);
  builder_.add_round_mode(round_mode);
  builder_.add_transpose_b(transpose_b);
  builder_.add_transpose_a(transpose_a);
  builder_.add_use_axis(use_axis);
  builder_.add_has_bias(has_bias);
  builder_.add_eltwise_mode(eltwise_mode);
  builder_.add_pad_mode(pad_mode);
  builder_.add_is_training(is_training);
  builder_.add_activation_type(activation_type);
  return builder_.Finish();
}

inline flatbuffers::Offset<GenOP> CreateGenOPDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    mindspore::schema::ActivationType activation_type = mindspore::schema::ActivationType_NO_ACTIVATION,
    float alpha = 0.0f,
    float min_val = 0.0f,
    float max_val = 0.0f,
    bool is_training = false,
    mindspore::schema::Format format = mindspore::schema::Format_NCHW,
    const std::vector<int64_t> *kernel_size = nullptr,
    const std::vector<int64_t> *stride = nullptr,
    const std::vector<int64_t> *dilation = nullptr,
    mindspore::schema::PadMode pad_mode = mindspore::schema::PadMode_PAD,
    const std::vector<int64_t> *pad_list = nullptr,
    int64_t mode = 0,
    int64_t group = 0,
    int64_t in_channel = 0,
    int64_t out_channel = 0,
    mindspore::schema::EltwiseMode eltwise_mode = mindspore::schema::EltwiseMode_PROD,
    bool has_bias = false,
    bool use_axis = false,
    int64_t axis = 0,
    float epsilon = 0.0001f,
    float momentum = 0.9f,
    bool transpose_a = false,
    bool transpose_b = false,
    const std::vector<int64_t> *pad = nullptr,
    mindspore::schema::RoundMode round_mode = mindspore::schema::RoundMode_FLOOR,
    bool global = false,
    bool channel_shared = false,
    const std::vector<int64_t> *axes = nullptr,
    bool keep_dims = false,
    mindspore::schema::ReduceMode reduce_mode = mindspore::schema::ReduceMode_ReduceMean,
    bool reduce_to_end = false,
    float coeff = 0.0f) {
  auto kernel_size__ = kernel_size ? _fbb.CreateVector<int64_t>(*kernel_size) : 0;
  auto stride__ = stride ? _fbb.CreateVector<int64_t>(*stride) : 0;
  auto dilation__ = dilation ? _fbb.CreateVector<int64_t>(*dilation) : 0;
  auto pad_list__ = pad_list ? _fbb.CreateVector<int64_t>(*pad_list) : 0;
  auto pad__ = pad ? _fbb.CreateVector<int64_t>(*pad) : 0;
  auto axes__ = axes ? _fbb.CreateVector<int64_t>(*axes) : 0;
  return mindspore::schema::CreateGenOP(
      _fbb,
      activation_type,
      alpha,
      min_val,
      max_val,
      is_training,
      format,
      kernel_size__,
      stride__,
      dilation__,
      pad_mode,
      pad_list__,
      mode,
      group,
      in_channel,
      out_channel,
      eltwise_mode,
      has_bias,
      use_axis,
      axis,
      epsilon,
      momentum,
      transpose_a,
      transpose_b,
      pad__,
      round_mode,
      global,
      channel_shared,
      axes__,
      keep_dims,
      reduce_mode,
      reduce_to_end,
      coeff);
}

flatbuffers::Offset<GenOP> CreateGenOP(flatbuffers::FlatBufferBuilder &_fbb, const GenOPT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct RaggedRangeT : public flatbuffers::NativeTable {
  typedef RaggedRange TableType;
};

struct RaggedRange FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef RaggedRangeT NativeTableType;
  typedef RaggedRangeBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return RaggedRangeTypeTable();
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  RaggedRangeT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(RaggedRangeT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<RaggedRange> Pack(flatbuffers::FlatBufferBuilder &_fbb, const RaggedRangeT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct RaggedRangeBuilder {
  typedef RaggedRange Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit RaggedRangeBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<RaggedRange> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<RaggedRange>(end);
    return o;
  }
};

inline flatbuffers::Offset<RaggedRange> CreateRaggedRange(
    flatbuffers::FlatBufferBuilder &_fbb) {
  RaggedRangeBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<RaggedRange> CreateRaggedRange(flatbuffers::FlatBufferBuilder &_fbb, const RaggedRangeT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct GLUT : public flatbuffers::NativeTable {
  typedef GLU TableType;
  int64_t axis = -1LL;
};

struct GLU FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef GLUT NativeTableType;
  typedef GLUBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return GLUTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_AXIS = 4
  };
  int64_t axis() const {
    return GetField<int64_t>(VT_AXIS, -1LL);
  }
  bool mutate_axis(int64_t _axis) {
    return SetField<int64_t>(VT_AXIS, _axis, -1LL);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_AXIS) &&
           verifier.EndTable();
  }
  GLUT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(GLUT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<GLU> Pack(flatbuffers::FlatBufferBuilder &_fbb, const GLUT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct GLUBuilder {
  typedef GLU Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_axis(int64_t axis) {
    fbb_.AddElement<int64_t>(GLU::VT_AXIS, axis, -1LL);
  }
  explicit GLUBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<GLU> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<GLU>(end);
    return o;
  }
};

inline flatbuffers::Offset<GLU> CreateGLU(
    flatbuffers::FlatBufferBuilder &_fbb,
    int64_t axis = -1LL) {
  GLUBuilder builder_(_fbb);
  builder_.add_axis(axis);
  return builder_.Finish();
}

flatbuffers::Offset<GLU> CreateGLU(flatbuffers::FlatBufferBuilder &_fbb, const GLUT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct TensorArrayT : public flatbuffers::NativeTable {
  typedef TensorArray TableType;
  bool dynamic_size = false;
  bool identical_element_shapes = false;
  std::vector<int32_t> element_shape{};
  int32_t data_type = 0;
};

struct TensorArray FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef TensorArrayT NativeTableType;
  typedef TensorArrayBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return TensorArrayTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_DYNAMIC_SIZE = 4,
    VT_IDENTICAL_ELEMENT_SHAPES = 6,
    VT_ELEMENT_SHAPE = 8,
    VT_DATA_TYPE = 10
  };
  bool dynamic_size() const {
    return GetField<uint8_t>(VT_DYNAMIC_SIZE, 0) != 0;
  }
  bool mutate_dynamic_size(bool _dynamic_size) {
    return SetField<uint8_t>(VT_DYNAMIC_SIZE, static_cast<uint8_t>(_dynamic_size), 0);
  }
  bool identical_element_shapes() const {
    return GetField<uint8_t>(VT_IDENTICAL_ELEMENT_SHAPES, 0) != 0;
  }
  bool mutate_identical_element_shapes(bool _identical_element_shapes) {
    return SetField<uint8_t>(VT_IDENTICAL_ELEMENT_SHAPES, static_cast<uint8_t>(_identical_element_shapes), 0);
  }
  const flatbuffers::Vector<int32_t> *element_shape() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_ELEMENT_SHAPE);
  }
  flatbuffers::Vector<int32_t> *mutable_element_shape() {
    return GetPointer<flatbuffers::Vector<int32_t> *>(VT_ELEMENT_SHAPE);
  }
  int32_t data_type() const {
    return GetField<int32_t>(VT_DATA_TYPE, 0);
  }
  bool mutate_data_type(int32_t _data_type) {
    return SetField<int32_t>(VT_DATA_TYPE, _data_type, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_DYNAMIC_SIZE) &&
           VerifyField<uint8_t>(verifier, VT_IDENTICAL_ELEMENT_SHAPES) &&
           VerifyOffset(verifier, VT_ELEMENT_SHAPE) &&
           verifier.VerifyVector(element_shape()) &&
           VerifyField<int32_t>(verifier, VT_DATA_TYPE) &&
           verifier.EndTable();
  }
  TensorArrayT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(TensorArrayT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<TensorArray> Pack(flatbuffers::FlatBufferBuilder &_fbb, const TensorArrayT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct TensorArrayBuilder {
  typedef TensorArray Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_dynamic_size(bool dynamic_size) {
    fbb_.AddElement<uint8_t>(TensorArray::VT_DYNAMIC_SIZE, static_cast<uint8_t>(dynamic_size), 0);
  }
  void add_identical_element_shapes(bool identical_element_shapes) {
    fbb_.AddElement<uint8_t>(TensorArray::VT_IDENTICAL_ELEMENT_SHAPES, static_cast<uint8_t>(identical_element_shapes), 0);
  }
  void add_element_shape(flatbuffers::Offset<flatbuffers::Vector<int32_t>> element_shape) {
    fbb_.AddOffset(TensorArray::VT_ELEMENT_SHAPE, element_shape);
  }
  void add_data_type(int32_t data_type) {
    fbb_.AddElement<int32_t>(TensorArray::VT_DATA_TYPE, data_type, 0);
  }
  explicit TensorArrayBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<TensorArray> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<TensorArray>(end);
    return o;
  }
};

inline flatbuffers::Offset<TensorArray> CreateTensorArray(
    flatbuffers::FlatBufferBuilder &_fbb,
    bool dynamic_size = false,
    bool identical_element_shapes = false,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> element_shape = 0,
    int32_t data_type = 0) {
  TensorArrayBuilder builder_(_fbb);
  builder_.add_data_type(data_type);
  builder_.add_element_shape(element_shape);
  builder_.add_identical_element_shapes(identical_element_shapes);
  builder_.add_dynamic_size(dynamic_size);
  return builder_.Finish();
}

inline flatbuffers::Offset<TensorArray> CreateTensorArrayDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    bool dynamic_size = false,
    bool identical_element_shapes = false,
    const std::vector<int32_t> *element_shape = nullptr,
    int32_t data_type = 0) {
  auto element_shape__ = element_shape ? _fbb.CreateVector<int32_t>(*element_shape) : 0;
  return mindspore::schema::CreateTensorArray(
      _fbb,
      dynamic_size,
      identical_element_shapes,
      element_shape__,
      data_type);
}

flatbuffers::Offset<TensorArray> CreateTensorArray(flatbuffers::FlatBufferBuilder &_fbb, const TensorArrayT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct TensorArrayReadT : public flatbuffers::NativeTable {
  typedef TensorArrayRead TableType;
};

struct TensorArrayRead FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef TensorArrayReadT NativeTableType;
  typedef TensorArrayReadBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return TensorArrayReadTypeTable();
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  TensorArrayReadT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(TensorArrayReadT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<TensorArrayRead> Pack(flatbuffers::FlatBufferBuilder &_fbb, const TensorArrayReadT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct TensorArrayReadBuilder {
  typedef TensorArrayRead Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit TensorArrayReadBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<TensorArrayRead> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<TensorArrayRead>(end);
    return o;
  }
};

inline flatbuffers::Offset<TensorArrayRead> CreateTensorArrayRead(
    flatbuffers::FlatBufferBuilder &_fbb) {
  TensorArrayReadBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<TensorArrayRead> CreateTensorArrayRead(flatbuffers::FlatBufferBuilder &_fbb, const TensorArrayReadT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct TensorArrayWriteT : public flatbuffers::NativeTable {
  typedef TensorArrayWrite TableType;
};

struct TensorArrayWrite FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef TensorArrayWriteT NativeTableType;
  typedef TensorArrayWriteBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return TensorArrayWriteTypeTable();
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  TensorArrayWriteT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(TensorArrayWriteT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<TensorArrayWrite> Pack(flatbuffers::FlatBufferBuilder &_fbb, const TensorArrayWriteT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct TensorArrayWriteBuilder {
  typedef TensorArrayWrite Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit TensorArrayWriteBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<TensorArrayWrite> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<TensorArrayWrite>(end);
    return o;
  }
};

inline flatbuffers::Offset<TensorArrayWrite> CreateTensorArrayWrite(
    flatbuffers::FlatBufferBuilder &_fbb) {
  TensorArrayWriteBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<TensorArrayWrite> CreateTensorArrayWrite(flatbuffers::FlatBufferBuilder &_fbb, const TensorArrayWriteT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct AffineT : public flatbuffers::NativeTable {
  typedef Affine TableType;
  std::vector<int64_t> context{};
  int64_t output_dim = 0;
  mindspore::schema::ActivationType activation_type = mindspore::schema::ActivationType_NO_ACTIVATION;
  bool transpose_a = false;
  bool transpose_b = false;
};

struct Affine FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef AffineT NativeTableType;
  typedef AffineBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return AffineTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_CONTEXT = 4,
    VT_OUTPUT_DIM = 6,
    VT_ACTIVATION_TYPE = 8,
    VT_TRANSPOSE_A = 10,
    VT_TRANSPOSE_B = 12
  };
  const flatbuffers::Vector<int64_t> *context() const {
    return GetPointer<const flatbuffers::Vector<int64_t> *>(VT_CONTEXT);
  }
  flatbuffers::Vector<int64_t> *mutable_context() {
    return GetPointer<flatbuffers::Vector<int64_t> *>(VT_CONTEXT);
  }
  int64_t output_dim() const {
    return GetField<int64_t>(VT_OUTPUT_DIM, 0);
  }
  bool mutate_output_dim(int64_t _output_dim) {
    return SetField<int64_t>(VT_OUTPUT_DIM, _output_dim, 0);
  }
  mindspore::schema::ActivationType activation_type() const {
    return static_cast<mindspore::schema::ActivationType>(GetField<int8_t>(VT_ACTIVATION_TYPE, 0));
  }
  bool mutate_activation_type(mindspore::schema::ActivationType _activation_type) {
    return SetField<int8_t>(VT_ACTIVATION_TYPE, static_cast<int8_t>(_activation_type), 0);
  }
  bool transpose_a() const {
    return GetField<uint8_t>(VT_TRANSPOSE_A, 0) != 0;
  }
  bool mutate_transpose_a(bool _transpose_a) {
    return SetField<uint8_t>(VT_TRANSPOSE_A, static_cast<uint8_t>(_transpose_a), 0);
  }
  bool transpose_b() const {
    return GetField<uint8_t>(VT_TRANSPOSE_B, 0) != 0;
  }
  bool mutate_transpose_b(bool _transpose_b) {
    return SetField<uint8_t>(VT_TRANSPOSE_B, static_cast<uint8_t>(_transpose_b), 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_CONTEXT) &&
           verifier.VerifyVector(context()) &&
           VerifyField<int64_t>(verifier, VT_OUTPUT_DIM) &&
           VerifyField<int8_t>(verifier, VT_ACTIVATION_TYPE) &&
           VerifyField<uint8_t>(verifier, VT_TRANSPOSE_A) &&
           VerifyField<uint8_t>(verifier, VT_TRANSPOSE_B) &&
           verifier.EndTable();
  }
  AffineT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(AffineT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Affine> Pack(flatbuffers::FlatBufferBuilder &_fbb, const AffineT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct AffineBuilder {
  typedef Affine Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_context(flatbuffers::Offset<flatbuffers::Vector<int64_t>> context) {
    fbb_.AddOffset(Affine::VT_CONTEXT, context);
  }
  void add_output_dim(int64_t output_dim) {
    fbb_.AddElement<int64_t>(Affine::VT_OUTPUT_DIM, output_dim, 0);
  }
  void add_activation_type(mindspore::schema::ActivationType activation_type) {
    fbb_.AddElement<int8_t>(Affine::VT_ACTIVATION_TYPE, static_cast<int8_t>(activation_type), 0);
  }
  void add_transpose_a(bool transpose_a) {
    fbb_.AddElement<uint8_t>(Affine::VT_TRANSPOSE_A, static_cast<uint8_t>(transpose_a), 0);
  }
  void add_transpose_b(bool transpose_b) {
    fbb_.AddElement<uint8_t>(Affine::VT_TRANSPOSE_B, static_cast<uint8_t>(transpose_b), 0);
  }
  explicit AffineBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Affine> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Affine>(end);
    return o;
  }
};

inline flatbuffers::Offset<Affine> CreateAffine(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<int64_t>> context = 0,
    int64_t output_dim = 0,
    mindspore::schema::ActivationType activation_type = mindspore::schema::ActivationType_NO_ACTIVATION,
    bool transpose_a = false,
    bool transpose_b = false) {
  AffineBuilder builder_(_fbb);
  builder_.add_output_dim(output_dim);
  builder_.add_context(context);
  builder_.add_transpose_b(transpose_b);
  builder_.add_transpose_a(transpose_a);
  builder_.add_activation_type(activation_type);
  return builder_.Finish();
}

inline flatbuffers::Offset<Affine> CreateAffineDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<int64_t> *context = nullptr,
    int64_t output_dim = 0,
    mindspore::schema::ActivationType activation_type = mindspore::schema::ActivationType_NO_ACTIVATION,
    bool transpose_a = false,
    bool transpose_b = false) {
  auto context__ = context ? _fbb.CreateVector<int64_t>(*context) : 0;
  return mindspore::schema::CreateAffine(
      _fbb,
      context__,
      output_dim,
      activation_type,
      transpose_a,
      transpose_b);
}

flatbuffers::Offset<Affine> CreateAffine(flatbuffers::FlatBufferBuilder &_fbb, const AffineT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ScatterNdUpdateT : public flatbuffers::NativeTable {
  typedef ScatterNdUpdate TableType;
};

struct ScatterNdUpdate FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ScatterNdUpdateT NativeTableType;
  typedef ScatterNdUpdateBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return ScatterNdUpdateTypeTable();
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  ScatterNdUpdateT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ScatterNdUpdateT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<ScatterNdUpdate> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ScatterNdUpdateT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ScatterNdUpdateBuilder {
  typedef ScatterNdUpdate Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit ScatterNdUpdateBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<ScatterNdUpdate> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ScatterNdUpdate>(end);
    return o;
  }
};

inline flatbuffers::Offset<ScatterNdUpdate> CreateScatterNdUpdate(
    flatbuffers::FlatBufferBuilder &_fbb) {
  ScatterNdUpdateBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<ScatterNdUpdate> CreateScatterNdUpdate(flatbuffers::FlatBufferBuilder &_fbb, const ScatterNdUpdateT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

inline AbsT *Abs::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<AbsT>(new AbsT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Abs::UnPackTo(AbsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<Abs> Abs::Pack(flatbuffers::FlatBufferBuilder &_fbb, const AbsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateAbs(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Abs> CreateAbs(flatbuffers::FlatBufferBuilder &_fbb, const AbsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const AbsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return mindspore::schema::CreateAbs(
      _fbb);
}

inline ActivationT *Activation::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<ActivationT>(new ActivationT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Activation::UnPackTo(ActivationT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = activation_type(); _o->activation_type = _e; }
  { auto _e = alpha(); _o->alpha = _e; }
  { auto _e = min_val(); _o->min_val = _e; }
  { auto _e = max_val(); _o->max_val = _e; }
  { auto _e = approximate(); _o->approximate = _e; }
}

inline flatbuffers::Offset<Activation> Activation::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ActivationT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateActivation(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Activation> CreateActivation(flatbuffers::FlatBufferBuilder &_fbb, const ActivationT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ActivationT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _activation_type = _o->activation_type;
  auto _alpha = _o->alpha;
  auto _min_val = _o->min_val;
  auto _max_val = _o->max_val;
  auto _approximate = _o->approximate;
  return mindspore::schema::CreateActivation(
      _fbb,
      _activation_type,
      _alpha,
      _min_val,
      _max_val,
      _approximate);
}

inline ActivationGradT *ActivationGrad::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<ActivationGradT>(new ActivationGradT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void ActivationGrad::UnPackTo(ActivationGradT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = activation_type(); _o->activation_type = _e; }
  { auto _e = alpha(); _o->alpha = _e; }
}

inline flatbuffers::Offset<ActivationGrad> ActivationGrad::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ActivationGradT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateActivationGrad(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<ActivationGrad> CreateActivationGrad(flatbuffers::FlatBufferBuilder &_fbb, const ActivationGradT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ActivationGradT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _activation_type = _o->activation_type;
  auto _alpha = _o->alpha;
  return mindspore::schema::CreateActivationGrad(
      _fbb,
      _activation_type,
      _alpha);
}

inline AdamT *Adam::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<AdamT>(new AdamT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Adam::UnPackTo(AdamT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = use_locking(); _o->use_locking = _e; }
  { auto _e = use_nesterov(); _o->use_nesterov = _e; }
}

inline flatbuffers::Offset<Adam> Adam::Pack(flatbuffers::FlatBufferBuilder &_fbb, const AdamT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateAdam(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Adam> CreateAdam(flatbuffers::FlatBufferBuilder &_fbb, const AdamT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const AdamT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _use_locking = _o->use_locking;
  auto _use_nesterov = _o->use_nesterov;
  return mindspore::schema::CreateAdam(
      _fbb,
      _use_locking,
      _use_nesterov);
}

inline AddFusionT *AddFusion::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<AddFusionT>(new AddFusionT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void AddFusion::UnPackTo(AddFusionT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = activation_type(); _o->activation_type = _e; }
}

inline flatbuffers::Offset<AddFusion> AddFusion::Pack(flatbuffers::FlatBufferBuilder &_fbb, const AddFusionT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateAddFusion(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<AddFusion> CreateAddFusion(flatbuffers::FlatBufferBuilder &_fbb, const AddFusionT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const AddFusionT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _activation_type = _o->activation_type;
  return mindspore::schema::CreateAddFusion(
      _fbb,
      _activation_type);
}

inline AdderFusionT *AdderFusion::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<AdderFusionT>(new AdderFusionT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void AdderFusion::UnPackTo(AdderFusionT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = format(); _o->format = _e; }
  { auto _e = kernel_size(); if (_e) { _o->kernel_size.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->kernel_size[_i] = _e->Get(_i); } } }
  { auto _e = stride(); if (_e) { _o->stride.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->stride[_i] = _e->Get(_i); } } }
  { auto _e = dilation(); if (_e) { _o->dilation.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->dilation[_i] = _e->Get(_i); } } }
  { auto _e = pad_mode(); _o->pad_mode = _e; }
  { auto _e = pad_list(); if (_e) { _o->pad_list.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->pad_list[_i] = _e->Get(_i); } } }
  { auto _e = group(); _o->group = _e; }
  { auto _e = in_channel(); _o->in_channel = _e; }
  { auto _e = out_channel(); _o->out_channel = _e; }
  { auto _e = activation_type(); _o->activation_type = _e; }
}

inline flatbuffers::Offset<AdderFusion> AdderFusion::Pack(flatbuffers::FlatBufferBuilder &_fbb, const AdderFusionT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateAdderFusion(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<AdderFusion> CreateAdderFusion(flatbuffers::FlatBufferBuilder &_fbb, const AdderFusionT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const AdderFusionT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _format = _o->format;
  auto _kernel_size = _o->kernel_size.size() ? _fbb.CreateVector(_o->kernel_size) : 0;
  auto _stride = _o->stride.size() ? _fbb.CreateVector(_o->stride) : 0;
  auto _dilation = _o->dilation.size() ? _fbb.CreateVector(_o->dilation) : 0;
  auto _pad_mode = _o->pad_mode;
  auto _pad_list = _o->pad_list.size() ? _fbb.CreateVector(_o->pad_list) : 0;
  auto _group = _o->group;
  auto _in_channel = _o->in_channel;
  auto _out_channel = _o->out_channel;
  auto _activation_type = _o->activation_type;
  return mindspore::schema::CreateAdderFusion(
      _fbb,
      _format,
      _kernel_size,
      _stride,
      _dilation,
      _pad_mode,
      _pad_list,
      _group,
      _in_channel,
      _out_channel,
      _activation_type);
}

inline AddGradT *AddGrad::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<AddGradT>(new AddGradT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void AddGrad::UnPackTo(AddGradT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<AddGrad> AddGrad::Pack(flatbuffers::FlatBufferBuilder &_fbb, const AddGradT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateAddGrad(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<AddGrad> CreateAddGrad(flatbuffers::FlatBufferBuilder &_fbb, const AddGradT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const AddGradT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return mindspore::schema::CreateAddGrad(
      _fbb);
}

inline AddNT *AddN::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<AddNT>(new AddNT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void AddN::UnPackTo(AddNT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<AddN> AddN::Pack(flatbuffers::FlatBufferBuilder &_fbb, const AddNT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateAddN(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<AddN> CreateAddN(flatbuffers::FlatBufferBuilder &_fbb, const AddNT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const AddNT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return mindspore::schema::CreateAddN(
      _fbb);
}

inline AllT *All::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<AllT>(new AllT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void All::UnPackTo(AllT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = keep_dims(); _o->keep_dims = _e; }
}

inline flatbuffers::Offset<All> All::Pack(flatbuffers::FlatBufferBuilder &_fbb, const AllT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateAll(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<All> CreateAll(flatbuffers::FlatBufferBuilder &_fbb, const AllT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const AllT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _keep_dims = _o->keep_dims;
  return mindspore::schema::CreateAll(
      _fbb,
      _keep_dims);
}

inline ApplyMomentumT *ApplyMomentum::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<ApplyMomentumT>(new ApplyMomentumT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void ApplyMomentum::UnPackTo(ApplyMomentumT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = use_nesterov(); _o->use_nesterov = _e; }
  { auto _e = use_locking(); _o->use_locking = _e; }
  { auto _e = gradient_scale(); _o->gradient_scale = _e; }
}

inline flatbuffers::Offset<ApplyMomentum> ApplyMomentum::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ApplyMomentumT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateApplyMomentum(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<ApplyMomentum> CreateApplyMomentum(flatbuffers::FlatBufferBuilder &_fbb, const ApplyMomentumT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ApplyMomentumT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _use_nesterov = _o->use_nesterov;
  auto _use_locking = _o->use_locking;
  auto _gradient_scale = _o->gradient_scale;
  return mindspore::schema::CreateApplyMomentum(
      _fbb,
      _use_nesterov,
      _use_locking,
      _gradient_scale);
}

inline ArgMaxFusionT *ArgMaxFusion::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<ArgMaxFusionT>(new ArgMaxFusionT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void ArgMaxFusion::UnPackTo(ArgMaxFusionT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = axis(); _o->axis = _e; }
  { auto _e = top_k(); _o->top_k = _e; }
  { auto _e = keep_dims(); _o->keep_dims = _e; }
  { auto _e = out_max_value(); _o->out_max_value = _e; }
}

inline flatbuffers::Offset<ArgMaxFusion> ArgMaxFusion::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ArgMaxFusionT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateArgMaxFusion(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<ArgMaxFusion> CreateArgMaxFusion(flatbuffers::FlatBufferBuilder &_fbb, const ArgMaxFusionT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ArgMaxFusionT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _axis = _o->axis;
  auto _top_k = _o->top_k;
  auto _keep_dims = _o->keep_dims;
  auto _out_max_value = _o->out_max_value;
  return mindspore::schema::CreateArgMaxFusion(
      _fbb,
      _axis,
      _top_k,
      _keep_dims,
      _out_max_value);
}

inline ArgMinFusionT *ArgMinFusion::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<ArgMinFusionT>(new ArgMinFusionT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void ArgMinFusion::UnPackTo(ArgMinFusionT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = axis(); _o->axis = _e; }
  { auto _e = top_k(); _o->top_k = _e; }
  { auto _e = keep_dims(); _o->keep_dims = _e; }
  { auto _e = out_max_value(); _o->out_max_value = _e; }
}

inline flatbuffers::Offset<ArgMinFusion> ArgMinFusion::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ArgMinFusionT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateArgMinFusion(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<ArgMinFusion> CreateArgMinFusion(flatbuffers::FlatBufferBuilder &_fbb, const ArgMinFusionT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ArgMinFusionT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _axis = _o->axis;
  auto _top_k = _o->top_k;
  auto _keep_dims = _o->keep_dims;
  auto _out_max_value = _o->out_max_value;
  return mindspore::schema::CreateArgMinFusion(
      _fbb,
      _axis,
      _top_k,
      _keep_dims,
      _out_max_value);
}

inline AssertT *Assert::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<AssertT>(new AssertT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Assert::UnPackTo(AssertT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = summarize(); _o->summarize = _e; }
}

inline flatbuffers::Offset<Assert> Assert::Pack(flatbuffers::FlatBufferBuilder &_fbb, const AssertT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateAssert(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Assert> CreateAssert(flatbuffers::FlatBufferBuilder &_fbb, const AssertT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const AssertT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _summarize = _o->summarize;
  return mindspore::schema::CreateAssert(
      _fbb,
      _summarize);
}

inline AssignT *Assign::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<AssignT>(new AssignT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Assign::UnPackTo(AssignT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<Assign> Assign::Pack(flatbuffers::FlatBufferBuilder &_fbb, const AssignT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateAssign(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Assign> CreateAssign(flatbuffers::FlatBufferBuilder &_fbb, const AssignT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const AssignT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return mindspore::schema::CreateAssign(
      _fbb);
}

inline AssignAddT *AssignAdd::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<AssignAddT>(new AssignAddT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void AssignAdd::UnPackTo(AssignAddT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<AssignAdd> AssignAdd::Pack(flatbuffers::FlatBufferBuilder &_fbb, const AssignAddT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateAssignAdd(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<AssignAdd> CreateAssignAdd(flatbuffers::FlatBufferBuilder &_fbb, const AssignAddT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const AssignAddT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return mindspore::schema::CreateAssignAdd(
      _fbb);
}

inline AudioSpectrogramT *AudioSpectrogram::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<AudioSpectrogramT>(new AudioSpectrogramT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void AudioSpectrogram::UnPackTo(AudioSpectrogramT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = window_size(); _o->window_size = _e; }
  { auto _e = stride(); _o->stride = _e; }
  { auto _e = mag_square(); _o->mag_square = _e; }
}

inline flatbuffers::Offset<AudioSpectrogram> AudioSpectrogram::Pack(flatbuffers::FlatBufferBuilder &_fbb, const AudioSpectrogramT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateAudioSpectrogram(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<AudioSpectrogram> CreateAudioSpectrogram(flatbuffers::FlatBufferBuilder &_fbb, const AudioSpectrogramT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const AudioSpectrogramT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _window_size = _o->window_size;
  auto _stride = _o->stride;
  auto _mag_square = _o->mag_square;
  return mindspore::schema::CreateAudioSpectrogram(
      _fbb,
      _window_size,
      _stride,
      _mag_square);
}

inline AvgPoolFusionT *AvgPoolFusion::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<AvgPoolFusionT>(new AvgPoolFusionT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void AvgPoolFusion::UnPackTo(AvgPoolFusionT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = kernel_size(); if (_e) { _o->kernel_size.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->kernel_size[_i] = _e->Get(_i); } } }
  { auto _e = strides(); if (_e) { _o->strides.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->strides[_i] = _e->Get(_i); } } }
  { auto _e = pad(); if (_e) { _o->pad.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->pad[_i] = _e->Get(_i); } } }
  { auto _e = pad_mode(); _o->pad_mode = _e; }
  { auto _e = round_mode(); _o->round_mode = _e; }
  { auto _e = format(); _o->format = _e; }
  { auto _e = global(); _o->global = _e; }
  { auto _e = activation_type(); _o->activation_type = _e; }
}

inline flatbuffers::Offset<AvgPoolFusion> AvgPoolFusion::Pack(flatbuffers::FlatBufferBuilder &_fbb, const AvgPoolFusionT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateAvgPoolFusion(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<AvgPoolFusion> CreateAvgPoolFusion(flatbuffers::FlatBufferBuilder &_fbb, const AvgPoolFusionT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const AvgPoolFusionT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _kernel_size = _o->kernel_size.size() ? _fbb.CreateVector(_o->kernel_size) : 0;
  auto _strides = _o->strides.size() ? _fbb.CreateVector(_o->strides) : 0;
  auto _pad = _o->pad.size() ? _fbb.CreateVector(_o->pad) : 0;
  auto _pad_mode = _o->pad_mode;
  auto _round_mode = _o->round_mode;
  auto _format = _o->format;
  auto _global = _o->global;
  auto _activation_type = _o->activation_type;
  return mindspore::schema::CreateAvgPoolFusion(
      _fbb,
      _kernel_size,
      _strides,
      _pad,
      _pad_mode,
      _round_mode,
      _format,
      _global,
      _activation_type);
}

inline AvgPoolGradT *AvgPoolGrad::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<AvgPoolGradT>(new AvgPoolGradT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void AvgPoolGrad::UnPackTo(AvgPoolGradT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = kernel_size(); if (_e) { _o->kernel_size.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->kernel_size[_i] = _e->Get(_i); } } }
  { auto _e = strides(); if (_e) { _o->strides.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->strides[_i] = _e->Get(_i); } } }
  { auto _e = pad_mode(); _o->pad_mode = _e; }
  { auto _e = format(); _o->format = _e; }
}

inline flatbuffers::Offset<AvgPoolGrad> AvgPoolGrad::Pack(flatbuffers::FlatBufferBuilder &_fbb, const AvgPoolGradT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateAvgPoolGrad(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<AvgPoolGrad> CreateAvgPoolGrad(flatbuffers::FlatBufferBuilder &_fbb, const AvgPoolGradT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const AvgPoolGradT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _kernel_size = _o->kernel_size.size() ? _fbb.CreateVector(_o->kernel_size) : 0;
  auto _strides = _o->strides.size() ? _fbb.CreateVector(_o->strides) : 0;
  auto _pad_mode = _o->pad_mode;
  auto _format = _o->format;
  return mindspore::schema::CreateAvgPoolGrad(
      _fbb,
      _kernel_size,
      _strides,
      _pad_mode,
      _format);
}

inline BatchNormT *BatchNorm::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<BatchNormT>(new BatchNormT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void BatchNorm::UnPackTo(BatchNormT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = epsilon(); _o->epsilon = _e; }
  { auto _e = format(); _o->format = _e; }
  { auto _e = is_training(); _o->is_training = _e; }
}

inline flatbuffers::Offset<BatchNorm> BatchNorm::Pack(flatbuffers::FlatBufferBuilder &_fbb, const BatchNormT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateBatchNorm(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<BatchNorm> CreateBatchNorm(flatbuffers::FlatBufferBuilder &_fbb, const BatchNormT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const BatchNormT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _epsilon = _o->epsilon;
  auto _format = _o->format;
  auto _is_training = _o->is_training;
  return mindspore::schema::CreateBatchNorm(
      _fbb,
      _epsilon,
      _format,
      _is_training);
}

inline BatchNormGradT *BatchNormGrad::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<BatchNormGradT>(new BatchNormGradT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void BatchNormGrad::UnPackTo(BatchNormGradT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = epsilon(); _o->epsilon = _e; }
}

inline flatbuffers::Offset<BatchNormGrad> BatchNormGrad::Pack(flatbuffers::FlatBufferBuilder &_fbb, const BatchNormGradT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateBatchNormGrad(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<BatchNormGrad> CreateBatchNormGrad(flatbuffers::FlatBufferBuilder &_fbb, const BatchNormGradT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const BatchNormGradT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _epsilon = _o->epsilon;
  return mindspore::schema::CreateBatchNormGrad(
      _fbb,
      _epsilon);
}

inline BatchToSpaceT *BatchToSpace::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<BatchToSpaceT>(new BatchToSpaceT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void BatchToSpace::UnPackTo(BatchToSpaceT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = block_size(); if (_e) { _o->block_size.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->block_size[_i] = _e->Get(_i); } } }
  { auto _e = crops(); if (_e) _o->crops = std::unique_ptr<mindspore::schema::Vec2DT>(_e->UnPack(_resolver)); }
}

inline flatbuffers::Offset<BatchToSpace> BatchToSpace::Pack(flatbuffers::FlatBufferBuilder &_fbb, const BatchToSpaceT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateBatchToSpace(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<BatchToSpace> CreateBatchToSpace(flatbuffers::FlatBufferBuilder &_fbb, const BatchToSpaceT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const BatchToSpaceT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _block_size = _o->block_size.size() ? _fbb.CreateVector(_o->block_size) : 0;
  auto _crops = _o->crops ? CreateVec2D(_fbb, _o->crops.get(), _rehasher) : 0;
  return mindspore::schema::CreateBatchToSpace(
      _fbb,
      _block_size,
      _crops);
}

inline BatchToSpaceNDT *BatchToSpaceND::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<BatchToSpaceNDT>(new BatchToSpaceNDT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void BatchToSpaceND::UnPackTo(BatchToSpaceNDT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = block_shape(); if (_e) { _o->block_shape.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->block_shape[_i] = _e->Get(_i); } } }
  { auto _e = crops(); if (_e) _o->crops = std::unique_ptr<mindspore::schema::Vec2DT>(_e->UnPack(_resolver)); }
}

inline flatbuffers::Offset<BatchToSpaceND> BatchToSpaceND::Pack(flatbuffers::FlatBufferBuilder &_fbb, const BatchToSpaceNDT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateBatchToSpaceND(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<BatchToSpaceND> CreateBatchToSpaceND(flatbuffers::FlatBufferBuilder &_fbb, const BatchToSpaceNDT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const BatchToSpaceNDT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _block_shape = _o->block_shape.size() ? _fbb.CreateVector(_o->block_shape) : 0;
  auto _crops = _o->crops ? CreateVec2D(_fbb, _o->crops.get(), _rehasher) : 0;
  return mindspore::schema::CreateBatchToSpaceND(
      _fbb,
      _block_shape,
      _crops);
}

inline BiasAddT *BiasAdd::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<BiasAddT>(new BiasAddT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void BiasAdd::UnPackTo(BiasAddT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = format(); _o->format = _e; }
}

inline flatbuffers::Offset<BiasAdd> BiasAdd::Pack(flatbuffers::FlatBufferBuilder &_fbb, const BiasAddT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateBiasAdd(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<BiasAdd> CreateBiasAdd(flatbuffers::FlatBufferBuilder &_fbb, const BiasAddT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const BiasAddT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _format = _o->format;
  return mindspore::schema::CreateBiasAdd(
      _fbb,
      _format);
}

inline BinaryCrossEntropyT *BinaryCrossEntropy::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<BinaryCrossEntropyT>(new BinaryCrossEntropyT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void BinaryCrossEntropy::UnPackTo(BinaryCrossEntropyT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = reduction(); _o->reduction = _e; }
}

inline flatbuffers::Offset<BinaryCrossEntropy> BinaryCrossEntropy::Pack(flatbuffers::FlatBufferBuilder &_fbb, const BinaryCrossEntropyT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateBinaryCrossEntropy(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<BinaryCrossEntropy> CreateBinaryCrossEntropy(flatbuffers::FlatBufferBuilder &_fbb, const BinaryCrossEntropyT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const BinaryCrossEntropyT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _reduction = _o->reduction;
  return mindspore::schema::CreateBinaryCrossEntropy(
      _fbb,
      _reduction);
}

inline BinaryCrossEntropyGradT *BinaryCrossEntropyGrad::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<BinaryCrossEntropyGradT>(new BinaryCrossEntropyGradT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void BinaryCrossEntropyGrad::UnPackTo(BinaryCrossEntropyGradT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = reduction(); _o->reduction = _e; }
}

inline flatbuffers::Offset<BinaryCrossEntropyGrad> BinaryCrossEntropyGrad::Pack(flatbuffers::FlatBufferBuilder &_fbb, const BinaryCrossEntropyGradT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateBinaryCrossEntropyGrad(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<BinaryCrossEntropyGrad> CreateBinaryCrossEntropyGrad(flatbuffers::FlatBufferBuilder &_fbb, const BinaryCrossEntropyGradT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const BinaryCrossEntropyGradT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _reduction = _o->reduction;
  return mindspore::schema::CreateBinaryCrossEntropyGrad(
      _fbb,
      _reduction);
}

inline BiasAddGradT *BiasAddGrad::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<BiasAddGradT>(new BiasAddGradT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void BiasAddGrad::UnPackTo(BiasAddGradT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<BiasAddGrad> BiasAddGrad::Pack(flatbuffers::FlatBufferBuilder &_fbb, const BiasAddGradT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateBiasAddGrad(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<BiasAddGrad> CreateBiasAddGrad(flatbuffers::FlatBufferBuilder &_fbb, const BiasAddGradT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const BiasAddGradT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return mindspore::schema::CreateBiasAddGrad(
      _fbb);
}

inline BroadcastToT *BroadcastTo::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<BroadcastToT>(new BroadcastToT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void BroadcastTo::UnPackTo(BroadcastToT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = shape(); if (_e) { _o->shape.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->shape[_i] = _e->Get(_i); } } }
}

inline flatbuffers::Offset<BroadcastTo> BroadcastTo::Pack(flatbuffers::FlatBufferBuilder &_fbb, const BroadcastToT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateBroadcastTo(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<BroadcastTo> CreateBroadcastTo(flatbuffers::FlatBufferBuilder &_fbb, const BroadcastToT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const BroadcastToT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _shape = _o->shape.size() ? _fbb.CreateVector(_o->shape) : 0;
  return mindspore::schema::CreateBroadcastTo(
      _fbb,
      _shape);
}

inline CastT *Cast::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<CastT>(new CastT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Cast::UnPackTo(CastT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<Cast> Cast::Pack(flatbuffers::FlatBufferBuilder &_fbb, const CastT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateCast(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Cast> CreateCast(flatbuffers::FlatBufferBuilder &_fbb, const CastT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const CastT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return mindspore::schema::CreateCast(
      _fbb);
}

inline CeilT *Ceil::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<CeilT>(new CeilT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Ceil::UnPackTo(CeilT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<Ceil> Ceil::Pack(flatbuffers::FlatBufferBuilder &_fbb, const CeilT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateCeil(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Ceil> CreateCeil(flatbuffers::FlatBufferBuilder &_fbb, const CeilT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const CeilT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return mindspore::schema::CreateCeil(
      _fbb);
}

inline ClipT *Clip::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<ClipT>(new ClipT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Clip::UnPackTo(ClipT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = max(); _o->max = _e; }
  { auto _e = min(); _o->min = _e; }
}

inline flatbuffers::Offset<Clip> Clip::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ClipT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateClip(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Clip> CreateClip(flatbuffers::FlatBufferBuilder &_fbb, const ClipT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ClipT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _max = _o->max;
  auto _min = _o->min;
  return mindspore::schema::CreateClip(
      _fbb,
      _max,
      _min);
}

inline ConcatT *Concat::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<ConcatT>(new ConcatT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Concat::UnPackTo(ConcatT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = axis(); _o->axis = _e; }
}

inline flatbuffers::Offset<Concat> Concat::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ConcatT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateConcat(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Concat> CreateConcat(flatbuffers::FlatBufferBuilder &_fbb, const ConcatT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ConcatT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _axis = _o->axis;
  return mindspore::schema::CreateConcat(
      _fbb,
      _axis);
}

inline AttentionT *Attention::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<AttentionT>(new AttentionT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Attention::UnPackTo(AttentionT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<Attention> Attention::Pack(flatbuffers::FlatBufferBuilder &_fbb, const AttentionT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateAttention(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Attention> CreateAttention(flatbuffers::FlatBufferBuilder &_fbb, const AttentionT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const AttentionT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return mindspore::schema::CreateAttention(
      _fbb);
}

inline Conv2DBackpropFilterFusionT *Conv2DBackpropFilterFusion::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<Conv2DBackpropFilterFusionT>(new Conv2DBackpropFilterFusionT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Conv2DBackpropFilterFusion::UnPackTo(Conv2DBackpropFilterFusionT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = format(); _o->format = _e; }
  { auto _e = kernel_size(); if (_e) { _o->kernel_size.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->kernel_size[_i] = _e->Get(_i); } } }
  { auto _e = stride(); if (_e) { _o->stride.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->stride[_i] = _e->Get(_i); } } }
  { auto _e = dilation(); if (_e) { _o->dilation.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->dilation[_i] = _e->Get(_i); } } }
  { auto _e = pad_mode(); _o->pad_mode = _e; }
  { auto _e = pad_list(); if (_e) { _o->pad_list.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->pad_list[_i] = _e->Get(_i); } } }
  { auto _e = mode(); _o->mode = _e; }
  { auto _e = group(); _o->group = _e; }
  { auto _e = in_channel(); _o->in_channel = _e; }
  { auto _e = out_channel(); _o->out_channel = _e; }
  { auto _e = activation_type(); _o->activation_type = _e; }
}

inline flatbuffers::Offset<Conv2DBackpropFilterFusion> Conv2DBackpropFilterFusion::Pack(flatbuffers::FlatBufferBuilder &_fbb, const Conv2DBackpropFilterFusionT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateConv2DBackpropFilterFusion(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Conv2DBackpropFilterFusion> CreateConv2DBackpropFilterFusion(flatbuffers::FlatBufferBuilder &_fbb, const Conv2DBackpropFilterFusionT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const Conv2DBackpropFilterFusionT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _format = _o->format;
  auto _kernel_size = _o->kernel_size.size() ? _fbb.CreateVector(_o->kernel_size) : 0;
  auto _stride = _o->stride.size() ? _fbb.CreateVector(_o->stride) : 0;
  auto _dilation = _o->dilation.size() ? _fbb.CreateVector(_o->dilation) : 0;
  auto _pad_mode = _o->pad_mode;
  auto _pad_list = _o->pad_list.size() ? _fbb.CreateVector(_o->pad_list) : 0;
  auto _mode = _o->mode;
  auto _group = _o->group;
  auto _in_channel = _o->in_channel;
  auto _out_channel = _o->out_channel;
  auto _activation_type = _o->activation_type;
  return mindspore::schema::CreateConv2DBackpropFilterFusion(
      _fbb,
      _format,
      _kernel_size,
      _stride,
      _dilation,
      _pad_mode,
      _pad_list,
      _mode,
      _group,
      _in_channel,
      _out_channel,
      _activation_type);
}

inline Conv2DBackpropInputFusionT *Conv2DBackpropInputFusion::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<Conv2DBackpropInputFusionT>(new Conv2DBackpropInputFusionT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Conv2DBackpropInputFusion::UnPackTo(Conv2DBackpropInputFusionT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = format(); _o->format = _e; }
  { auto _e = kernel_size(); if (_e) { _o->kernel_size.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->kernel_size[_i] = _e->Get(_i); } } }
  { auto _e = stride(); if (_e) { _o->stride.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->stride[_i] = _e->Get(_i); } } }
  { auto _e = dilation(); if (_e) { _o->dilation.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->dilation[_i] = _e->Get(_i); } } }
  { auto _e = pad_mode(); _o->pad_mode = _e; }
  { auto _e = pad(); if (_e) { _o->pad.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->pad[_i] = _e->Get(_i); } } }
  { auto _e = pad_list(); if (_e) { _o->pad_list.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->pad_list[_i] = _e->Get(_i); } } }
  { auto _e = mode(); _o->mode = _e; }
  { auto _e = group(); _o->group = _e; }
  { auto _e = in_channel(); _o->in_channel = _e; }
  { auto _e = out_channel(); _o->out_channel = _e; }
  { auto _e = activation_type(); _o->activation_type = _e; }
}

inline flatbuffers::Offset<Conv2DBackpropInputFusion> Conv2DBackpropInputFusion::Pack(flatbuffers::FlatBufferBuilder &_fbb, const Conv2DBackpropInputFusionT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateConv2DBackpropInputFusion(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Conv2DBackpropInputFusion> CreateConv2DBackpropInputFusion(flatbuffers::FlatBufferBuilder &_fbb, const Conv2DBackpropInputFusionT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const Conv2DBackpropInputFusionT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _format = _o->format;
  auto _kernel_size = _o->kernel_size.size() ? _fbb.CreateVector(_o->kernel_size) : 0;
  auto _stride = _o->stride.size() ? _fbb.CreateVector(_o->stride) : 0;
  auto _dilation = _o->dilation.size() ? _fbb.CreateVector(_o->dilation) : 0;
  auto _pad_mode = _o->pad_mode;
  auto _pad = _o->pad.size() ? _fbb.CreateVector(_o->pad) : 0;
  auto _pad_list = _o->pad_list.size() ? _fbb.CreateVector(_o->pad_list) : 0;
  auto _mode = _o->mode;
  auto _group = _o->group;
  auto _in_channel = _o->in_channel;
  auto _out_channel = _o->out_channel;
  auto _activation_type = _o->activation_type;
  return mindspore::schema::CreateConv2DBackpropInputFusion(
      _fbb,
      _format,
      _kernel_size,
      _stride,
      _dilation,
      _pad_mode,
      _pad,
      _pad_list,
      _mode,
      _group,
      _in_channel,
      _out_channel,
      _activation_type);
}

inline Conv2DFusionT *Conv2DFusion::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<Conv2DFusionT>(new Conv2DFusionT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Conv2DFusion::UnPackTo(Conv2DFusionT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = format(); _o->format = _e; }
  { auto _e = kernel_size(); if (_e) { _o->kernel_size.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->kernel_size[_i] = _e->Get(_i); } } }
  { auto _e = stride(); if (_e) { _o->stride.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->stride[_i] = _e->Get(_i); } } }
  { auto _e = dilation(); if (_e) { _o->dilation.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->dilation[_i] = _e->Get(_i); } } }
  { auto _e = pad_mode(); _o->pad_mode = _e; }
  { auto _e = pad_list(); if (_e) { _o->pad_list.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->pad_list[_i] = _e->Get(_i); } } }
  { auto _e = mode(); _o->mode = _e; }
  { auto _e = group(); _o->group = _e; }
  { auto _e = in_channel(); _o->in_channel = _e; }
  { auto _e = out_channel(); _o->out_channel = _e; }
  { auto _e = activation_type(); _o->activation_type = _e; }
}

inline flatbuffers::Offset<Conv2DFusion> Conv2DFusion::Pack(flatbuffers::FlatBufferBuilder &_fbb, const Conv2DFusionT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateConv2DFusion(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Conv2DFusion> CreateConv2DFusion(flatbuffers::FlatBufferBuilder &_fbb, const Conv2DFusionT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const Conv2DFusionT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _format = _o->format;
  auto _kernel_size = _o->kernel_size.size() ? _fbb.CreateVector(_o->kernel_size) : 0;
  auto _stride = _o->stride.size() ? _fbb.CreateVector(_o->stride) : 0;
  auto _dilation = _o->dilation.size() ? _fbb.CreateVector(_o->dilation) : 0;
  auto _pad_mode = _o->pad_mode;
  auto _pad_list = _o->pad_list.size() ? _fbb.CreateVector(_o->pad_list) : 0;
  auto _mode = _o->mode;
  auto _group = _o->group;
  auto _in_channel = _o->in_channel;
  auto _out_channel = _o->out_channel;
  auto _activation_type = _o->activation_type;
  return mindspore::schema::CreateConv2DFusion(
      _fbb,
      _format,
      _kernel_size,
      _stride,
      _dilation,
      _pad_mode,
      _pad_list,
      _mode,
      _group,
      _in_channel,
      _out_channel,
      _activation_type);
}

inline Conv2dTransposeFusionT *Conv2dTransposeFusion::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<Conv2dTransposeFusionT>(new Conv2dTransposeFusionT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Conv2dTransposeFusion::UnPackTo(Conv2dTransposeFusionT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = format(); _o->format = _e; }
  { auto _e = kernel_size(); if (_e) { _o->kernel_size.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->kernel_size[_i] = _e->Get(_i); } } }
  { auto _e = stride(); if (_e) { _o->stride.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->stride[_i] = _e->Get(_i); } } }
  { auto _e = dilation(); if (_e) { _o->dilation.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->dilation[_i] = _e->Get(_i); } } }
  { auto _e = pad_mode(); _o->pad_mode = _e; }
  { auto _e = pad(); if (_e) { _o->pad.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->pad[_i] = _e->Get(_i); } } }
  { auto _e = pad_list(); if (_e) { _o->pad_list.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->pad_list[_i] = _e->Get(_i); } } }
  { auto _e = mode(); _o->mode = _e; }
  { auto _e = group(); _o->group = _e; }
  { auto _e = in_channel(); _o->in_channel = _e; }
  { auto _e = out_channel(); _o->out_channel = _e; }
  { auto _e = activation_type(); _o->activation_type = _e; }
  { auto _e = output_paddings(); if (_e) { _o->output_paddings.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->output_paddings[_i] = _e->Get(_i); } } }
}

inline flatbuffers::Offset<Conv2dTransposeFusion> Conv2dTransposeFusion::Pack(flatbuffers::FlatBufferBuilder &_fbb, const Conv2dTransposeFusionT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateConv2dTransposeFusion(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Conv2dTransposeFusion> CreateConv2dTransposeFusion(flatbuffers::FlatBufferBuilder &_fbb, const Conv2dTransposeFusionT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const Conv2dTransposeFusionT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _format = _o->format;
  auto _kernel_size = _o->kernel_size.size() ? _fbb.CreateVector(_o->kernel_size) : 0;
  auto _stride = _o->stride.size() ? _fbb.CreateVector(_o->stride) : 0;
  auto _dilation = _o->dilation.size() ? _fbb.CreateVector(_o->dilation) : 0;
  auto _pad_mode = _o->pad_mode;
  auto _pad = _o->pad.size() ? _fbb.CreateVector(_o->pad) : 0;
  auto _pad_list = _o->pad_list.size() ? _fbb.CreateVector(_o->pad_list) : 0;
  auto _mode = _o->mode;
  auto _group = _o->group;
  auto _in_channel = _o->in_channel;
  auto _out_channel = _o->out_channel;
  auto _activation_type = _o->activation_type;
  auto _output_paddings = _o->output_paddings.size() ? _fbb.CreateVector(_o->output_paddings) : 0;
  return mindspore::schema::CreateConv2dTransposeFusion(
      _fbb,
      _format,
      _kernel_size,
      _stride,
      _dilation,
      _pad_mode,
      _pad,
      _pad_list,
      _mode,
      _group,
      _in_channel,
      _out_channel,
      _activation_type,
      _output_paddings);
}

inline CosT *Cos::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<CosT>(new CosT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Cos::UnPackTo(CosT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<Cos> Cos::Pack(flatbuffers::FlatBufferBuilder &_fbb, const CosT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateCos(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Cos> CreateCos(flatbuffers::FlatBufferBuilder &_fbb, const CosT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const CosT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return mindspore::schema::CreateCos(
      _fbb);
}

inline ConstantOfShapeT *ConstantOfShape::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<ConstantOfShapeT>(new ConstantOfShapeT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void ConstantOfShape::UnPackTo(ConstantOfShapeT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = data_type(); _o->data_type = _e; }
  { auto _e = value(); if (_e) { _o->value.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->value[_i] = _e->Get(_i); } } }
}

inline flatbuffers::Offset<ConstantOfShape> ConstantOfShape::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ConstantOfShapeT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateConstantOfShape(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<ConstantOfShape> CreateConstantOfShape(flatbuffers::FlatBufferBuilder &_fbb, const ConstantOfShapeT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ConstantOfShapeT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _data_type = _o->data_type;
  auto _value = _o->value.size() ? _fbb.CreateVector(_o->value) : 0;
  return mindspore::schema::CreateConstantOfShape(
      _fbb,
      _data_type,
      _value);
}

inline CropT *Crop::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<CropT>(new CropT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Crop::UnPackTo(CropT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = axis(); _o->axis = _e; }
  { auto _e = offsets(); if (_e) { _o->offsets.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->offsets[_i] = _e->Get(_i); } } }
}

inline flatbuffers::Offset<Crop> Crop::Pack(flatbuffers::FlatBufferBuilder &_fbb, const CropT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateCrop(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Crop> CreateCrop(flatbuffers::FlatBufferBuilder &_fbb, const CropT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const CropT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _axis = _o->axis;
  auto _offsets = _o->offsets.size() ? _fbb.CreateVector(_o->offsets) : 0;
  return mindspore::schema::CreateCrop(
      _fbb,
      _axis,
      _offsets);
}

inline CustomExtractFeaturesT *CustomExtractFeatures::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<CustomExtractFeaturesT>(new CustomExtractFeaturesT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void CustomExtractFeatures::UnPackTo(CustomExtractFeaturesT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<CustomExtractFeatures> CustomExtractFeatures::Pack(flatbuffers::FlatBufferBuilder &_fbb, const CustomExtractFeaturesT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateCustomExtractFeatures(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<CustomExtractFeatures> CreateCustomExtractFeatures(flatbuffers::FlatBufferBuilder &_fbb, const CustomExtractFeaturesT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const CustomExtractFeaturesT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return mindspore::schema::CreateCustomExtractFeatures(
      _fbb);
}

inline CustomNormalizeT *CustomNormalize::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<CustomNormalizeT>(new CustomNormalizeT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void CustomNormalize::UnPackTo(CustomNormalizeT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<CustomNormalize> CustomNormalize::Pack(flatbuffers::FlatBufferBuilder &_fbb, const CustomNormalizeT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateCustomNormalize(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<CustomNormalize> CreateCustomNormalize(flatbuffers::FlatBufferBuilder &_fbb, const CustomNormalizeT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const CustomNormalizeT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return mindspore::schema::CreateCustomNormalize(
      _fbb);
}

inline CustomPredictT *CustomPredict::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<CustomPredictT>(new CustomPredictT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void CustomPredict::UnPackTo(CustomPredictT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = output_num(); _o->output_num = _e; }
  { auto _e = weight_threshold(); _o->weight_threshold = _e; }
}

inline flatbuffers::Offset<CustomPredict> CustomPredict::Pack(flatbuffers::FlatBufferBuilder &_fbb, const CustomPredictT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateCustomPredict(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<CustomPredict> CreateCustomPredict(flatbuffers::FlatBufferBuilder &_fbb, const CustomPredictT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const CustomPredictT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _output_num = _o->output_num;
  auto _weight_threshold = _o->weight_threshold;
  return mindspore::schema::CreateCustomPredict(
      _fbb,
      _output_num,
      _weight_threshold);
}

inline DeConv2DGradFilterT *DeConv2DGradFilter::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<DeConv2DGradFilterT>(new DeConv2DGradFilterT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void DeConv2DGradFilter::UnPackTo(DeConv2DGradFilterT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = in_channel(); _o->in_channel = _e; }
  { auto _e = out_channel(); _o->out_channel = _e; }
  { auto _e = kernel_size(); if (_e) { _o->kernel_size.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->kernel_size[_i] = _e->Get(_i); } } }
  { auto _e = pad_mode(); _o->pad_mode = _e; }
  { auto _e = pad_list(); if (_e) { _o->pad_list.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->pad_list[_i] = _e->Get(_i); } } }
  { auto _e = stride(); if (_e) { _o->stride.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->stride[_i] = _e->Get(_i); } } }
  { auto _e = dilation(); if (_e) { _o->dilation.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->dilation[_i] = _e->Get(_i); } } }
  { auto _e = group(); _o->group = _e; }
  { auto _e = format(); _o->format = _e; }
  { auto _e = activation_type(); _o->activation_type = _e; }
}

inline flatbuffers::Offset<DeConv2DGradFilter> DeConv2DGradFilter::Pack(flatbuffers::FlatBufferBuilder &_fbb, const DeConv2DGradFilterT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateDeConv2DGradFilter(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<DeConv2DGradFilter> CreateDeConv2DGradFilter(flatbuffers::FlatBufferBuilder &_fbb, const DeConv2DGradFilterT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const DeConv2DGradFilterT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _in_channel = _o->in_channel;
  auto _out_channel = _o->out_channel;
  auto _kernel_size = _o->kernel_size.size() ? _fbb.CreateVector(_o->kernel_size) : 0;
  auto _pad_mode = _o->pad_mode;
  auto _pad_list = _o->pad_list.size() ? _fbb.CreateVector(_o->pad_list) : 0;
  auto _stride = _o->stride.size() ? _fbb.CreateVector(_o->stride) : 0;
  auto _dilation = _o->dilation.size() ? _fbb.CreateVector(_o->dilation) : 0;
  auto _group = _o->group;
  auto _format = _o->format;
  auto _activation_type = _o->activation_type;
  return mindspore::schema::CreateDeConv2DGradFilter(
      _fbb,
      _in_channel,
      _out_channel,
      _kernel_size,
      _pad_mode,
      _pad_list,
      _stride,
      _dilation,
      _group,
      _format,
      _activation_type);
}

inline DependT *Depend::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<DependT>(new DependT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Depend::UnPackTo(DependT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<Depend> Depend::Pack(flatbuffers::FlatBufferBuilder &_fbb, const DependT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateDepend(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Depend> CreateDepend(flatbuffers::FlatBufferBuilder &_fbb, const DependT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const DependT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return mindspore::schema::CreateDepend(
      _fbb);
}

inline DepthToSpaceT *DepthToSpace::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<DepthToSpaceT>(new DepthToSpaceT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void DepthToSpace::UnPackTo(DepthToSpaceT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = block_size(); _o->block_size = _e; }
  { auto _e = format(); _o->format = _e; }
}

inline flatbuffers::Offset<DepthToSpace> DepthToSpace::Pack(flatbuffers::FlatBufferBuilder &_fbb, const DepthToSpaceT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateDepthToSpace(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<DepthToSpace> CreateDepthToSpace(flatbuffers::FlatBufferBuilder &_fbb, const DepthToSpaceT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const DepthToSpaceT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _block_size = _o->block_size;
  auto _format = _o->format;
  return mindspore::schema::CreateDepthToSpace(
      _fbb,
      _block_size,
      _format);
}

inline DetectionPostProcessT *DetectionPostProcess::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<DetectionPostProcessT>(new DetectionPostProcessT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void DetectionPostProcess::UnPackTo(DetectionPostProcessT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = format(); _o->format = _e; }
  { auto _e = input_size(); _o->input_size = _e; }
  { auto _e = scale(); if (_e) { _o->scale.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->scale[_i] = _e->Get(_i); } } }
  { auto _e = nms_iou_threshold(); _o->nms_iou_threshold = _e; }
  { auto _e = nms_score_threshold(); _o->nms_score_threshold = _e; }
  { auto _e = max_detections(); _o->max_detections = _e; }
  { auto _e = detections_per_class(); _o->detections_per_class = _e; }
  { auto _e = max_classes_per_detection(); _o->max_classes_per_detection = _e; }
  { auto _e = num_classes(); _o->num_classes = _e; }
  { auto _e = use_regular_nms(); _o->use_regular_nms = _e; }
  { auto _e = out_quantized(); _o->out_quantized = _e; }
}

inline flatbuffers::Offset<DetectionPostProcess> DetectionPostProcess::Pack(flatbuffers::FlatBufferBuilder &_fbb, const DetectionPostProcessT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateDetectionPostProcess(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<DetectionPostProcess> CreateDetectionPostProcess(flatbuffers::FlatBufferBuilder &_fbb, const DetectionPostProcessT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const DetectionPostProcessT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _format = _o->format;
  auto _input_size = _o->input_size;
  auto _scale = _o->scale.size() ? _fbb.CreateVector(_o->scale) : 0;
  auto _nms_iou_threshold = _o->nms_iou_threshold;
  auto _nms_score_threshold = _o->nms_score_threshold;
  auto _max_detections = _o->max_detections;
  auto _detections_per_class = _o->detections_per_class;
  auto _max_classes_per_detection = _o->max_classes_per_detection;
  auto _num_classes = _o->num_classes;
  auto _use_regular_nms = _o->use_regular_nms;
  auto _out_quantized = _o->out_quantized;
  return mindspore::schema::CreateDetectionPostProcess(
      _fbb,
      _format,
      _input_size,
      _scale,
      _nms_iou_threshold,
      _nms_score_threshold,
      _max_detections,
      _detections_per_class,
      _max_classes_per_detection,
      _num_classes,
      _use_regular_nms,
      _out_quantized);
}

inline DivFusionT *DivFusion::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<DivFusionT>(new DivFusionT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void DivFusion::UnPackTo(DivFusionT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = activation_type(); _o->activation_type = _e; }
}

inline flatbuffers::Offset<DivFusion> DivFusion::Pack(flatbuffers::FlatBufferBuilder &_fbb, const DivFusionT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateDivFusion(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<DivFusion> CreateDivFusion(flatbuffers::FlatBufferBuilder &_fbb, const DivFusionT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const DivFusionT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _activation_type = _o->activation_type;
  return mindspore::schema::CreateDivFusion(
      _fbb,
      _activation_type);
}

inline DivGradT *DivGrad::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<DivGradT>(new DivGradT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void DivGrad::UnPackTo(DivGradT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<DivGrad> DivGrad::Pack(flatbuffers::FlatBufferBuilder &_fbb, const DivGradT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateDivGrad(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<DivGrad> CreateDivGrad(flatbuffers::FlatBufferBuilder &_fbb, const DivGradT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const DivGradT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return mindspore::schema::CreateDivGrad(
      _fbb);
}

inline DropoutT *Dropout::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<DropoutT>(new DropoutT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Dropout::UnPackTo(DropoutT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = keep_prob(); _o->keep_prob = _e; }
}

inline flatbuffers::Offset<Dropout> Dropout::Pack(flatbuffers::FlatBufferBuilder &_fbb, const DropoutT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateDropout(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Dropout> CreateDropout(flatbuffers::FlatBufferBuilder &_fbb, const DropoutT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const DropoutT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _keep_prob = _o->keep_prob;
  return mindspore::schema::CreateDropout(
      _fbb,
      _keep_prob);
}

inline DropoutGradT *DropoutGrad::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<DropoutGradT>(new DropoutGradT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void DropoutGrad::UnPackTo(DropoutGradT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = keep_prob(); _o->keep_prob = _e; }
}

inline flatbuffers::Offset<DropoutGrad> DropoutGrad::Pack(flatbuffers::FlatBufferBuilder &_fbb, const DropoutGradT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateDropoutGrad(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<DropoutGrad> CreateDropoutGrad(flatbuffers::FlatBufferBuilder &_fbb, const DropoutGradT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const DropoutGradT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _keep_prob = _o->keep_prob;
  return mindspore::schema::CreateDropoutGrad(
      _fbb,
      _keep_prob);
}

inline EluT *Elu::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<EluT>(new EluT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Elu::UnPackTo(EluT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = alpha(); _o->alpha = _e; }
}

inline flatbuffers::Offset<Elu> Elu::Pack(flatbuffers::FlatBufferBuilder &_fbb, const EluT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateElu(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Elu> CreateElu(flatbuffers::FlatBufferBuilder &_fbb, const EluT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const EluT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _alpha = _o->alpha;
  return mindspore::schema::CreateElu(
      _fbb,
      _alpha);
}

inline EltwiseT *Eltwise::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<EltwiseT>(new EltwiseT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Eltwise::UnPackTo(EltwiseT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = mode(); _o->mode = _e; }
}

inline flatbuffers::Offset<Eltwise> Eltwise::Pack(flatbuffers::FlatBufferBuilder &_fbb, const EltwiseT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateEltwise(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Eltwise> CreateEltwise(flatbuffers::FlatBufferBuilder &_fbb, const EltwiseT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const EltwiseT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _mode = _o->mode;
  return mindspore::schema::CreateEltwise(
      _fbb,
      _mode);
}

inline EqualT *Equal::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<EqualT>(new EqualT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Equal::UnPackTo(EqualT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<Equal> Equal::Pack(flatbuffers::FlatBufferBuilder &_fbb, const EqualT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateEqual(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Equal> CreateEqual(flatbuffers::FlatBufferBuilder &_fbb, const EqualT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const EqualT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return mindspore::schema::CreateEqual(
      _fbb);
}

inline EmbeddingLookupFusionT *EmbeddingLookupFusion::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<EmbeddingLookupFusionT>(new EmbeddingLookupFusionT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void EmbeddingLookupFusion::UnPackTo(EmbeddingLookupFusionT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = max_norm(); _o->max_norm = _e; }
}

inline flatbuffers::Offset<EmbeddingLookupFusion> EmbeddingLookupFusion::Pack(flatbuffers::FlatBufferBuilder &_fbb, const EmbeddingLookupFusionT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateEmbeddingLookupFusion(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<EmbeddingLookupFusion> CreateEmbeddingLookupFusion(flatbuffers::FlatBufferBuilder &_fbb, const EmbeddingLookupFusionT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const EmbeddingLookupFusionT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _max_norm = _o->max_norm;
  return mindspore::schema::CreateEmbeddingLookupFusion(
      _fbb,
      _max_norm);
}

inline ExpFusionT *ExpFusion::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<ExpFusionT>(new ExpFusionT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void ExpFusion::UnPackTo(ExpFusionT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = base(); _o->base = _e; }
  { auto _e = scale(); _o->scale = _e; }
  { auto _e = shift(); _o->shift = _e; }
}

inline flatbuffers::Offset<ExpFusion> ExpFusion::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ExpFusionT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateExpFusion(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<ExpFusion> CreateExpFusion(flatbuffers::FlatBufferBuilder &_fbb, const ExpFusionT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ExpFusionT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _base = _o->base;
  auto _scale = _o->scale;
  auto _shift = _o->shift;
  return mindspore::schema::CreateExpFusion(
      _fbb,
      _base,
      _scale,
      _shift);
}

inline ExpandDimsT *ExpandDims::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<ExpandDimsT>(new ExpandDimsT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void ExpandDims::UnPackTo(ExpandDimsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<ExpandDims> ExpandDims::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ExpandDimsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateExpandDims(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<ExpandDims> CreateExpandDims(flatbuffers::FlatBufferBuilder &_fbb, const ExpandDimsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ExpandDimsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return mindspore::schema::CreateExpandDims(
      _fbb);
}

inline FakeQuantWithMinMaxVarsT *FakeQuantWithMinMaxVars::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<FakeQuantWithMinMaxVarsT>(new FakeQuantWithMinMaxVarsT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void FakeQuantWithMinMaxVars::UnPackTo(FakeQuantWithMinMaxVarsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = num_bits(); _o->num_bits = _e; }
  { auto _e = narrow_range(); _o->narrow_range = _e; }
}

inline flatbuffers::Offset<FakeQuantWithMinMaxVars> FakeQuantWithMinMaxVars::Pack(flatbuffers::FlatBufferBuilder &_fbb, const FakeQuantWithMinMaxVarsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateFakeQuantWithMinMaxVars(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<FakeQuantWithMinMaxVars> CreateFakeQuantWithMinMaxVars(flatbuffers::FlatBufferBuilder &_fbb, const FakeQuantWithMinMaxVarsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const FakeQuantWithMinMaxVarsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _num_bits = _o->num_bits;
  auto _narrow_range = _o->narrow_range;
  return mindspore::schema::CreateFakeQuantWithMinMaxVars(
      _fbb,
      _num_bits,
      _narrow_range);
}

inline FakeQuantWithMinMaxVarsPerChannelT *FakeQuantWithMinMaxVarsPerChannel::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<FakeQuantWithMinMaxVarsPerChannelT>(new FakeQuantWithMinMaxVarsPerChannelT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void FakeQuantWithMinMaxVarsPerChannel::UnPackTo(FakeQuantWithMinMaxVarsPerChannelT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = num_bits(); _o->num_bits = _e; }
  { auto _e = narrow_range(); _o->narrow_range = _e; }
}

inline flatbuffers::Offset<FakeQuantWithMinMaxVarsPerChannel> FakeQuantWithMinMaxVarsPerChannel::Pack(flatbuffers::FlatBufferBuilder &_fbb, const FakeQuantWithMinMaxVarsPerChannelT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateFakeQuantWithMinMaxVarsPerChannel(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<FakeQuantWithMinMaxVarsPerChannel> CreateFakeQuantWithMinMaxVarsPerChannel(flatbuffers::FlatBufferBuilder &_fbb, const FakeQuantWithMinMaxVarsPerChannelT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const FakeQuantWithMinMaxVarsPerChannelT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _num_bits = _o->num_bits;
  auto _narrow_range = _o->narrow_range;
  return mindspore::schema::CreateFakeQuantWithMinMaxVarsPerChannel(
      _fbb,
      _num_bits,
      _narrow_range);
}

inline FftRealT *FftReal::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<FftRealT>(new FftRealT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void FftReal::UnPackTo(FftRealT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<FftReal> FftReal::Pack(flatbuffers::FlatBufferBuilder &_fbb, const FftRealT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateFftReal(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<FftReal> CreateFftReal(flatbuffers::FlatBufferBuilder &_fbb, const FftRealT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const FftRealT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return mindspore::schema::CreateFftReal(
      _fbb);
}

inline FftImagT *FftImag::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<FftImagT>(new FftImagT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void FftImag::UnPackTo(FftImagT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<FftImag> FftImag::Pack(flatbuffers::FlatBufferBuilder &_fbb, const FftImagT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateFftImag(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<FftImag> CreateFftImag(flatbuffers::FlatBufferBuilder &_fbb, const FftImagT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const FftImagT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return mindspore::schema::CreateFftImag(
      _fbb);
}

inline FlattenT *Flatten::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<FlattenT>(new FlattenT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Flatten::UnPackTo(FlattenT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<Flatten> Flatten::Pack(flatbuffers::FlatBufferBuilder &_fbb, const FlattenT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateFlatten(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Flatten> CreateFlatten(flatbuffers::FlatBufferBuilder &_fbb, const FlattenT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const FlattenT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return mindspore::schema::CreateFlatten(
      _fbb);
}

inline FlattenGradT *FlattenGrad::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<FlattenGradT>(new FlattenGradT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void FlattenGrad::UnPackTo(FlattenGradT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<FlattenGrad> FlattenGrad::Pack(flatbuffers::FlatBufferBuilder &_fbb, const FlattenGradT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateFlattenGrad(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<FlattenGrad> CreateFlattenGrad(flatbuffers::FlatBufferBuilder &_fbb, const FlattenGradT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const FlattenGradT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return mindspore::schema::CreateFlattenGrad(
      _fbb);
}

inline FloorT *Floor::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<FloorT>(new FloorT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Floor::UnPackTo(FloorT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<Floor> Floor::Pack(flatbuffers::FlatBufferBuilder &_fbb, const FloorT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateFloor(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Floor> CreateFloor(flatbuffers::FlatBufferBuilder &_fbb, const FloorT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const FloorT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return mindspore::schema::CreateFloor(
      _fbb);
}

inline FloorDivT *FloorDiv::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<FloorDivT>(new FloorDivT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void FloorDiv::UnPackTo(FloorDivT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<FloorDiv> FloorDiv::Pack(flatbuffers::FlatBufferBuilder &_fbb, const FloorDivT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateFloorDiv(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<FloorDiv> CreateFloorDiv(flatbuffers::FlatBufferBuilder &_fbb, const FloorDivT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const FloorDivT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return mindspore::schema::CreateFloorDiv(
      _fbb);
}

inline FloorModT *FloorMod::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<FloorModT>(new FloorModT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void FloorMod::UnPackTo(FloorModT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<FloorMod> FloorMod::Pack(flatbuffers::FlatBufferBuilder &_fbb, const FloorModT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateFloorMod(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<FloorMod> CreateFloorMod(flatbuffers::FlatBufferBuilder &_fbb, const FloorModT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const FloorModT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return mindspore::schema::CreateFloorMod(
      _fbb);
}

inline FillT *Fill::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<FillT>(new FillT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Fill::UnPackTo(FillT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<Fill> Fill::Pack(flatbuffers::FlatBufferBuilder &_fbb, const FillT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateFill(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Fill> CreateFill(flatbuffers::FlatBufferBuilder &_fbb, const FillT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const FillT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return mindspore::schema::CreateFill(
      _fbb);
}

inline FullConnectionT *FullConnection::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<FullConnectionT>(new FullConnectionT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void FullConnection::UnPackTo(FullConnectionT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = has_bias(); _o->has_bias = _e; }
  { auto _e = use_axis(); _o->use_axis = _e; }
  { auto _e = axis(); _o->axis = _e; }
  { auto _e = activation_type(); _o->activation_type = _e; }
}

inline flatbuffers::Offset<FullConnection> FullConnection::Pack(flatbuffers::FlatBufferBuilder &_fbb, const FullConnectionT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateFullConnection(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<FullConnection> CreateFullConnection(flatbuffers::FlatBufferBuilder &_fbb, const FullConnectionT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const FullConnectionT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _has_bias = _o->has_bias;
  auto _use_axis = _o->use_axis;
  auto _axis = _o->axis;
  auto _activation_type = _o->activation_type;
  return mindspore::schema::CreateFullConnection(
      _fbb,
      _has_bias,
      _use_axis,
      _axis,
      _activation_type);
}

inline FusedBatchNormT *FusedBatchNorm::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<FusedBatchNormT>(new FusedBatchNormT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void FusedBatchNorm::UnPackTo(FusedBatchNormT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = epsilon(); _o->epsilon = _e; }
  { auto _e = momentum(); _o->momentum = _e; }
  { auto _e = mode(); _o->mode = _e; }
}

inline flatbuffers::Offset<FusedBatchNorm> FusedBatchNorm::Pack(flatbuffers::FlatBufferBuilder &_fbb, const FusedBatchNormT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateFusedBatchNorm(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<FusedBatchNorm> CreateFusedBatchNorm(flatbuffers::FlatBufferBuilder &_fbb, const FusedBatchNormT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const FusedBatchNormT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _epsilon = _o->epsilon;
  auto _momentum = _o->momentum;
  auto _mode = _o->mode;
  return mindspore::schema::CreateFusedBatchNorm(
      _fbb,
      _epsilon,
      _momentum,
      _mode);
}

inline GatherT *Gather::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<GatherT>(new GatherT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Gather::UnPackTo(GatherT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<Gather> Gather::Pack(flatbuffers::FlatBufferBuilder &_fbb, const GatherT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateGather(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Gather> CreateGather(flatbuffers::FlatBufferBuilder &_fbb, const GatherT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const GatherT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return mindspore::schema::CreateGather(
      _fbb);
}

inline GatherNdT *GatherNd::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<GatherNdT>(new GatherNdT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void GatherNd::UnPackTo(GatherNdT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<GatherNd> GatherNd::Pack(flatbuffers::FlatBufferBuilder &_fbb, const GatherNdT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateGatherNd(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<GatherNd> CreateGatherNd(flatbuffers::FlatBufferBuilder &_fbb, const GatherNdT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const GatherNdT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return mindspore::schema::CreateGatherNd(
      _fbb);
}

inline GreaterT *Greater::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<GreaterT>(new GreaterT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Greater::UnPackTo(GreaterT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<Greater> Greater::Pack(flatbuffers::FlatBufferBuilder &_fbb, const GreaterT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateGreater(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Greater> CreateGreater(flatbuffers::FlatBufferBuilder &_fbb, const GreaterT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const GreaterT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return mindspore::schema::CreateGreater(
      _fbb);
}

inline GreaterEqualT *GreaterEqual::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<GreaterEqualT>(new GreaterEqualT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void GreaterEqual::UnPackTo(GreaterEqualT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<GreaterEqual> GreaterEqual::Pack(flatbuffers::FlatBufferBuilder &_fbb, const GreaterEqualT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateGreaterEqual(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<GreaterEqual> CreateGreaterEqual(flatbuffers::FlatBufferBuilder &_fbb, const GreaterEqualT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const GreaterEqualT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return mindspore::schema::CreateGreaterEqual(
      _fbb);
}

inline HashtableLookupT *HashtableLookup::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<HashtableLookupT>(new HashtableLookupT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void HashtableLookup::UnPackTo(HashtableLookupT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<HashtableLookup> HashtableLookup::Pack(flatbuffers::FlatBufferBuilder &_fbb, const HashtableLookupT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateHashtableLookup(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<HashtableLookup> CreateHashtableLookup(flatbuffers::FlatBufferBuilder &_fbb, const HashtableLookupT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const HashtableLookupT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return mindspore::schema::CreateHashtableLookup(
      _fbb);
}

inline InstanceNormT *InstanceNorm::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<InstanceNormT>(new InstanceNormT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void InstanceNorm::UnPackTo(InstanceNormT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = epsilon(); _o->epsilon = _e; }
}

inline flatbuffers::Offset<InstanceNorm> InstanceNorm::Pack(flatbuffers::FlatBufferBuilder &_fbb, const InstanceNormT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateInstanceNorm(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<InstanceNorm> CreateInstanceNorm(flatbuffers::FlatBufferBuilder &_fbb, const InstanceNormT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const InstanceNormT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _epsilon = _o->epsilon;
  return mindspore::schema::CreateInstanceNorm(
      _fbb,
      _epsilon);
}

inline LayerNormFusionT *LayerNormFusion::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<LayerNormFusionT>(new LayerNormFusionT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void LayerNormFusion::UnPackTo(LayerNormFusionT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = begin_norm_axis(); _o->begin_norm_axis = _e; }
  { auto _e = epsilon(); _o->epsilon = _e; }
  { auto _e = elementwise_affine(); _o->elementwise_affine = _e; }
  { auto _e = begin_params_axis(); _o->begin_params_axis = _e; }
}

inline flatbuffers::Offset<LayerNormFusion> LayerNormFusion::Pack(flatbuffers::FlatBufferBuilder &_fbb, const LayerNormFusionT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateLayerNormFusion(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<LayerNormFusion> CreateLayerNormFusion(flatbuffers::FlatBufferBuilder &_fbb, const LayerNormFusionT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const LayerNormFusionT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _begin_norm_axis = _o->begin_norm_axis;
  auto _epsilon = _o->epsilon;
  auto _elementwise_affine = _o->elementwise_affine;
  auto _begin_params_axis = _o->begin_params_axis;
  return mindspore::schema::CreateLayerNormFusion(
      _fbb,
      _begin_norm_axis,
      _epsilon,
      _elementwise_affine,
      _begin_params_axis);
}

inline LeakyReluT *LeakyRelu::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<LeakyReluT>(new LeakyReluT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void LeakyRelu::UnPackTo(LeakyReluT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = negative_slope(); _o->negative_slope = _e; }
}

inline flatbuffers::Offset<LeakyRelu> LeakyRelu::Pack(flatbuffers::FlatBufferBuilder &_fbb, const LeakyReluT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateLeakyRelu(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<LeakyRelu> CreateLeakyRelu(flatbuffers::FlatBufferBuilder &_fbb, const LeakyReluT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const LeakyReluT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _negative_slope = _o->negative_slope;
  return mindspore::schema::CreateLeakyRelu(
      _fbb,
      _negative_slope);
}

inline LessT *Less::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<LessT>(new LessT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Less::UnPackTo(LessT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<Less> Less::Pack(flatbuffers::FlatBufferBuilder &_fbb, const LessT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateLess(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Less> CreateLess(flatbuffers::FlatBufferBuilder &_fbb, const LessT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const LessT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return mindspore::schema::CreateLess(
      _fbb);
}

inline LessEqualT *LessEqual::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<LessEqualT>(new LessEqualT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void LessEqual::UnPackTo(LessEqualT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<LessEqual> LessEqual::Pack(flatbuffers::FlatBufferBuilder &_fbb, const LessEqualT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateLessEqual(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<LessEqual> CreateLessEqual(flatbuffers::FlatBufferBuilder &_fbb, const LessEqualT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const LessEqualT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return mindspore::schema::CreateLessEqual(
      _fbb);
}

inline LogT *Log::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<LogT>(new LogT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Log::UnPackTo(LogT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<Log> Log::Pack(flatbuffers::FlatBufferBuilder &_fbb, const LogT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateLog(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Log> CreateLog(flatbuffers::FlatBufferBuilder &_fbb, const LogT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const LogT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return mindspore::schema::CreateLog(
      _fbb);
}

inline LogGradT *LogGrad::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<LogGradT>(new LogGradT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void LogGrad::UnPackTo(LogGradT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<LogGrad> LogGrad::Pack(flatbuffers::FlatBufferBuilder &_fbb, const LogGradT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateLogGrad(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<LogGrad> CreateLogGrad(flatbuffers::FlatBufferBuilder &_fbb, const LogGradT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const LogGradT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return mindspore::schema::CreateLogGrad(
      _fbb);
}

inline LogicalAndT *LogicalAnd::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<LogicalAndT>(new LogicalAndT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void LogicalAnd::UnPackTo(LogicalAndT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<LogicalAnd> LogicalAnd::Pack(flatbuffers::FlatBufferBuilder &_fbb, const LogicalAndT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateLogicalAnd(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<LogicalAnd> CreateLogicalAnd(flatbuffers::FlatBufferBuilder &_fbb, const LogicalAndT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const LogicalAndT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return mindspore::schema::CreateLogicalAnd(
      _fbb);
}

inline LogicalNotT *LogicalNot::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<LogicalNotT>(new LogicalNotT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void LogicalNot::UnPackTo(LogicalNotT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<LogicalNot> LogicalNot::Pack(flatbuffers::FlatBufferBuilder &_fbb, const LogicalNotT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateLogicalNot(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<LogicalNot> CreateLogicalNot(flatbuffers::FlatBufferBuilder &_fbb, const LogicalNotT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const LogicalNotT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return mindspore::schema::CreateLogicalNot(
      _fbb);
}

inline LogicalOrT *LogicalOr::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<LogicalOrT>(new LogicalOrT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void LogicalOr::UnPackTo(LogicalOrT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<LogicalOr> LogicalOr::Pack(flatbuffers::FlatBufferBuilder &_fbb, const LogicalOrT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateLogicalOr(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<LogicalOr> CreateLogicalOr(flatbuffers::FlatBufferBuilder &_fbb, const LogicalOrT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const LogicalOrT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return mindspore::schema::CreateLogicalOr(
      _fbb);
}

inline LpNormalizationT *LpNormalization::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<LpNormalizationT>(new LpNormalizationT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void LpNormalization::UnPackTo(LpNormalizationT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = axis(); _o->axis = _e; }
  { auto _e = p(); _o->p = _e; }
}

inline flatbuffers::Offset<LpNormalization> LpNormalization::Pack(flatbuffers::FlatBufferBuilder &_fbb, const LpNormalizationT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateLpNormalization(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<LpNormalization> CreateLpNormalization(flatbuffers::FlatBufferBuilder &_fbb, const LpNormalizationT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const LpNormalizationT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _axis = _o->axis;
  auto _p = _o->p;
  return mindspore::schema::CreateLpNormalization(
      _fbb,
      _axis,
      _p);
}

inline LRNT *LRN::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<LRNT>(new LRNT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void LRN::UnPackTo(LRNT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = depth_radius(); _o->depth_radius = _e; }
  { auto _e = bias(); _o->bias = _e; }
  { auto _e = alpha(); _o->alpha = _e; }
  { auto _e = beta(); _o->beta = _e; }
  { auto _e = norm_region(); if (_e) _o->norm_region = _e->str(); }
}

inline flatbuffers::Offset<LRN> LRN::Pack(flatbuffers::FlatBufferBuilder &_fbb, const LRNT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateLRN(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<LRN> CreateLRN(flatbuffers::FlatBufferBuilder &_fbb, const LRNT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const LRNT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _depth_radius = _o->depth_radius;
  auto _bias = _o->bias;
  auto _alpha = _o->alpha;
  auto _beta = _o->beta;
  auto _norm_region = _o->norm_region.empty() ? 0 : _fbb.CreateString(_o->norm_region);
  return mindspore::schema::CreateLRN(
      _fbb,
      _depth_radius,
      _bias,
      _alpha,
      _beta,
      _norm_region);
}

inline LshProjectionT *LshProjection::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<LshProjectionT>(new LshProjectionT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void LshProjection::UnPackTo(LshProjectionT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = type(); _o->type = _e; }
}

inline flatbuffers::Offset<LshProjection> LshProjection::Pack(flatbuffers::FlatBufferBuilder &_fbb, const LshProjectionT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateLshProjection(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<LshProjection> CreateLshProjection(flatbuffers::FlatBufferBuilder &_fbb, const LshProjectionT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const LshProjectionT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _type = _o->type;
  return mindspore::schema::CreateLshProjection(
      _fbb,
      _type);
}

inline LSTMT *LSTM::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<LSTMT>(new LSTMT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void LSTM::UnPackTo(LSTMT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = bidirectional(); _o->bidirectional = _e; }
  { auto _e = has_bias(); _o->has_bias = _e; }
  { auto _e = input_size(); _o->input_size = _e; }
  { auto _e = hidden_size(); _o->hidden_size = _e; }
  { auto _e = num_layers(); _o->num_layers = _e; }
  { auto _e = num_directions(); _o->num_directions = _e; }
  { auto _e = dropout(); _o->dropout = _e; }
  { auto _e = zoneout_cell(); _o->zoneout_cell = _e; }
  { auto _e = zoneout_hidden(); _o->zoneout_hidden = _e; }
}

inline flatbuffers::Offset<LSTM> LSTM::Pack(flatbuffers::FlatBufferBuilder &_fbb, const LSTMT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateLSTM(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<LSTM> CreateLSTM(flatbuffers::FlatBufferBuilder &_fbb, const LSTMT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const LSTMT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _bidirectional = _o->bidirectional;
  auto _has_bias = _o->has_bias;
  auto _input_size = _o->input_size;
  auto _hidden_size = _o->hidden_size;
  auto _num_layers = _o->num_layers;
  auto _num_directions = _o->num_directions;
  auto _dropout = _o->dropout;
  auto _zoneout_cell = _o->zoneout_cell;
  auto _zoneout_hidden = _o->zoneout_hidden;
  return mindspore::schema::CreateLSTM(
      _fbb,
      _bidirectional,
      _has_bias,
      _input_size,
      _hidden_size,
      _num_layers,
      _num_directions,
      _dropout,
      _zoneout_cell,
      _zoneout_hidden);
}

inline LSTMGradT *LSTMGrad::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<LSTMGradT>(new LSTMGradT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void LSTMGrad::UnPackTo(LSTMGradT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = bidirectional(); _o->bidirectional = _e; }
  { auto _e = has_bias(); _o->has_bias = _e; }
  { auto _e = input_size(); _o->input_size = _e; }
  { auto _e = hidden_size(); _o->hidden_size = _e; }
  { auto _e = num_layers(); _o->num_layers = _e; }
  { auto _e = num_directions(); _o->num_directions = _e; }
  { auto _e = dropout(); _o->dropout = _e; }
  { auto _e = zoneout_cell(); _o->zoneout_cell = _e; }
  { auto _e = zoneout_hidden(); _o->zoneout_hidden = _e; }
}

inline flatbuffers::Offset<LSTMGrad> LSTMGrad::Pack(flatbuffers::FlatBufferBuilder &_fbb, const LSTMGradT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateLSTMGrad(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<LSTMGrad> CreateLSTMGrad(flatbuffers::FlatBufferBuilder &_fbb, const LSTMGradT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const LSTMGradT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _bidirectional = _o->bidirectional;
  auto _has_bias = _o->has_bias;
  auto _input_size = _o->input_size;
  auto _hidden_size = _o->hidden_size;
  auto _num_layers = _o->num_layers;
  auto _num_directions = _o->num_directions;
  auto _dropout = _o->dropout;
  auto _zoneout_cell = _o->zoneout_cell;
  auto _zoneout_hidden = _o->zoneout_hidden;
  return mindspore::schema::CreateLSTMGrad(
      _fbb,
      _bidirectional,
      _has_bias,
      _input_size,
      _hidden_size,
      _num_layers,
      _num_directions,
      _dropout,
      _zoneout_cell,
      _zoneout_hidden);
}

inline L2NormalizeFusionT *L2NormalizeFusion::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<L2NormalizeFusionT>(new L2NormalizeFusionT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void L2NormalizeFusion::UnPackTo(L2NormalizeFusionT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = axis(); if (_e) { _o->axis.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->axis[_i] = _e->Get(_i); } } }
  { auto _e = epsilon(); _o->epsilon = _e; }
  { auto _e = activation_type(); _o->activation_type = _e; }
}

inline flatbuffers::Offset<L2NormalizeFusion> L2NormalizeFusion::Pack(flatbuffers::FlatBufferBuilder &_fbb, const L2NormalizeFusionT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateL2NormalizeFusion(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<L2NormalizeFusion> CreateL2NormalizeFusion(flatbuffers::FlatBufferBuilder &_fbb, const L2NormalizeFusionT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const L2NormalizeFusionT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _axis = _o->axis.size() ? _fbb.CreateVector(_o->axis) : 0;
  auto _epsilon = _o->epsilon;
  auto _activation_type = _o->activation_type;
  return mindspore::schema::CreateL2NormalizeFusion(
      _fbb,
      _axis,
      _epsilon,
      _activation_type);
}

inline MatMulFusionT *MatMulFusion::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<MatMulFusionT>(new MatMulFusionT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void MatMulFusion::UnPackTo(MatMulFusionT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = transpose_a(); _o->transpose_a = _e; }
  { auto _e = transpose_b(); _o->transpose_b = _e; }
  { auto _e = activation_type(); _o->activation_type = _e; }
}

inline flatbuffers::Offset<MatMulFusion> MatMulFusion::Pack(flatbuffers::FlatBufferBuilder &_fbb, const MatMulFusionT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateMatMulFusion(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<MatMulFusion> CreateMatMulFusion(flatbuffers::FlatBufferBuilder &_fbb, const MatMulFusionT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const MatMulFusionT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _transpose_a = _o->transpose_a;
  auto _transpose_b = _o->transpose_b;
  auto _activation_type = _o->activation_type;
  return mindspore::schema::CreateMatMulFusion(
      _fbb,
      _transpose_a,
      _transpose_b,
      _activation_type);
}

inline MaximumT *Maximum::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<MaximumT>(new MaximumT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Maximum::UnPackTo(MaximumT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<Maximum> Maximum::Pack(flatbuffers::FlatBufferBuilder &_fbb, const MaximumT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateMaximum(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Maximum> CreateMaximum(flatbuffers::FlatBufferBuilder &_fbb, const MaximumT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const MaximumT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return mindspore::schema::CreateMaximum(
      _fbb);
}

inline MaximumGradT *MaximumGrad::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<MaximumGradT>(new MaximumGradT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void MaximumGrad::UnPackTo(MaximumGradT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = grad_x(); _o->grad_x = _e; }
  { auto _e = grad_y(); _o->grad_y = _e; }
}

inline flatbuffers::Offset<MaximumGrad> MaximumGrad::Pack(flatbuffers::FlatBufferBuilder &_fbb, const MaximumGradT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateMaximumGrad(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<MaximumGrad> CreateMaximumGrad(flatbuffers::FlatBufferBuilder &_fbb, const MaximumGradT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const MaximumGradT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _grad_x = _o->grad_x;
  auto _grad_y = _o->grad_y;
  return mindspore::schema::CreateMaximumGrad(
      _fbb,
      _grad_x,
      _grad_y);
}

inline MaxPoolFusionT *MaxPoolFusion::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<MaxPoolFusionT>(new MaxPoolFusionT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void MaxPoolFusion::UnPackTo(MaxPoolFusionT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = kernel_size(); if (_e) { _o->kernel_size.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->kernel_size[_i] = _e->Get(_i); } } }
  { auto _e = strides(); if (_e) { _o->strides.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->strides[_i] = _e->Get(_i); } } }
  { auto _e = pad(); if (_e) { _o->pad.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->pad[_i] = _e->Get(_i); } } }
  { auto _e = pad_mode(); _o->pad_mode = _e; }
  { auto _e = round_mode(); _o->round_mode = _e; }
  { auto _e = format(); _o->format = _e; }
  { auto _e = global(); _o->global = _e; }
  { auto _e = activation_type(); _o->activation_type = _e; }
}

inline flatbuffers::Offset<MaxPoolFusion> MaxPoolFusion::Pack(flatbuffers::FlatBufferBuilder &_fbb, const MaxPoolFusionT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateMaxPoolFusion(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<MaxPoolFusion> CreateMaxPoolFusion(flatbuffers::FlatBufferBuilder &_fbb, const MaxPoolFusionT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const MaxPoolFusionT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _kernel_size = _o->kernel_size.size() ? _fbb.CreateVector(_o->kernel_size) : 0;
  auto _strides = _o->strides.size() ? _fbb.CreateVector(_o->strides) : 0;
  auto _pad = _o->pad.size() ? _fbb.CreateVector(_o->pad) : 0;
  auto _pad_mode = _o->pad_mode;
  auto _round_mode = _o->round_mode;
  auto _format = _o->format;
  auto _global = _o->global;
  auto _activation_type = _o->activation_type;
  return mindspore::schema::CreateMaxPoolFusion(
      _fbb,
      _kernel_size,
      _strides,
      _pad,
      _pad_mode,
      _round_mode,
      _format,
      _global,
      _activation_type);
}

inline MaxPoolGradT *MaxPoolGrad::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<MaxPoolGradT>(new MaxPoolGradT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void MaxPoolGrad::UnPackTo(MaxPoolGradT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = kernel_size(); if (_e) { _o->kernel_size.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->kernel_size[_i] = _e->Get(_i); } } }
  { auto _e = strides(); if (_e) { _o->strides.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->strides[_i] = _e->Get(_i); } } }
  { auto _e = pad_mode(); _o->pad_mode = _e; }
  { auto _e = format(); _o->format = _e; }
}

inline flatbuffers::Offset<MaxPoolGrad> MaxPoolGrad::Pack(flatbuffers::FlatBufferBuilder &_fbb, const MaxPoolGradT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateMaxPoolGrad(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<MaxPoolGrad> CreateMaxPoolGrad(flatbuffers::FlatBufferBuilder &_fbb, const MaxPoolGradT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const MaxPoolGradT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _kernel_size = _o->kernel_size.size() ? _fbb.CreateVector(_o->kernel_size) : 0;
  auto _strides = _o->strides.size() ? _fbb.CreateVector(_o->strides) : 0;
  auto _pad_mode = _o->pad_mode;
  auto _format = _o->format;
  return mindspore::schema::CreateMaxPoolGrad(
      _fbb,
      _kernel_size,
      _strides,
      _pad_mode,
      _format);
}

inline MergeT *Merge::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<MergeT>(new MergeT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Merge::UnPackTo(MergeT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<Merge> Merge::Pack(flatbuffers::FlatBufferBuilder &_fbb, const MergeT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateMerge(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Merge> CreateMerge(flatbuffers::FlatBufferBuilder &_fbb, const MergeT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const MergeT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return mindspore::schema::CreateMerge(
      _fbb);
}

inline MfccT *Mfcc::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<MfccT>(new MfccT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Mfcc::UnPackTo(MfccT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = freq_upper_limit(); _o->freq_upper_limit = _e; }
  { auto _e = freq_lower_limit(); _o->freq_lower_limit = _e; }
  { auto _e = filter_bank_channel_num(); _o->filter_bank_channel_num = _e; }
  { auto _e = dct_coeff_num(); _o->dct_coeff_num = _e; }
}

inline flatbuffers::Offset<Mfcc> Mfcc::Pack(flatbuffers::FlatBufferBuilder &_fbb, const MfccT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateMfcc(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Mfcc> CreateMfcc(flatbuffers::FlatBufferBuilder &_fbb, const MfccT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const MfccT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _freq_upper_limit = _o->freq_upper_limit;
  auto _freq_lower_limit = _o->freq_lower_limit;
  auto _filter_bank_channel_num = _o->filter_bank_channel_num;
  auto _dct_coeff_num = _o->dct_coeff_num;
  return mindspore::schema::CreateMfcc(
      _fbb,
      _freq_upper_limit,
      _freq_lower_limit,
      _filter_bank_channel_num,
      _dct_coeff_num);
}

inline MinimumT *Minimum::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<MinimumT>(new MinimumT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Minimum::UnPackTo(MinimumT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<Minimum> Minimum::Pack(flatbuffers::FlatBufferBuilder &_fbb, const MinimumT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateMinimum(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Minimum> CreateMinimum(flatbuffers::FlatBufferBuilder &_fbb, const MinimumT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const MinimumT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return mindspore::schema::CreateMinimum(
      _fbb);
}

inline MinimumGradT *MinimumGrad::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<MinimumGradT>(new MinimumGradT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void MinimumGrad::UnPackTo(MinimumGradT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = grad_x(); _o->grad_x = _e; }
  { auto _e = grad_y(); _o->grad_y = _e; }
}

inline flatbuffers::Offset<MinimumGrad> MinimumGrad::Pack(flatbuffers::FlatBufferBuilder &_fbb, const MinimumGradT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateMinimumGrad(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<MinimumGrad> CreateMinimumGrad(flatbuffers::FlatBufferBuilder &_fbb, const MinimumGradT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const MinimumGradT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _grad_x = _o->grad_x;
  auto _grad_y = _o->grad_y;
  return mindspore::schema::CreateMinimumGrad(
      _fbb,
      _grad_x,
      _grad_y);
}

inline ModT *Mod::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<ModT>(new ModT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Mod::UnPackTo(ModT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<Mod> Mod::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ModT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateMod(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Mod> CreateMod(flatbuffers::FlatBufferBuilder &_fbb, const ModT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ModT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return mindspore::schema::CreateMod(
      _fbb);
}

inline MulFusionT *MulFusion::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<MulFusionT>(new MulFusionT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void MulFusion::UnPackTo(MulFusionT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = activation_type(); _o->activation_type = _e; }
}

inline flatbuffers::Offset<MulFusion> MulFusion::Pack(flatbuffers::FlatBufferBuilder &_fbb, const MulFusionT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateMulFusion(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<MulFusion> CreateMulFusion(flatbuffers::FlatBufferBuilder &_fbb, const MulFusionT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const MulFusionT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _activation_type = _o->activation_type;
  return mindspore::schema::CreateMulFusion(
      _fbb,
      _activation_type);
}

inline MulGradT *MulGrad::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<MulGradT>(new MulGradT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void MulGrad::UnPackTo(MulGradT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<MulGrad> MulGrad::Pack(flatbuffers::FlatBufferBuilder &_fbb, const MulGradT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateMulGrad(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<MulGrad> CreateMulGrad(flatbuffers::FlatBufferBuilder &_fbb, const MulGradT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const MulGradT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return mindspore::schema::CreateMulGrad(
      _fbb);
}

inline NegT *Neg::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<NegT>(new NegT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Neg::UnPackTo(NegT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<Neg> Neg::Pack(flatbuffers::FlatBufferBuilder &_fbb, const NegT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateNeg(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Neg> CreateNeg(flatbuffers::FlatBufferBuilder &_fbb, const NegT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const NegT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return mindspore::schema::CreateNeg(
      _fbb);
}

inline NegGradT *NegGrad::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<NegGradT>(new NegGradT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void NegGrad::UnPackTo(NegGradT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<NegGrad> NegGrad::Pack(flatbuffers::FlatBufferBuilder &_fbb, const NegGradT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateNegGrad(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<NegGrad> CreateNegGrad(flatbuffers::FlatBufferBuilder &_fbb, const NegGradT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const NegGradT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return mindspore::schema::CreateNegGrad(
      _fbb);
}

inline NotEqualT *NotEqual::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<NotEqualT>(new NotEqualT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void NotEqual::UnPackTo(NotEqualT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<NotEqual> NotEqual::Pack(flatbuffers::FlatBufferBuilder &_fbb, const NotEqualT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateNotEqual(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<NotEqual> CreateNotEqual(flatbuffers::FlatBufferBuilder &_fbb, const NotEqualT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const NotEqualT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return mindspore::schema::CreateNotEqual(
      _fbb);
}

inline NonMaxSuppressionT *NonMaxSuppression::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<NonMaxSuppressionT>(new NonMaxSuppressionT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void NonMaxSuppression::UnPackTo(NonMaxSuppressionT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = center_point_box(); _o->center_point_box = _e; }
}

inline flatbuffers::Offset<NonMaxSuppression> NonMaxSuppression::Pack(flatbuffers::FlatBufferBuilder &_fbb, const NonMaxSuppressionT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateNonMaxSuppression(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<NonMaxSuppression> CreateNonMaxSuppression(flatbuffers::FlatBufferBuilder &_fbb, const NonMaxSuppressionT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const NonMaxSuppressionT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _center_point_box = _o->center_point_box;
  return mindspore::schema::CreateNonMaxSuppression(
      _fbb,
      _center_point_box);
}

inline OneHotT *OneHot::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<OneHotT>(new OneHotT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void OneHot::UnPackTo(OneHotT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = axis(); _o->axis = _e; }
}

inline flatbuffers::Offset<OneHot> OneHot::Pack(flatbuffers::FlatBufferBuilder &_fbb, const OneHotT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateOneHot(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<OneHot> CreateOneHot(flatbuffers::FlatBufferBuilder &_fbb, const OneHotT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const OneHotT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _axis = _o->axis;
  return mindspore::schema::CreateOneHot(
      _fbb,
      _axis);
}

inline OnesLikeT *OnesLike::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<OnesLikeT>(new OnesLikeT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void OnesLike::UnPackTo(OnesLikeT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<OnesLike> OnesLike::Pack(flatbuffers::FlatBufferBuilder &_fbb, const OnesLikeT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateOnesLike(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<OnesLike> CreateOnesLike(flatbuffers::FlatBufferBuilder &_fbb, const OnesLikeT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const OnesLikeT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return mindspore::schema::CreateOnesLike(
      _fbb);
}

inline PadFusionT *PadFusion::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<PadFusionT>(new PadFusionT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void PadFusion::UnPackTo(PadFusionT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = paddings(); if (_e) _o->paddings = std::unique_ptr<mindspore::schema::Vec2DT>(_e->UnPack(_resolver)); }
  { auto _e = padding_mode(); _o->padding_mode = _e; }
  { auto _e = constant_value(); _o->constant_value = _e; }
}

inline flatbuffers::Offset<PadFusion> PadFusion::Pack(flatbuffers::FlatBufferBuilder &_fbb, const PadFusionT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreatePadFusion(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<PadFusion> CreatePadFusion(flatbuffers::FlatBufferBuilder &_fbb, const PadFusionT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const PadFusionT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _paddings = _o->paddings ? CreateVec2D(_fbb, _o->paddings.get(), _rehasher) : 0;
  auto _padding_mode = _o->padding_mode;
  auto _constant_value = _o->constant_value;
  return mindspore::schema::CreatePadFusion(
      _fbb,
      _paddings,
      _padding_mode,
      _constant_value);
}

inline PartialFusionT *PartialFusion::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<PartialFusionT>(new PartialFusionT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void PartialFusion::UnPackTo(PartialFusionT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = sub_graph_index(); _o->sub_graph_index = _e; }
}

inline flatbuffers::Offset<PartialFusion> PartialFusion::Pack(flatbuffers::FlatBufferBuilder &_fbb, const PartialFusionT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreatePartialFusion(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<PartialFusion> CreatePartialFusion(flatbuffers::FlatBufferBuilder &_fbb, const PartialFusionT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const PartialFusionT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _sub_graph_index = _o->sub_graph_index;
  return mindspore::schema::CreatePartialFusion(
      _fbb,
      _sub_graph_index);
}

inline PowerGradT *PowerGrad::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<PowerGradT>(new PowerGradT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void PowerGrad::UnPackTo(PowerGradT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = power(); _o->power = _e; }
  { auto _e = scale(); _o->scale = _e; }
  { auto _e = shift(); _o->shift = _e; }
}

inline flatbuffers::Offset<PowerGrad> PowerGrad::Pack(flatbuffers::FlatBufferBuilder &_fbb, const PowerGradT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreatePowerGrad(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<PowerGrad> CreatePowerGrad(flatbuffers::FlatBufferBuilder &_fbb, const PowerGradT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const PowerGradT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _power = _o->power;
  auto _scale = _o->scale;
  auto _shift = _o->shift;
  return mindspore::schema::CreatePowerGrad(
      _fbb,
      _power,
      _scale,
      _shift);
}

inline PowFusionT *PowFusion::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<PowFusionT>(new PowFusionT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void PowFusion::UnPackTo(PowFusionT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = scale(); _o->scale = _e; }
  { auto _e = shift(); _o->shift = _e; }
}

inline flatbuffers::Offset<PowFusion> PowFusion::Pack(flatbuffers::FlatBufferBuilder &_fbb, const PowFusionT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreatePowFusion(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<PowFusion> CreatePowFusion(flatbuffers::FlatBufferBuilder &_fbb, const PowFusionT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const PowFusionT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _scale = _o->scale;
  auto _shift = _o->shift;
  return mindspore::schema::CreatePowFusion(
      _fbb,
      _scale,
      _shift);
}

inline PriorBoxT *PriorBox::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<PriorBoxT>(new PriorBoxT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void PriorBox::UnPackTo(PriorBoxT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = min_sizes(); if (_e) { _o->min_sizes.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->min_sizes[_i] = _e->Get(_i); } } }
  { auto _e = max_sizes(); if (_e) { _o->max_sizes.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->max_sizes[_i] = _e->Get(_i); } } }
  { auto _e = aspect_ratios(); if (_e) { _o->aspect_ratios.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->aspect_ratios[_i] = _e->Get(_i); } } }
  { auto _e = variances(); if (_e) { _o->variances.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->variances[_i] = _e->Get(_i); } } }
  { auto _e = image_size_w(); _o->image_size_w = _e; }
  { auto _e = image_size_h(); _o->image_size_h = _e; }
  { auto _e = step_w(); _o->step_w = _e; }
  { auto _e = step_h(); _o->step_h = _e; }
  { auto _e = clip(); _o->clip = _e; }
  { auto _e = flip(); _o->flip = _e; }
  { auto _e = offset(); _o->offset = _e; }
}

inline flatbuffers::Offset<PriorBox> PriorBox::Pack(flatbuffers::FlatBufferBuilder &_fbb, const PriorBoxT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreatePriorBox(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<PriorBox> CreatePriorBox(flatbuffers::FlatBufferBuilder &_fbb, const PriorBoxT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const PriorBoxT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _min_sizes = _o->min_sizes.size() ? _fbb.CreateVector(_o->min_sizes) : 0;
  auto _max_sizes = _o->max_sizes.size() ? _fbb.CreateVector(_o->max_sizes) : 0;
  auto _aspect_ratios = _o->aspect_ratios.size() ? _fbb.CreateVector(_o->aspect_ratios) : 0;
  auto _variances = _o->variances.size() ? _fbb.CreateVector(_o->variances) : 0;
  auto _image_size_w = _o->image_size_w;
  auto _image_size_h = _o->image_size_h;
  auto _step_w = _o->step_w;
  auto _step_h = _o->step_h;
  auto _clip = _o->clip;
  auto _flip = _o->flip;
  auto _offset = _o->offset;
  return mindspore::schema::CreatePriorBox(
      _fbb,
      _min_sizes,
      _max_sizes,
      _aspect_ratios,
      _variances,
      _image_size_w,
      _image_size_h,
      _step_w,
      _step_h,
      _clip,
      _flip,
      _offset);
}

inline PReLUFusionT *PReLUFusion::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<PReLUFusionT>(new PReLUFusionT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void PReLUFusion::UnPackTo(PReLUFusionT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = channel_shared(); _o->channel_shared = _e; }
}

inline flatbuffers::Offset<PReLUFusion> PReLUFusion::Pack(flatbuffers::FlatBufferBuilder &_fbb, const PReLUFusionT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreatePReLUFusion(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<PReLUFusion> CreatePReLUFusion(flatbuffers::FlatBufferBuilder &_fbb, const PReLUFusionT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const PReLUFusionT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _channel_shared = _o->channel_shared;
  return mindspore::schema::CreatePReLUFusion(
      _fbb,
      _channel_shared);
}

inline RankT *Rank::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<RankT>(new RankT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Rank::UnPackTo(RankT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<Rank> Rank::Pack(flatbuffers::FlatBufferBuilder &_fbb, const RankT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateRank(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Rank> CreateRank(flatbuffers::FlatBufferBuilder &_fbb, const RankT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const RankT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return mindspore::schema::CreateRank(
      _fbb);
}

inline RangeT *Range::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<RangeT>(new RangeT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Range::UnPackTo(RangeT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = d_type(); _o->d_type = _e; }
  { auto _e = start(); _o->start = _e; }
  { auto _e = limit(); _o->limit = _e; }
  { auto _e = delta(); _o->delta = _e; }
}

inline flatbuffers::Offset<Range> Range::Pack(flatbuffers::FlatBufferBuilder &_fbb, const RangeT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateRange(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Range> CreateRange(flatbuffers::FlatBufferBuilder &_fbb, const RangeT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const RangeT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _d_type = _o->d_type;
  auto _start = _o->start;
  auto _limit = _o->limit;
  auto _delta = _o->delta;
  return mindspore::schema::CreateRange(
      _fbb,
      _d_type,
      _start,
      _limit,
      _delta);
}

inline ReciprocalT *Reciprocal::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<ReciprocalT>(new ReciprocalT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Reciprocal::UnPackTo(ReciprocalT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<Reciprocal> Reciprocal::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ReciprocalT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateReciprocal(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Reciprocal> CreateReciprocal(flatbuffers::FlatBufferBuilder &_fbb, const ReciprocalT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ReciprocalT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return mindspore::schema::CreateReciprocal(
      _fbb);
}

inline RealDivT *RealDiv::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<RealDivT>(new RealDivT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void RealDiv::UnPackTo(RealDivT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<RealDiv> RealDiv::Pack(flatbuffers::FlatBufferBuilder &_fbb, const RealDivT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateRealDiv(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<RealDiv> CreateRealDiv(flatbuffers::FlatBufferBuilder &_fbb, const RealDivT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const RealDivT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return mindspore::schema::CreateRealDiv(
      _fbb);
}

inline ReduceFusionT *ReduceFusion::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<ReduceFusionT>(new ReduceFusionT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void ReduceFusion::UnPackTo(ReduceFusionT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = keep_dims(); _o->keep_dims = _e; }
  { auto _e = mode(); _o->mode = _e; }
  { auto _e = reduce_to_end(); _o->reduce_to_end = _e; }
  { auto _e = coeff(); _o->coeff = _e; }
}

inline flatbuffers::Offset<ReduceFusion> ReduceFusion::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ReduceFusionT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateReduceFusion(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<ReduceFusion> CreateReduceFusion(flatbuffers::FlatBufferBuilder &_fbb, const ReduceFusionT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ReduceFusionT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _keep_dims = _o->keep_dims;
  auto _mode = _o->mode;
  auto _reduce_to_end = _o->reduce_to_end;
  auto _coeff = _o->coeff;
  return mindspore::schema::CreateReduceFusion(
      _fbb,
      _keep_dims,
      _mode,
      _reduce_to_end,
      _coeff);
}

inline ReshapeT *Reshape::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<ReshapeT>(new ReshapeT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Reshape::UnPackTo(ReshapeT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<Reshape> Reshape::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ReshapeT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateReshape(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Reshape> CreateReshape(flatbuffers::FlatBufferBuilder &_fbb, const ReshapeT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ReshapeT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return mindspore::schema::CreateReshape(
      _fbb);
}

inline ResizeT *Resize::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<ResizeT>(new ResizeT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Resize::UnPackTo(ResizeT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = format(); _o->format = _e; }
  { auto _e = method(); _o->method = _e; }
  { auto _e = new_height(); _o->new_height = _e; }
  { auto _e = new_width(); _o->new_width = _e; }
  { auto _e = preserve_aspect_ratio(); _o->preserve_aspect_ratio = _e; }
  { auto _e = coordinate_transform_mode(); _o->coordinate_transform_mode = _e; }
  { auto _e = cubic_coeff(); _o->cubic_coeff = _e; }
  { auto _e = exclude_outside(); _o->exclude_outside = _e; }
  { auto _e = extrapolation_value(); _o->extrapolation_value = _e; }
  { auto _e = nearest_mode(); _o->nearest_mode = _e; }
}

inline flatbuffers::Offset<Resize> Resize::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ResizeT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateResize(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Resize> CreateResize(flatbuffers::FlatBufferBuilder &_fbb, const ResizeT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ResizeT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _format = _o->format;
  auto _method = _o->method;
  auto _new_height = _o->new_height;
  auto _new_width = _o->new_width;
  auto _preserve_aspect_ratio = _o->preserve_aspect_ratio;
  auto _coordinate_transform_mode = _o->coordinate_transform_mode;
  auto _cubic_coeff = _o->cubic_coeff;
  auto _exclude_outside = _o->exclude_outside;
  auto _extrapolation_value = _o->extrapolation_value;
  auto _nearest_mode = _o->nearest_mode;
  return mindspore::schema::CreateResize(
      _fbb,
      _format,
      _method,
      _new_height,
      _new_width,
      _preserve_aspect_ratio,
      _coordinate_transform_mode,
      _cubic_coeff,
      _exclude_outside,
      _extrapolation_value,
      _nearest_mode);
}

inline ReverseSequenceT *ReverseSequence::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<ReverseSequenceT>(new ReverseSequenceT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void ReverseSequence::UnPackTo(ReverseSequenceT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = seq_dim(); _o->seq_dim = _e; }
  { auto _e = batch_dim(); _o->batch_dim = _e; }
}

inline flatbuffers::Offset<ReverseSequence> ReverseSequence::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ReverseSequenceT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateReverseSequence(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<ReverseSequence> CreateReverseSequence(flatbuffers::FlatBufferBuilder &_fbb, const ReverseSequenceT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ReverseSequenceT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _seq_dim = _o->seq_dim;
  auto _batch_dim = _o->batch_dim;
  return mindspore::schema::CreateReverseSequence(
      _fbb,
      _seq_dim,
      _batch_dim);
}

inline ReverseV2T *ReverseV2::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<ReverseV2T>(new ReverseV2T());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void ReverseV2::UnPackTo(ReverseV2T *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = axis(); if (_e) { _o->axis.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->axis[_i] = _e->Get(_i); } } }
}

inline flatbuffers::Offset<ReverseV2> ReverseV2::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ReverseV2T* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateReverseV2(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<ReverseV2> CreateReverseV2(flatbuffers::FlatBufferBuilder &_fbb, const ReverseV2T *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ReverseV2T* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _axis = _o->axis.size() ? _fbb.CreateVector(_o->axis) : 0;
  return mindspore::schema::CreateReverseV2(
      _fbb,
      _axis);
}

inline RfftT *Rfft::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<RfftT>(new RfftT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Rfft::UnPackTo(RfftT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = fft_length(); _o->fft_length = _e; }
}

inline flatbuffers::Offset<Rfft> Rfft::Pack(flatbuffers::FlatBufferBuilder &_fbb, const RfftT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateRfft(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Rfft> CreateRfft(flatbuffers::FlatBufferBuilder &_fbb, const RfftT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const RfftT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _fft_length = _o->fft_length;
  return mindspore::schema::CreateRfft(
      _fbb,
      _fft_length);
}

inline ROIPoolingT *ROIPooling::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<ROIPoolingT>(new ROIPoolingT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void ROIPooling::UnPackTo(ROIPoolingT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = pooled_h(); _o->pooled_h = _e; }
  { auto _e = pooled_w(); _o->pooled_w = _e; }
  { auto _e = scale(); _o->scale = _e; }
}

inline flatbuffers::Offset<ROIPooling> ROIPooling::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ROIPoolingT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateROIPooling(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<ROIPooling> CreateROIPooling(flatbuffers::FlatBufferBuilder &_fbb, const ROIPoolingT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ROIPoolingT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _pooled_h = _o->pooled_h;
  auto _pooled_w = _o->pooled_w;
  auto _scale = _o->scale;
  return mindspore::schema::CreateROIPooling(
      _fbb,
      _pooled_h,
      _pooled_w,
      _scale);
}

inline RoundT *Round::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<RoundT>(new RoundT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Round::UnPackTo(RoundT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<Round> Round::Pack(flatbuffers::FlatBufferBuilder &_fbb, const RoundT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateRound(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Round> CreateRound(flatbuffers::FlatBufferBuilder &_fbb, const RoundT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const RoundT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return mindspore::schema::CreateRound(
      _fbb);
}

inline RsqrtT *Rsqrt::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<RsqrtT>(new RsqrtT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Rsqrt::UnPackTo(RsqrtT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<Rsqrt> Rsqrt::Pack(flatbuffers::FlatBufferBuilder &_fbb, const RsqrtT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateRsqrt(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Rsqrt> CreateRsqrt(flatbuffers::FlatBufferBuilder &_fbb, const RsqrtT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const RsqrtT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return mindspore::schema::CreateRsqrt(
      _fbb);
}

inline QuantDTypeCastT *QuantDTypeCast::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<QuantDTypeCastT>(new QuantDTypeCastT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void QuantDTypeCast::UnPackTo(QuantDTypeCastT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = src_t(); _o->src_t = _e; }
  { auto _e = dst_t(); _o->dst_t = _e; }
}

inline flatbuffers::Offset<QuantDTypeCast> QuantDTypeCast::Pack(flatbuffers::FlatBufferBuilder &_fbb, const QuantDTypeCastT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateQuantDTypeCast(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<QuantDTypeCast> CreateQuantDTypeCast(flatbuffers::FlatBufferBuilder &_fbb, const QuantDTypeCastT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const QuantDTypeCastT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _src_t = _o->src_t;
  auto _dst_t = _o->dst_t;
  return mindspore::schema::CreateQuantDTypeCast(
      _fbb,
      _src_t,
      _dst_t);
}

inline ScaleFusionT *ScaleFusion::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<ScaleFusionT>(new ScaleFusionT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void ScaleFusion::UnPackTo(ScaleFusionT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = axis(); _o->axis = _e; }
  { auto _e = activation_type(); _o->activation_type = _e; }
}

inline flatbuffers::Offset<ScaleFusion> ScaleFusion::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ScaleFusionT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateScaleFusion(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<ScaleFusion> CreateScaleFusion(flatbuffers::FlatBufferBuilder &_fbb, const ScaleFusionT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ScaleFusionT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _axis = _o->axis;
  auto _activation_type = _o->activation_type;
  return mindspore::schema::CreateScaleFusion(
      _fbb,
      _axis,
      _activation_type);
}

inline ScatterNdT *ScatterNd::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<ScatterNdT>(new ScatterNdT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void ScatterNd::UnPackTo(ScatterNdT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<ScatterNd> ScatterNd::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ScatterNdT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateScatterNd(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<ScatterNd> CreateScatterNd(flatbuffers::FlatBufferBuilder &_fbb, const ScatterNdT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ScatterNdT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return mindspore::schema::CreateScatterNd(
      _fbb);
}

inline SGDT *SGD::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<SGDT>(new SGDT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void SGD::UnPackTo(SGDT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = nesterov(); _o->nesterov = _e; }
  { auto _e = dampening(); _o->dampening = _e; }
  { auto _e = weight_decay(); _o->weight_decay = _e; }
}

inline flatbuffers::Offset<SGD> SGD::Pack(flatbuffers::FlatBufferBuilder &_fbb, const SGDT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateSGD(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<SGD> CreateSGD(flatbuffers::FlatBufferBuilder &_fbb, const SGDT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const SGDT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _nesterov = _o->nesterov;
  auto _dampening = _o->dampening;
  auto _weight_decay = _o->weight_decay;
  return mindspore::schema::CreateSGD(
      _fbb,
      _nesterov,
      _dampening,
      _weight_decay);
}

inline ShapeT *Shape::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<ShapeT>(new ShapeT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Shape::UnPackTo(ShapeT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<Shape> Shape::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ShapeT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateShape(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Shape> CreateShape(flatbuffers::FlatBufferBuilder &_fbb, const ShapeT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ShapeT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return mindspore::schema::CreateShape(
      _fbb);
}

inline SigmoidCrossEntropyWithLogitsT *SigmoidCrossEntropyWithLogits::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<SigmoidCrossEntropyWithLogitsT>(new SigmoidCrossEntropyWithLogitsT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void SigmoidCrossEntropyWithLogits::UnPackTo(SigmoidCrossEntropyWithLogitsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<SigmoidCrossEntropyWithLogits> SigmoidCrossEntropyWithLogits::Pack(flatbuffers::FlatBufferBuilder &_fbb, const SigmoidCrossEntropyWithLogitsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateSigmoidCrossEntropyWithLogits(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<SigmoidCrossEntropyWithLogits> CreateSigmoidCrossEntropyWithLogits(flatbuffers::FlatBufferBuilder &_fbb, const SigmoidCrossEntropyWithLogitsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const SigmoidCrossEntropyWithLogitsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return mindspore::schema::CreateSigmoidCrossEntropyWithLogits(
      _fbb);
}

inline SigmoidCrossEntropyWithLogitsGradT *SigmoidCrossEntropyWithLogitsGrad::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<SigmoidCrossEntropyWithLogitsGradT>(new SigmoidCrossEntropyWithLogitsGradT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void SigmoidCrossEntropyWithLogitsGrad::UnPackTo(SigmoidCrossEntropyWithLogitsGradT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<SigmoidCrossEntropyWithLogitsGrad> SigmoidCrossEntropyWithLogitsGrad::Pack(flatbuffers::FlatBufferBuilder &_fbb, const SigmoidCrossEntropyWithLogitsGradT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateSigmoidCrossEntropyWithLogitsGrad(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<SigmoidCrossEntropyWithLogitsGrad> CreateSigmoidCrossEntropyWithLogitsGrad(flatbuffers::FlatBufferBuilder &_fbb, const SigmoidCrossEntropyWithLogitsGradT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const SigmoidCrossEntropyWithLogitsGradT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return mindspore::schema::CreateSigmoidCrossEntropyWithLogitsGrad(
      _fbb);
}

inline SinT *Sin::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<SinT>(new SinT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Sin::UnPackTo(SinT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<Sin> Sin::Pack(flatbuffers::FlatBufferBuilder &_fbb, const SinT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateSin(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Sin> CreateSin(flatbuffers::FlatBufferBuilder &_fbb, const SinT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const SinT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return mindspore::schema::CreateSin(
      _fbb);
}

inline SkipGramT *SkipGram::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<SkipGramT>(new SkipGramT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void SkipGram::UnPackTo(SkipGramT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = include_all_grams(); _o->include_all_grams = _e; }
  { auto _e = max_skip_size(); _o->max_skip_size = _e; }
  { auto _e = ngram_size(); _o->ngram_size = _e; }
}

inline flatbuffers::Offset<SkipGram> SkipGram::Pack(flatbuffers::FlatBufferBuilder &_fbb, const SkipGramT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateSkipGram(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<SkipGram> CreateSkipGram(flatbuffers::FlatBufferBuilder &_fbb, const SkipGramT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const SkipGramT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _include_all_grams = _o->include_all_grams;
  auto _max_skip_size = _o->max_skip_size;
  auto _ngram_size = _o->ngram_size;
  return mindspore::schema::CreateSkipGram(
      _fbb,
      _include_all_grams,
      _max_skip_size,
      _ngram_size);
}

inline SliceFusionT *SliceFusion::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<SliceFusionT>(new SliceFusionT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void SliceFusion::UnPackTo(SliceFusionT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = axes(); if (_e) { _o->axes.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->axes[_i] = _e->Get(_i); } } }
}

inline flatbuffers::Offset<SliceFusion> SliceFusion::Pack(flatbuffers::FlatBufferBuilder &_fbb, const SliceFusionT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateSliceFusion(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<SliceFusion> CreateSliceFusion(flatbuffers::FlatBufferBuilder &_fbb, const SliceFusionT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const SliceFusionT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _axes = _o->axes.size() ? _fbb.CreateVector(_o->axes) : 0;
  return mindspore::schema::CreateSliceFusion(
      _fbb,
      _axes);
}

inline SmoothL1LossT *SmoothL1Loss::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<SmoothL1LossT>(new SmoothL1LossT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void SmoothL1Loss::UnPackTo(SmoothL1LossT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = beta(); _o->beta = _e; }
}

inline flatbuffers::Offset<SmoothL1Loss> SmoothL1Loss::Pack(flatbuffers::FlatBufferBuilder &_fbb, const SmoothL1LossT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateSmoothL1Loss(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<SmoothL1Loss> CreateSmoothL1Loss(flatbuffers::FlatBufferBuilder &_fbb, const SmoothL1LossT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const SmoothL1LossT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _beta = _o->beta;
  return mindspore::schema::CreateSmoothL1Loss(
      _fbb,
      _beta);
}

inline SmoothL1LossGradT *SmoothL1LossGrad::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<SmoothL1LossGradT>(new SmoothL1LossGradT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void SmoothL1LossGrad::UnPackTo(SmoothL1LossGradT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = beta(); _o->beta = _e; }
}

inline flatbuffers::Offset<SmoothL1LossGrad> SmoothL1LossGrad::Pack(flatbuffers::FlatBufferBuilder &_fbb, const SmoothL1LossGradT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateSmoothL1LossGrad(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<SmoothL1LossGrad> CreateSmoothL1LossGrad(flatbuffers::FlatBufferBuilder &_fbb, const SmoothL1LossGradT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const SmoothL1LossGradT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _beta = _o->beta;
  return mindspore::schema::CreateSmoothL1LossGrad(
      _fbb,
      _beta);
}

inline SoftmaxT *Softmax::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<SoftmaxT>(new SoftmaxT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Softmax::UnPackTo(SoftmaxT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = axis(); if (_e) { _o->axis.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->axis[_i] = _e->Get(_i); } } }
}

inline flatbuffers::Offset<Softmax> Softmax::Pack(flatbuffers::FlatBufferBuilder &_fbb, const SoftmaxT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateSoftmax(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Softmax> CreateSoftmax(flatbuffers::FlatBufferBuilder &_fbb, const SoftmaxT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const SoftmaxT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _axis = _o->axis.size() ? _fbb.CreateVector(_o->axis) : 0;
  return mindspore::schema::CreateSoftmax(
      _fbb,
      _axis);
}

inline SoftmaxCrossEntropyWithLogitsT *SoftmaxCrossEntropyWithLogits::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<SoftmaxCrossEntropyWithLogitsT>(new SoftmaxCrossEntropyWithLogitsT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void SoftmaxCrossEntropyWithLogits::UnPackTo(SoftmaxCrossEntropyWithLogitsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<SoftmaxCrossEntropyWithLogits> SoftmaxCrossEntropyWithLogits::Pack(flatbuffers::FlatBufferBuilder &_fbb, const SoftmaxCrossEntropyWithLogitsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateSoftmaxCrossEntropyWithLogits(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<SoftmaxCrossEntropyWithLogits> CreateSoftmaxCrossEntropyWithLogits(flatbuffers::FlatBufferBuilder &_fbb, const SoftmaxCrossEntropyWithLogitsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const SoftmaxCrossEntropyWithLogitsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return mindspore::schema::CreateSoftmaxCrossEntropyWithLogits(
      _fbb);
}

inline SpaceToBatchT *SpaceToBatch::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<SpaceToBatchT>(new SpaceToBatchT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void SpaceToBatch::UnPackTo(SpaceToBatchT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = block_size(); if (_e) { _o->block_size.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->block_size[_i] = _e->Get(_i); } } }
  { auto _e = paddings(); if (_e) _o->paddings = std::unique_ptr<mindspore::schema::Vec2DT>(_e->UnPack(_resolver)); }
}

inline flatbuffers::Offset<SpaceToBatch> SpaceToBatch::Pack(flatbuffers::FlatBufferBuilder &_fbb, const SpaceToBatchT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateSpaceToBatch(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<SpaceToBatch> CreateSpaceToBatch(flatbuffers::FlatBufferBuilder &_fbb, const SpaceToBatchT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const SpaceToBatchT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _block_size = _o->block_size.size() ? _fbb.CreateVector(_o->block_size) : 0;
  auto _paddings = _o->paddings ? CreateVec2D(_fbb, _o->paddings.get(), _rehasher) : 0;
  return mindspore::schema::CreateSpaceToBatch(
      _fbb,
      _block_size,
      _paddings);
}

inline SpaceToBatchNDT *SpaceToBatchND::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<SpaceToBatchNDT>(new SpaceToBatchNDT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void SpaceToBatchND::UnPackTo(SpaceToBatchNDT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = block_shape(); if (_e) { _o->block_shape.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->block_shape[_i] = _e->Get(_i); } } }
  { auto _e = paddings(); if (_e) _o->paddings = std::unique_ptr<mindspore::schema::Vec2DT>(_e->UnPack(_resolver)); }
}

inline flatbuffers::Offset<SpaceToBatchND> SpaceToBatchND::Pack(flatbuffers::FlatBufferBuilder &_fbb, const SpaceToBatchNDT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateSpaceToBatchND(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<SpaceToBatchND> CreateSpaceToBatchND(flatbuffers::FlatBufferBuilder &_fbb, const SpaceToBatchNDT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const SpaceToBatchNDT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _block_shape = _o->block_shape.size() ? _fbb.CreateVector(_o->block_shape) : 0;
  auto _paddings = _o->paddings ? CreateVec2D(_fbb, _o->paddings.get(), _rehasher) : 0;
  return mindspore::schema::CreateSpaceToBatchND(
      _fbb,
      _block_shape,
      _paddings);
}

inline SpaceToDepthT *SpaceToDepth::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<SpaceToDepthT>(new SpaceToDepthT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void SpaceToDepth::UnPackTo(SpaceToDepthT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = block_size(); _o->block_size = _e; }
  { auto _e = format(); _o->format = _e; }
}

inline flatbuffers::Offset<SpaceToDepth> SpaceToDepth::Pack(flatbuffers::FlatBufferBuilder &_fbb, const SpaceToDepthT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateSpaceToDepth(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<SpaceToDepth> CreateSpaceToDepth(flatbuffers::FlatBufferBuilder &_fbb, const SpaceToDepthT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const SpaceToDepthT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _block_size = _o->block_size;
  auto _format = _o->format;
  return mindspore::schema::CreateSpaceToDepth(
      _fbb,
      _block_size,
      _format);
}

inline SparseSoftmaxCrossEntropyWithLogitsT *SparseSoftmaxCrossEntropyWithLogits::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<SparseSoftmaxCrossEntropyWithLogitsT>(new SparseSoftmaxCrossEntropyWithLogitsT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void SparseSoftmaxCrossEntropyWithLogits::UnPackTo(SparseSoftmaxCrossEntropyWithLogitsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = is_grad(); _o->is_grad = _e; }
}

inline flatbuffers::Offset<SparseSoftmaxCrossEntropyWithLogits> SparseSoftmaxCrossEntropyWithLogits::Pack(flatbuffers::FlatBufferBuilder &_fbb, const SparseSoftmaxCrossEntropyWithLogitsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateSparseSoftmaxCrossEntropyWithLogits(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<SparseSoftmaxCrossEntropyWithLogits> CreateSparseSoftmaxCrossEntropyWithLogits(flatbuffers::FlatBufferBuilder &_fbb, const SparseSoftmaxCrossEntropyWithLogitsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const SparseSoftmaxCrossEntropyWithLogitsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _is_grad = _o->is_grad;
  return mindspore::schema::CreateSparseSoftmaxCrossEntropyWithLogits(
      _fbb,
      _is_grad);
}

inline SparseToDenseT *SparseToDense::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<SparseToDenseT>(new SparseToDenseT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void SparseToDense::UnPackTo(SparseToDenseT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<SparseToDense> SparseToDense::Pack(flatbuffers::FlatBufferBuilder &_fbb, const SparseToDenseT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateSparseToDense(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<SparseToDense> CreateSparseToDense(flatbuffers::FlatBufferBuilder &_fbb, const SparseToDenseT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const SparseToDenseT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return mindspore::schema::CreateSparseToDense(
      _fbb);
}

inline SplitT *Split::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<SplitT>(new SplitT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Split::UnPackTo(SplitT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = output_num(); _o->output_num = _e; }
  { auto _e = size_splits(); if (_e) { _o->size_splits.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->size_splits[_i] = _e->Get(_i); } } }
  { auto _e = axis(); _o->axis = _e; }
}

inline flatbuffers::Offset<Split> Split::Pack(flatbuffers::FlatBufferBuilder &_fbb, const SplitT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateSplit(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Split> CreateSplit(flatbuffers::FlatBufferBuilder &_fbb, const SplitT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const SplitT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _output_num = _o->output_num;
  auto _size_splits = _o->size_splits.size() ? _fbb.CreateVector(_o->size_splits) : 0;
  auto _axis = _o->axis;
  return mindspore::schema::CreateSplit(
      _fbb,
      _output_num,
      _size_splits,
      _axis);
}

inline SqrtT *Sqrt::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<SqrtT>(new SqrtT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Sqrt::UnPackTo(SqrtT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<Sqrt> Sqrt::Pack(flatbuffers::FlatBufferBuilder &_fbb, const SqrtT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateSqrt(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Sqrt> CreateSqrt(flatbuffers::FlatBufferBuilder &_fbb, const SqrtT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const SqrtT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return mindspore::schema::CreateSqrt(
      _fbb);
}

inline SqueezeT *Squeeze::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<SqueezeT>(new SqueezeT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Squeeze::UnPackTo(SqueezeT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = axis(); if (_e) { _o->axis.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->axis[_i] = _e->Get(_i); } } }
}

inline flatbuffers::Offset<Squeeze> Squeeze::Pack(flatbuffers::FlatBufferBuilder &_fbb, const SqueezeT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateSqueeze(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Squeeze> CreateSqueeze(flatbuffers::FlatBufferBuilder &_fbb, const SqueezeT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const SqueezeT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _axis = _o->axis.size() ? _fbb.CreateVector(_o->axis) : 0;
  return mindspore::schema::CreateSqueeze(
      _fbb,
      _axis);
}

inline SquareT *Square::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<SquareT>(new SquareT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Square::UnPackTo(SquareT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<Square> Square::Pack(flatbuffers::FlatBufferBuilder &_fbb, const SquareT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateSquare(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Square> CreateSquare(flatbuffers::FlatBufferBuilder &_fbb, const SquareT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const SquareT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return mindspore::schema::CreateSquare(
      _fbb);
}

inline SquaredDifferenceT *SquaredDifference::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<SquaredDifferenceT>(new SquaredDifferenceT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void SquaredDifference::UnPackTo(SquaredDifferenceT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<SquaredDifference> SquaredDifference::Pack(flatbuffers::FlatBufferBuilder &_fbb, const SquaredDifferenceT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateSquaredDifference(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<SquaredDifference> CreateSquaredDifference(flatbuffers::FlatBufferBuilder &_fbb, const SquaredDifferenceT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const SquaredDifferenceT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return mindspore::schema::CreateSquaredDifference(
      _fbb);
}

inline StackT *Stack::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<StackT>(new StackT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Stack::UnPackTo(StackT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = axis(); _o->axis = _e; }
}

inline flatbuffers::Offset<Stack> Stack::Pack(flatbuffers::FlatBufferBuilder &_fbb, const StackT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateStack(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Stack> CreateStack(flatbuffers::FlatBufferBuilder &_fbb, const StackT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const StackT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _axis = _o->axis;
  return mindspore::schema::CreateStack(
      _fbb,
      _axis);
}

inline StridedSliceT *StridedSlice::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<StridedSliceT>(new StridedSliceT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void StridedSlice::UnPackTo(StridedSliceT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = begin_mask(); _o->begin_mask = _e; }
  { auto _e = end_mask(); _o->end_mask = _e; }
  { auto _e = ellipsis_mask(); _o->ellipsis_mask = _e; }
  { auto _e = new_axis_mask(); _o->new_axis_mask = _e; }
  { auto _e = shrink_axis_mask(); _o->shrink_axis_mask = _e; }
}

inline flatbuffers::Offset<StridedSlice> StridedSlice::Pack(flatbuffers::FlatBufferBuilder &_fbb, const StridedSliceT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateStridedSlice(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<StridedSlice> CreateStridedSlice(flatbuffers::FlatBufferBuilder &_fbb, const StridedSliceT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const StridedSliceT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _begin_mask = _o->begin_mask;
  auto _end_mask = _o->end_mask;
  auto _ellipsis_mask = _o->ellipsis_mask;
  auto _new_axis_mask = _o->new_axis_mask;
  auto _shrink_axis_mask = _o->shrink_axis_mask;
  return mindspore::schema::CreateStridedSlice(
      _fbb,
      _begin_mask,
      _end_mask,
      _ellipsis_mask,
      _new_axis_mask,
      _shrink_axis_mask);
}

inline SubFusionT *SubFusion::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<SubFusionT>(new SubFusionT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void SubFusion::UnPackTo(SubFusionT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = activation_type(); _o->activation_type = _e; }
}

inline flatbuffers::Offset<SubFusion> SubFusion::Pack(flatbuffers::FlatBufferBuilder &_fbb, const SubFusionT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateSubFusion(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<SubFusion> CreateSubFusion(flatbuffers::FlatBufferBuilder &_fbb, const SubFusionT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const SubFusionT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _activation_type = _o->activation_type;
  return mindspore::schema::CreateSubFusion(
      _fbb,
      _activation_type);
}

inline SubGradT *SubGrad::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<SubGradT>(new SubGradT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void SubGrad::UnPackTo(SubGradT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<SubGrad> SubGrad::Pack(flatbuffers::FlatBufferBuilder &_fbb, const SubGradT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateSubGrad(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<SubGrad> CreateSubGrad(flatbuffers::FlatBufferBuilder &_fbb, const SubGradT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const SubGradT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return mindspore::schema::CreateSubGrad(
      _fbb);
}

inline SwitchT *Switch::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<SwitchT>(new SwitchT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Switch::UnPackTo(SwitchT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<Switch> Switch::Pack(flatbuffers::FlatBufferBuilder &_fbb, const SwitchT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateSwitch(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Switch> CreateSwitch(flatbuffers::FlatBufferBuilder &_fbb, const SwitchT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const SwitchT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return mindspore::schema::CreateSwitch(
      _fbb);
}

inline TensorListFromTensorT *TensorListFromTensor::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<TensorListFromTensorT>(new TensorListFromTensorT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void TensorListFromTensor::UnPackTo(TensorListFromTensorT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = element_dtype(); _o->element_dtype = _e; }
  { auto _e = shape_type(); _o->shape_type = _e; }
}

inline flatbuffers::Offset<TensorListFromTensor> TensorListFromTensor::Pack(flatbuffers::FlatBufferBuilder &_fbb, const TensorListFromTensorT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateTensorListFromTensor(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<TensorListFromTensor> CreateTensorListFromTensor(flatbuffers::FlatBufferBuilder &_fbb, const TensorListFromTensorT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const TensorListFromTensorT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _element_dtype = _o->element_dtype;
  auto _shape_type = _o->shape_type;
  return mindspore::schema::CreateTensorListFromTensor(
      _fbb,
      _element_dtype,
      _shape_type);
}

inline TensorListGetItemT *TensorListGetItem::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<TensorListGetItemT>(new TensorListGetItemT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void TensorListGetItem::UnPackTo(TensorListGetItemT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = element_dtype(); _o->element_dtype = _e; }
}

inline flatbuffers::Offset<TensorListGetItem> TensorListGetItem::Pack(flatbuffers::FlatBufferBuilder &_fbb, const TensorListGetItemT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateTensorListGetItem(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<TensorListGetItem> CreateTensorListGetItem(flatbuffers::FlatBufferBuilder &_fbb, const TensorListGetItemT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const TensorListGetItemT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _element_dtype = _o->element_dtype;
  return mindspore::schema::CreateTensorListGetItem(
      _fbb,
      _element_dtype);
}

inline TensorListReserveT *TensorListReserve::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<TensorListReserveT>(new TensorListReserveT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void TensorListReserve::UnPackTo(TensorListReserveT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = element_dtype(); _o->element_dtype = _e; }
  { auto _e = shape_type(); _o->shape_type = _e; }
}

inline flatbuffers::Offset<TensorListReserve> TensorListReserve::Pack(flatbuffers::FlatBufferBuilder &_fbb, const TensorListReserveT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateTensorListReserve(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<TensorListReserve> CreateTensorListReserve(flatbuffers::FlatBufferBuilder &_fbb, const TensorListReserveT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const TensorListReserveT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _element_dtype = _o->element_dtype;
  auto _shape_type = _o->shape_type;
  return mindspore::schema::CreateTensorListReserve(
      _fbb,
      _element_dtype,
      _shape_type);
}

inline TensorListSetItemT *TensorListSetItem::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<TensorListSetItemT>(new TensorListSetItemT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void TensorListSetItem::UnPackTo(TensorListSetItemT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = element_dtype(); _o->element_dtype = _e; }
}

inline flatbuffers::Offset<TensorListSetItem> TensorListSetItem::Pack(flatbuffers::FlatBufferBuilder &_fbb, const TensorListSetItemT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateTensorListSetItem(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<TensorListSetItem> CreateTensorListSetItem(flatbuffers::FlatBufferBuilder &_fbb, const TensorListSetItemT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const TensorListSetItemT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _element_dtype = _o->element_dtype;
  return mindspore::schema::CreateTensorListSetItem(
      _fbb,
      _element_dtype);
}

inline TensorListStackT *TensorListStack::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<TensorListStackT>(new TensorListStackT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void TensorListStack::UnPackTo(TensorListStackT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = num_elements(); _o->num_elements = _e; }
  { auto _e = element_dtype(); _o->element_dtype = _e; }
}

inline flatbuffers::Offset<TensorListStack> TensorListStack::Pack(flatbuffers::FlatBufferBuilder &_fbb, const TensorListStackT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateTensorListStack(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<TensorListStack> CreateTensorListStack(flatbuffers::FlatBufferBuilder &_fbb, const TensorListStackT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const TensorListStackT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _num_elements = _o->num_elements;
  auto _element_dtype = _o->element_dtype;
  return mindspore::schema::CreateTensorListStack(
      _fbb,
      _num_elements,
      _element_dtype);
}

inline TileFusionT *TileFusion::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<TileFusionT>(new TileFusionT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void TileFusion::UnPackTo(TileFusionT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = dims(); if (_e) { _o->dims.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->dims[_i] = _e->Get(_i); } } }
}

inline flatbuffers::Offset<TileFusion> TileFusion::Pack(flatbuffers::FlatBufferBuilder &_fbb, const TileFusionT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateTileFusion(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<TileFusion> CreateTileFusion(flatbuffers::FlatBufferBuilder &_fbb, const TileFusionT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const TileFusionT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _dims = _o->dims.size() ? _fbb.CreateVector(_o->dims) : 0;
  return mindspore::schema::CreateTileFusion(
      _fbb,
      _dims);
}

inline TopKFusionT *TopKFusion::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<TopKFusionT>(new TopKFusionT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void TopKFusion::UnPackTo(TopKFusionT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = sorted(); _o->sorted = _e; }
  { auto _e = axis(); _o->axis = _e; }
  { auto _e = largest(); _o->largest = _e; }
}

inline flatbuffers::Offset<TopKFusion> TopKFusion::Pack(flatbuffers::FlatBufferBuilder &_fbb, const TopKFusionT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateTopKFusion(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<TopKFusion> CreateTopKFusion(flatbuffers::FlatBufferBuilder &_fbb, const TopKFusionT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const TopKFusionT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _sorted = _o->sorted;
  auto _axis = _o->axis;
  auto _largest = _o->largest;
  return mindspore::schema::CreateTopKFusion(
      _fbb,
      _sorted,
      _axis,
      _largest);
}

inline TransposeT *Transpose::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<TransposeT>(new TransposeT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Transpose::UnPackTo(TransposeT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<Transpose> Transpose::Pack(flatbuffers::FlatBufferBuilder &_fbb, const TransposeT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateTranspose(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Transpose> CreateTranspose(flatbuffers::FlatBufferBuilder &_fbb, const TransposeT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const TransposeT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return mindspore::schema::CreateTranspose(
      _fbb);
}

inline UniqueT *Unique::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<UniqueT>(new UniqueT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Unique::UnPackTo(UniqueT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<Unique> Unique::Pack(flatbuffers::FlatBufferBuilder &_fbb, const UniqueT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateUnique(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Unique> CreateUnique(flatbuffers::FlatBufferBuilder &_fbb, const UniqueT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const UniqueT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return mindspore::schema::CreateUnique(
      _fbb);
}

inline UnsortedSegmentSumT *UnsortedSegmentSum::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<UnsortedSegmentSumT>(new UnsortedSegmentSumT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void UnsortedSegmentSum::UnPackTo(UnsortedSegmentSumT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<UnsortedSegmentSum> UnsortedSegmentSum::Pack(flatbuffers::FlatBufferBuilder &_fbb, const UnsortedSegmentSumT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateUnsortedSegmentSum(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<UnsortedSegmentSum> CreateUnsortedSegmentSum(flatbuffers::FlatBufferBuilder &_fbb, const UnsortedSegmentSumT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const UnsortedSegmentSumT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return mindspore::schema::CreateUnsortedSegmentSum(
      _fbb);
}

inline UnsqueezeT *Unsqueeze::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<UnsqueezeT>(new UnsqueezeT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Unsqueeze::UnPackTo(UnsqueezeT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = axis(); if (_e) { _o->axis.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->axis[_i] = _e->Get(_i); } } }
}

inline flatbuffers::Offset<Unsqueeze> Unsqueeze::Pack(flatbuffers::FlatBufferBuilder &_fbb, const UnsqueezeT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateUnsqueeze(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Unsqueeze> CreateUnsqueeze(flatbuffers::FlatBufferBuilder &_fbb, const UnsqueezeT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const UnsqueezeT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _axis = _o->axis.size() ? _fbb.CreateVector(_o->axis) : 0;
  return mindspore::schema::CreateUnsqueeze(
      _fbb,
      _axis);
}

inline UnstackT *Unstack::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<UnstackT>(new UnstackT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Unstack::UnPackTo(UnstackT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = axis(); _o->axis = _e; }
}

inline flatbuffers::Offset<Unstack> Unstack::Pack(flatbuffers::FlatBufferBuilder &_fbb, const UnstackT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateUnstack(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Unstack> CreateUnstack(flatbuffers::FlatBufferBuilder &_fbb, const UnstackT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const UnstackT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _axis = _o->axis;
  return mindspore::schema::CreateUnstack(
      _fbb,
      _axis);
}

inline WhereT *Where::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<WhereT>(new WhereT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Where::UnPackTo(WhereT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<Where> Where::Pack(flatbuffers::FlatBufferBuilder &_fbb, const WhereT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateWhere(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Where> CreateWhere(flatbuffers::FlatBufferBuilder &_fbb, const WhereT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const WhereT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return mindspore::schema::CreateWhere(
      _fbb);
}

inline ZerosLikeT *ZerosLike::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<ZerosLikeT>(new ZerosLikeT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void ZerosLike::UnPackTo(ZerosLikeT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<ZerosLike> ZerosLike::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ZerosLikeT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateZerosLike(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<ZerosLike> CreateZerosLike(flatbuffers::FlatBufferBuilder &_fbb, const ZerosLikeT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ZerosLikeT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return mindspore::schema::CreateZerosLike(
      _fbb);
}

inline SelectT *Select::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<SelectT>(new SelectT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Select::UnPackTo(SelectT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<Select> Select::Pack(flatbuffers::FlatBufferBuilder &_fbb, const SelectT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateSelect(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Select> CreateSelect(flatbuffers::FlatBufferBuilder &_fbb, const SelectT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const SelectT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return mindspore::schema::CreateSelect(
      _fbb);
}

inline GRUT *GRU::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<GRUT>(new GRUT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void GRU::UnPackTo(GRUT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = bidirectional(); _o->bidirectional = _e; }
}

inline flatbuffers::Offset<GRU> GRU::Pack(flatbuffers::FlatBufferBuilder &_fbb, const GRUT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateGRU(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<GRU> CreateGRU(flatbuffers::FlatBufferBuilder &_fbb, const GRUT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const GRUT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _bidirectional = _o->bidirectional;
  return mindspore::schema::CreateGRU(
      _fbb,
      _bidirectional);
}

inline NonZeroT *NonZero::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<NonZeroT>(new NonZeroT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void NonZero::UnPackTo(NonZeroT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<NonZero> NonZero::Pack(flatbuffers::FlatBufferBuilder &_fbb, const NonZeroT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateNonZero(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<NonZero> CreateNonZero(flatbuffers::FlatBufferBuilder &_fbb, const NonZeroT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const NonZeroT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return mindspore::schema::CreateNonZero(
      _fbb);
}

inline InvertPermutationT *InvertPermutation::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<InvertPermutationT>(new InvertPermutationT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void InvertPermutation::UnPackTo(InvertPermutationT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<InvertPermutation> InvertPermutation::Pack(flatbuffers::FlatBufferBuilder &_fbb, const InvertPermutationT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateInvertPermutation(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<InvertPermutation> CreateInvertPermutation(flatbuffers::FlatBufferBuilder &_fbb, const InvertPermutationT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const InvertPermutationT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return mindspore::schema::CreateInvertPermutation(
      _fbb);
}

inline SizeT *Size::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<SizeT>(new SizeT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Size::UnPackTo(SizeT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<Size> Size::Pack(flatbuffers::FlatBufferBuilder &_fbb, const SizeT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateSize(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Size> CreateSize(flatbuffers::FlatBufferBuilder &_fbb, const SizeT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const SizeT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return mindspore::schema::CreateSize(
      _fbb);
}

inline RandomStandardNormalT *RandomStandardNormal::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<RandomStandardNormalT>(new RandomStandardNormalT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void RandomStandardNormal::UnPackTo(RandomStandardNormalT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = seed(); _o->seed = _e; }
  { auto _e = seed2(); _o->seed2 = _e; }
}

inline flatbuffers::Offset<RandomStandardNormal> RandomStandardNormal::Pack(flatbuffers::FlatBufferBuilder &_fbb, const RandomStandardNormalT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateRandomStandardNormal(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<RandomStandardNormal> CreateRandomStandardNormal(flatbuffers::FlatBufferBuilder &_fbb, const RandomStandardNormalT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const RandomStandardNormalT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _seed = _o->seed;
  auto _seed2 = _o->seed2;
  return mindspore::schema::CreateRandomStandardNormal(
      _fbb,
      _seed,
      _seed2);
}

inline CropAndResizeT *CropAndResize::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<CropAndResizeT>(new CropAndResizeT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void CropAndResize::UnPackTo(CropAndResizeT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = method(); _o->method = _e; }
  { auto _e = extrapolation_value(); _o->extrapolation_value = _e; }
}

inline flatbuffers::Offset<CropAndResize> CropAndResize::Pack(flatbuffers::FlatBufferBuilder &_fbb, const CropAndResizeT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateCropAndResize(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<CropAndResize> CreateCropAndResize(flatbuffers::FlatBufferBuilder &_fbb, const CropAndResizeT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const CropAndResizeT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _method = _o->method;
  auto _extrapolation_value = _o->extrapolation_value;
  return mindspore::schema::CreateCropAndResize(
      _fbb,
      _method,
      _extrapolation_value);
}

inline ErfT *Erf::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<ErfT>(new ErfT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Erf::UnPackTo(ErfT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<Erf> Erf::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ErfT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateErf(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Erf> CreateErf(flatbuffers::FlatBufferBuilder &_fbb, const ErfT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ErfT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return mindspore::schema::CreateErf(
      _fbb);
}

inline StridedSliceGradT *StridedSliceGrad::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<StridedSliceGradT>(new StridedSliceGradT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void StridedSliceGrad::UnPackTo(StridedSliceGradT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = begin_mask(); _o->begin_mask = _e; }
  { auto _e = end_mask(); _o->end_mask = _e; }
  { auto _e = ellipsis_mask(); _o->ellipsis_mask = _e; }
  { auto _e = new_axis_mask(); _o->new_axis_mask = _e; }
  { auto _e = shrink_axis_mask(); _o->shrink_axis_mask = _e; }
}

inline flatbuffers::Offset<StridedSliceGrad> StridedSliceGrad::Pack(flatbuffers::FlatBufferBuilder &_fbb, const StridedSliceGradT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateStridedSliceGrad(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<StridedSliceGrad> CreateStridedSliceGrad(flatbuffers::FlatBufferBuilder &_fbb, const StridedSliceGradT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const StridedSliceGradT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _begin_mask = _o->begin_mask;
  auto _end_mask = _o->end_mask;
  auto _ellipsis_mask = _o->ellipsis_mask;
  auto _new_axis_mask = _o->new_axis_mask;
  auto _shrink_axis_mask = _o->shrink_axis_mask;
  return mindspore::schema::CreateStridedSliceGrad(
      _fbb,
      _begin_mask,
      _end_mask,
      _ellipsis_mask,
      _new_axis_mask,
      _shrink_axis_mask);
}

inline IsFiniteT *IsFinite::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<IsFiniteT>(new IsFiniteT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void IsFinite::UnPackTo(IsFiniteT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<IsFinite> IsFinite::Pack(flatbuffers::FlatBufferBuilder &_fbb, const IsFiniteT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateIsFinite(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<IsFinite> CreateIsFinite(flatbuffers::FlatBufferBuilder &_fbb, const IsFiniteT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const IsFiniteT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return mindspore::schema::CreateIsFinite(
      _fbb);
}

inline LinSpaceT *LinSpace::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<LinSpaceT>(new LinSpaceT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void LinSpace::UnPackTo(LinSpaceT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<LinSpace> LinSpace::Pack(flatbuffers::FlatBufferBuilder &_fbb, const LinSpaceT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateLinSpace(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<LinSpace> CreateLinSpace(flatbuffers::FlatBufferBuilder &_fbb, const LinSpaceT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const LinSpaceT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return mindspore::schema::CreateLinSpace(
      _fbb);
}

inline UniformRealT *UniformReal::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<UniformRealT>(new UniformRealT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void UniformReal::UnPackTo(UniformRealT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = seed(); _o->seed = _e; }
  { auto _e = seed2(); _o->seed2 = _e; }
}

inline flatbuffers::Offset<UniformReal> UniformReal::Pack(flatbuffers::FlatBufferBuilder &_fbb, const UniformRealT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateUniformReal(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<UniformReal> CreateUniformReal(flatbuffers::FlatBufferBuilder &_fbb, const UniformRealT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const UniformRealT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _seed = _o->seed;
  auto _seed2 = _o->seed2;
  return mindspore::schema::CreateUniformReal(
      _fbb,
      _seed,
      _seed2);
}

inline AbsGradT *AbsGrad::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<AbsGradT>(new AbsGradT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void AbsGrad::UnPackTo(AbsGradT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<AbsGrad> AbsGrad::Pack(flatbuffers::FlatBufferBuilder &_fbb, const AbsGradT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateAbsGrad(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<AbsGrad> CreateAbsGrad(flatbuffers::FlatBufferBuilder &_fbb, const AbsGradT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const AbsGradT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return mindspore::schema::CreateAbsGrad(
      _fbb);
}

inline RsqrtGradT *RsqrtGrad::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<RsqrtGradT>(new RsqrtGradT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void RsqrtGrad::UnPackTo(RsqrtGradT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<RsqrtGrad> RsqrtGrad::Pack(flatbuffers::FlatBufferBuilder &_fbb, const RsqrtGradT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateRsqrtGrad(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<RsqrtGrad> CreateRsqrtGrad(flatbuffers::FlatBufferBuilder &_fbb, const RsqrtGradT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const RsqrtGradT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return mindspore::schema::CreateRsqrtGrad(
      _fbb);
}

inline SqrtGradT *SqrtGrad::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<SqrtGradT>(new SqrtGradT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void SqrtGrad::UnPackTo(SqrtGradT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<SqrtGrad> SqrtGrad::Pack(flatbuffers::FlatBufferBuilder &_fbb, const SqrtGradT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateSqrtGrad(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<SqrtGrad> CreateSqrtGrad(flatbuffers::FlatBufferBuilder &_fbb, const SqrtGradT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const SqrtGradT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return mindspore::schema::CreateSqrtGrad(
      _fbb);
}

inline LayerNormGradT *LayerNormGrad::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<LayerNormGradT>(new LayerNormGradT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void LayerNormGrad::UnPackTo(LayerNormGradT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = begin_norm_axis(); _o->begin_norm_axis = _e; }
  { auto _e = begin_params_axis(); _o->begin_params_axis = _e; }
}

inline flatbuffers::Offset<LayerNormGrad> LayerNormGrad::Pack(flatbuffers::FlatBufferBuilder &_fbb, const LayerNormGradT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateLayerNormGrad(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<LayerNormGrad> CreateLayerNormGrad(flatbuffers::FlatBufferBuilder &_fbb, const LayerNormGradT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const LayerNormGradT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _begin_norm_axis = _o->begin_norm_axis;
  auto _begin_params_axis = _o->begin_params_axis;
  return mindspore::schema::CreateLayerNormGrad(
      _fbb,
      _begin_norm_axis,
      _begin_params_axis);
}

inline ResizeGradT *ResizeGrad::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<ResizeGradT>(new ResizeGradT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void ResizeGrad::UnPackTo(ResizeGradT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = method(); _o->method = _e; }
  { auto _e = align_corners(); _o->align_corners = _e; }
}

inline flatbuffers::Offset<ResizeGrad> ResizeGrad::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ResizeGradT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateResizeGrad(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<ResizeGrad> CreateResizeGrad(flatbuffers::FlatBufferBuilder &_fbb, const ResizeGradT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ResizeGradT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _method = _o->method;
  auto _align_corners = _o->align_corners;
  return mindspore::schema::CreateResizeGrad(
      _fbb,
      _method,
      _align_corners);
}

inline SpliceT *Splice::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<SpliceT>(new SpliceT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Splice::UnPackTo(SpliceT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = context(); if (_e) { _o->context.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->context[_i] = _e->Get(_i); } } }
  { auto _e = forward_indexes(); if (_e) { _o->forward_indexes.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->forward_indexes[_i] = _e->Get(_i); } } }
  { auto _e = output_dim(); _o->output_dim = _e; }
}

inline flatbuffers::Offset<Splice> Splice::Pack(flatbuffers::FlatBufferBuilder &_fbb, const SpliceT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateSplice(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Splice> CreateSplice(flatbuffers::FlatBufferBuilder &_fbb, const SpliceT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const SpliceT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _context = _o->context.size() ? _fbb.CreateVector(_o->context) : 0;
  auto _forward_indexes = _o->forward_indexes.size() ? _fbb.CreateVector(_o->forward_indexes) : 0;
  auto _output_dim = _o->output_dim;
  return mindspore::schema::CreateSplice(
      _fbb,
      _context,
      _forward_indexes,
      _output_dim);
}

inline LogSoftmaxT *LogSoftmax::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<LogSoftmaxT>(new LogSoftmaxT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void LogSoftmax::UnPackTo(LogSoftmaxT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = axis(); _o->axis = _e; }
}

inline flatbuffers::Offset<LogSoftmax> LogSoftmax::Pack(flatbuffers::FlatBufferBuilder &_fbb, const LogSoftmaxT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateLogSoftmax(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<LogSoftmax> CreateLogSoftmax(flatbuffers::FlatBufferBuilder &_fbb, const LogSoftmaxT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const LogSoftmaxT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _axis = _o->axis;
  return mindspore::schema::CreateLogSoftmax(
      _fbb,
      _axis);
}

inline CallT *Call::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<CallT>(new CallT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Call::UnPackTo(CallT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<Call> Call::Pack(flatbuffers::FlatBufferBuilder &_fbb, const CallT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateCall(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Call> CreateCall(flatbuffers::FlatBufferBuilder &_fbb, const CallT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const CallT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return mindspore::schema::CreateCall(
      _fbb);
}

inline CumSumT *CumSum::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<CumSumT>(new CumSumT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void CumSum::UnPackTo(CumSumT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = exclusive(); _o->exclusive = _e; }
  { auto _e = reverse(); _o->reverse = _e; }
}

inline flatbuffers::Offset<CumSum> CumSum::Pack(flatbuffers::FlatBufferBuilder &_fbb, const CumSumT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateCumSum(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<CumSum> CreateCumSum(flatbuffers::FlatBufferBuilder &_fbb, const CumSumT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const CumSumT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _exclusive = _o->exclusive;
  auto _reverse = _o->reverse;
  return mindspore::schema::CreateCumSum(
      _fbb,
      _exclusive,
      _reverse);
}

inline CustomT *Custom::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<CustomT>(new CustomT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Custom::UnPackTo(CustomT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = type(); if (_e) _o->type = _e->str(); }
  { auto _e = attr(); if (_e) { _o->attr.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->attr[_i] = std::unique_ptr<mindspore::schema::AttributeT>(_e->Get(_i)->UnPack(_resolver)); } } }
}

inline flatbuffers::Offset<Custom> Custom::Pack(flatbuffers::FlatBufferBuilder &_fbb, const CustomT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateCustom(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Custom> CreateCustom(flatbuffers::FlatBufferBuilder &_fbb, const CustomT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const CustomT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _type = _o->type.empty() ? 0 : _fbb.CreateString(_o->type);
  auto _attr = _o->attr.size() ? _fbb.CreateVector<flatbuffers::Offset<mindspore::schema::Attribute>> (_o->attr.size(), [](size_t i, _VectorArgs *__va) { return CreateAttribute(*__va->__fbb, __va->__o->attr[i].get(), __va->__rehasher); }, &_va ) : 0;
  return mindspore::schema::CreateCustom(
      _fbb,
      _type,
      _attr);
}

inline SplitWithOverlapT *SplitWithOverlap::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<SplitWithOverlapT>(new SplitWithOverlapT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void SplitWithOverlap::UnPackTo(SplitWithOverlapT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = split_dim(); _o->split_dim = _e; }
  { auto _e = number_split(); _o->number_split = _e; }
  { auto _e = ratio(); if (_e) { _o->ratio.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->ratio[_i] = _e->Get(_i); } } }
  { auto _e = extend_top(); if (_e) { _o->extend_top.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->extend_top[_i] = _e->Get(_i); } } }
  { auto _e = extend_bottom(); if (_e) { _o->extend_bottom.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->extend_bottom[_i] = _e->Get(_i); } } }
}

inline flatbuffers::Offset<SplitWithOverlap> SplitWithOverlap::Pack(flatbuffers::FlatBufferBuilder &_fbb, const SplitWithOverlapT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateSplitWithOverlap(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<SplitWithOverlap> CreateSplitWithOverlap(flatbuffers::FlatBufferBuilder &_fbb, const SplitWithOverlapT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const SplitWithOverlapT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _split_dim = _o->split_dim;
  auto _number_split = _o->number_split;
  auto _ratio = _o->ratio.size() ? _fbb.CreateVector(_o->ratio) : 0;
  auto _extend_top = _o->extend_top.size() ? _fbb.CreateVector(_o->extend_top) : 0;
  auto _extend_bottom = _o->extend_bottom.size() ? _fbb.CreateVector(_o->extend_bottom) : 0;
  return mindspore::schema::CreateSplitWithOverlap(
      _fbb,
      _split_dim,
      _number_split,
      _ratio,
      _extend_top,
      _extend_bottom);
}

inline GenOPT *GenOP::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<GenOPT>(new GenOPT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void GenOP::UnPackTo(GenOPT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = activation_type(); _o->activation_type = _e; }
  { auto _e = alpha(); _o->alpha = _e; }
  { auto _e = min_val(); _o->min_val = _e; }
  { auto _e = max_val(); _o->max_val = _e; }
  { auto _e = is_training(); _o->is_training = _e; }
  { auto _e = format(); _o->format = _e; }
  { auto _e = kernel_size(); if (_e) { _o->kernel_size.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->kernel_size[_i] = _e->Get(_i); } } }
  { auto _e = stride(); if (_e) { _o->stride.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->stride[_i] = _e->Get(_i); } } }
  { auto _e = dilation(); if (_e) { _o->dilation.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->dilation[_i] = _e->Get(_i); } } }
  { auto _e = pad_mode(); _o->pad_mode = _e; }
  { auto _e = pad_list(); if (_e) { _o->pad_list.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->pad_list[_i] = _e->Get(_i); } } }
  { auto _e = mode(); _o->mode = _e; }
  { auto _e = group(); _o->group = _e; }
  { auto _e = in_channel(); _o->in_channel = _e; }
  { auto _e = out_channel(); _o->out_channel = _e; }
  { auto _e = eltwise_mode(); _o->eltwise_mode = _e; }
  { auto _e = has_bias(); _o->has_bias = _e; }
  { auto _e = use_axis(); _o->use_axis = _e; }
  { auto _e = axis(); _o->axis = _e; }
  { auto _e = epsilon(); _o->epsilon = _e; }
  { auto _e = momentum(); _o->momentum = _e; }
  { auto _e = transpose_a(); _o->transpose_a = _e; }
  { auto _e = transpose_b(); _o->transpose_b = _e; }
  { auto _e = pad(); if (_e) { _o->pad.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->pad[_i] = _e->Get(_i); } } }
  { auto _e = round_mode(); _o->round_mode = _e; }
  { auto _e = global(); _o->global = _e; }
  { auto _e = channel_shared(); _o->channel_shared = _e; }
  { auto _e = axes(); if (_e) { _o->axes.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->axes[_i] = _e->Get(_i); } } }
  { auto _e = keep_dims(); _o->keep_dims = _e; }
  { auto _e = reduce_mode(); _o->reduce_mode = _e; }
  { auto _e = reduce_to_end(); _o->reduce_to_end = _e; }
  { auto _e = coeff(); _o->coeff = _e; }
}

inline flatbuffers::Offset<GenOP> GenOP::Pack(flatbuffers::FlatBufferBuilder &_fbb, const GenOPT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateGenOP(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<GenOP> CreateGenOP(flatbuffers::FlatBufferBuilder &_fbb, const GenOPT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const GenOPT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _activation_type = _o->activation_type;
  auto _alpha = _o->alpha;
  auto _min_val = _o->min_val;
  auto _max_val = _o->max_val;
  auto _is_training = _o->is_training;
  auto _format = _o->format;
  auto _kernel_size = _o->kernel_size.size() ? _fbb.CreateVector(_o->kernel_size) : 0;
  auto _stride = _o->stride.size() ? _fbb.CreateVector(_o->stride) : 0;
  auto _dilation = _o->dilation.size() ? _fbb.CreateVector(_o->dilation) : 0;
  auto _pad_mode = _o->pad_mode;
  auto _pad_list = _o->pad_list.size() ? _fbb.CreateVector(_o->pad_list) : 0;
  auto _mode = _o->mode;
  auto _group = _o->group;
  auto _in_channel = _o->in_channel;
  auto _out_channel = _o->out_channel;
  auto _eltwise_mode = _o->eltwise_mode;
  auto _has_bias = _o->has_bias;
  auto _use_axis = _o->use_axis;
  auto _axis = _o->axis;
  auto _epsilon = _o->epsilon;
  auto _momentum = _o->momentum;
  auto _transpose_a = _o->transpose_a;
  auto _transpose_b = _o->transpose_b;
  auto _pad = _o->pad.size() ? _fbb.CreateVector(_o->pad) : 0;
  auto _round_mode = _o->round_mode;
  auto _global = _o->global;
  auto _channel_shared = _o->channel_shared;
  auto _axes = _o->axes.size() ? _fbb.CreateVector(_o->axes) : 0;
  auto _keep_dims = _o->keep_dims;
  auto _reduce_mode = _o->reduce_mode;
  auto _reduce_to_end = _o->reduce_to_end;
  auto _coeff = _o->coeff;
  return mindspore::schema::CreateGenOP(
      _fbb,
      _activation_type,
      _alpha,
      _min_val,
      _max_val,
      _is_training,
      _format,
      _kernel_size,
      _stride,
      _dilation,
      _pad_mode,
      _pad_list,
      _mode,
      _group,
      _in_channel,
      _out_channel,
      _eltwise_mode,
      _has_bias,
      _use_axis,
      _axis,
      _epsilon,
      _momentum,
      _transpose_a,
      _transpose_b,
      _pad,
      _round_mode,
      _global,
      _channel_shared,
      _axes,
      _keep_dims,
      _reduce_mode,
      _reduce_to_end,
      _coeff);
}

inline RaggedRangeT *RaggedRange::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<RaggedRangeT>(new RaggedRangeT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void RaggedRange::UnPackTo(RaggedRangeT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<RaggedRange> RaggedRange::Pack(flatbuffers::FlatBufferBuilder &_fbb, const RaggedRangeT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateRaggedRange(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<RaggedRange> CreateRaggedRange(flatbuffers::FlatBufferBuilder &_fbb, const RaggedRangeT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const RaggedRangeT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return mindspore::schema::CreateRaggedRange(
      _fbb);
}

inline GLUT *GLU::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<GLUT>(new GLUT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void GLU::UnPackTo(GLUT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = axis(); _o->axis = _e; }
}

inline flatbuffers::Offset<GLU> GLU::Pack(flatbuffers::FlatBufferBuilder &_fbb, const GLUT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateGLU(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<GLU> CreateGLU(flatbuffers::FlatBufferBuilder &_fbb, const GLUT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const GLUT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _axis = _o->axis;
  return mindspore::schema::CreateGLU(
      _fbb,
      _axis);
}

inline TensorArrayT *TensorArray::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<TensorArrayT>(new TensorArrayT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void TensorArray::UnPackTo(TensorArrayT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = dynamic_size(); _o->dynamic_size = _e; }
  { auto _e = identical_element_shapes(); _o->identical_element_shapes = _e; }
  { auto _e = element_shape(); if (_e) { _o->element_shape.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->element_shape[_i] = _e->Get(_i); } } }
  { auto _e = data_type(); _o->data_type = _e; }
}

inline flatbuffers::Offset<TensorArray> TensorArray::Pack(flatbuffers::FlatBufferBuilder &_fbb, const TensorArrayT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateTensorArray(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<TensorArray> CreateTensorArray(flatbuffers::FlatBufferBuilder &_fbb, const TensorArrayT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const TensorArrayT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _dynamic_size = _o->dynamic_size;
  auto _identical_element_shapes = _o->identical_element_shapes;
  auto _element_shape = _o->element_shape.size() ? _fbb.CreateVector(_o->element_shape) : 0;
  auto _data_type = _o->data_type;
  return mindspore::schema::CreateTensorArray(
      _fbb,
      _dynamic_size,
      _identical_element_shapes,
      _element_shape,
      _data_type);
}

inline TensorArrayReadT *TensorArrayRead::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<TensorArrayReadT>(new TensorArrayReadT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void TensorArrayRead::UnPackTo(TensorArrayReadT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<TensorArrayRead> TensorArrayRead::Pack(flatbuffers::FlatBufferBuilder &_fbb, const TensorArrayReadT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateTensorArrayRead(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<TensorArrayRead> CreateTensorArrayRead(flatbuffers::FlatBufferBuilder &_fbb, const TensorArrayReadT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const TensorArrayReadT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return mindspore::schema::CreateTensorArrayRead(
      _fbb);
}

inline TensorArrayWriteT *TensorArrayWrite::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<TensorArrayWriteT>(new TensorArrayWriteT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void TensorArrayWrite::UnPackTo(TensorArrayWriteT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<TensorArrayWrite> TensorArrayWrite::Pack(flatbuffers::FlatBufferBuilder &_fbb, const TensorArrayWriteT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateTensorArrayWrite(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<TensorArrayWrite> CreateTensorArrayWrite(flatbuffers::FlatBufferBuilder &_fbb, const TensorArrayWriteT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const TensorArrayWriteT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return mindspore::schema::CreateTensorArrayWrite(
      _fbb);
}

inline AffineT *Affine::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<AffineT>(new AffineT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Affine::UnPackTo(AffineT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = context(); if (_e) { _o->context.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->context[_i] = _e->Get(_i); } } }
  { auto _e = output_dim(); _o->output_dim = _e; }
  { auto _e = activation_type(); _o->activation_type = _e; }
  { auto _e = transpose_a(); _o->transpose_a = _e; }
  { auto _e = transpose_b(); _o->transpose_b = _e; }
}

inline flatbuffers::Offset<Affine> Affine::Pack(flatbuffers::FlatBufferBuilder &_fbb, const AffineT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateAffine(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Affine> CreateAffine(flatbuffers::FlatBufferBuilder &_fbb, const AffineT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const AffineT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _context = _o->context.size() ? _fbb.CreateVector(_o->context) : 0;
  auto _output_dim = _o->output_dim;
  auto _activation_type = _o->activation_type;
  auto _transpose_a = _o->transpose_a;
  auto _transpose_b = _o->transpose_b;
  return mindspore::schema::CreateAffine(
      _fbb,
      _context,
      _output_dim,
      _activation_type,
      _transpose_a,
      _transpose_b);
}

inline ScatterNdUpdateT *ScatterNdUpdate::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<ScatterNdUpdateT>(new ScatterNdUpdateT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void ScatterNdUpdate::UnPackTo(ScatterNdUpdateT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<ScatterNdUpdate> ScatterNdUpdate::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ScatterNdUpdateT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateScatterNdUpdate(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<ScatterNdUpdate> CreateScatterNdUpdate(flatbuffers::FlatBufferBuilder &_fbb, const ScatterNdUpdateT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ScatterNdUpdateT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return mindspore::schema::CreateScatterNdUpdate(
      _fbb);
}

inline bool VerifyPrimitiveType(flatbuffers::Verifier &verifier, const void *obj, PrimitiveType type) {
  switch (type) {
    case PrimitiveType_NONE: {
      return true;
    }
    case PrimitiveType_Abs: {
      auto ptr = reinterpret_cast<const mindspore::schema::Abs *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_Activation: {
      auto ptr = reinterpret_cast<const mindspore::schema::Activation *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_ActivationGrad: {
      auto ptr = reinterpret_cast<const mindspore::schema::ActivationGrad *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_Adam: {
      auto ptr = reinterpret_cast<const mindspore::schema::Adam *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_AddFusion: {
      auto ptr = reinterpret_cast<const mindspore::schema::AddFusion *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_AdderFusion: {
      auto ptr = reinterpret_cast<const mindspore::schema::AdderFusion *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_AddGrad: {
      auto ptr = reinterpret_cast<const mindspore::schema::AddGrad *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_AddN: {
      auto ptr = reinterpret_cast<const mindspore::schema::AddN *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_All: {
      auto ptr = reinterpret_cast<const mindspore::schema::All *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_ApplyMomentum: {
      auto ptr = reinterpret_cast<const mindspore::schema::ApplyMomentum *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_ArgMaxFusion: {
      auto ptr = reinterpret_cast<const mindspore::schema::ArgMaxFusion *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_ArgMinFusion: {
      auto ptr = reinterpret_cast<const mindspore::schema::ArgMinFusion *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_Assert: {
      auto ptr = reinterpret_cast<const mindspore::schema::Assert *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_Assign: {
      auto ptr = reinterpret_cast<const mindspore::schema::Assign *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_AssignAdd: {
      auto ptr = reinterpret_cast<const mindspore::schema::AssignAdd *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_AudioSpectrogram: {
      auto ptr = reinterpret_cast<const mindspore::schema::AudioSpectrogram *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_AvgPoolFusion: {
      auto ptr = reinterpret_cast<const mindspore::schema::AvgPoolFusion *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_AvgPoolGrad: {
      auto ptr = reinterpret_cast<const mindspore::schema::AvgPoolGrad *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_BatchNorm: {
      auto ptr = reinterpret_cast<const mindspore::schema::BatchNorm *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_BatchNormGrad: {
      auto ptr = reinterpret_cast<const mindspore::schema::BatchNormGrad *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_BatchToSpace: {
      auto ptr = reinterpret_cast<const mindspore::schema::BatchToSpace *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_BatchToSpaceND: {
      auto ptr = reinterpret_cast<const mindspore::schema::BatchToSpaceND *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_BiasAdd: {
      auto ptr = reinterpret_cast<const mindspore::schema::BiasAdd *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_BinaryCrossEntropy: {
      auto ptr = reinterpret_cast<const mindspore::schema::BinaryCrossEntropy *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_BinaryCrossEntropyGrad: {
      auto ptr = reinterpret_cast<const mindspore::schema::BinaryCrossEntropyGrad *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_BiasAddGrad: {
      auto ptr = reinterpret_cast<const mindspore::schema::BiasAddGrad *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_BroadcastTo: {
      auto ptr = reinterpret_cast<const mindspore::schema::BroadcastTo *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_Cast: {
      auto ptr = reinterpret_cast<const mindspore::schema::Cast *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_Ceil: {
      auto ptr = reinterpret_cast<const mindspore::schema::Ceil *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_Clip: {
      auto ptr = reinterpret_cast<const mindspore::schema::Clip *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_Concat: {
      auto ptr = reinterpret_cast<const mindspore::schema::Concat *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_Attention: {
      auto ptr = reinterpret_cast<const mindspore::schema::Attention *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_Conv2DBackpropFilterFusion: {
      auto ptr = reinterpret_cast<const mindspore::schema::Conv2DBackpropFilterFusion *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_Conv2DBackpropInputFusion: {
      auto ptr = reinterpret_cast<const mindspore::schema::Conv2DBackpropInputFusion *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_Conv2DFusion: {
      auto ptr = reinterpret_cast<const mindspore::schema::Conv2DFusion *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_Conv2dTransposeFusion: {
      auto ptr = reinterpret_cast<const mindspore::schema::Conv2dTransposeFusion *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_Cos: {
      auto ptr = reinterpret_cast<const mindspore::schema::Cos *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_ConstantOfShape: {
      auto ptr = reinterpret_cast<const mindspore::schema::ConstantOfShape *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_Crop: {
      auto ptr = reinterpret_cast<const mindspore::schema::Crop *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_CustomExtractFeatures: {
      auto ptr = reinterpret_cast<const mindspore::schema::CustomExtractFeatures *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_CustomNormalize: {
      auto ptr = reinterpret_cast<const mindspore::schema::CustomNormalize *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_CustomPredict: {
      auto ptr = reinterpret_cast<const mindspore::schema::CustomPredict *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_DeConv2DGradFilter: {
      auto ptr = reinterpret_cast<const mindspore::schema::DeConv2DGradFilter *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_Depend: {
      auto ptr = reinterpret_cast<const mindspore::schema::Depend *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_DepthToSpace: {
      auto ptr = reinterpret_cast<const mindspore::schema::DepthToSpace *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_DetectionPostProcess: {
      auto ptr = reinterpret_cast<const mindspore::schema::DetectionPostProcess *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_DivFusion: {
      auto ptr = reinterpret_cast<const mindspore::schema::DivFusion *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_DivGrad: {
      auto ptr = reinterpret_cast<const mindspore::schema::DivGrad *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_Dropout: {
      auto ptr = reinterpret_cast<const mindspore::schema::Dropout *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_DropoutGrad: {
      auto ptr = reinterpret_cast<const mindspore::schema::DropoutGrad *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_Elu: {
      auto ptr = reinterpret_cast<const mindspore::schema::Elu *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_Eltwise: {
      auto ptr = reinterpret_cast<const mindspore::schema::Eltwise *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_Equal: {
      auto ptr = reinterpret_cast<const mindspore::schema::Equal *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_EmbeddingLookupFusion: {
      auto ptr = reinterpret_cast<const mindspore::schema::EmbeddingLookupFusion *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_ExpFusion: {
      auto ptr = reinterpret_cast<const mindspore::schema::ExpFusion *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_ExpandDims: {
      auto ptr = reinterpret_cast<const mindspore::schema::ExpandDims *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_FakeQuantWithMinMaxVars: {
      auto ptr = reinterpret_cast<const mindspore::schema::FakeQuantWithMinMaxVars *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_FakeQuantWithMinMaxVarsPerChannel: {
      auto ptr = reinterpret_cast<const mindspore::schema::FakeQuantWithMinMaxVarsPerChannel *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_FftReal: {
      auto ptr = reinterpret_cast<const mindspore::schema::FftReal *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_FftImag: {
      auto ptr = reinterpret_cast<const mindspore::schema::FftImag *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_Flatten: {
      auto ptr = reinterpret_cast<const mindspore::schema::Flatten *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_FlattenGrad: {
      auto ptr = reinterpret_cast<const mindspore::schema::FlattenGrad *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_Floor: {
      auto ptr = reinterpret_cast<const mindspore::schema::Floor *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_FloorDiv: {
      auto ptr = reinterpret_cast<const mindspore::schema::FloorDiv *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_FloorMod: {
      auto ptr = reinterpret_cast<const mindspore::schema::FloorMod *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_Fill: {
      auto ptr = reinterpret_cast<const mindspore::schema::Fill *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_FullConnection: {
      auto ptr = reinterpret_cast<const mindspore::schema::FullConnection *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_FusedBatchNorm: {
      auto ptr = reinterpret_cast<const mindspore::schema::FusedBatchNorm *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_Gather: {
      auto ptr = reinterpret_cast<const mindspore::schema::Gather *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_GatherNd: {
      auto ptr = reinterpret_cast<const mindspore::schema::GatherNd *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_Greater: {
      auto ptr = reinterpret_cast<const mindspore::schema::Greater *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_GreaterEqual: {
      auto ptr = reinterpret_cast<const mindspore::schema::GreaterEqual *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_HashtableLookup: {
      auto ptr = reinterpret_cast<const mindspore::schema::HashtableLookup *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_InstanceNorm: {
      auto ptr = reinterpret_cast<const mindspore::schema::InstanceNorm *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_LayerNormFusion: {
      auto ptr = reinterpret_cast<const mindspore::schema::LayerNormFusion *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_LeakyRelu: {
      auto ptr = reinterpret_cast<const mindspore::schema::LeakyRelu *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_Less: {
      auto ptr = reinterpret_cast<const mindspore::schema::Less *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_LessEqual: {
      auto ptr = reinterpret_cast<const mindspore::schema::LessEqual *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_Log: {
      auto ptr = reinterpret_cast<const mindspore::schema::Log *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_LogGrad: {
      auto ptr = reinterpret_cast<const mindspore::schema::LogGrad *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_LogicalAnd: {
      auto ptr = reinterpret_cast<const mindspore::schema::LogicalAnd *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_LogicalNot: {
      auto ptr = reinterpret_cast<const mindspore::schema::LogicalNot *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_LogicalOr: {
      auto ptr = reinterpret_cast<const mindspore::schema::LogicalOr *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_LpNormalization: {
      auto ptr = reinterpret_cast<const mindspore::schema::LpNormalization *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_LRN: {
      auto ptr = reinterpret_cast<const mindspore::schema::LRN *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_LshProjection: {
      auto ptr = reinterpret_cast<const mindspore::schema::LshProjection *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_LSTM: {
      auto ptr = reinterpret_cast<const mindspore::schema::LSTM *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_L2NormalizeFusion: {
      auto ptr = reinterpret_cast<const mindspore::schema::L2NormalizeFusion *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_MatMulFusion: {
      auto ptr = reinterpret_cast<const mindspore::schema::MatMulFusion *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_Maximum: {
      auto ptr = reinterpret_cast<const mindspore::schema::Maximum *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_MaximumGrad: {
      auto ptr = reinterpret_cast<const mindspore::schema::MaximumGrad *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_MaxPoolFusion: {
      auto ptr = reinterpret_cast<const mindspore::schema::MaxPoolFusion *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_MaxPoolGrad: {
      auto ptr = reinterpret_cast<const mindspore::schema::MaxPoolGrad *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_Merge: {
      auto ptr = reinterpret_cast<const mindspore::schema::Merge *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_Mfcc: {
      auto ptr = reinterpret_cast<const mindspore::schema::Mfcc *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_Minimum: {
      auto ptr = reinterpret_cast<const mindspore::schema::Minimum *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_MinimumGrad: {
      auto ptr = reinterpret_cast<const mindspore::schema::MinimumGrad *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_Mod: {
      auto ptr = reinterpret_cast<const mindspore::schema::Mod *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_MulFusion: {
      auto ptr = reinterpret_cast<const mindspore::schema::MulFusion *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_MulGrad: {
      auto ptr = reinterpret_cast<const mindspore::schema::MulGrad *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_Neg: {
      auto ptr = reinterpret_cast<const mindspore::schema::Neg *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_NegGrad: {
      auto ptr = reinterpret_cast<const mindspore::schema::NegGrad *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_NotEqual: {
      auto ptr = reinterpret_cast<const mindspore::schema::NotEqual *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_NonMaxSuppression: {
      auto ptr = reinterpret_cast<const mindspore::schema::NonMaxSuppression *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_OneHot: {
      auto ptr = reinterpret_cast<const mindspore::schema::OneHot *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_OnesLike: {
      auto ptr = reinterpret_cast<const mindspore::schema::OnesLike *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_PadFusion: {
      auto ptr = reinterpret_cast<const mindspore::schema::PadFusion *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_PartialFusion: {
      auto ptr = reinterpret_cast<const mindspore::schema::PartialFusion *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_PowerGrad: {
      auto ptr = reinterpret_cast<const mindspore::schema::PowerGrad *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_PowFusion: {
      auto ptr = reinterpret_cast<const mindspore::schema::PowFusion *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_PriorBox: {
      auto ptr = reinterpret_cast<const mindspore::schema::PriorBox *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_PReLUFusion: {
      auto ptr = reinterpret_cast<const mindspore::schema::PReLUFusion *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_QuantDTypeCast: {
      auto ptr = reinterpret_cast<const mindspore::schema::QuantDTypeCast *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_Rank: {
      auto ptr = reinterpret_cast<const mindspore::schema::Rank *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_Range: {
      auto ptr = reinterpret_cast<const mindspore::schema::Range *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_Reciprocal: {
      auto ptr = reinterpret_cast<const mindspore::schema::Reciprocal *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_RealDiv: {
      auto ptr = reinterpret_cast<const mindspore::schema::RealDiv *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_ReduceFusion: {
      auto ptr = reinterpret_cast<const mindspore::schema::ReduceFusion *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_Reshape: {
      auto ptr = reinterpret_cast<const mindspore::schema::Reshape *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_Resize: {
      auto ptr = reinterpret_cast<const mindspore::schema::Resize *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_ReverseSequence: {
      auto ptr = reinterpret_cast<const mindspore::schema::ReverseSequence *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_ReverseV2: {
      auto ptr = reinterpret_cast<const mindspore::schema::ReverseV2 *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_Rfft: {
      auto ptr = reinterpret_cast<const mindspore::schema::Rfft *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_ROIPooling: {
      auto ptr = reinterpret_cast<const mindspore::schema::ROIPooling *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_Round: {
      auto ptr = reinterpret_cast<const mindspore::schema::Round *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_Rsqrt: {
      auto ptr = reinterpret_cast<const mindspore::schema::Rsqrt *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_ScaleFusion: {
      auto ptr = reinterpret_cast<const mindspore::schema::ScaleFusion *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_ScatterNd: {
      auto ptr = reinterpret_cast<const mindspore::schema::ScatterNd *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_SGD: {
      auto ptr = reinterpret_cast<const mindspore::schema::SGD *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_Shape: {
      auto ptr = reinterpret_cast<const mindspore::schema::Shape *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_SigmoidCrossEntropyWithLogits: {
      auto ptr = reinterpret_cast<const mindspore::schema::SigmoidCrossEntropyWithLogits *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_SigmoidCrossEntropyWithLogitsGrad: {
      auto ptr = reinterpret_cast<const mindspore::schema::SigmoidCrossEntropyWithLogitsGrad *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_Sin: {
      auto ptr = reinterpret_cast<const mindspore::schema::Sin *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_SkipGram: {
      auto ptr = reinterpret_cast<const mindspore::schema::SkipGram *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_SliceFusion: {
      auto ptr = reinterpret_cast<const mindspore::schema::SliceFusion *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_SmoothL1Loss: {
      auto ptr = reinterpret_cast<const mindspore::schema::SmoothL1Loss *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_SmoothL1LossGrad: {
      auto ptr = reinterpret_cast<const mindspore::schema::SmoothL1LossGrad *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_Softmax: {
      auto ptr = reinterpret_cast<const mindspore::schema::Softmax *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_SoftmaxCrossEntropyWithLogits: {
      auto ptr = reinterpret_cast<const mindspore::schema::SoftmaxCrossEntropyWithLogits *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_SpaceToBatch: {
      auto ptr = reinterpret_cast<const mindspore::schema::SpaceToBatch *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_SpaceToBatchND: {
      auto ptr = reinterpret_cast<const mindspore::schema::SpaceToBatchND *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_SpaceToDepth: {
      auto ptr = reinterpret_cast<const mindspore::schema::SpaceToDepth *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_SparseSoftmaxCrossEntropyWithLogits: {
      auto ptr = reinterpret_cast<const mindspore::schema::SparseSoftmaxCrossEntropyWithLogits *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_SparseToDense: {
      auto ptr = reinterpret_cast<const mindspore::schema::SparseToDense *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_Split: {
      auto ptr = reinterpret_cast<const mindspore::schema::Split *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_Sqrt: {
      auto ptr = reinterpret_cast<const mindspore::schema::Sqrt *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_Squeeze: {
      auto ptr = reinterpret_cast<const mindspore::schema::Squeeze *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_Square: {
      auto ptr = reinterpret_cast<const mindspore::schema::Square *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_SquaredDifference: {
      auto ptr = reinterpret_cast<const mindspore::schema::SquaredDifference *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_Stack: {
      auto ptr = reinterpret_cast<const mindspore::schema::Stack *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_StridedSlice: {
      auto ptr = reinterpret_cast<const mindspore::schema::StridedSlice *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_SubFusion: {
      auto ptr = reinterpret_cast<const mindspore::schema::SubFusion *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_SubGrad: {
      auto ptr = reinterpret_cast<const mindspore::schema::SubGrad *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_Switch: {
      auto ptr = reinterpret_cast<const mindspore::schema::Switch *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_TensorListFromTensor: {
      auto ptr = reinterpret_cast<const mindspore::schema::TensorListFromTensor *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_TensorListGetItem: {
      auto ptr = reinterpret_cast<const mindspore::schema::TensorListGetItem *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_TensorListReserve: {
      auto ptr = reinterpret_cast<const mindspore::schema::TensorListReserve *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_TensorListSetItem: {
      auto ptr = reinterpret_cast<const mindspore::schema::TensorListSetItem *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_TensorListStack: {
      auto ptr = reinterpret_cast<const mindspore::schema::TensorListStack *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_TileFusion: {
      auto ptr = reinterpret_cast<const mindspore::schema::TileFusion *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_TopKFusion: {
      auto ptr = reinterpret_cast<const mindspore::schema::TopKFusion *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_Transpose: {
      auto ptr = reinterpret_cast<const mindspore::schema::Transpose *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_Unique: {
      auto ptr = reinterpret_cast<const mindspore::schema::Unique *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_UnsortedSegmentSum: {
      auto ptr = reinterpret_cast<const mindspore::schema::UnsortedSegmentSum *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_Unsqueeze: {
      auto ptr = reinterpret_cast<const mindspore::schema::Unsqueeze *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_Unstack: {
      auto ptr = reinterpret_cast<const mindspore::schema::Unstack *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_LSTMGrad: {
      auto ptr = reinterpret_cast<const mindspore::schema::LSTMGrad *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_Where: {
      auto ptr = reinterpret_cast<const mindspore::schema::Where *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_ZerosLike: {
      auto ptr = reinterpret_cast<const mindspore::schema::ZerosLike *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_Select: {
      auto ptr = reinterpret_cast<const mindspore::schema::Select *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_ScatterNdUpdate: {
      auto ptr = reinterpret_cast<const mindspore::schema::ScatterNdUpdate *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_GRU: {
      auto ptr = reinterpret_cast<const mindspore::schema::GRU *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_NonZero: {
      auto ptr = reinterpret_cast<const mindspore::schema::NonZero *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_InvertPermutation: {
      auto ptr = reinterpret_cast<const mindspore::schema::InvertPermutation *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_Size: {
      auto ptr = reinterpret_cast<const mindspore::schema::Size *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_RandomStandardNormal: {
      auto ptr = reinterpret_cast<const mindspore::schema::RandomStandardNormal *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_CropAndResize: {
      auto ptr = reinterpret_cast<const mindspore::schema::CropAndResize *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_Erf: {
      auto ptr = reinterpret_cast<const mindspore::schema::Erf *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_StridedSliceGrad: {
      auto ptr = reinterpret_cast<const mindspore::schema::StridedSliceGrad *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_IsFinite: {
      auto ptr = reinterpret_cast<const mindspore::schema::IsFinite *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_LinSpace: {
      auto ptr = reinterpret_cast<const mindspore::schema::LinSpace *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_UniformReal: {
      auto ptr = reinterpret_cast<const mindspore::schema::UniformReal *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_AbsGrad: {
      auto ptr = reinterpret_cast<const mindspore::schema::AbsGrad *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_RsqrtGrad: {
      auto ptr = reinterpret_cast<const mindspore::schema::RsqrtGrad *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_SqrtGrad: {
      auto ptr = reinterpret_cast<const mindspore::schema::SqrtGrad *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_LayerNormGrad: {
      auto ptr = reinterpret_cast<const mindspore::schema::LayerNormGrad *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_ResizeGrad: {
      auto ptr = reinterpret_cast<const mindspore::schema::ResizeGrad *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_Splice: {
      auto ptr = reinterpret_cast<const mindspore::schema::Splice *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_LogSoftmax: {
      auto ptr = reinterpret_cast<const mindspore::schema::LogSoftmax *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_Call: {
      auto ptr = reinterpret_cast<const mindspore::schema::Call *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_Custom: {
      auto ptr = reinterpret_cast<const mindspore::schema::Custom *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_CumSum: {
      auto ptr = reinterpret_cast<const mindspore::schema::CumSum *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_SplitWithOverlap: {
      auto ptr = reinterpret_cast<const mindspore::schema::SplitWithOverlap *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_GenOP: {
      auto ptr = reinterpret_cast<const mindspore::schema::GenOP *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_RaggedRange: {
      auto ptr = reinterpret_cast<const mindspore::schema::RaggedRange *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_GLU: {
      auto ptr = reinterpret_cast<const mindspore::schema::GLU *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_TensorArray: {
      auto ptr = reinterpret_cast<const mindspore::schema::TensorArray *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_TensorArrayRead: {
      auto ptr = reinterpret_cast<const mindspore::schema::TensorArrayRead *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_TensorArrayWrite: {
      auto ptr = reinterpret_cast<const mindspore::schema::TensorArrayWrite *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_Affine: {
      auto ptr = reinterpret_cast<const mindspore::schema::Affine *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return true;
  }
}

inline bool VerifyPrimitiveTypeVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyPrimitiveType(
        verifier,  values->Get(i), types->GetEnum<PrimitiveType>(i))) {
      return false;
    }
  }
  return true;
}

inline void *PrimitiveTypeUnion::UnPack(const void *obj, PrimitiveType type, const flatbuffers::resolver_function_t *resolver) {
  switch (type) {
    case PrimitiveType_Abs: {
      auto ptr = reinterpret_cast<const mindspore::schema::Abs *>(obj);
      return ptr->UnPack(resolver);
    }
    case PrimitiveType_Activation: {
      auto ptr = reinterpret_cast<const mindspore::schema::Activation *>(obj);
      return ptr->UnPack(resolver);
    }
    case PrimitiveType_ActivationGrad: {
      auto ptr = reinterpret_cast<const mindspore::schema::ActivationGrad *>(obj);
      return ptr->UnPack(resolver);
    }
    case PrimitiveType_Adam: {
      auto ptr = reinterpret_cast<const mindspore::schema::Adam *>(obj);
      return ptr->UnPack(resolver);
    }
    case PrimitiveType_AddFusion: {
      auto ptr = reinterpret_cast<const mindspore::schema::AddFusion *>(obj);
      return ptr->UnPack(resolver);
    }
    case PrimitiveType_AdderFusion: {
      auto ptr = reinterpret_cast<const mindspore::schema::AdderFusion *>(obj);
      return ptr->UnPack(resolver);
    }
    case PrimitiveType_AddGrad: {
      auto ptr = reinterpret_cast<const mindspore::schema::AddGrad *>(obj);
      return ptr->UnPack(resolver);
    }
    case PrimitiveType_AddN: {
      auto ptr = reinterpret_cast<const mindspore::schema::AddN *>(obj);
      return ptr->UnPack(resolver);
    }
    case PrimitiveType_All: {
      auto ptr = reinterpret_cast<const mindspore::schema::All *>(obj);
      return ptr->UnPack(resolver);
    }
    case PrimitiveType_ApplyMomentum: {
      auto ptr = reinterpret_cast<const mindspore::schema::ApplyMomentum *>(obj);
      return ptr->UnPack(resolver);
    }
    case PrimitiveType_ArgMaxFusion: {
      auto ptr = reinterpret_cast<const mindspore::schema::ArgMaxFusion *>(obj);
      return ptr->UnPack(resolver);
    }
    case PrimitiveType_ArgMinFusion: {
      auto ptr = reinterpret_cast<const mindspore::schema::ArgMinFusion *>(obj);
      return ptr->UnPack(resolver);
    }
    case PrimitiveType_Assert: {
      auto ptr = reinterpret_cast<const mindspore::schema::Assert *>(obj);
      return ptr->UnPack(resolver);
    }
    case PrimitiveType_Assign: {
      auto ptr = reinterpret_cast<const mindspore::schema::Assign *>(obj);
      return ptr->UnPack(resolver);
    }
    case PrimitiveType_AssignAdd: {
      auto ptr = reinterpret_cast<const mindspore::schema::AssignAdd *>(obj);
      return ptr->UnPack(resolver);
    }
    case PrimitiveType_AudioSpectrogram: {
      auto ptr = reinterpret_cast<const mindspore::schema::AudioSpectrogram *>(obj);
      return ptr->UnPack(resolver);
    }
    case PrimitiveType_AvgPoolFusion: {
      auto ptr = reinterpret_cast<const mindspore::schema::AvgPoolFusion *>(obj);
      return ptr->UnPack(resolver);
    }
    case PrimitiveType_AvgPoolGrad: {
      auto ptr = reinterpret_cast<const mindspore::schema::AvgPoolGrad *>(obj);
      return ptr->UnPack(resolver);
    }
    case PrimitiveType_BatchNorm: {
      auto ptr = reinterpret_cast<const mindspore::schema::BatchNorm *>(obj);
      return ptr->UnPack(resolver);
    }
    case PrimitiveType_BatchNormGrad: {
      auto ptr = reinterpret_cast<const mindspore::schema::BatchNormGrad *>(obj);
      return ptr->UnPack(resolver);
    }
    case PrimitiveType_BatchToSpace: {
      auto ptr = reinterpret_cast<const mindspore::schema::BatchToSpace *>(obj);
      return ptr->UnPack(resolver);
    }
    case PrimitiveType_BatchToSpaceND: {
      auto ptr = reinterpret_cast<const mindspore::schema::BatchToSpaceND *>(obj);
      return ptr->UnPack(resolver);
    }
    case PrimitiveType_BiasAdd: {
      auto ptr = reinterpret_cast<const mindspore::schema::BiasAdd *>(obj);
      return ptr->UnPack(resolver);
    }
    case PrimitiveType_BinaryCrossEntropy: {
      auto ptr = reinterpret_cast<const mindspore::schema::BinaryCrossEntropy *>(obj);
      return ptr->UnPack(resolver);
    }
    case PrimitiveType_BinaryCrossEntropyGrad: {
      auto ptr = reinterpret_cast<const mindspore::schema::BinaryCrossEntropyGrad *>(obj);
      return ptr->UnPack(resolver);
    }
    case PrimitiveType_BiasAddGrad: {
      auto ptr = reinterpret_cast<const mindspore::schema::BiasAddGrad *>(obj);
      return ptr->UnPack(resolver);
    }
    case PrimitiveType_BroadcastTo: {
      auto ptr = reinterpret_cast<const mindspore::schema::BroadcastTo *>(obj);
      return ptr->UnPack(resolver);
    }
    case PrimitiveType_Cast: {
      auto ptr = reinterpret_cast<const mindspore::schema::Cast *>(obj);
      return ptr->UnPack(resolver);
    }
    case PrimitiveType_Ceil: {
      auto ptr = reinterpret_cast<const mindspore::schema::Ceil *>(obj);
      return ptr->UnPack(resolver);
    }
    case PrimitiveType_Clip: {
      auto ptr = reinterpret_cast<const mindspore::schema::Clip *>(obj);
      return ptr->UnPack(resolver);
    }
    case PrimitiveType_Concat: {
      auto ptr = reinterpret_cast<const mindspore::schema::Concat *>(obj);
      return ptr->UnPack(resolver);
    }
    case PrimitiveType_Attention: {
      auto ptr = reinterpret_cast<const mindspore::schema::Attention *>(obj);
      return ptr->UnPack(resolver);
    }
    case PrimitiveType_Conv2DBackpropFilterFusion: {
      auto ptr = reinterpret_cast<const mindspore::schema::Conv2DBackpropFilterFusion *>(obj);
      return ptr->UnPack(resolver);
    }
    case PrimitiveType_Conv2DBackpropInputFusion: {
      auto ptr = reinterpret_cast<const mindspore::schema::Conv2DBackpropInputFusion *>(obj);
      return ptr->UnPack(resolver);
    }
    case PrimitiveType_Conv2DFusion: {
      auto ptr = reinterpret_cast<const mindspore::schema::Conv2DFusion *>(obj);
      return ptr->UnPack(resolver);
    }
    case PrimitiveType_Conv2dTransposeFusion: {
      auto ptr = reinterpret_cast<const mindspore::schema::Conv2dTransposeFusion *>(obj);
      return ptr->UnPack(resolver);
    }
    case PrimitiveType_Cos: {
      auto ptr = reinterpret_cast<const mindspore::schema::Cos *>(obj);
      return ptr->UnPack(resolver);
    }
    case PrimitiveType_ConstantOfShape: {
      auto ptr = reinterpret_cast<const mindspore::schema::ConstantOfShape *>(obj);
      return ptr->UnPack(resolver);
    }
    case PrimitiveType_Crop: {
      auto ptr = reinterpret_cast<const mindspore::schema::Crop *>(obj);
      return ptr->UnPack(resolver);
    }
    case PrimitiveType_CustomExtractFeatures: {
      auto ptr = reinterpret_cast<const mindspore::schema::CustomExtractFeatures *>(obj);
      return ptr->UnPack(resolver);
    }
    case PrimitiveType_CustomNormalize: {
      auto ptr = reinterpret_cast<const mindspore::schema::CustomNormalize *>(obj);
      return ptr->UnPack(resolver);
    }
    case PrimitiveType_CustomPredict: {
      auto ptr = reinterpret_cast<const mindspore::schema::CustomPredict *>(obj);
      return ptr->UnPack(resolver);
    }
    case PrimitiveType_DeConv2DGradFilter: {
      auto ptr = reinterpret_cast<const mindspore::schema::DeConv2DGradFilter *>(obj);
      return ptr->UnPack(resolver);
    }
    case PrimitiveType_Depend: {
      auto ptr = reinterpret_cast<const mindspore::schema::Depend *>(obj);
      return ptr->UnPack(resolver);
    }
    case PrimitiveType_DepthToSpace: {
      auto ptr = reinterpret_cast<const mindspore::schema::DepthToSpace *>(obj);
      return ptr->UnPack(resolver);
    }
    case PrimitiveType_DetectionPostProcess: {
      auto ptr = reinterpret_cast<const mindspore::schema::DetectionPostProcess *>(obj);
      return ptr->UnPack(resolver);
    }
    case PrimitiveType_DivFusion: {
      auto ptr = reinterpret_cast<const mindspore::schema::DivFusion *>(obj);
      return ptr->UnPack(resolver);
    }
    case PrimitiveType_DivGrad: {
      auto ptr = reinterpret_cast<const mindspore::schema::DivGrad *>(obj);
      return ptr->UnPack(resolver);
    }
    case PrimitiveType_Dropout: {
      auto ptr = reinterpret_cast<const mindspore::schema::Dropout *>(obj);
      return ptr->UnPack(resolver);
    }
    case PrimitiveType_DropoutGrad: {
      auto ptr = reinterpret_cast<const mindspore::schema::DropoutGrad *>(obj);
      return ptr->UnPack(resolver);
    }
    case PrimitiveType_Elu: {
      auto ptr = reinterpret_cast<const mindspore::schema::Elu *>(obj);
      return ptr->UnPack(resolver);
    }
    case PrimitiveType_Eltwise: {
      auto ptr = reinterpret_cast<const mindspore::schema::Eltwise *>(obj);
      return ptr->UnPack(resolver);
    }
    case PrimitiveType_Equal: {
      auto ptr = reinterpret_cast<const mindspore::schema::Equal *>(obj);
      return ptr->UnPack(resolver);
    }
    case PrimitiveType_EmbeddingLookupFusion: {
      auto ptr = reinterpret_cast<const mindspore::schema::EmbeddingLookupFusion *>(obj);
      return ptr->UnPack(resolver);
    }
    case PrimitiveType_ExpFusion: {
      auto ptr = reinterpret_cast<const mindspore::schema::ExpFusion *>(obj);
      return ptr->UnPack(resolver);
    }
    case PrimitiveType_ExpandDims: {
      auto ptr = reinterpret_cast<const mindspore::schema::ExpandDims *>(obj);
      return ptr->UnPack(resolver);
    }
    case PrimitiveType_FakeQuantWithMinMaxVars: {
      auto ptr = reinterpret_cast<const mindspore::schema::FakeQuantWithMinMaxVars *>(obj);
      return ptr->UnPack(resolver);
    }
    case PrimitiveType_FakeQuantWithMinMaxVarsPerChannel: {
      auto ptr = reinterpret_cast<const mindspore::schema::FakeQuantWithMinMaxVarsPerChannel *>(obj);
      return ptr->UnPack(resolver);
    }
    case PrimitiveType_FftReal: {
      auto ptr = reinterpret_cast<const mindspore::schema::FftReal *>(obj);
      return ptr->UnPack(resolver);
    }
    case PrimitiveType_FftImag: {
      auto ptr = reinterpret_cast<const mindspore::schema::FftImag *>(obj);
      return ptr->UnPack(resolver);
    }
    case PrimitiveType_Flatten: {
      auto ptr = reinterpret_cast<const mindspore::schema::Flatten *>(obj);
      return ptr->UnPack(resolver);
    }
    case PrimitiveType_FlattenGrad: {
      auto ptr = reinterpret_cast<const mindspore::schema::FlattenGrad *>(obj);
      return ptr->UnPack(resolver);
    }
    case PrimitiveType_Floor: {
      auto ptr = reinterpret_cast<const mindspore::schema::Floor *>(obj);
      return ptr->UnPack(resolver);
    }
    case PrimitiveType_FloorDiv: {
      auto ptr = reinterpret_cast<const mindspore::schema::FloorDiv *>(obj);
      return ptr->UnPack(resolver);
    }
    case PrimitiveType_FloorMod: {
      auto ptr = reinterpret_cast<const mindspore::schema::FloorMod *>(obj);
      return ptr->UnPack(resolver);
    }
    case PrimitiveType_Fill: {
      auto ptr = reinterpret_cast<const mindspore::schema::Fill *>(obj);
      return ptr->UnPack(resolver);
    }
    case PrimitiveType_FullConnection: {
      auto ptr = reinterpret_cast<const mindspore::schema::FullConnection *>(obj);
      return ptr->UnPack(resolver);
    }
    case PrimitiveType_FusedBatchNorm: {
      auto ptr = reinterpret_cast<const mindspore::schema::FusedBatchNorm *>(obj);
      return ptr->UnPack(resolver);
    }
    case PrimitiveType_Gather: {
      auto ptr = reinterpret_cast<const mindspore::schema::Gather *>(obj);
      return ptr->UnPack(resolver);
    }
    case PrimitiveType_GatherNd: {
      auto ptr = reinterpret_cast<const mindspore::schema::GatherNd *>(obj);
      return ptr->UnPack(resolver);
    }
    case PrimitiveType_Greater: {
      auto ptr = reinterpret_cast<const mindspore::schema::Greater *>(obj);
      return ptr->UnPack(resolver);
    }
    case PrimitiveType_GreaterEqual: {
      auto ptr = reinterpret_cast<const mindspore::schema::GreaterEqual *>(obj);
      return ptr->UnPack(resolver);
    }
    case PrimitiveType_HashtableLookup: {
      auto ptr = reinterpret_cast<const mindspore::schema::HashtableLookup *>(obj);
      return ptr->UnPack(resolver);
    }
    case PrimitiveType_InstanceNorm: {
      auto ptr = reinterpret_cast<const mindspore::schema::InstanceNorm *>(obj);
      return ptr->UnPack(resolver);
    }
    case PrimitiveType_LayerNormFusion: {
      auto ptr = reinterpret_cast<const mindspore::schema::LayerNormFusion *>(obj);
      return ptr->UnPack(resolver);
    }
    case PrimitiveType_LeakyRelu: {
      auto ptr = reinterpret_cast<const mindspore::schema::LeakyRelu *>(obj);
      return ptr->UnPack(resolver);
    }
    case PrimitiveType_Less: {
      auto ptr = reinterpret_cast<const mindspore::schema::Less *>(obj);
      return ptr->UnPack(resolver);
    }
    case PrimitiveType_LessEqual: {
      auto ptr = reinterpret_cast<const mindspore::schema::LessEqual *>(obj);
      return ptr->UnPack(resolver);
    }
    case PrimitiveType_Log: {
      auto ptr = reinterpret_cast<const mindspore::schema::Log *>(obj);
      return ptr->UnPack(resolver);
    }
    case PrimitiveType_LogGrad: {
      auto ptr = reinterpret_cast<const mindspore::schema::LogGrad *>(obj);
      return ptr->UnPack(resolver);
    }
    case PrimitiveType_LogicalAnd: {
      auto ptr = reinterpret_cast<const mindspore::schema::LogicalAnd *>(obj);
      return ptr->UnPack(resolver);
    }
    case PrimitiveType_LogicalNot: {
      auto ptr = reinterpret_cast<const mindspore::schema::LogicalNot *>(obj);
      return ptr->UnPack(resolver);
    }
    case PrimitiveType_LogicalOr: {
      auto ptr = reinterpret_cast<const mindspore::schema::LogicalOr *>(obj);
      return ptr->UnPack(resolver);
    }
    case PrimitiveType_LpNormalization: {
      auto ptr = reinterpret_cast<const mindspore::schema::LpNormalization *>(obj);
      return ptr->UnPack(resolver);
    }
    case PrimitiveType_LRN: {
      auto ptr = reinterpret_cast<const mindspore::schema::LRN *>(obj);
      return ptr->UnPack(resolver);
    }
    case PrimitiveType_LshProjection: {
      auto ptr = reinterpret_cast<const mindspore::schema::LshProjection *>(obj);
      return ptr->UnPack(resolver);
    }
    case PrimitiveType_LSTM: {
      auto ptr = reinterpret_cast<const mindspore::schema::LSTM *>(obj);
      return ptr->UnPack(resolver);
    }
    case PrimitiveType_L2NormalizeFusion: {
      auto ptr = reinterpret_cast<const mindspore::schema::L2NormalizeFusion *>(obj);
      return ptr->UnPack(resolver);
    }
    case PrimitiveType_MatMulFusion: {
      auto ptr = reinterpret_cast<const mindspore::schema::MatMulFusion *>(obj);
      return ptr->UnPack(resolver);
    }
    case PrimitiveType_Maximum: {
      auto ptr = reinterpret_cast<const mindspore::schema::Maximum *>(obj);
      return ptr->UnPack(resolver);
    }
    case PrimitiveType_MaximumGrad: {
      auto ptr = reinterpret_cast<const mindspore::schema::MaximumGrad *>(obj);
      return ptr->UnPack(resolver);
    }
    case PrimitiveType_MaxPoolFusion: {
      auto ptr = reinterpret_cast<const mindspore::schema::MaxPoolFusion *>(obj);
      return ptr->UnPack(resolver);
    }
    case PrimitiveType_MaxPoolGrad: {
      auto ptr = reinterpret_cast<const mindspore::schema::MaxPoolGrad *>(obj);
      return ptr->UnPack(resolver);
    }
    case PrimitiveType_Merge: {
      auto ptr = reinterpret_cast<const mindspore::schema::Merge *>(obj);
      return ptr->UnPack(resolver);
    }
    case PrimitiveType_Mfcc: {
      auto ptr = reinterpret_cast<const mindspore::schema::Mfcc *>(obj);
      return ptr->UnPack(resolver);
    }
    case PrimitiveType_Minimum: {
      auto ptr = reinterpret_cast<const mindspore::schema::Minimum *>(obj);
      return ptr->UnPack(resolver);
    }
    case PrimitiveType_MinimumGrad: {
      auto ptr = reinterpret_cast<const mindspore::schema::MinimumGrad *>(obj);
      return ptr->UnPack(resolver);
    }
    case PrimitiveType_Mod: {
      auto ptr = reinterpret_cast<const mindspore::schema::Mod *>(obj);
      return ptr->UnPack(resolver);
    }
    case PrimitiveType_MulFusion: {
      auto ptr = reinterpret_cast<const mindspore::schema::MulFusion *>(obj);
      return ptr->UnPack(resolver);
    }
    case PrimitiveType_MulGrad: {
      auto ptr = reinterpret_cast<const mindspore::schema::MulGrad *>(obj);
      return ptr->UnPack(resolver);
    }
    case PrimitiveType_Neg: {
      auto ptr = reinterpret_cast<const mindspore::schema::Neg *>(obj);
      return ptr->UnPack(resolver);
    }
    case PrimitiveType_NegGrad: {
      auto ptr = reinterpret_cast<const mindspore::schema::NegGrad *>(obj);
      return ptr->UnPack(resolver);
    }
    case PrimitiveType_NotEqual: {
      auto ptr = reinterpret_cast<const mindspore::schema::NotEqual *>(obj);
      return ptr->UnPack(resolver);
    }
    case PrimitiveType_NonMaxSuppression: {
      auto ptr = reinterpret_cast<const mindspore::schema::NonMaxSuppression *>(obj);
      return ptr->UnPack(resolver);
    }
    case PrimitiveType_OneHot: {
      auto ptr = reinterpret_cast<const mindspore::schema::OneHot *>(obj);
      return ptr->UnPack(resolver);
    }
    case PrimitiveType_OnesLike: {
      auto ptr = reinterpret_cast<const mindspore::schema::OnesLike *>(obj);
      return ptr->UnPack(resolver);
    }
    case PrimitiveType_PadFusion: {
      auto ptr = reinterpret_cast<const mindspore::schema::PadFusion *>(obj);
      return ptr->UnPack(resolver);
    }
    case PrimitiveType_PartialFusion: {
      auto ptr = reinterpret_cast<const mindspore::schema::PartialFusion *>(obj);
      return ptr->UnPack(resolver);
    }
    case PrimitiveType_PowerGrad: {
      auto ptr = reinterpret_cast<const mindspore::schema::PowerGrad *>(obj);
      return ptr->UnPack(resolver);
    }
    case PrimitiveType_PowFusion: {
      auto ptr = reinterpret_cast<const mindspore::schema::PowFusion *>(obj);
      return ptr->UnPack(resolver);
    }
    case PrimitiveType_PriorBox: {
      auto ptr = reinterpret_cast<const mindspore::schema::PriorBox *>(obj);
      return ptr->UnPack(resolver);
    }
    case PrimitiveType_PReLUFusion: {
      auto ptr = reinterpret_cast<const mindspore::schema::PReLUFusion *>(obj);
      return ptr->UnPack(resolver);
    }
    case PrimitiveType_QuantDTypeCast: {
      auto ptr = reinterpret_cast<const mindspore::schema::QuantDTypeCast *>(obj);
      return ptr->UnPack(resolver);
    }
    case PrimitiveType_Rank: {
      auto ptr = reinterpret_cast<const mindspore::schema::Rank *>(obj);
      return ptr->UnPack(resolver);
    }
    case PrimitiveType_Range: {
      auto ptr = reinterpret_cast<const mindspore::schema::Range *>(obj);
      return ptr->UnPack(resolver);
    }
    case PrimitiveType_Reciprocal: {
      auto ptr = reinterpret_cast<const mindspore::schema::Reciprocal *>(obj);
      return ptr->UnPack(resolver);
    }
    case PrimitiveType_RealDiv: {
      auto ptr = reinterpret_cast<const mindspore::schema::RealDiv *>(obj);
      return ptr->UnPack(resolver);
    }
    case PrimitiveType_ReduceFusion: {
      auto ptr = reinterpret_cast<const mindspore::schema::ReduceFusion *>(obj);
      return ptr->UnPack(resolver);
    }
    case PrimitiveType_Reshape: {
      auto ptr = reinterpret_cast<const mindspore::schema::Reshape *>(obj);
      return ptr->UnPack(resolver);
    }
    case PrimitiveType_Resize: {
      auto ptr = reinterpret_cast<const mindspore::schema::Resize *>(obj);
      return ptr->UnPack(resolver);
    }
    case PrimitiveType_ReverseSequence: {
      auto ptr = reinterpret_cast<const mindspore::schema::ReverseSequence *>(obj);
      return ptr->UnPack(resolver);
    }
    case PrimitiveType_ReverseV2: {
      auto ptr = reinterpret_cast<const mindspore::schema::ReverseV2 *>(obj);
      return ptr->UnPack(resolver);
    }
    case PrimitiveType_Rfft: {
      auto ptr = reinterpret_cast<const mindspore::schema::Rfft *>(obj);
      return ptr->UnPack(resolver);
    }
    case PrimitiveType_ROIPooling: {
      auto ptr = reinterpret_cast<const mindspore::schema::ROIPooling *>(obj);
      return ptr->UnPack(resolver);
    }
    case PrimitiveType_Round: {
      auto ptr = reinterpret_cast<const mindspore::schema::Round *>(obj);
      return ptr->UnPack(resolver);
    }
    case PrimitiveType_Rsqrt: {
      auto ptr = reinterpret_cast<const mindspore::schema::Rsqrt *>(obj);
      return ptr->UnPack(resolver);
    }
    case PrimitiveType_ScaleFusion: {
      auto ptr = reinterpret_cast<const mindspore::schema::ScaleFusion *>(obj);
      return ptr->UnPack(resolver);
    }
    case PrimitiveType_ScatterNd: {
      auto ptr = reinterpret_cast<const mindspore::schema::ScatterNd *>(obj);
      return ptr->UnPack(resolver);
    }
    case PrimitiveType_SGD: {
      auto ptr = reinterpret_cast<const mindspore::schema::SGD *>(obj);
      return ptr->UnPack(resolver);
    }
    case PrimitiveType_Shape: {
      auto ptr = reinterpret_cast<const mindspore::schema::Shape *>(obj);
      return ptr->UnPack(resolver);
    }
    case PrimitiveType_SigmoidCrossEntropyWithLogits: {
      auto ptr = reinterpret_cast<const mindspore::schema::SigmoidCrossEntropyWithLogits *>(obj);
      return ptr->UnPack(resolver);
    }
    case PrimitiveType_SigmoidCrossEntropyWithLogitsGrad: {
      auto ptr = reinterpret_cast<const mindspore::schema::SigmoidCrossEntropyWithLogitsGrad *>(obj);
      return ptr->UnPack(resolver);
    }
    case PrimitiveType_Sin: {
      auto ptr = reinterpret_cast<const mindspore::schema::Sin *>(obj);
      return ptr->UnPack(resolver);
    }
    case PrimitiveType_SkipGram: {
      auto ptr = reinterpret_cast<const mindspore::schema::SkipGram *>(obj);
      return ptr->UnPack(resolver);
    }
    case PrimitiveType_SliceFusion: {
      auto ptr = reinterpret_cast<const mindspore::schema::SliceFusion *>(obj);
      return ptr->UnPack(resolver);
    }
    case PrimitiveType_SmoothL1Loss: {
      auto ptr = reinterpret_cast<const mindspore::schema::SmoothL1Loss *>(obj);
      return ptr->UnPack(resolver);
    }
    case PrimitiveType_SmoothL1LossGrad: {
      auto ptr = reinterpret_cast<const mindspore::schema::SmoothL1LossGrad *>(obj);
      return ptr->UnPack(resolver);
    }
    case PrimitiveType_Softmax: {
      auto ptr = reinterpret_cast<const mindspore::schema::Softmax *>(obj);
      return ptr->UnPack(resolver);
    }
    case PrimitiveType_SoftmaxCrossEntropyWithLogits: {
      auto ptr = reinterpret_cast<const mindspore::schema::SoftmaxCrossEntropyWithLogits *>(obj);
      return ptr->UnPack(resolver);
    }
    case PrimitiveType_SpaceToBatch: {
      auto ptr = reinterpret_cast<const mindspore::schema::SpaceToBatch *>(obj);
      return ptr->UnPack(resolver);
    }
    case PrimitiveType_SpaceToBatchND: {
      auto ptr = reinterpret_cast<const mindspore::schema::SpaceToBatchND *>(obj);
      return ptr->UnPack(resolver);
    }
    case PrimitiveType_SpaceToDepth: {
      auto ptr = reinterpret_cast<const mindspore::schema::SpaceToDepth *>(obj);
      return ptr->UnPack(resolver);
    }
    case PrimitiveType_SparseSoftmaxCrossEntropyWithLogits: {
      auto ptr = reinterpret_cast<const mindspore::schema::SparseSoftmaxCrossEntropyWithLogits *>(obj);
      return ptr->UnPack(resolver);
    }
    case PrimitiveType_SparseToDense: {
      auto ptr = reinterpret_cast<const mindspore::schema::SparseToDense *>(obj);
      return ptr->UnPack(resolver);
    }
    case PrimitiveType_Split: {
      auto ptr = reinterpret_cast<const mindspore::schema::Split *>(obj);
      return ptr->UnPack(resolver);
    }
    case PrimitiveType_Sqrt: {
      auto ptr = reinterpret_cast<const mindspore::schema::Sqrt *>(obj);
      return ptr->UnPack(resolver);
    }
    case PrimitiveType_Squeeze: {
      auto ptr = reinterpret_cast<const mindspore::schema::Squeeze *>(obj);
      return ptr->UnPack(resolver);
    }
    case PrimitiveType_Square: {
      auto ptr = reinterpret_cast<const mindspore::schema::Square *>(obj);
      return ptr->UnPack(resolver);
    }
    case PrimitiveType_SquaredDifference: {
      auto ptr = reinterpret_cast<const mindspore::schema::SquaredDifference *>(obj);
      return ptr->UnPack(resolver);
    }
    case PrimitiveType_Stack: {
      auto ptr = reinterpret_cast<const mindspore::schema::Stack *>(obj);
      return ptr->UnPack(resolver);
    }
    case PrimitiveType_StridedSlice: {
      auto ptr = reinterpret_cast<const mindspore::schema::StridedSlice *>(obj);
      return ptr->UnPack(resolver);
    }
    case PrimitiveType_SubFusion: {
      auto ptr = reinterpret_cast<const mindspore::schema::SubFusion *>(obj);
      return ptr->UnPack(resolver);
    }
    case PrimitiveType_SubGrad: {
      auto ptr = reinterpret_cast<const mindspore::schema::SubGrad *>(obj);
      return ptr->UnPack(resolver);
    }
    case PrimitiveType_Switch: {
      auto ptr = reinterpret_cast<const mindspore::schema::Switch *>(obj);
      return ptr->UnPack(resolver);
    }
    case PrimitiveType_TensorListFromTensor: {
      auto ptr = reinterpret_cast<const mindspore::schema::TensorListFromTensor *>(obj);
      return ptr->UnPack(resolver);
    }
    case PrimitiveType_TensorListGetItem: {
      auto ptr = reinterpret_cast<const mindspore::schema::TensorListGetItem *>(obj);
      return ptr->UnPack(resolver);
    }
    case PrimitiveType_TensorListReserve: {
      auto ptr = reinterpret_cast<const mindspore::schema::TensorListReserve *>(obj);
      return ptr->UnPack(resolver);
    }
    case PrimitiveType_TensorListSetItem: {
      auto ptr = reinterpret_cast<const mindspore::schema::TensorListSetItem *>(obj);
      return ptr->UnPack(resolver);
    }
    case PrimitiveType_TensorListStack: {
      auto ptr = reinterpret_cast<const mindspore::schema::TensorListStack *>(obj);
      return ptr->UnPack(resolver);
    }
    case PrimitiveType_TileFusion: {
      auto ptr = reinterpret_cast<const mindspore::schema::TileFusion *>(obj);
      return ptr->UnPack(resolver);
    }
    case PrimitiveType_TopKFusion: {
      auto ptr = reinterpret_cast<const mindspore::schema::TopKFusion *>(obj);
      return ptr->UnPack(resolver);
    }
    case PrimitiveType_Transpose: {
      auto ptr = reinterpret_cast<const mindspore::schema::Transpose *>(obj);
      return ptr->UnPack(resolver);
    }
    case PrimitiveType_Unique: {
      auto ptr = reinterpret_cast<const mindspore::schema::Unique *>(obj);
      return ptr->UnPack(resolver);
    }
    case PrimitiveType_UnsortedSegmentSum: {
      auto ptr = reinterpret_cast<const mindspore::schema::UnsortedSegmentSum *>(obj);
      return ptr->UnPack(resolver);
    }
    case PrimitiveType_Unsqueeze: {
      auto ptr = reinterpret_cast<const mindspore::schema::Unsqueeze *>(obj);
      return ptr->UnPack(resolver);
    }
    case PrimitiveType_Unstack: {
      auto ptr = reinterpret_cast<const mindspore::schema::Unstack *>(obj);
      return ptr->UnPack(resolver);
    }
    case PrimitiveType_LSTMGrad: {
      auto ptr = reinterpret_cast<const mindspore::schema::LSTMGrad *>(obj);
      return ptr->UnPack(resolver);
    }
    case PrimitiveType_Where: {
      auto ptr = reinterpret_cast<const mindspore::schema::Where *>(obj);
      return ptr->UnPack(resolver);
    }
    case PrimitiveType_ZerosLike: {
      auto ptr = reinterpret_cast<const mindspore::schema::ZerosLike *>(obj);
      return ptr->UnPack(resolver);
    }
    case PrimitiveType_Select: {
      auto ptr = reinterpret_cast<const mindspore::schema::Select *>(obj);
      return ptr->UnPack(resolver);
    }
    case PrimitiveType_ScatterNdUpdate: {
      auto ptr = reinterpret_cast<const mindspore::schema::ScatterNdUpdate *>(obj);
      return ptr->UnPack(resolver);
    }
    case PrimitiveType_GRU: {
      auto ptr = reinterpret_cast<const mindspore::schema::GRU *>(obj);
      return ptr->UnPack(resolver);
    }
    case PrimitiveType_NonZero: {
      auto ptr = reinterpret_cast<const mindspore::schema::NonZero *>(obj);
      return ptr->UnPack(resolver);
    }
    case PrimitiveType_InvertPermutation: {
      auto ptr = reinterpret_cast<const mindspore::schema::InvertPermutation *>(obj);
      return ptr->UnPack(resolver);
    }
    case PrimitiveType_Size: {
      auto ptr = reinterpret_cast<const mindspore::schema::Size *>(obj);
      return ptr->UnPack(resolver);
    }
    case PrimitiveType_RandomStandardNormal: {
      auto ptr = reinterpret_cast<const mindspore::schema::RandomStandardNormal *>(obj);
      return ptr->UnPack(resolver);
    }
    case PrimitiveType_CropAndResize: {
      auto ptr = reinterpret_cast<const mindspore::schema::CropAndResize *>(obj);
      return ptr->UnPack(resolver);
    }
    case PrimitiveType_Erf: {
      auto ptr = reinterpret_cast<const mindspore::schema::Erf *>(obj);
      return ptr->UnPack(resolver);
    }
    case PrimitiveType_StridedSliceGrad: {
      auto ptr = reinterpret_cast<const mindspore::schema::StridedSliceGrad *>(obj);
      return ptr->UnPack(resolver);
    }
    case PrimitiveType_IsFinite: {
      auto ptr = reinterpret_cast<const mindspore::schema::IsFinite *>(obj);
      return ptr->UnPack(resolver);
    }
    case PrimitiveType_LinSpace: {
      auto ptr = reinterpret_cast<const mindspore::schema::LinSpace *>(obj);
      return ptr->UnPack(resolver);
    }
    case PrimitiveType_UniformReal: {
      auto ptr = reinterpret_cast<const mindspore::schema::UniformReal *>(obj);
      return ptr->UnPack(resolver);
    }
    case PrimitiveType_AbsGrad: {
      auto ptr = reinterpret_cast<const mindspore::schema::AbsGrad *>(obj);
      return ptr->UnPack(resolver);
    }
    case PrimitiveType_RsqrtGrad: {
      auto ptr = reinterpret_cast<const mindspore::schema::RsqrtGrad *>(obj);
      return ptr->UnPack(resolver);
    }
    case PrimitiveType_SqrtGrad: {
      auto ptr = reinterpret_cast<const mindspore::schema::SqrtGrad *>(obj);
      return ptr->UnPack(resolver);
    }
    case PrimitiveType_LayerNormGrad: {
      auto ptr = reinterpret_cast<const mindspore::schema::LayerNormGrad *>(obj);
      return ptr->UnPack(resolver);
    }
    case PrimitiveType_ResizeGrad: {
      auto ptr = reinterpret_cast<const mindspore::schema::ResizeGrad *>(obj);
      return ptr->UnPack(resolver);
    }
    case PrimitiveType_Splice: {
      auto ptr = reinterpret_cast<const mindspore::schema::Splice *>(obj);
      return ptr->UnPack(resolver);
    }
    case PrimitiveType_LogSoftmax: {
      auto ptr = reinterpret_cast<const mindspore::schema::LogSoftmax *>(obj);
      return ptr->UnPack(resolver);
    }
    case PrimitiveType_Call: {
      auto ptr = reinterpret_cast<const mindspore::schema::Call *>(obj);
      return ptr->UnPack(resolver);
    }
    case PrimitiveType_Custom: {
      auto ptr = reinterpret_cast<const mindspore::schema::Custom *>(obj);
      return ptr->UnPack(resolver);
    }
    case PrimitiveType_CumSum: {
      auto ptr = reinterpret_cast<const mindspore::schema::CumSum *>(obj);
      return ptr->UnPack(resolver);
    }
    case PrimitiveType_SplitWithOverlap: {
      auto ptr = reinterpret_cast<const mindspore::schema::SplitWithOverlap *>(obj);
      return ptr->UnPack(resolver);
    }
    case PrimitiveType_GenOP: {
      auto ptr = reinterpret_cast<const mindspore::schema::GenOP *>(obj);
      return ptr->UnPack(resolver);
    }
    case PrimitiveType_RaggedRange: {
      auto ptr = reinterpret_cast<const mindspore::schema::RaggedRange *>(obj);
      return ptr->UnPack(resolver);
    }
    case PrimitiveType_GLU: {
      auto ptr = reinterpret_cast<const mindspore::schema::GLU *>(obj);
      return ptr->UnPack(resolver);
    }
    case PrimitiveType_TensorArray: {
      auto ptr = reinterpret_cast<const mindspore::schema::TensorArray *>(obj);
      return ptr->UnPack(resolver);
    }
    case PrimitiveType_TensorArrayRead: {
      auto ptr = reinterpret_cast<const mindspore::schema::TensorArrayRead *>(obj);
      return ptr->UnPack(resolver);
    }
    case PrimitiveType_TensorArrayWrite: {
      auto ptr = reinterpret_cast<const mindspore::schema::TensorArrayWrite *>(obj);
      return ptr->UnPack(resolver);
    }
    case PrimitiveType_Affine: {
      auto ptr = reinterpret_cast<const mindspore::schema::Affine *>(obj);
      return ptr->UnPack(resolver);
    }
    default: return nullptr;
  }
}

inline flatbuffers::Offset<void> PrimitiveTypeUnion::Pack(flatbuffers::FlatBufferBuilder &_fbb, const flatbuffers::rehasher_function_t *_rehasher) const {
  switch (type) {
    case PrimitiveType_Abs: {
      auto ptr = reinterpret_cast<const mindspore::schema::AbsT *>(value);
      return CreateAbs(_fbb, ptr, _rehasher).Union();
    }
    case PrimitiveType_Activation: {
      auto ptr = reinterpret_cast<const mindspore::schema::ActivationT *>(value);
      return CreateActivation(_fbb, ptr, _rehasher).Union();
    }
    case PrimitiveType_ActivationGrad: {
      auto ptr = reinterpret_cast<const mindspore::schema::ActivationGradT *>(value);
      return CreateActivationGrad(_fbb, ptr, _rehasher).Union();
    }
    case PrimitiveType_Adam: {
      auto ptr = reinterpret_cast<const mindspore::schema::AdamT *>(value);
      return CreateAdam(_fbb, ptr, _rehasher).Union();
    }
    case PrimitiveType_AddFusion: {
      auto ptr = reinterpret_cast<const mindspore::schema::AddFusionT *>(value);
      return CreateAddFusion(_fbb, ptr, _rehasher).Union();
    }
    case PrimitiveType_AdderFusion: {
      auto ptr = reinterpret_cast<const mindspore::schema::AdderFusionT *>(value);
      return CreateAdderFusion(_fbb, ptr, _rehasher).Union();
    }
    case PrimitiveType_AddGrad: {
      auto ptr = reinterpret_cast<const mindspore::schema::AddGradT *>(value);
      return CreateAddGrad(_fbb, ptr, _rehasher).Union();
    }
    case PrimitiveType_AddN: {
      auto ptr = reinterpret_cast<const mindspore::schema::AddNT *>(value);
      return CreateAddN(_fbb, ptr, _rehasher).Union();
    }
    case PrimitiveType_All: {
      auto ptr = reinterpret_cast<const mindspore::schema::AllT *>(value);
      return CreateAll(_fbb, ptr, _rehasher).Union();
    }
    case PrimitiveType_ApplyMomentum: {
      auto ptr = reinterpret_cast<const mindspore::schema::ApplyMomentumT *>(value);
      return CreateApplyMomentum(_fbb, ptr, _rehasher).Union();
    }
    case PrimitiveType_ArgMaxFusion: {
      auto ptr = reinterpret_cast<const mindspore::schema::ArgMaxFusionT *>(value);
      return CreateArgMaxFusion(_fbb, ptr, _rehasher).Union();
    }
    case PrimitiveType_ArgMinFusion: {
      auto ptr = reinterpret_cast<const mindspore::schema::ArgMinFusionT *>(value);
      return CreateArgMinFusion(_fbb, ptr, _rehasher).Union();
    }
    case PrimitiveType_Assert: {
      auto ptr = reinterpret_cast<const mindspore::schema::AssertT *>(value);
      return CreateAssert(_fbb, ptr, _rehasher).Union();
    }
    case PrimitiveType_Assign: {
      auto ptr = reinterpret_cast<const mindspore::schema::AssignT *>(value);
      return CreateAssign(_fbb, ptr, _rehasher).Union();
    }
    case PrimitiveType_AssignAdd: {
      auto ptr = reinterpret_cast<const mindspore::schema::AssignAddT *>(value);
      return CreateAssignAdd(_fbb, ptr, _rehasher).Union();
    }
    case PrimitiveType_AudioSpectrogram: {
      auto ptr = reinterpret_cast<const mindspore::schema::AudioSpectrogramT *>(value);
      return CreateAudioSpectrogram(_fbb, ptr, _rehasher).Union();
    }
    case PrimitiveType_AvgPoolFusion: {
      auto ptr = reinterpret_cast<const mindspore::schema::AvgPoolFusionT *>(value);
      return CreateAvgPoolFusion(_fbb, ptr, _rehasher).Union();
    }
    case PrimitiveType_AvgPoolGrad: {
      auto ptr = reinterpret_cast<const mindspore::schema::AvgPoolGradT *>(value);
      return CreateAvgPoolGrad(_fbb, ptr, _rehasher).Union();
    }
    case PrimitiveType_BatchNorm: {
      auto ptr = reinterpret_cast<const mindspore::schema::BatchNormT *>(value);
      return CreateBatchNorm(_fbb, ptr, _rehasher).Union();
    }
    case PrimitiveType_BatchNormGrad: {
      auto ptr = reinterpret_cast<const mindspore::schema::BatchNormGradT *>(value);
      return CreateBatchNormGrad(_fbb, ptr, _rehasher).Union();
    }
    case PrimitiveType_BatchToSpace: {
      auto ptr = reinterpret_cast<const mindspore::schema::BatchToSpaceT *>(value);
      return CreateBatchToSpace(_fbb, ptr, _rehasher).Union();
    }
    case PrimitiveType_BatchToSpaceND: {
      auto ptr = reinterpret_cast<const mindspore::schema::BatchToSpaceNDT *>(value);
      return CreateBatchToSpaceND(_fbb, ptr, _rehasher).Union();
    }
    case PrimitiveType_BiasAdd: {
      auto ptr = reinterpret_cast<const mindspore::schema::BiasAddT *>(value);
      return CreateBiasAdd(_fbb, ptr, _rehasher).Union();
    }
    case PrimitiveType_BinaryCrossEntropy: {
      auto ptr = reinterpret_cast<const mindspore::schema::BinaryCrossEntropyT *>(value);
      return CreateBinaryCrossEntropy(_fbb, ptr, _rehasher).Union();
    }
    case PrimitiveType_BinaryCrossEntropyGrad: {
      auto ptr = reinterpret_cast<const mindspore::schema::BinaryCrossEntropyGradT *>(value);
      return CreateBinaryCrossEntropyGrad(_fbb, ptr, _rehasher).Union();
    }
    case PrimitiveType_BiasAddGrad: {
      auto ptr = reinterpret_cast<const mindspore::schema::BiasAddGradT *>(value);
      return CreateBiasAddGrad(_fbb, ptr, _rehasher).Union();
    }
    case PrimitiveType_BroadcastTo: {
      auto ptr = reinterpret_cast<const mindspore::schema::BroadcastToT *>(value);
      return CreateBroadcastTo(_fbb, ptr, _rehasher).Union();
    }
    case PrimitiveType_Cast: {
      auto ptr = reinterpret_cast<const mindspore::schema::CastT *>(value);
      return CreateCast(_fbb, ptr, _rehasher).Union();
    }
    case PrimitiveType_Ceil: {
      auto ptr = reinterpret_cast<const mindspore::schema::CeilT *>(value);
      return CreateCeil(_fbb, ptr, _rehasher).Union();
    }
    case PrimitiveType_Clip: {
      auto ptr = reinterpret_cast<const mindspore::schema::ClipT *>(value);
      return CreateClip(_fbb, ptr, _rehasher).Union();
    }
    case PrimitiveType_Concat: {
      auto ptr = reinterpret_cast<const mindspore::schema::ConcatT *>(value);
      return CreateConcat(_fbb, ptr, _rehasher).Union();
    }
    case PrimitiveType_Attention: {
      auto ptr = reinterpret_cast<const mindspore::schema::AttentionT *>(value);
      return CreateAttention(_fbb, ptr, _rehasher).Union();
    }
    case PrimitiveType_Conv2DBackpropFilterFusion: {
      auto ptr = reinterpret_cast<const mindspore::schema::Conv2DBackpropFilterFusionT *>(value);
      return CreateConv2DBackpropFilterFusion(_fbb, ptr, _rehasher).Union();
    }
    case PrimitiveType_Conv2DBackpropInputFusion: {
      auto ptr = reinterpret_cast<const mindspore::schema::Conv2DBackpropInputFusionT *>(value);
      return CreateConv2DBackpropInputFusion(_fbb, ptr, _rehasher).Union();
    }
    case PrimitiveType_Conv2DFusion: {
      auto ptr = reinterpret_cast<const mindspore::schema::Conv2DFusionT *>(value);
      return CreateConv2DFusion(_fbb, ptr, _rehasher).Union();
    }
    case PrimitiveType_Conv2dTransposeFusion: {
      auto ptr = reinterpret_cast<const mindspore::schema::Conv2dTransposeFusionT *>(value);
      return CreateConv2dTransposeFusion(_fbb, ptr, _rehasher).Union();
    }
    case PrimitiveType_Cos: {
      auto ptr = reinterpret_cast<const mindspore::schema::CosT *>(value);
      return CreateCos(_fbb, ptr, _rehasher).Union();
    }
    case PrimitiveType_ConstantOfShape: {
      auto ptr = reinterpret_cast<const mindspore::schema::ConstantOfShapeT *>(value);
      return CreateConstantOfShape(_fbb, ptr, _rehasher).Union();
    }
    case PrimitiveType_Crop: {
      auto ptr = reinterpret_cast<const mindspore::schema::CropT *>(value);
      return CreateCrop(_fbb, ptr, _rehasher).Union();
    }
    case PrimitiveType_CustomExtractFeatures: {
      auto ptr = reinterpret_cast<const mindspore::schema::CustomExtractFeaturesT *>(value);
      return CreateCustomExtractFeatures(_fbb, ptr, _rehasher).Union();
    }
    case PrimitiveType_CustomNormalize: {
      auto ptr = reinterpret_cast<const mindspore::schema::CustomNormalizeT *>(value);
      return CreateCustomNormalize(_fbb, ptr, _rehasher).Union();
    }
    case PrimitiveType_CustomPredict: {
      auto ptr = reinterpret_cast<const mindspore::schema::CustomPredictT *>(value);
      return CreateCustomPredict(_fbb, ptr, _rehasher).Union();
    }
    case PrimitiveType_DeConv2DGradFilter: {
      auto ptr = reinterpret_cast<const mindspore::schema::DeConv2DGradFilterT *>(value);
      return CreateDeConv2DGradFilter(_fbb, ptr, _rehasher).Union();
    }
    case PrimitiveType_Depend: {
      auto ptr = reinterpret_cast<const mindspore::schema::DependT *>(value);
      return CreateDepend(_fbb, ptr, _rehasher).Union();
    }
    case PrimitiveType_DepthToSpace: {
      auto ptr = reinterpret_cast<const mindspore::schema::DepthToSpaceT *>(value);
      return CreateDepthToSpace(_fbb, ptr, _rehasher).Union();
    }
    case PrimitiveType_DetectionPostProcess: {
      auto ptr = reinterpret_cast<const mindspore::schema::DetectionPostProcessT *>(value);
      return CreateDetectionPostProcess(_fbb, ptr, _rehasher).Union();
    }
    case PrimitiveType_DivFusion: {
      auto ptr = reinterpret_cast<const mindspore::schema::DivFusionT *>(value);
      return CreateDivFusion(_fbb, ptr, _rehasher).Union();
    }
    case PrimitiveType_DivGrad: {
      auto ptr = reinterpret_cast<const mindspore::schema::DivGradT *>(value);
      return CreateDivGrad(_fbb, ptr, _rehasher).Union();
    }
    case PrimitiveType_Dropout: {
      auto ptr = reinterpret_cast<const mindspore::schema::DropoutT *>(value);
      return CreateDropout(_fbb, ptr, _rehasher).Union();
    }
    case PrimitiveType_DropoutGrad: {
      auto ptr = reinterpret_cast<const mindspore::schema::DropoutGradT *>(value);
      return CreateDropoutGrad(_fbb, ptr, _rehasher).Union();
    }
    case PrimitiveType_Elu: {
      auto ptr = reinterpret_cast<const mindspore::schema::EluT *>(value);
      return CreateElu(_fbb, ptr, _rehasher).Union();
    }
    case PrimitiveType_Eltwise: {
      auto ptr = reinterpret_cast<const mindspore::schema::EltwiseT *>(value);
      return CreateEltwise(_fbb, ptr, _rehasher).Union();
    }
    case PrimitiveType_Equal: {
      auto ptr = reinterpret_cast<const mindspore::schema::EqualT *>(value);
      return CreateEqual(_fbb, ptr, _rehasher).Union();
    }
    case PrimitiveType_EmbeddingLookupFusion: {
      auto ptr = reinterpret_cast<const mindspore::schema::EmbeddingLookupFusionT *>(value);
      return CreateEmbeddingLookupFusion(_fbb, ptr, _rehasher).Union();
    }
    case PrimitiveType_ExpFusion: {
      auto ptr = reinterpret_cast<const mindspore::schema::ExpFusionT *>(value);
      return CreateExpFusion(_fbb, ptr, _rehasher).Union();
    }
    case PrimitiveType_ExpandDims: {
      auto ptr = reinterpret_cast<const mindspore::schema::ExpandDimsT *>(value);
      return CreateExpandDims(_fbb, ptr, _rehasher).Union();
    }
    case PrimitiveType_FakeQuantWithMinMaxVars: {
      auto ptr = reinterpret_cast<const mindspore::schema::FakeQuantWithMinMaxVarsT *>(value);
      return CreateFakeQuantWithMinMaxVars(_fbb, ptr, _rehasher).Union();
    }
    case PrimitiveType_FakeQuantWithMinMaxVarsPerChannel: {
      auto ptr = reinterpret_cast<const mindspore::schema::FakeQuantWithMinMaxVarsPerChannelT *>(value);
      return CreateFakeQuantWithMinMaxVarsPerChannel(_fbb, ptr, _rehasher).Union();
    }
    case PrimitiveType_FftReal: {
      auto ptr = reinterpret_cast<const mindspore::schema::FftRealT *>(value);
      return CreateFftReal(_fbb, ptr, _rehasher).Union();
    }
    case PrimitiveType_FftImag: {
      auto ptr = reinterpret_cast<const mindspore::schema::FftImagT *>(value);
      return CreateFftImag(_fbb, ptr, _rehasher).Union();
    }
    case PrimitiveType_Flatten: {
      auto ptr = reinterpret_cast<const mindspore::schema::FlattenT *>(value);
      return CreateFlatten(_fbb, ptr, _rehasher).Union();
    }
    case PrimitiveType_FlattenGrad: {
      auto ptr = reinterpret_cast<const mindspore::schema::FlattenGradT *>(value);
      return CreateFlattenGrad(_fbb, ptr, _rehasher).Union();
    }
    case PrimitiveType_Floor: {
      auto ptr = reinterpret_cast<const mindspore::schema::FloorT *>(value);
      return CreateFloor(_fbb, ptr, _rehasher).Union();
    }
    case PrimitiveType_FloorDiv: {
      auto ptr = reinterpret_cast<const mindspore::schema::FloorDivT *>(value);
      return CreateFloorDiv(_fbb, ptr, _rehasher).Union();
    }
    case PrimitiveType_FloorMod: {
      auto ptr = reinterpret_cast<const mindspore::schema::FloorModT *>(value);
      return CreateFloorMod(_fbb, ptr, _rehasher).Union();
    }
    case PrimitiveType_Fill: {
      auto ptr = reinterpret_cast<const mindspore::schema::FillT *>(value);
      return CreateFill(_fbb, ptr, _rehasher).Union();
    }
    case PrimitiveType_FullConnection: {
      auto ptr = reinterpret_cast<const mindspore::schema::FullConnectionT *>(value);
      return CreateFullConnection(_fbb, ptr, _rehasher).Union();
    }
    case PrimitiveType_FusedBatchNorm: {
      auto ptr = reinterpret_cast<const mindspore::schema::FusedBatchNormT *>(value);
      return CreateFusedBatchNorm(_fbb, ptr, _rehasher).Union();
    }
    case PrimitiveType_Gather: {
      auto ptr = reinterpret_cast<const mindspore::schema::GatherT *>(value);
      return CreateGather(_fbb, ptr, _rehasher).Union();
    }
    case PrimitiveType_GatherNd: {
      auto ptr = reinterpret_cast<const mindspore::schema::GatherNdT *>(value);
      return CreateGatherNd(_fbb, ptr, _rehasher).Union();
    }
    case PrimitiveType_Greater: {
      auto ptr = reinterpret_cast<const mindspore::schema::GreaterT *>(value);
      return CreateGreater(_fbb, ptr, _rehasher).Union();
    }
    case PrimitiveType_GreaterEqual: {
      auto ptr = reinterpret_cast<const mindspore::schema::GreaterEqualT *>(value);
      return CreateGreaterEqual(_fbb, ptr, _rehasher).Union();
    }
    case PrimitiveType_HashtableLookup: {
      auto ptr = reinterpret_cast<const mindspore::schema::HashtableLookupT *>(value);
      return CreateHashtableLookup(_fbb, ptr, _rehasher).Union();
    }
    case PrimitiveType_InstanceNorm: {
      auto ptr = reinterpret_cast<const mindspore::schema::InstanceNormT *>(value);
      return CreateInstanceNorm(_fbb, ptr, _rehasher).Union();
    }
    case PrimitiveType_LayerNormFusion: {
      auto ptr = reinterpret_cast<const mindspore::schema::LayerNormFusionT *>(value);
      return CreateLayerNormFusion(_fbb, ptr, _rehasher).Union();
    }
    case PrimitiveType_LeakyRelu: {
      auto ptr = reinterpret_cast<const mindspore::schema::LeakyReluT *>(value);
      return CreateLeakyRelu(_fbb, ptr, _rehasher).Union();
    }
    case PrimitiveType_Less: {
      auto ptr = reinterpret_cast<const mindspore::schema::LessT *>(value);
      return CreateLess(_fbb, ptr, _rehasher).Union();
    }
    case PrimitiveType_LessEqual: {
      auto ptr = reinterpret_cast<const mindspore::schema::LessEqualT *>(value);
      return CreateLessEqual(_fbb, ptr, _rehasher).Union();
    }
    case PrimitiveType_Log: {
      auto ptr = reinterpret_cast<const mindspore::schema::LogT *>(value);
      return CreateLog(_fbb, ptr, _rehasher).Union();
    }
    case PrimitiveType_LogGrad: {
      auto ptr = reinterpret_cast<const mindspore::schema::LogGradT *>(value);
      return CreateLogGrad(_fbb, ptr, _rehasher).Union();
    }
    case PrimitiveType_LogicalAnd: {
      auto ptr = reinterpret_cast<const mindspore::schema::LogicalAndT *>(value);
      return CreateLogicalAnd(_fbb, ptr, _rehasher).Union();
    }
    case PrimitiveType_LogicalNot: {
      auto ptr = reinterpret_cast<const mindspore::schema::LogicalNotT *>(value);
      return CreateLogicalNot(_fbb, ptr, _rehasher).Union();
    }
    case PrimitiveType_LogicalOr: {
      auto ptr = reinterpret_cast<const mindspore::schema::LogicalOrT *>(value);
      return CreateLogicalOr(_fbb, ptr, _rehasher).Union();
    }
    case PrimitiveType_LpNormalization: {
      auto ptr = reinterpret_cast<const mindspore::schema::LpNormalizationT *>(value);
      return CreateLpNormalization(_fbb, ptr, _rehasher).Union();
    }
    case PrimitiveType_LRN: {
      auto ptr = reinterpret_cast<const mindspore::schema::LRNT *>(value);
      return CreateLRN(_fbb, ptr, _rehasher).Union();
    }
    case PrimitiveType_LshProjection: {
      auto ptr = reinterpret_cast<const mindspore::schema::LshProjectionT *>(value);
      return CreateLshProjection(_fbb, ptr, _rehasher).Union();
    }
    case PrimitiveType_LSTM: {
      auto ptr = reinterpret_cast<const mindspore::schema::LSTMT *>(value);
      return CreateLSTM(_fbb, ptr, _rehasher).Union();
    }
    case PrimitiveType_L2NormalizeFusion: {
      auto ptr = reinterpret_cast<const mindspore::schema::L2NormalizeFusionT *>(value);
      return CreateL2NormalizeFusion(_fbb, ptr, _rehasher).Union();
    }
    case PrimitiveType_MatMulFusion: {
      auto ptr = reinterpret_cast<const mindspore::schema::MatMulFusionT *>(value);
      return CreateMatMulFusion(_fbb, ptr, _rehasher).Union();
    }
    case PrimitiveType_Maximum: {
      auto ptr = reinterpret_cast<const mindspore::schema::MaximumT *>(value);
      return CreateMaximum(_fbb, ptr, _rehasher).Union();
    }
    case PrimitiveType_MaximumGrad: {
      auto ptr = reinterpret_cast<const mindspore::schema::MaximumGradT *>(value);
      return CreateMaximumGrad(_fbb, ptr, _rehasher).Union();
    }
    case PrimitiveType_MaxPoolFusion: {
      auto ptr = reinterpret_cast<const mindspore::schema::MaxPoolFusionT *>(value);
      return CreateMaxPoolFusion(_fbb, ptr, _rehasher).Union();
    }
    case PrimitiveType_MaxPoolGrad: {
      auto ptr = reinterpret_cast<const mindspore::schema::MaxPoolGradT *>(value);
      return CreateMaxPoolGrad(_fbb, ptr, _rehasher).Union();
    }
    case PrimitiveType_Merge: {
      auto ptr = reinterpret_cast<const mindspore::schema::MergeT *>(value);
      return CreateMerge(_fbb, ptr, _rehasher).Union();
    }
    case PrimitiveType_Mfcc: {
      auto ptr = reinterpret_cast<const mindspore::schema::MfccT *>(value);
      return CreateMfcc(_fbb, ptr, _rehasher).Union();
    }
    case PrimitiveType_Minimum: {
      auto ptr = reinterpret_cast<const mindspore::schema::MinimumT *>(value);
      return CreateMinimum(_fbb, ptr, _rehasher).Union();
    }
    case PrimitiveType_MinimumGrad: {
      auto ptr = reinterpret_cast<const mindspore::schema::MinimumGradT *>(value);
      return CreateMinimumGrad(_fbb, ptr, _rehasher).Union();
    }
    case PrimitiveType_Mod: {
      auto ptr = reinterpret_cast<const mindspore::schema::ModT *>(value);
      return CreateMod(_fbb, ptr, _rehasher).Union();
    }
    case PrimitiveType_MulFusion: {
      auto ptr = reinterpret_cast<const mindspore::schema::MulFusionT *>(value);
      return CreateMulFusion(_fbb, ptr, _rehasher).Union();
    }
    case PrimitiveType_MulGrad: {
      auto ptr = reinterpret_cast<const mindspore::schema::MulGradT *>(value);
      return CreateMulGrad(_fbb, ptr, _rehasher).Union();
    }
    case PrimitiveType_Neg: {
      auto ptr = reinterpret_cast<const mindspore::schema::NegT *>(value);
      return CreateNeg(_fbb, ptr, _rehasher).Union();
    }
    case PrimitiveType_NegGrad: {
      auto ptr = reinterpret_cast<const mindspore::schema::NegGradT *>(value);
      return CreateNegGrad(_fbb, ptr, _rehasher).Union();
    }
    case PrimitiveType_NotEqual: {
      auto ptr = reinterpret_cast<const mindspore::schema::NotEqualT *>(value);
      return CreateNotEqual(_fbb, ptr, _rehasher).Union();
    }
    case PrimitiveType_NonMaxSuppression: {
      auto ptr = reinterpret_cast<const mindspore::schema::NonMaxSuppressionT *>(value);
      return CreateNonMaxSuppression(_fbb, ptr, _rehasher).Union();
    }
    case PrimitiveType_OneHot: {
      auto ptr = reinterpret_cast<const mindspore::schema::OneHotT *>(value);
      return CreateOneHot(_fbb, ptr, _rehasher).Union();
    }
    case PrimitiveType_OnesLike: {
      auto ptr = reinterpret_cast<const mindspore::schema::OnesLikeT *>(value);
      return CreateOnesLike(_fbb, ptr, _rehasher).Union();
    }
    case PrimitiveType_PadFusion: {
      auto ptr = reinterpret_cast<const mindspore::schema::PadFusionT *>(value);
      return CreatePadFusion(_fbb, ptr, _rehasher).Union();
    }
    case PrimitiveType_PartialFusion: {
      auto ptr = reinterpret_cast<const mindspore::schema::PartialFusionT *>(value);
      return CreatePartialFusion(_fbb, ptr, _rehasher).Union();
    }
    case PrimitiveType_PowerGrad: {
      auto ptr = reinterpret_cast<const mindspore::schema::PowerGradT *>(value);
      return CreatePowerGrad(_fbb, ptr, _rehasher).Union();
    }
    case PrimitiveType_PowFusion: {
      auto ptr = reinterpret_cast<const mindspore::schema::PowFusionT *>(value);
      return CreatePowFusion(_fbb, ptr, _rehasher).Union();
    }
    case PrimitiveType_PriorBox: {
      auto ptr = reinterpret_cast<const mindspore::schema::PriorBoxT *>(value);
      return CreatePriorBox(_fbb, ptr, _rehasher).Union();
    }
    case PrimitiveType_PReLUFusion: {
      auto ptr = reinterpret_cast<const mindspore::schema::PReLUFusionT *>(value);
      return CreatePReLUFusion(_fbb, ptr, _rehasher).Union();
    }
    case PrimitiveType_QuantDTypeCast: {
      auto ptr = reinterpret_cast<const mindspore::schema::QuantDTypeCastT *>(value);
      return CreateQuantDTypeCast(_fbb, ptr, _rehasher).Union();
    }
    case PrimitiveType_Rank: {
      auto ptr = reinterpret_cast<const mindspore::schema::RankT *>(value);
      return CreateRank(_fbb, ptr, _rehasher).Union();
    }
    case PrimitiveType_Range: {
      auto ptr = reinterpret_cast<const mindspore::schema::RangeT *>(value);
      return CreateRange(_fbb, ptr, _rehasher).Union();
    }
    case PrimitiveType_Reciprocal: {
      auto ptr = reinterpret_cast<const mindspore::schema::ReciprocalT *>(value);
      return CreateReciprocal(_fbb, ptr, _rehasher).Union();
    }
    case PrimitiveType_RealDiv: {
      auto ptr = reinterpret_cast<const mindspore::schema::RealDivT *>(value);
      return CreateRealDiv(_fbb, ptr, _rehasher).Union();
    }
    case PrimitiveType_ReduceFusion: {
      auto ptr = reinterpret_cast<const mindspore::schema::ReduceFusionT *>(value);
      return CreateReduceFusion(_fbb, ptr, _rehasher).Union();
    }
    case PrimitiveType_Reshape: {
      auto ptr = reinterpret_cast<const mindspore::schema::ReshapeT *>(value);
      return CreateReshape(_fbb, ptr, _rehasher).Union();
    }
    case PrimitiveType_Resize: {
      auto ptr = reinterpret_cast<const mindspore::schema::ResizeT *>(value);
      return CreateResize(_fbb, ptr, _rehasher).Union();
    }
    case PrimitiveType_ReverseSequence: {
      auto ptr = reinterpret_cast<const mindspore::schema::ReverseSequenceT *>(value);
      return CreateReverseSequence(_fbb, ptr, _rehasher).Union();
    }
    case PrimitiveType_ReverseV2: {
      auto ptr = reinterpret_cast<const mindspore::schema::ReverseV2T *>(value);
      return CreateReverseV2(_fbb, ptr, _rehasher).Union();
    }
    case PrimitiveType_Rfft: {
      auto ptr = reinterpret_cast<const mindspore::schema::RfftT *>(value);
      return CreateRfft(_fbb, ptr, _rehasher).Union();
    }
    case PrimitiveType_ROIPooling: {
      auto ptr = reinterpret_cast<const mindspore::schema::ROIPoolingT *>(value);
      return CreateROIPooling(_fbb, ptr, _rehasher).Union();
    }
    case PrimitiveType_Round: {
      auto ptr = reinterpret_cast<const mindspore::schema::RoundT *>(value);
      return CreateRound(_fbb, ptr, _rehasher).Union();
    }
    case PrimitiveType_Rsqrt: {
      auto ptr = reinterpret_cast<const mindspore::schema::RsqrtT *>(value);
      return CreateRsqrt(_fbb, ptr, _rehasher).Union();
    }
    case PrimitiveType_ScaleFusion: {
      auto ptr = reinterpret_cast<const mindspore::schema::ScaleFusionT *>(value);
      return CreateScaleFusion(_fbb, ptr, _rehasher).Union();
    }
    case PrimitiveType_ScatterNd: {
      auto ptr = reinterpret_cast<const mindspore::schema::ScatterNdT *>(value);
      return CreateScatterNd(_fbb, ptr, _rehasher).Union();
    }
    case PrimitiveType_SGD: {
      auto ptr = reinterpret_cast<const mindspore::schema::SGDT *>(value);
      return CreateSGD(_fbb, ptr, _rehasher).Union();
    }
    case PrimitiveType_Shape: {
      auto ptr = reinterpret_cast<const mindspore::schema::ShapeT *>(value);
      return CreateShape(_fbb, ptr, _rehasher).Union();
    }
    case PrimitiveType_SigmoidCrossEntropyWithLogits: {
      auto ptr = reinterpret_cast<const mindspore::schema::SigmoidCrossEntropyWithLogitsT *>(value);
      return CreateSigmoidCrossEntropyWithLogits(_fbb, ptr, _rehasher).Union();
    }
    case PrimitiveType_SigmoidCrossEntropyWithLogitsGrad: {
      auto ptr = reinterpret_cast<const mindspore::schema::SigmoidCrossEntropyWithLogitsGradT *>(value);
      return CreateSigmoidCrossEntropyWithLogitsGrad(_fbb, ptr, _rehasher).Union();
    }
    case PrimitiveType_Sin: {
      auto ptr = reinterpret_cast<const mindspore::schema::SinT *>(value);
      return CreateSin(_fbb, ptr, _rehasher).Union();
    }
    case PrimitiveType_SkipGram: {
      auto ptr = reinterpret_cast<const mindspore::schema::SkipGramT *>(value);
      return CreateSkipGram(_fbb, ptr, _rehasher).Union();
    }
    case PrimitiveType_SliceFusion: {
      auto ptr = reinterpret_cast<const mindspore::schema::SliceFusionT *>(value);
      return CreateSliceFusion(_fbb, ptr, _rehasher).Union();
    }
    case PrimitiveType_SmoothL1Loss: {
      auto ptr = reinterpret_cast<const mindspore::schema::SmoothL1LossT *>(value);
      return CreateSmoothL1Loss(_fbb, ptr, _rehasher).Union();
    }
    case PrimitiveType_SmoothL1LossGrad: {
      auto ptr = reinterpret_cast<const mindspore::schema::SmoothL1LossGradT *>(value);
      return CreateSmoothL1LossGrad(_fbb, ptr, _rehasher).Union();
    }
    case PrimitiveType_Softmax: {
      auto ptr = reinterpret_cast<const mindspore::schema::SoftmaxT *>(value);
      return CreateSoftmax(_fbb, ptr, _rehasher).Union();
    }
    case PrimitiveType_SoftmaxCrossEntropyWithLogits: {
      auto ptr = reinterpret_cast<const mindspore::schema::SoftmaxCrossEntropyWithLogitsT *>(value);
      return CreateSoftmaxCrossEntropyWithLogits(_fbb, ptr, _rehasher).Union();
    }
    case PrimitiveType_SpaceToBatch: {
      auto ptr = reinterpret_cast<const mindspore::schema::SpaceToBatchT *>(value);
      return CreateSpaceToBatch(_fbb, ptr, _rehasher).Union();
    }
    case PrimitiveType_SpaceToBatchND: {
      auto ptr = reinterpret_cast<const mindspore::schema::SpaceToBatchNDT *>(value);
      return CreateSpaceToBatchND(_fbb, ptr, _rehasher).Union();
    }
    case PrimitiveType_SpaceToDepth: {
      auto ptr = reinterpret_cast<const mindspore::schema::SpaceToDepthT *>(value);
      return CreateSpaceToDepth(_fbb, ptr, _rehasher).Union();
    }
    case PrimitiveType_SparseSoftmaxCrossEntropyWithLogits: {
      auto ptr = reinterpret_cast<const mindspore::schema::SparseSoftmaxCrossEntropyWithLogitsT *>(value);
      return CreateSparseSoftmaxCrossEntropyWithLogits(_fbb, ptr, _rehasher).Union();
    }
    case PrimitiveType_SparseToDense: {
      auto ptr = reinterpret_cast<const mindspore::schema::SparseToDenseT *>(value);
      return CreateSparseToDense(_fbb, ptr, _rehasher).Union();
    }
    case PrimitiveType_Split: {
      auto ptr = reinterpret_cast<const mindspore::schema::SplitT *>(value);
      return CreateSplit(_fbb, ptr, _rehasher).Union();
    }
    case PrimitiveType_Sqrt: {
      auto ptr = reinterpret_cast<const mindspore::schema::SqrtT *>(value);
      return CreateSqrt(_fbb, ptr, _rehasher).Union();
    }
    case PrimitiveType_Squeeze: {
      auto ptr = reinterpret_cast<const mindspore::schema::SqueezeT *>(value);
      return CreateSqueeze(_fbb, ptr, _rehasher).Union();
    }
    case PrimitiveType_Square: {
      auto ptr = reinterpret_cast<const mindspore::schema::SquareT *>(value);
      return CreateSquare(_fbb, ptr, _rehasher).Union();
    }
    case PrimitiveType_SquaredDifference: {
      auto ptr = reinterpret_cast<const mindspore::schema::SquaredDifferenceT *>(value);
      return CreateSquaredDifference(_fbb, ptr, _rehasher).Union();
    }
    case PrimitiveType_Stack: {
      auto ptr = reinterpret_cast<const mindspore::schema::StackT *>(value);
      return CreateStack(_fbb, ptr, _rehasher).Union();
    }
    case PrimitiveType_StridedSlice: {
      auto ptr = reinterpret_cast<const mindspore::schema::StridedSliceT *>(value);
      return CreateStridedSlice(_fbb, ptr, _rehasher).Union();
    }
    case PrimitiveType_SubFusion: {
      auto ptr = reinterpret_cast<const mindspore::schema::SubFusionT *>(value);
      return CreateSubFusion(_fbb, ptr, _rehasher).Union();
    }
    case PrimitiveType_SubGrad: {
      auto ptr = reinterpret_cast<const mindspore::schema::SubGradT *>(value);
      return CreateSubGrad(_fbb, ptr, _rehasher).Union();
    }
    case PrimitiveType_Switch: {
      auto ptr = reinterpret_cast<const mindspore::schema::SwitchT *>(value);
      return CreateSwitch(_fbb, ptr, _rehasher).Union();
    }
    case PrimitiveType_TensorListFromTensor: {
      auto ptr = reinterpret_cast<const mindspore::schema::TensorListFromTensorT *>(value);
      return CreateTensorListFromTensor(_fbb, ptr, _rehasher).Union();
    }
    case PrimitiveType_TensorListGetItem: {
      auto ptr = reinterpret_cast<const mindspore::schema::TensorListGetItemT *>(value);
      return CreateTensorListGetItem(_fbb, ptr, _rehasher).Union();
    }
    case PrimitiveType_TensorListReserve: {
      auto ptr = reinterpret_cast<const mindspore::schema::TensorListReserveT *>(value);
      return CreateTensorListReserve(_fbb, ptr, _rehasher).Union();
    }
    case PrimitiveType_TensorListSetItem: {
      auto ptr = reinterpret_cast<const mindspore::schema::TensorListSetItemT *>(value);
      return CreateTensorListSetItem(_fbb, ptr, _rehasher).Union();
    }
    case PrimitiveType_TensorListStack: {
      auto ptr = reinterpret_cast<const mindspore::schema::TensorListStackT *>(value);
      return CreateTensorListStack(_fbb, ptr, _rehasher).Union();
    }
    case PrimitiveType_TileFusion: {
      auto ptr = reinterpret_cast<const mindspore::schema::TileFusionT *>(value);
      return CreateTileFusion(_fbb, ptr, _rehasher).Union();
    }
    case PrimitiveType_TopKFusion: {
      auto ptr = reinterpret_cast<const mindspore::schema::TopKFusionT *>(value);
      return CreateTopKFusion(_fbb, ptr, _rehasher).Union();
    }
    case PrimitiveType_Transpose: {
      auto ptr = reinterpret_cast<const mindspore::schema::TransposeT *>(value);
      return CreateTranspose(_fbb, ptr, _rehasher).Union();
    }
    case PrimitiveType_Unique: {
      auto ptr = reinterpret_cast<const mindspore::schema::UniqueT *>(value);
      return CreateUnique(_fbb, ptr, _rehasher).Union();
    }
    case PrimitiveType_UnsortedSegmentSum: {
      auto ptr = reinterpret_cast<const mindspore::schema::UnsortedSegmentSumT *>(value);
      return CreateUnsortedSegmentSum(_fbb, ptr, _rehasher).Union();
    }
    case PrimitiveType_Unsqueeze: {
      auto ptr = reinterpret_cast<const mindspore::schema::UnsqueezeT *>(value);
      return CreateUnsqueeze(_fbb, ptr, _rehasher).Union();
    }
    case PrimitiveType_Unstack: {
      auto ptr = reinterpret_cast<const mindspore::schema::UnstackT *>(value);
      return CreateUnstack(_fbb, ptr, _rehasher).Union();
    }
    case PrimitiveType_LSTMGrad: {
      auto ptr = reinterpret_cast<const mindspore::schema::LSTMGradT *>(value);
      return CreateLSTMGrad(_fbb, ptr, _rehasher).Union();
    }
    case PrimitiveType_Where: {
      auto ptr = reinterpret_cast<const mindspore::schema::WhereT *>(value);
      return CreateWhere(_fbb, ptr, _rehasher).Union();
    }
    case PrimitiveType_ZerosLike: {
      auto ptr = reinterpret_cast<const mindspore::schema::ZerosLikeT *>(value);
      return CreateZerosLike(_fbb, ptr, _rehasher).Union();
    }
    case PrimitiveType_Select: {
      auto ptr = reinterpret_cast<const mindspore::schema::SelectT *>(value);
      return CreateSelect(_fbb, ptr, _rehasher).Union();
    }
    case PrimitiveType_ScatterNdUpdate: {
      auto ptr = reinterpret_cast<const mindspore::schema::ScatterNdUpdateT *>(value);
      return CreateScatterNdUpdate(_fbb, ptr, _rehasher).Union();
    }
    case PrimitiveType_GRU: {
      auto ptr = reinterpret_cast<const mindspore::schema::GRUT *>(value);
      return CreateGRU(_fbb, ptr, _rehasher).Union();
    }
    case PrimitiveType_NonZero: {
      auto ptr = reinterpret_cast<const mindspore::schema::NonZeroT *>(value);
      return CreateNonZero(_fbb, ptr, _rehasher).Union();
    }
    case PrimitiveType_InvertPermutation: {
      auto ptr = reinterpret_cast<const mindspore::schema::InvertPermutationT *>(value);
      return CreateInvertPermutation(_fbb, ptr, _rehasher).Union();
    }
    case PrimitiveType_Size: {
      auto ptr = reinterpret_cast<const mindspore::schema::SizeT *>(value);
      return CreateSize(_fbb, ptr, _rehasher).Union();
    }
    case PrimitiveType_RandomStandardNormal: {
      auto ptr = reinterpret_cast<const mindspore::schema::RandomStandardNormalT *>(value);
      return CreateRandomStandardNormal(_fbb, ptr, _rehasher).Union();
    }
    case PrimitiveType_CropAndResize: {
      auto ptr = reinterpret_cast<const mindspore::schema::CropAndResizeT *>(value);
      return CreateCropAndResize(_fbb, ptr, _rehasher).Union();
    }
    case PrimitiveType_Erf: {
      auto ptr = reinterpret_cast<const mindspore::schema::ErfT *>(value);
      return CreateErf(_fbb, ptr, _rehasher).Union();
    }
    case PrimitiveType_StridedSliceGrad: {
      auto ptr = reinterpret_cast<const mindspore::schema::StridedSliceGradT *>(value);
      return CreateStridedSliceGrad(_fbb, ptr, _rehasher).Union();
    }
    case PrimitiveType_IsFinite: {
      auto ptr = reinterpret_cast<const mindspore::schema::IsFiniteT *>(value);
      return CreateIsFinite(_fbb, ptr, _rehasher).Union();
    }
    case PrimitiveType_LinSpace: {
      auto ptr = reinterpret_cast<const mindspore::schema::LinSpaceT *>(value);
      return CreateLinSpace(_fbb, ptr, _rehasher).Union();
    }
    case PrimitiveType_UniformReal: {
      auto ptr = reinterpret_cast<const mindspore::schema::UniformRealT *>(value);
      return CreateUniformReal(_fbb, ptr, _rehasher).Union();
    }
    case PrimitiveType_AbsGrad: {
      auto ptr = reinterpret_cast<const mindspore::schema::AbsGradT *>(value);
      return CreateAbsGrad(_fbb, ptr, _rehasher).Union();
    }
    case PrimitiveType_RsqrtGrad: {
      auto ptr = reinterpret_cast<const mindspore::schema::RsqrtGradT *>(value);
      return CreateRsqrtGrad(_fbb, ptr, _rehasher).Union();
    }
    case PrimitiveType_SqrtGrad: {
      auto ptr = reinterpret_cast<const mindspore::schema::SqrtGradT *>(value);
      return CreateSqrtGrad(_fbb, ptr, _rehasher).Union();
    }
    case PrimitiveType_LayerNormGrad: {
      auto ptr = reinterpret_cast<const mindspore::schema::LayerNormGradT *>(value);
      return CreateLayerNormGrad(_fbb, ptr, _rehasher).Union();
    }
    case PrimitiveType_ResizeGrad: {
      auto ptr = reinterpret_cast<const mindspore::schema::ResizeGradT *>(value);
      return CreateResizeGrad(_fbb, ptr, _rehasher).Union();
    }
    case PrimitiveType_Splice: {
      auto ptr = reinterpret_cast<const mindspore::schema::SpliceT *>(value);
      return CreateSplice(_fbb, ptr, _rehasher).Union();
    }
    case PrimitiveType_LogSoftmax: {
      auto ptr = reinterpret_cast<const mindspore::schema::LogSoftmaxT *>(value);
      return CreateLogSoftmax(_fbb, ptr, _rehasher).Union();
    }
    case PrimitiveType_Call: {
      auto ptr = reinterpret_cast<const mindspore::schema::CallT *>(value);
      return CreateCall(_fbb, ptr, _rehasher).Union();
    }
    case PrimitiveType_Custom: {
      auto ptr = reinterpret_cast<const mindspore::schema::CustomT *>(value);
      return CreateCustom(_fbb, ptr, _rehasher).Union();
    }
    case PrimitiveType_CumSum: {
      auto ptr = reinterpret_cast<const mindspore::schema::CumSumT *>(value);
      return CreateCumSum(_fbb, ptr, _rehasher).Union();
    }
    case PrimitiveType_SplitWithOverlap: {
      auto ptr = reinterpret_cast<const mindspore::schema::SplitWithOverlapT *>(value);
      return CreateSplitWithOverlap(_fbb, ptr, _rehasher).Union();
    }
    case PrimitiveType_GenOP: {
      auto ptr = reinterpret_cast<const mindspore::schema::GenOPT *>(value);
      return CreateGenOP(_fbb, ptr, _rehasher).Union();
    }
    case PrimitiveType_RaggedRange: {
      auto ptr = reinterpret_cast<const mindspore::schema::RaggedRangeT *>(value);
      return CreateRaggedRange(_fbb, ptr, _rehasher).Union();
    }
    case PrimitiveType_GLU: {
      auto ptr = reinterpret_cast<const mindspore::schema::GLUT *>(value);
      return CreateGLU(_fbb, ptr, _rehasher).Union();
    }
    case PrimitiveType_TensorArray: {
      auto ptr = reinterpret_cast<const mindspore::schema::TensorArrayT *>(value);
      return CreateTensorArray(_fbb, ptr, _rehasher).Union();
    }
    case PrimitiveType_TensorArrayRead: {
      auto ptr = reinterpret_cast<const mindspore::schema::TensorArrayReadT *>(value);
      return CreateTensorArrayRead(_fbb, ptr, _rehasher).Union();
    }
    case PrimitiveType_TensorArrayWrite: {
      auto ptr = reinterpret_cast<const mindspore::schema::TensorArrayWriteT *>(value);
      return CreateTensorArrayWrite(_fbb, ptr, _rehasher).Union();
    }
    case PrimitiveType_Affine: {
      auto ptr = reinterpret_cast<const mindspore::schema::AffineT *>(value);
      return CreateAffine(_fbb, ptr, _rehasher).Union();
    }
    default: return 0;
  }
}

inline PrimitiveTypeUnion::PrimitiveTypeUnion(const PrimitiveTypeUnion &u) : type(u.type), value(nullptr) {
  switch (type) {
    case PrimitiveType_Abs: {
      value = new mindspore::schema::AbsT(*reinterpret_cast<mindspore::schema::AbsT *>(u.value));
      break;
    }
    case PrimitiveType_Activation: {
      value = new mindspore::schema::ActivationT(*reinterpret_cast<mindspore::schema::ActivationT *>(u.value));
      break;
    }
    case PrimitiveType_ActivationGrad: {
      value = new mindspore::schema::ActivationGradT(*reinterpret_cast<mindspore::schema::ActivationGradT *>(u.value));
      break;
    }
    case PrimitiveType_Adam: {
      value = new mindspore::schema::AdamT(*reinterpret_cast<mindspore::schema::AdamT *>(u.value));
      break;
    }
    case PrimitiveType_AddFusion: {
      value = new mindspore::schema::AddFusionT(*reinterpret_cast<mindspore::schema::AddFusionT *>(u.value));
      break;
    }
    case PrimitiveType_AdderFusion: {
      value = new mindspore::schema::AdderFusionT(*reinterpret_cast<mindspore::schema::AdderFusionT *>(u.value));
      break;
    }
    case PrimitiveType_AddGrad: {
      value = new mindspore::schema::AddGradT(*reinterpret_cast<mindspore::schema::AddGradT *>(u.value));
      break;
    }
    case PrimitiveType_AddN: {
      value = new mindspore::schema::AddNT(*reinterpret_cast<mindspore::schema::AddNT *>(u.value));
      break;
    }
    case PrimitiveType_All: {
      value = new mindspore::schema::AllT(*reinterpret_cast<mindspore::schema::AllT *>(u.value));
      break;
    }
    case PrimitiveType_ApplyMomentum: {
      value = new mindspore::schema::ApplyMomentumT(*reinterpret_cast<mindspore::schema::ApplyMomentumT *>(u.value));
      break;
    }
    case PrimitiveType_ArgMaxFusion: {
      value = new mindspore::schema::ArgMaxFusionT(*reinterpret_cast<mindspore::schema::ArgMaxFusionT *>(u.value));
      break;
    }
    case PrimitiveType_ArgMinFusion: {
      value = new mindspore::schema::ArgMinFusionT(*reinterpret_cast<mindspore::schema::ArgMinFusionT *>(u.value));
      break;
    }
    case PrimitiveType_Assert: {
      value = new mindspore::schema::AssertT(*reinterpret_cast<mindspore::schema::AssertT *>(u.value));
      break;
    }
    case PrimitiveType_Assign: {
      value = new mindspore::schema::AssignT(*reinterpret_cast<mindspore::schema::AssignT *>(u.value));
      break;
    }
    case PrimitiveType_AssignAdd: {
      value = new mindspore::schema::AssignAddT(*reinterpret_cast<mindspore::schema::AssignAddT *>(u.value));
      break;
    }
    case PrimitiveType_AudioSpectrogram: {
      value = new mindspore::schema::AudioSpectrogramT(*reinterpret_cast<mindspore::schema::AudioSpectrogramT *>(u.value));
      break;
    }
    case PrimitiveType_AvgPoolFusion: {
      value = new mindspore::schema::AvgPoolFusionT(*reinterpret_cast<mindspore::schema::AvgPoolFusionT *>(u.value));
      break;
    }
    case PrimitiveType_AvgPoolGrad: {
      value = new mindspore::schema::AvgPoolGradT(*reinterpret_cast<mindspore::schema::AvgPoolGradT *>(u.value));
      break;
    }
    case PrimitiveType_BatchNorm: {
      value = new mindspore::schema::BatchNormT(*reinterpret_cast<mindspore::schema::BatchNormT *>(u.value));
      break;
    }
    case PrimitiveType_BatchNormGrad: {
      value = new mindspore::schema::BatchNormGradT(*reinterpret_cast<mindspore::schema::BatchNormGradT *>(u.value));
      break;
    }
    case PrimitiveType_BatchToSpace: {
      FLATBUFFERS_ASSERT(false);  // mindspore::schema::BatchToSpaceT not copyable.
      break;
    }
    case PrimitiveType_BatchToSpaceND: {
      FLATBUFFERS_ASSERT(false);  // mindspore::schema::BatchToSpaceNDT not copyable.
      break;
    }
    case PrimitiveType_BiasAdd: {
      value = new mindspore::schema::BiasAddT(*reinterpret_cast<mindspore::schema::BiasAddT *>(u.value));
      break;
    }
    case PrimitiveType_BinaryCrossEntropy: {
      value = new mindspore::schema::BinaryCrossEntropyT(*reinterpret_cast<mindspore::schema::BinaryCrossEntropyT *>(u.value));
      break;
    }
    case PrimitiveType_BinaryCrossEntropyGrad: {
      value = new mindspore::schema::BinaryCrossEntropyGradT(*reinterpret_cast<mindspore::schema::BinaryCrossEntropyGradT *>(u.value));
      break;
    }
    case PrimitiveType_BiasAddGrad: {
      value = new mindspore::schema::BiasAddGradT(*reinterpret_cast<mindspore::schema::BiasAddGradT *>(u.value));
      break;
    }
    case PrimitiveType_BroadcastTo: {
      value = new mindspore::schema::BroadcastToT(*reinterpret_cast<mindspore::schema::BroadcastToT *>(u.value));
      break;
    }
    case PrimitiveType_Cast: {
      value = new mindspore::schema::CastT(*reinterpret_cast<mindspore::schema::CastT *>(u.value));
      break;
    }
    case PrimitiveType_Ceil: {
      value = new mindspore::schema::CeilT(*reinterpret_cast<mindspore::schema::CeilT *>(u.value));
      break;
    }
    case PrimitiveType_Clip: {
      value = new mindspore::schema::ClipT(*reinterpret_cast<mindspore::schema::ClipT *>(u.value));
      break;
    }
    case PrimitiveType_Concat: {
      value = new mindspore::schema::ConcatT(*reinterpret_cast<mindspore::schema::ConcatT *>(u.value));
      break;
    }
    case PrimitiveType_Attention: {
      value = new mindspore::schema::AttentionT(*reinterpret_cast<mindspore::schema::AttentionT *>(u.value));
      break;
    }
    case PrimitiveType_Conv2DBackpropFilterFusion: {
      value = new mindspore::schema::Conv2DBackpropFilterFusionT(*reinterpret_cast<mindspore::schema::Conv2DBackpropFilterFusionT *>(u.value));
      break;
    }
    case PrimitiveType_Conv2DBackpropInputFusion: {
      value = new mindspore::schema::Conv2DBackpropInputFusionT(*reinterpret_cast<mindspore::schema::Conv2DBackpropInputFusionT *>(u.value));
      break;
    }
    case PrimitiveType_Conv2DFusion: {
      value = new mindspore::schema::Conv2DFusionT(*reinterpret_cast<mindspore::schema::Conv2DFusionT *>(u.value));
      break;
    }
    case PrimitiveType_Conv2dTransposeFusion: {
      value = new mindspore::schema::Conv2dTransposeFusionT(*reinterpret_cast<mindspore::schema::Conv2dTransposeFusionT *>(u.value));
      break;
    }
    case PrimitiveType_Cos: {
      value = new mindspore::schema::CosT(*reinterpret_cast<mindspore::schema::CosT *>(u.value));
      break;
    }
    case PrimitiveType_ConstantOfShape: {
      value = new mindspore::schema::ConstantOfShapeT(*reinterpret_cast<mindspore::schema::ConstantOfShapeT *>(u.value));
      break;
    }
    case PrimitiveType_Crop: {
      value = new mindspore::schema::CropT(*reinterpret_cast<mindspore::schema::CropT *>(u.value));
      break;
    }
    case PrimitiveType_CustomExtractFeatures: {
      value = new mindspore::schema::CustomExtractFeaturesT(*reinterpret_cast<mindspore::schema::CustomExtractFeaturesT *>(u.value));
      break;
    }
    case PrimitiveType_CustomNormalize: {
      value = new mindspore::schema::CustomNormalizeT(*reinterpret_cast<mindspore::schema::CustomNormalizeT *>(u.value));
      break;
    }
    case PrimitiveType_CustomPredict: {
      value = new mindspore::schema::CustomPredictT(*reinterpret_cast<mindspore::schema::CustomPredictT *>(u.value));
      break;
    }
    case PrimitiveType_DeConv2DGradFilter: {
      value = new mindspore::schema::DeConv2DGradFilterT(*reinterpret_cast<mindspore::schema::DeConv2DGradFilterT *>(u.value));
      break;
    }
    case PrimitiveType_Depend: {
      value = new mindspore::schema::DependT(*reinterpret_cast<mindspore::schema::DependT *>(u.value));
      break;
    }
    case PrimitiveType_DepthToSpace: {
      value = new mindspore::schema::DepthToSpaceT(*reinterpret_cast<mindspore::schema::DepthToSpaceT *>(u.value));
      break;
    }
    case PrimitiveType_DetectionPostProcess: {
      value = new mindspore::schema::DetectionPostProcessT(*reinterpret_cast<mindspore::schema::DetectionPostProcessT *>(u.value));
      break;
    }
    case PrimitiveType_DivFusion: {
      value = new mindspore::schema::DivFusionT(*reinterpret_cast<mindspore::schema::DivFusionT *>(u.value));
      break;
    }
    case PrimitiveType_DivGrad: {
      value = new mindspore::schema::DivGradT(*reinterpret_cast<mindspore::schema::DivGradT *>(u.value));
      break;
    }
    case PrimitiveType_Dropout: {
      value = new mindspore::schema::DropoutT(*reinterpret_cast<mindspore::schema::DropoutT *>(u.value));
      break;
    }
    case PrimitiveType_DropoutGrad: {
      value = new mindspore::schema::DropoutGradT(*reinterpret_cast<mindspore::schema::DropoutGradT *>(u.value));
      break;
    }
    case PrimitiveType_Elu: {
      value = new mindspore::schema::EluT(*reinterpret_cast<mindspore::schema::EluT *>(u.value));
      break;
    }
    case PrimitiveType_Eltwise: {
      value = new mindspore::schema::EltwiseT(*reinterpret_cast<mindspore::schema::EltwiseT *>(u.value));
      break;
    }
    case PrimitiveType_Equal: {
      value = new mindspore::schema::EqualT(*reinterpret_cast<mindspore::schema::EqualT *>(u.value));
      break;
    }
    case PrimitiveType_EmbeddingLookupFusion: {
      value = new mindspore::schema::EmbeddingLookupFusionT(*reinterpret_cast<mindspore::schema::EmbeddingLookupFusionT *>(u.value));
      break;
    }
    case PrimitiveType_ExpFusion: {
      value = new mindspore::schema::ExpFusionT(*reinterpret_cast<mindspore::schema::ExpFusionT *>(u.value));
      break;
    }
    case PrimitiveType_ExpandDims: {
      value = new mindspore::schema::ExpandDimsT(*reinterpret_cast<mindspore::schema::ExpandDimsT *>(u.value));
      break;
    }
    case PrimitiveType_FakeQuantWithMinMaxVars: {
      value = new mindspore::schema::FakeQuantWithMinMaxVarsT(*reinterpret_cast<mindspore::schema::FakeQuantWithMinMaxVarsT *>(u.value));
      break;
    }
    case PrimitiveType_FakeQuantWithMinMaxVarsPerChannel: {
      value = new mindspore::schema::FakeQuantWithMinMaxVarsPerChannelT(*reinterpret_cast<mindspore::schema::FakeQuantWithMinMaxVarsPerChannelT *>(u.value));
      break;
    }
    case PrimitiveType_FftReal: {
      value = new mindspore::schema::FftRealT(*reinterpret_cast<mindspore::schema::FftRealT *>(u.value));
      break;
    }
    case PrimitiveType_FftImag: {
      value = new mindspore::schema::FftImagT(*reinterpret_cast<mindspore::schema::FftImagT *>(u.value));
      break;
    }
    case PrimitiveType_Flatten: {
      value = new mindspore::schema::FlattenT(*reinterpret_cast<mindspore::schema::FlattenT *>(u.value));
      break;
    }
    case PrimitiveType_FlattenGrad: {
      value = new mindspore::schema::FlattenGradT(*reinterpret_cast<mindspore::schema::FlattenGradT *>(u.value));
      break;
    }
    case PrimitiveType_Floor: {
      value = new mindspore::schema::FloorT(*reinterpret_cast<mindspore::schema::FloorT *>(u.value));
      break;
    }
    case PrimitiveType_FloorDiv: {
      value = new mindspore::schema::FloorDivT(*reinterpret_cast<mindspore::schema::FloorDivT *>(u.value));
      break;
    }
    case PrimitiveType_FloorMod: {
      value = new mindspore::schema::FloorModT(*reinterpret_cast<mindspore::schema::FloorModT *>(u.value));
      break;
    }
    case PrimitiveType_Fill: {
      value = new mindspore::schema::FillT(*reinterpret_cast<mindspore::schema::FillT *>(u.value));
      break;
    }
    case PrimitiveType_FullConnection: {
      value = new mindspore::schema::FullConnectionT(*reinterpret_cast<mindspore::schema::FullConnectionT *>(u.value));
      break;
    }
    case PrimitiveType_FusedBatchNorm: {
      value = new mindspore::schema::FusedBatchNormT(*reinterpret_cast<mindspore::schema::FusedBatchNormT *>(u.value));
      break;
    }
    case PrimitiveType_Gather: {
      value = new mindspore::schema::GatherT(*reinterpret_cast<mindspore::schema::GatherT *>(u.value));
      break;
    }
    case PrimitiveType_GatherNd: {
      value = new mindspore::schema::GatherNdT(*reinterpret_cast<mindspore::schema::GatherNdT *>(u.value));
      break;
    }
    case PrimitiveType_Greater: {
      value = new mindspore::schema::GreaterT(*reinterpret_cast<mindspore::schema::GreaterT *>(u.value));
      break;
    }
    case PrimitiveType_GreaterEqual: {
      value = new mindspore::schema::GreaterEqualT(*reinterpret_cast<mindspore::schema::GreaterEqualT *>(u.value));
      break;
    }
    case PrimitiveType_HashtableLookup: {
      value = new mindspore::schema::HashtableLookupT(*reinterpret_cast<mindspore::schema::HashtableLookupT *>(u.value));
      break;
    }
    case PrimitiveType_InstanceNorm: {
      value = new mindspore::schema::InstanceNormT(*reinterpret_cast<mindspore::schema::InstanceNormT *>(u.value));
      break;
    }
    case PrimitiveType_LayerNormFusion: {
      value = new mindspore::schema::LayerNormFusionT(*reinterpret_cast<mindspore::schema::LayerNormFusionT *>(u.value));
      break;
    }
    case PrimitiveType_LeakyRelu: {
      value = new mindspore::schema::LeakyReluT(*reinterpret_cast<mindspore::schema::LeakyReluT *>(u.value));
      break;
    }
    case PrimitiveType_Less: {
      value = new mindspore::schema::LessT(*reinterpret_cast<mindspore::schema::LessT *>(u.value));
      break;
    }
    case PrimitiveType_LessEqual: {
      value = new mindspore::schema::LessEqualT(*reinterpret_cast<mindspore::schema::LessEqualT *>(u.value));
      break;
    }
    case PrimitiveType_Log: {
      value = new mindspore::schema::LogT(*reinterpret_cast<mindspore::schema::LogT *>(u.value));
      break;
    }
    case PrimitiveType_LogGrad: {
      value = new mindspore::schema::LogGradT(*reinterpret_cast<mindspore::schema::LogGradT *>(u.value));
      break;
    }
    case PrimitiveType_LogicalAnd: {
      value = new mindspore::schema::LogicalAndT(*reinterpret_cast<mindspore::schema::LogicalAndT *>(u.value));
      break;
    }
    case PrimitiveType_LogicalNot: {
      value = new mindspore::schema::LogicalNotT(*reinterpret_cast<mindspore::schema::LogicalNotT *>(u.value));
      break;
    }
    case PrimitiveType_LogicalOr: {
      value = new mindspore::schema::LogicalOrT(*reinterpret_cast<mindspore::schema::LogicalOrT *>(u.value));
      break;
    }
    case PrimitiveType_LpNormalization: {
      value = new mindspore::schema::LpNormalizationT(*reinterpret_cast<mindspore::schema::LpNormalizationT *>(u.value));
      break;
    }
    case PrimitiveType_LRN: {
      value = new mindspore::schema::LRNT(*reinterpret_cast<mindspore::schema::LRNT *>(u.value));
      break;
    }
    case PrimitiveType_LshProjection: {
      value = new mindspore::schema::LshProjectionT(*reinterpret_cast<mindspore::schema::LshProjectionT *>(u.value));
      break;
    }
    case PrimitiveType_LSTM: {
      value = new mindspore::schema::LSTMT(*reinterpret_cast<mindspore::schema::LSTMT *>(u.value));
      break;
    }
    case PrimitiveType_L2NormalizeFusion: {
      value = new mindspore::schema::L2NormalizeFusionT(*reinterpret_cast<mindspore::schema::L2NormalizeFusionT *>(u.value));
      break;
    }
    case PrimitiveType_MatMulFusion: {
      value = new mindspore::schema::MatMulFusionT(*reinterpret_cast<mindspore::schema::MatMulFusionT *>(u.value));
      break;
    }
    case PrimitiveType_Maximum: {
      value = new mindspore::schema::MaximumT(*reinterpret_cast<mindspore::schema::MaximumT *>(u.value));
      break;
    }
    case PrimitiveType_MaximumGrad: {
      value = new mindspore::schema::MaximumGradT(*reinterpret_cast<mindspore::schema::MaximumGradT *>(u.value));
      break;
    }
    case PrimitiveType_MaxPoolFusion: {
      value = new mindspore::schema::MaxPoolFusionT(*reinterpret_cast<mindspore::schema::MaxPoolFusionT *>(u.value));
      break;
    }
    case PrimitiveType_MaxPoolGrad: {
      value = new mindspore::schema::MaxPoolGradT(*reinterpret_cast<mindspore::schema::MaxPoolGradT *>(u.value));
      break;
    }
    case PrimitiveType_Merge: {
      value = new mindspore::schema::MergeT(*reinterpret_cast<mindspore::schema::MergeT *>(u.value));
      break;
    }
    case PrimitiveType_Mfcc: {
      value = new mindspore::schema::MfccT(*reinterpret_cast<mindspore::schema::MfccT *>(u.value));
      break;
    }
    case PrimitiveType_Minimum: {
      value = new mindspore::schema::MinimumT(*reinterpret_cast<mindspore::schema::MinimumT *>(u.value));
      break;
    }
    case PrimitiveType_MinimumGrad: {
      value = new mindspore::schema::MinimumGradT(*reinterpret_cast<mindspore::schema::MinimumGradT *>(u.value));
      break;
    }
    case PrimitiveType_Mod: {
      value = new mindspore::schema::ModT(*reinterpret_cast<mindspore::schema::ModT *>(u.value));
      break;
    }
    case PrimitiveType_MulFusion: {
      value = new mindspore::schema::MulFusionT(*reinterpret_cast<mindspore::schema::MulFusionT *>(u.value));
      break;
    }
    case PrimitiveType_MulGrad: {
      value = new mindspore::schema::MulGradT(*reinterpret_cast<mindspore::schema::MulGradT *>(u.value));
      break;
    }
    case PrimitiveType_Neg: {
      value = new mindspore::schema::NegT(*reinterpret_cast<mindspore::schema::NegT *>(u.value));
      break;
    }
    case PrimitiveType_NegGrad: {
      value = new mindspore::schema::NegGradT(*reinterpret_cast<mindspore::schema::NegGradT *>(u.value));
      break;
    }
    case PrimitiveType_NotEqual: {
      value = new mindspore::schema::NotEqualT(*reinterpret_cast<mindspore::schema::NotEqualT *>(u.value));
      break;
    }
    case PrimitiveType_NonMaxSuppression: {
      value = new mindspore::schema::NonMaxSuppressionT(*reinterpret_cast<mindspore::schema::NonMaxSuppressionT *>(u.value));
      break;
    }
    case PrimitiveType_OneHot: {
      value = new mindspore::schema::OneHotT(*reinterpret_cast<mindspore::schema::OneHotT *>(u.value));
      break;
    }
    case PrimitiveType_OnesLike: {
      value = new mindspore::schema::OnesLikeT(*reinterpret_cast<mindspore::schema::OnesLikeT *>(u.value));
      break;
    }
    case PrimitiveType_PadFusion: {
      FLATBUFFERS_ASSERT(false);  // mindspore::schema::PadFusionT not copyable.
      break;
    }
    case PrimitiveType_PartialFusion: {
      value = new mindspore::schema::PartialFusionT(*reinterpret_cast<mindspore::schema::PartialFusionT *>(u.value));
      break;
    }
    case PrimitiveType_PowerGrad: {
      value = new mindspore::schema::PowerGradT(*reinterpret_cast<mindspore::schema::PowerGradT *>(u.value));
      break;
    }
    case PrimitiveType_PowFusion: {
      value = new mindspore::schema::PowFusionT(*reinterpret_cast<mindspore::schema::PowFusionT *>(u.value));
      break;
    }
    case PrimitiveType_PriorBox: {
      value = new mindspore::schema::PriorBoxT(*reinterpret_cast<mindspore::schema::PriorBoxT *>(u.value));
      break;
    }
    case PrimitiveType_PReLUFusion: {
      value = new mindspore::schema::PReLUFusionT(*reinterpret_cast<mindspore::schema::PReLUFusionT *>(u.value));
      break;
    }
    case PrimitiveType_QuantDTypeCast: {
      value = new mindspore::schema::QuantDTypeCastT(*reinterpret_cast<mindspore::schema::QuantDTypeCastT *>(u.value));
      break;
    }
    case PrimitiveType_Rank: {
      value = new mindspore::schema::RankT(*reinterpret_cast<mindspore::schema::RankT *>(u.value));
      break;
    }
    case PrimitiveType_Range: {
      value = new mindspore::schema::RangeT(*reinterpret_cast<mindspore::schema::RangeT *>(u.value));
      break;
    }
    case PrimitiveType_Reciprocal: {
      value = new mindspore::schema::ReciprocalT(*reinterpret_cast<mindspore::schema::ReciprocalT *>(u.value));
      break;
    }
    case PrimitiveType_RealDiv: {
      value = new mindspore::schema::RealDivT(*reinterpret_cast<mindspore::schema::RealDivT *>(u.value));
      break;
    }
    case PrimitiveType_ReduceFusion: {
      value = new mindspore::schema::ReduceFusionT(*reinterpret_cast<mindspore::schema::ReduceFusionT *>(u.value));
      break;
    }
    case PrimitiveType_Reshape: {
      value = new mindspore::schema::ReshapeT(*reinterpret_cast<mindspore::schema::ReshapeT *>(u.value));
      break;
    }
    case PrimitiveType_Resize: {
      value = new mindspore::schema::ResizeT(*reinterpret_cast<mindspore::schema::ResizeT *>(u.value));
      break;
    }
    case PrimitiveType_ReverseSequence: {
      value = new mindspore::schema::ReverseSequenceT(*reinterpret_cast<mindspore::schema::ReverseSequenceT *>(u.value));
      break;
    }
    case PrimitiveType_ReverseV2: {
      value = new mindspore::schema::ReverseV2T(*reinterpret_cast<mindspore::schema::ReverseV2T *>(u.value));
      break;
    }
    case PrimitiveType_Rfft: {
      value = new mindspore::schema::RfftT(*reinterpret_cast<mindspore::schema::RfftT *>(u.value));
      break;
    }
    case PrimitiveType_ROIPooling: {
      value = new mindspore::schema::ROIPoolingT(*reinterpret_cast<mindspore::schema::ROIPoolingT *>(u.value));
      break;
    }
    case PrimitiveType_Round: {
      value = new mindspore::schema::RoundT(*reinterpret_cast<mindspore::schema::RoundT *>(u.value));
      break;
    }
    case PrimitiveType_Rsqrt: {
      value = new mindspore::schema::RsqrtT(*reinterpret_cast<mindspore::schema::RsqrtT *>(u.value));
      break;
    }
    case PrimitiveType_ScaleFusion: {
      value = new mindspore::schema::ScaleFusionT(*reinterpret_cast<mindspore::schema::ScaleFusionT *>(u.value));
      break;
    }
    case PrimitiveType_ScatterNd: {
      value = new mindspore::schema::ScatterNdT(*reinterpret_cast<mindspore::schema::ScatterNdT *>(u.value));
      break;
    }
    case PrimitiveType_SGD: {
      value = new mindspore::schema::SGDT(*reinterpret_cast<mindspore::schema::SGDT *>(u.value));
      break;
    }
    case PrimitiveType_Shape: {
      value = new mindspore::schema::ShapeT(*reinterpret_cast<mindspore::schema::ShapeT *>(u.value));
      break;
    }
    case PrimitiveType_SigmoidCrossEntropyWithLogits: {
      value = new mindspore::schema::SigmoidCrossEntropyWithLogitsT(*reinterpret_cast<mindspore::schema::SigmoidCrossEntropyWithLogitsT *>(u.value));
      break;
    }
    case PrimitiveType_SigmoidCrossEntropyWithLogitsGrad: {
      value = new mindspore::schema::SigmoidCrossEntropyWithLogitsGradT(*reinterpret_cast<mindspore::schema::SigmoidCrossEntropyWithLogitsGradT *>(u.value));
      break;
    }
    case PrimitiveType_Sin: {
      value = new mindspore::schema::SinT(*reinterpret_cast<mindspore::schema::SinT *>(u.value));
      break;
    }
    case PrimitiveType_SkipGram: {
      value = new mindspore::schema::SkipGramT(*reinterpret_cast<mindspore::schema::SkipGramT *>(u.value));
      break;
    }
    case PrimitiveType_SliceFusion: {
      value = new mindspore::schema::SliceFusionT(*reinterpret_cast<mindspore::schema::SliceFusionT *>(u.value));
      break;
    }
    case PrimitiveType_SmoothL1Loss: {
      value = new mindspore::schema::SmoothL1LossT(*reinterpret_cast<mindspore::schema::SmoothL1LossT *>(u.value));
      break;
    }
    case PrimitiveType_SmoothL1LossGrad: {
      value = new mindspore::schema::SmoothL1LossGradT(*reinterpret_cast<mindspore::schema::SmoothL1LossGradT *>(u.value));
      break;
    }
    case PrimitiveType_Softmax: {
      value = new mindspore::schema::SoftmaxT(*reinterpret_cast<mindspore::schema::SoftmaxT *>(u.value));
      break;
    }
    case PrimitiveType_SoftmaxCrossEntropyWithLogits: {
      value = new mindspore::schema::SoftmaxCrossEntropyWithLogitsT(*reinterpret_cast<mindspore::schema::SoftmaxCrossEntropyWithLogitsT *>(u.value));
      break;
    }
    case PrimitiveType_SpaceToBatch: {
      FLATBUFFERS_ASSERT(false);  // mindspore::schema::SpaceToBatchT not copyable.
      break;
    }
    case PrimitiveType_SpaceToBatchND: {
      FLATBUFFERS_ASSERT(false);  // mindspore::schema::SpaceToBatchNDT not copyable.
      break;
    }
    case PrimitiveType_SpaceToDepth: {
      value = new mindspore::schema::SpaceToDepthT(*reinterpret_cast<mindspore::schema::SpaceToDepthT *>(u.value));
      break;
    }
    case PrimitiveType_SparseSoftmaxCrossEntropyWithLogits: {
      value = new mindspore::schema::SparseSoftmaxCrossEntropyWithLogitsT(*reinterpret_cast<mindspore::schema::SparseSoftmaxCrossEntropyWithLogitsT *>(u.value));
      break;
    }
    case PrimitiveType_SparseToDense: {
      value = new mindspore::schema::SparseToDenseT(*reinterpret_cast<mindspore::schema::SparseToDenseT *>(u.value));
      break;
    }
    case PrimitiveType_Split: {
      value = new mindspore::schema::SplitT(*reinterpret_cast<mindspore::schema::SplitT *>(u.value));
      break;
    }
    case PrimitiveType_Sqrt: {
      value = new mindspore::schema::SqrtT(*reinterpret_cast<mindspore::schema::SqrtT *>(u.value));
      break;
    }
    case PrimitiveType_Squeeze: {
      value = new mindspore::schema::SqueezeT(*reinterpret_cast<mindspore::schema::SqueezeT *>(u.value));
      break;
    }
    case PrimitiveType_Square: {
      value = new mindspore::schema::SquareT(*reinterpret_cast<mindspore::schema::SquareT *>(u.value));
      break;
    }
    case PrimitiveType_SquaredDifference: {
      value = new mindspore::schema::SquaredDifferenceT(*reinterpret_cast<mindspore::schema::SquaredDifferenceT *>(u.value));
      break;
    }
    case PrimitiveType_Stack: {
      value = new mindspore::schema::StackT(*reinterpret_cast<mindspore::schema::StackT *>(u.value));
      break;
    }
    case PrimitiveType_StridedSlice: {
      value = new mindspore::schema::StridedSliceT(*reinterpret_cast<mindspore::schema::StridedSliceT *>(u.value));
      break;
    }
    case PrimitiveType_SubFusion: {
      value = new mindspore::schema::SubFusionT(*reinterpret_cast<mindspore::schema::SubFusionT *>(u.value));
      break;
    }
    case PrimitiveType_SubGrad: {
      value = new mindspore::schema::SubGradT(*reinterpret_cast<mindspore::schema::SubGradT *>(u.value));
      break;
    }
    case PrimitiveType_Switch: {
      value = new mindspore::schema::SwitchT(*reinterpret_cast<mindspore::schema::SwitchT *>(u.value));
      break;
    }
    case PrimitiveType_TensorListFromTensor: {
      value = new mindspore::schema::TensorListFromTensorT(*reinterpret_cast<mindspore::schema::TensorListFromTensorT *>(u.value));
      break;
    }
    case PrimitiveType_TensorListGetItem: {
      value = new mindspore::schema::TensorListGetItemT(*reinterpret_cast<mindspore::schema::TensorListGetItemT *>(u.value));
      break;
    }
    case PrimitiveType_TensorListReserve: {
      value = new mindspore::schema::TensorListReserveT(*reinterpret_cast<mindspore::schema::TensorListReserveT *>(u.value));
      break;
    }
    case PrimitiveType_TensorListSetItem: {
      value = new mindspore::schema::TensorListSetItemT(*reinterpret_cast<mindspore::schema::TensorListSetItemT *>(u.value));
      break;
    }
    case PrimitiveType_TensorListStack: {
      value = new mindspore::schema::TensorListStackT(*reinterpret_cast<mindspore::schema::TensorListStackT *>(u.value));
      break;
    }
    case PrimitiveType_TileFusion: {
      value = new mindspore::schema::TileFusionT(*reinterpret_cast<mindspore::schema::TileFusionT *>(u.value));
      break;
    }
    case PrimitiveType_TopKFusion: {
      value = new mindspore::schema::TopKFusionT(*reinterpret_cast<mindspore::schema::TopKFusionT *>(u.value));
      break;
    }
    case PrimitiveType_Transpose: {
      value = new mindspore::schema::TransposeT(*reinterpret_cast<mindspore::schema::TransposeT *>(u.value));
      break;
    }
    case PrimitiveType_Unique: {
      value = new mindspore::schema::UniqueT(*reinterpret_cast<mindspore::schema::UniqueT *>(u.value));
      break;
    }
    case PrimitiveType_UnsortedSegmentSum: {
      value = new mindspore::schema::UnsortedSegmentSumT(*reinterpret_cast<mindspore::schema::UnsortedSegmentSumT *>(u.value));
      break;
    }
    case PrimitiveType_Unsqueeze: {
      value = new mindspore::schema::UnsqueezeT(*reinterpret_cast<mindspore::schema::UnsqueezeT *>(u.value));
      break;
    }
    case PrimitiveType_Unstack: {
      value = new mindspore::schema::UnstackT(*reinterpret_cast<mindspore::schema::UnstackT *>(u.value));
      break;
    }
    case PrimitiveType_LSTMGrad: {
      value = new mindspore::schema::LSTMGradT(*reinterpret_cast<mindspore::schema::LSTMGradT *>(u.value));
      break;
    }
    case PrimitiveType_Where: {
      value = new mindspore::schema::WhereT(*reinterpret_cast<mindspore::schema::WhereT *>(u.value));
      break;
    }
    case PrimitiveType_ZerosLike: {
      value = new mindspore::schema::ZerosLikeT(*reinterpret_cast<mindspore::schema::ZerosLikeT *>(u.value));
      break;
    }
    case PrimitiveType_Select: {
      value = new mindspore::schema::SelectT(*reinterpret_cast<mindspore::schema::SelectT *>(u.value));
      break;
    }
    case PrimitiveType_ScatterNdUpdate: {
      value = new mindspore::schema::ScatterNdUpdateT(*reinterpret_cast<mindspore::schema::ScatterNdUpdateT *>(u.value));
      break;
    }
    case PrimitiveType_GRU: {
      value = new mindspore::schema::GRUT(*reinterpret_cast<mindspore::schema::GRUT *>(u.value));
      break;
    }
    case PrimitiveType_NonZero: {
      value = new mindspore::schema::NonZeroT(*reinterpret_cast<mindspore::schema::NonZeroT *>(u.value));
      break;
    }
    case PrimitiveType_InvertPermutation: {
      value = new mindspore::schema::InvertPermutationT(*reinterpret_cast<mindspore::schema::InvertPermutationT *>(u.value));
      break;
    }
    case PrimitiveType_Size: {
      value = new mindspore::schema::SizeT(*reinterpret_cast<mindspore::schema::SizeT *>(u.value));
      break;
    }
    case PrimitiveType_RandomStandardNormal: {
      value = new mindspore::schema::RandomStandardNormalT(*reinterpret_cast<mindspore::schema::RandomStandardNormalT *>(u.value));
      break;
    }
    case PrimitiveType_CropAndResize: {
      value = new mindspore::schema::CropAndResizeT(*reinterpret_cast<mindspore::schema::CropAndResizeT *>(u.value));
      break;
    }
    case PrimitiveType_Erf: {
      value = new mindspore::schema::ErfT(*reinterpret_cast<mindspore::schema::ErfT *>(u.value));
      break;
    }
    case PrimitiveType_StridedSliceGrad: {
      value = new mindspore::schema::StridedSliceGradT(*reinterpret_cast<mindspore::schema::StridedSliceGradT *>(u.value));
      break;
    }
    case PrimitiveType_IsFinite: {
      value = new mindspore::schema::IsFiniteT(*reinterpret_cast<mindspore::schema::IsFiniteT *>(u.value));
      break;
    }
    case PrimitiveType_LinSpace: {
      value = new mindspore::schema::LinSpaceT(*reinterpret_cast<mindspore::schema::LinSpaceT *>(u.value));
      break;
    }
    case PrimitiveType_UniformReal: {
      value = new mindspore::schema::UniformRealT(*reinterpret_cast<mindspore::schema::UniformRealT *>(u.value));
      break;
    }
    case PrimitiveType_AbsGrad: {
      value = new mindspore::schema::AbsGradT(*reinterpret_cast<mindspore::schema::AbsGradT *>(u.value));
      break;
    }
    case PrimitiveType_RsqrtGrad: {
      value = new mindspore::schema::RsqrtGradT(*reinterpret_cast<mindspore::schema::RsqrtGradT *>(u.value));
      break;
    }
    case PrimitiveType_SqrtGrad: {
      value = new mindspore::schema::SqrtGradT(*reinterpret_cast<mindspore::schema::SqrtGradT *>(u.value));
      break;
    }
    case PrimitiveType_LayerNormGrad: {
      value = new mindspore::schema::LayerNormGradT(*reinterpret_cast<mindspore::schema::LayerNormGradT *>(u.value));
      break;
    }
    case PrimitiveType_ResizeGrad: {
      value = new mindspore::schema::ResizeGradT(*reinterpret_cast<mindspore::schema::ResizeGradT *>(u.value));
      break;
    }
    case PrimitiveType_Splice: {
      value = new mindspore::schema::SpliceT(*reinterpret_cast<mindspore::schema::SpliceT *>(u.value));
      break;
    }
    case PrimitiveType_LogSoftmax: {
      value = new mindspore::schema::LogSoftmaxT(*reinterpret_cast<mindspore::schema::LogSoftmaxT *>(u.value));
      break;
    }
    case PrimitiveType_Call: {
      value = new mindspore::schema::CallT(*reinterpret_cast<mindspore::schema::CallT *>(u.value));
      break;
    }
    case PrimitiveType_Custom: {
      FLATBUFFERS_ASSERT(false);  // mindspore::schema::CustomT not copyable.
      break;
    }
    case PrimitiveType_CumSum: {
      value = new mindspore::schema::CumSumT(*reinterpret_cast<mindspore::schema::CumSumT *>(u.value));
      break;
    }
    case PrimitiveType_SplitWithOverlap: {
      value = new mindspore::schema::SplitWithOverlapT(*reinterpret_cast<mindspore::schema::SplitWithOverlapT *>(u.value));
      break;
    }
    case PrimitiveType_GenOP: {
      value = new mindspore::schema::GenOPT(*reinterpret_cast<mindspore::schema::GenOPT *>(u.value));
      break;
    }
    case PrimitiveType_RaggedRange: {
      value = new mindspore::schema::RaggedRangeT(*reinterpret_cast<mindspore::schema::RaggedRangeT *>(u.value));
      break;
    }
    case PrimitiveType_GLU: {
      value = new mindspore::schema::GLUT(*reinterpret_cast<mindspore::schema::GLUT *>(u.value));
      break;
    }
    case PrimitiveType_TensorArray: {
      value = new mindspore::schema::TensorArrayT(*reinterpret_cast<mindspore::schema::TensorArrayT *>(u.value));
      break;
    }
    case PrimitiveType_TensorArrayRead: {
      value = new mindspore::schema::TensorArrayReadT(*reinterpret_cast<mindspore::schema::TensorArrayReadT *>(u.value));
      break;
    }
    case PrimitiveType_TensorArrayWrite: {
      value = new mindspore::schema::TensorArrayWriteT(*reinterpret_cast<mindspore::schema::TensorArrayWriteT *>(u.value));
      break;
    }
    case PrimitiveType_Affine: {
      value = new mindspore::schema::AffineT(*reinterpret_cast<mindspore::schema::AffineT *>(u.value));
      break;
    }
    default:
      break;
  }
}

inline void PrimitiveTypeUnion::Reset() {
  switch (type) {
    case PrimitiveType_Abs: {
      auto ptr = reinterpret_cast<mindspore::schema::AbsT *>(value);
      delete ptr;
      break;
    }
    case PrimitiveType_Activation: {
      auto ptr = reinterpret_cast<mindspore::schema::ActivationT *>(value);
      delete ptr;
      break;
    }
    case PrimitiveType_ActivationGrad: {
      auto ptr = reinterpret_cast<mindspore::schema::ActivationGradT *>(value);
      delete ptr;
      break;
    }
    case PrimitiveType_Adam: {
      auto ptr = reinterpret_cast<mindspore::schema::AdamT *>(value);
      delete ptr;
      break;
    }
    case PrimitiveType_AddFusion: {
      auto ptr = reinterpret_cast<mindspore::schema::AddFusionT *>(value);
      delete ptr;
      break;
    }
    case PrimitiveType_AdderFusion: {
      auto ptr = reinterpret_cast<mindspore::schema::AdderFusionT *>(value);
      delete ptr;
      break;
    }
    case PrimitiveType_AddGrad: {
      auto ptr = reinterpret_cast<mindspore::schema::AddGradT *>(value);
      delete ptr;
      break;
    }
    case PrimitiveType_AddN: {
      auto ptr = reinterpret_cast<mindspore::schema::AddNT *>(value);
      delete ptr;
      break;
    }
    case PrimitiveType_All: {
      auto ptr = reinterpret_cast<mindspore::schema::AllT *>(value);
      delete ptr;
      break;
    }
    case PrimitiveType_ApplyMomentum: {
      auto ptr = reinterpret_cast<mindspore::schema::ApplyMomentumT *>(value);
      delete ptr;
      break;
    }
    case PrimitiveType_ArgMaxFusion: {
      auto ptr = reinterpret_cast<mindspore::schema::ArgMaxFusionT *>(value);
      delete ptr;
      break;
    }
    case PrimitiveType_ArgMinFusion: {
      auto ptr = reinterpret_cast<mindspore::schema::ArgMinFusionT *>(value);
      delete ptr;
      break;
    }
    case PrimitiveType_Assert: {
      auto ptr = reinterpret_cast<mindspore::schema::AssertT *>(value);
      delete ptr;
      break;
    }
    case PrimitiveType_Assign: {
      auto ptr = reinterpret_cast<mindspore::schema::AssignT *>(value);
      delete ptr;
      break;
    }
    case PrimitiveType_AssignAdd: {
      auto ptr = reinterpret_cast<mindspore::schema::AssignAddT *>(value);
      delete ptr;
      break;
    }
    case PrimitiveType_AudioSpectrogram: {
      auto ptr = reinterpret_cast<mindspore::schema::AudioSpectrogramT *>(value);
      delete ptr;
      break;
    }
    case PrimitiveType_AvgPoolFusion: {
      auto ptr = reinterpret_cast<mindspore::schema::AvgPoolFusionT *>(value);
      delete ptr;
      break;
    }
    case PrimitiveType_AvgPoolGrad: {
      auto ptr = reinterpret_cast<mindspore::schema::AvgPoolGradT *>(value);
      delete ptr;
      break;
    }
    case PrimitiveType_BatchNorm: {
      auto ptr = reinterpret_cast<mindspore::schema::BatchNormT *>(value);
      delete ptr;
      break;
    }
    case PrimitiveType_BatchNormGrad: {
      auto ptr = reinterpret_cast<mindspore::schema::BatchNormGradT *>(value);
      delete ptr;
      break;
    }
    case PrimitiveType_BatchToSpace: {
      auto ptr = reinterpret_cast<mindspore::schema::BatchToSpaceT *>(value);
      delete ptr;
      break;
    }
    case PrimitiveType_BatchToSpaceND: {
      auto ptr = reinterpret_cast<mindspore::schema::BatchToSpaceNDT *>(value);
      delete ptr;
      break;
    }
    case PrimitiveType_BiasAdd: {
      auto ptr = reinterpret_cast<mindspore::schema::BiasAddT *>(value);
      delete ptr;
      break;
    }
    case PrimitiveType_BinaryCrossEntropy: {
      auto ptr = reinterpret_cast<mindspore::schema::BinaryCrossEntropyT *>(value);
      delete ptr;
      break;
    }
    case PrimitiveType_BinaryCrossEntropyGrad: {
      auto ptr = reinterpret_cast<mindspore::schema::BinaryCrossEntropyGradT *>(value);
      delete ptr;
      break;
    }
    case PrimitiveType_BiasAddGrad: {
      auto ptr = reinterpret_cast<mindspore::schema::BiasAddGradT *>(value);
      delete ptr;
      break;
    }
    case PrimitiveType_BroadcastTo: {
      auto ptr = reinterpret_cast<mindspore::schema::BroadcastToT *>(value);
      delete ptr;
      break;
    }
    case PrimitiveType_Cast: {
      auto ptr = reinterpret_cast<mindspore::schema::CastT *>(value);
      delete ptr;
      break;
    }
    case PrimitiveType_Ceil: {
      auto ptr = reinterpret_cast<mindspore::schema::CeilT *>(value);
      delete ptr;
      break;
    }
    case PrimitiveType_Clip: {
      auto ptr = reinterpret_cast<mindspore::schema::ClipT *>(value);
      delete ptr;
      break;
    }
    case PrimitiveType_Concat: {
      auto ptr = reinterpret_cast<mindspore::schema::ConcatT *>(value);
      delete ptr;
      break;
    }
    case PrimitiveType_Attention: {
      auto ptr = reinterpret_cast<mindspore::schema::AttentionT *>(value);
      delete ptr;
      break;
    }
    case PrimitiveType_Conv2DBackpropFilterFusion: {
      auto ptr = reinterpret_cast<mindspore::schema::Conv2DBackpropFilterFusionT *>(value);
      delete ptr;
      break;
    }
    case PrimitiveType_Conv2DBackpropInputFusion: {
      auto ptr = reinterpret_cast<mindspore::schema::Conv2DBackpropInputFusionT *>(value);
      delete ptr;
      break;
    }
    case PrimitiveType_Conv2DFusion: {
      auto ptr = reinterpret_cast<mindspore::schema::Conv2DFusionT *>(value);
      delete ptr;
      break;
    }
    case PrimitiveType_Conv2dTransposeFusion: {
      auto ptr = reinterpret_cast<mindspore::schema::Conv2dTransposeFusionT *>(value);
      delete ptr;
      break;
    }
    case PrimitiveType_Cos: {
      auto ptr = reinterpret_cast<mindspore::schema::CosT *>(value);
      delete ptr;
      break;
    }
    case PrimitiveType_ConstantOfShape: {
      auto ptr = reinterpret_cast<mindspore::schema::ConstantOfShapeT *>(value);
      delete ptr;
      break;
    }
    case PrimitiveType_Crop: {
      auto ptr = reinterpret_cast<mindspore::schema::CropT *>(value);
      delete ptr;
      break;
    }
    case PrimitiveType_CustomExtractFeatures: {
      auto ptr = reinterpret_cast<mindspore::schema::CustomExtractFeaturesT *>(value);
      delete ptr;
      break;
    }
    case PrimitiveType_CustomNormalize: {
      auto ptr = reinterpret_cast<mindspore::schema::CustomNormalizeT *>(value);
      delete ptr;
      break;
    }
    case PrimitiveType_CustomPredict: {
      auto ptr = reinterpret_cast<mindspore::schema::CustomPredictT *>(value);
      delete ptr;
      break;
    }
    case PrimitiveType_DeConv2DGradFilter: {
      auto ptr = reinterpret_cast<mindspore::schema::DeConv2DGradFilterT *>(value);
      delete ptr;
      break;
    }
    case PrimitiveType_Depend: {
      auto ptr = reinterpret_cast<mindspore::schema::DependT *>(value);
      delete ptr;
      break;
    }
    case PrimitiveType_DepthToSpace: {
      auto ptr = reinterpret_cast<mindspore::schema::DepthToSpaceT *>(value);
      delete ptr;
      break;
    }
    case PrimitiveType_DetectionPostProcess: {
      auto ptr = reinterpret_cast<mindspore::schema::DetectionPostProcessT *>(value);
      delete ptr;
      break;
    }
    case PrimitiveType_DivFusion: {
      auto ptr = reinterpret_cast<mindspore::schema::DivFusionT *>(value);
      delete ptr;
      break;
    }
    case PrimitiveType_DivGrad: {
      auto ptr = reinterpret_cast<mindspore::schema::DivGradT *>(value);
      delete ptr;
      break;
    }
    case PrimitiveType_Dropout: {
      auto ptr = reinterpret_cast<mindspore::schema::DropoutT *>(value);
      delete ptr;
      break;
    }
    case PrimitiveType_DropoutGrad: {
      auto ptr = reinterpret_cast<mindspore::schema::DropoutGradT *>(value);
      delete ptr;
      break;
    }
    case PrimitiveType_Elu: {
      auto ptr = reinterpret_cast<mindspore::schema::EluT *>(value);
      delete ptr;
      break;
    }
    case PrimitiveType_Eltwise: {
      auto ptr = reinterpret_cast<mindspore::schema::EltwiseT *>(value);
      delete ptr;
      break;
    }
    case PrimitiveType_Equal: {
      auto ptr = reinterpret_cast<mindspore::schema::EqualT *>(value);
      delete ptr;
      break;
    }
    case PrimitiveType_EmbeddingLookupFusion: {
      auto ptr = reinterpret_cast<mindspore::schema::EmbeddingLookupFusionT *>(value);
      delete ptr;
      break;
    }
    case PrimitiveType_ExpFusion: {
      auto ptr = reinterpret_cast<mindspore::schema::ExpFusionT *>(value);
      delete ptr;
      break;
    }
    case PrimitiveType_ExpandDims: {
      auto ptr = reinterpret_cast<mindspore::schema::ExpandDimsT *>(value);
      delete ptr;
      break;
    }
    case PrimitiveType_FakeQuantWithMinMaxVars: {
      auto ptr = reinterpret_cast<mindspore::schema::FakeQuantWithMinMaxVarsT *>(value);
      delete ptr;
      break;
    }
    case PrimitiveType_FakeQuantWithMinMaxVarsPerChannel: {
      auto ptr = reinterpret_cast<mindspore::schema::FakeQuantWithMinMaxVarsPerChannelT *>(value);
      delete ptr;
      break;
    }
    case PrimitiveType_FftReal: {
      auto ptr = reinterpret_cast<mindspore::schema::FftRealT *>(value);
      delete ptr;
      break;
    }
    case PrimitiveType_FftImag: {
      auto ptr = reinterpret_cast<mindspore::schema::FftImagT *>(value);
      delete ptr;
      break;
    }
    case PrimitiveType_Flatten: {
      auto ptr = reinterpret_cast<mindspore::schema::FlattenT *>(value);
      delete ptr;
      break;
    }
    case PrimitiveType_FlattenGrad: {
      auto ptr = reinterpret_cast<mindspore::schema::FlattenGradT *>(value);
      delete ptr;
      break;
    }
    case PrimitiveType_Floor: {
      auto ptr = reinterpret_cast<mindspore::schema::FloorT *>(value);
      delete ptr;
      break;
    }
    case PrimitiveType_FloorDiv: {
      auto ptr = reinterpret_cast<mindspore::schema::FloorDivT *>(value);
      delete ptr;
      break;
    }
    case PrimitiveType_FloorMod: {
      auto ptr = reinterpret_cast<mindspore::schema::FloorModT *>(value);
      delete ptr;
      break;
    }
    case PrimitiveType_Fill: {
      auto ptr = reinterpret_cast<mindspore::schema::FillT *>(value);
      delete ptr;
      break;
    }
    case PrimitiveType_FullConnection: {
      auto ptr = reinterpret_cast<mindspore::schema::FullConnectionT *>(value);
      delete ptr;
      break;
    }
    case PrimitiveType_FusedBatchNorm: {
      auto ptr = reinterpret_cast<mindspore::schema::FusedBatchNormT *>(value);
      delete ptr;
      break;
    }
    case PrimitiveType_Gather: {
      auto ptr = reinterpret_cast<mindspore::schema::GatherT *>(value);
      delete ptr;
      break;
    }
    case PrimitiveType_GatherNd: {
      auto ptr = reinterpret_cast<mindspore::schema::GatherNdT *>(value);
      delete ptr;
      break;
    }
    case PrimitiveType_Greater: {
      auto ptr = reinterpret_cast<mindspore::schema::GreaterT *>(value);
      delete ptr;
      break;
    }
    case PrimitiveType_GreaterEqual: {
      auto ptr = reinterpret_cast<mindspore::schema::GreaterEqualT *>(value);
      delete ptr;
      break;
    }
    case PrimitiveType_HashtableLookup: {
      auto ptr = reinterpret_cast<mindspore::schema::HashtableLookupT *>(value);
      delete ptr;
      break;
    }
    case PrimitiveType_InstanceNorm: {
      auto ptr = reinterpret_cast<mindspore::schema::InstanceNormT *>(value);
      delete ptr;
      break;
    }
    case PrimitiveType_LayerNormFusion: {
      auto ptr = reinterpret_cast<mindspore::schema::LayerNormFusionT *>(value);
      delete ptr;
      break;
    }
    case PrimitiveType_LeakyRelu: {
      auto ptr = reinterpret_cast<mindspore::schema::LeakyReluT *>(value);
      delete ptr;
      break;
    }
    case PrimitiveType_Less: {
      auto ptr = reinterpret_cast<mindspore::schema::LessT *>(value);
      delete ptr;
      break;
    }
    case PrimitiveType_LessEqual: {
      auto ptr = reinterpret_cast<mindspore::schema::LessEqualT *>(value);
      delete ptr;
      break;
    }
    case PrimitiveType_Log: {
      auto ptr = reinterpret_cast<mindspore::schema::LogT *>(value);
      delete ptr;
      break;
    }
    case PrimitiveType_LogGrad: {
      auto ptr = reinterpret_cast<mindspore::schema::LogGradT *>(value);
      delete ptr;
      break;
    }
    case PrimitiveType_LogicalAnd: {
      auto ptr = reinterpret_cast<mindspore::schema::LogicalAndT *>(value);
      delete ptr;
      break;
    }
    case PrimitiveType_LogicalNot: {
      auto ptr = reinterpret_cast<mindspore::schema::LogicalNotT *>(value);
      delete ptr;
      break;
    }
    case PrimitiveType_LogicalOr: {
      auto ptr = reinterpret_cast<mindspore::schema::LogicalOrT *>(value);
      delete ptr;
      break;
    }
    case PrimitiveType_LpNormalization: {
      auto ptr = reinterpret_cast<mindspore::schema::LpNormalizationT *>(value);
      delete ptr;
      break;
    }
    case PrimitiveType_LRN: {
      auto ptr = reinterpret_cast<mindspore::schema::LRNT *>(value);
      delete ptr;
      break;
    }
    case PrimitiveType_LshProjection: {
      auto ptr = reinterpret_cast<mindspore::schema::LshProjectionT *>(value);
      delete ptr;
      break;
    }
    case PrimitiveType_LSTM: {
      auto ptr = reinterpret_cast<mindspore::schema::LSTMT *>(value);
      delete ptr;
      break;
    }
    case PrimitiveType_L2NormalizeFusion: {
      auto ptr = reinterpret_cast<mindspore::schema::L2NormalizeFusionT *>(value);
      delete ptr;
      break;
    }
    case PrimitiveType_MatMulFusion: {
      auto ptr = reinterpret_cast<mindspore::schema::MatMulFusionT *>(value);
      delete ptr;
      break;
    }
    case PrimitiveType_Maximum: {
      auto ptr = reinterpret_cast<mindspore::schema::MaximumT *>(value);
      delete ptr;
      break;
    }
    case PrimitiveType_MaximumGrad: {
      auto ptr = reinterpret_cast<mindspore::schema::MaximumGradT *>(value);
      delete ptr;
      break;
    }
    case PrimitiveType_MaxPoolFusion: {
      auto ptr = reinterpret_cast<mindspore::schema::MaxPoolFusionT *>(value);
      delete ptr;
      break;
    }
    case PrimitiveType_MaxPoolGrad: {
      auto ptr = reinterpret_cast<mindspore::schema::MaxPoolGradT *>(value);
      delete ptr;
      break;
    }
    case PrimitiveType_Merge: {
      auto ptr = reinterpret_cast<mindspore::schema::MergeT *>(value);
      delete ptr;
      break;
    }
    case PrimitiveType_Mfcc: {
      auto ptr = reinterpret_cast<mindspore::schema::MfccT *>(value);
      delete ptr;
      break;
    }
    case PrimitiveType_Minimum: {
      auto ptr = reinterpret_cast<mindspore::schema::MinimumT *>(value);
      delete ptr;
      break;
    }
    case PrimitiveType_MinimumGrad: {
      auto ptr = reinterpret_cast<mindspore::schema::MinimumGradT *>(value);
      delete ptr;
      break;
    }
    case PrimitiveType_Mod: {
      auto ptr = reinterpret_cast<mindspore::schema::ModT *>(value);
      delete ptr;
      break;
    }
    case PrimitiveType_MulFusion: {
      auto ptr = reinterpret_cast<mindspore::schema::MulFusionT *>(value);
      delete ptr;
      break;
    }
    case PrimitiveType_MulGrad: {
      auto ptr = reinterpret_cast<mindspore::schema::MulGradT *>(value);
      delete ptr;
      break;
    }
    case PrimitiveType_Neg: {
      auto ptr = reinterpret_cast<mindspore::schema::NegT *>(value);
      delete ptr;
      break;
    }
    case PrimitiveType_NegGrad: {
      auto ptr = reinterpret_cast<mindspore::schema::NegGradT *>(value);
      delete ptr;
      break;
    }
    case PrimitiveType_NotEqual: {
      auto ptr = reinterpret_cast<mindspore::schema::NotEqualT *>(value);
      delete ptr;
      break;
    }
    case PrimitiveType_NonMaxSuppression: {
      auto ptr = reinterpret_cast<mindspore::schema::NonMaxSuppressionT *>(value);
      delete ptr;
      break;
    }
    case PrimitiveType_OneHot: {
      auto ptr = reinterpret_cast<mindspore::schema::OneHotT *>(value);
      delete ptr;
      break;
    }
    case PrimitiveType_OnesLike: {
      auto ptr = reinterpret_cast<mindspore::schema::OnesLikeT *>(value);
      delete ptr;
      break;
    }
    case PrimitiveType_PadFusion: {
      auto ptr = reinterpret_cast<mindspore::schema::PadFusionT *>(value);
      delete ptr;
      break;
    }
    case PrimitiveType_PartialFusion: {
      auto ptr = reinterpret_cast<mindspore::schema::PartialFusionT *>(value);
      delete ptr;
      break;
    }
    case PrimitiveType_PowerGrad: {
      auto ptr = reinterpret_cast<mindspore::schema::PowerGradT *>(value);
      delete ptr;
      break;
    }
    case PrimitiveType_PowFusion: {
      auto ptr = reinterpret_cast<mindspore::schema::PowFusionT *>(value);
      delete ptr;
      break;
    }
    case PrimitiveType_PriorBox: {
      auto ptr = reinterpret_cast<mindspore::schema::PriorBoxT *>(value);
      delete ptr;
      break;
    }
    case PrimitiveType_PReLUFusion: {
      auto ptr = reinterpret_cast<mindspore::schema::PReLUFusionT *>(value);
      delete ptr;
      break;
    }
    case PrimitiveType_QuantDTypeCast: {
      auto ptr = reinterpret_cast<mindspore::schema::QuantDTypeCastT *>(value);
      delete ptr;
      break;
    }
    case PrimitiveType_Rank: {
      auto ptr = reinterpret_cast<mindspore::schema::RankT *>(value);
      delete ptr;
      break;
    }
    case PrimitiveType_Range: {
      auto ptr = reinterpret_cast<mindspore::schema::RangeT *>(value);
      delete ptr;
      break;
    }
    case PrimitiveType_Reciprocal: {
      auto ptr = reinterpret_cast<mindspore::schema::ReciprocalT *>(value);
      delete ptr;
      break;
    }
    case PrimitiveType_RealDiv: {
      auto ptr = reinterpret_cast<mindspore::schema::RealDivT *>(value);
      delete ptr;
      break;
    }
    case PrimitiveType_ReduceFusion: {
      auto ptr = reinterpret_cast<mindspore::schema::ReduceFusionT *>(value);
      delete ptr;
      break;
    }
    case PrimitiveType_Reshape: {
      auto ptr = reinterpret_cast<mindspore::schema::ReshapeT *>(value);
      delete ptr;
      break;
    }
    case PrimitiveType_Resize: {
      auto ptr = reinterpret_cast<mindspore::schema::ResizeT *>(value);
      delete ptr;
      break;
    }
    case PrimitiveType_ReverseSequence: {
      auto ptr = reinterpret_cast<mindspore::schema::ReverseSequenceT *>(value);
      delete ptr;
      break;
    }
    case PrimitiveType_ReverseV2: {
      auto ptr = reinterpret_cast<mindspore::schema::ReverseV2T *>(value);
      delete ptr;
      break;
    }
    case PrimitiveType_Rfft: {
      auto ptr = reinterpret_cast<mindspore::schema::RfftT *>(value);
      delete ptr;
      break;
    }
    case PrimitiveType_ROIPooling: {
      auto ptr = reinterpret_cast<mindspore::schema::ROIPoolingT *>(value);
      delete ptr;
      break;
    }
    case PrimitiveType_Round: {
      auto ptr = reinterpret_cast<mindspore::schema::RoundT *>(value);
      delete ptr;
      break;
    }
    case PrimitiveType_Rsqrt: {
      auto ptr = reinterpret_cast<mindspore::schema::RsqrtT *>(value);
      delete ptr;
      break;
    }
    case PrimitiveType_ScaleFusion: {
      auto ptr = reinterpret_cast<mindspore::schema::ScaleFusionT *>(value);
      delete ptr;
      break;
    }
    case PrimitiveType_ScatterNd: {
      auto ptr = reinterpret_cast<mindspore::schema::ScatterNdT *>(value);
      delete ptr;
      break;
    }
    case PrimitiveType_SGD: {
      auto ptr = reinterpret_cast<mindspore::schema::SGDT *>(value);
      delete ptr;
      break;
    }
    case PrimitiveType_Shape: {
      auto ptr = reinterpret_cast<mindspore::schema::ShapeT *>(value);
      delete ptr;
      break;
    }
    case PrimitiveType_SigmoidCrossEntropyWithLogits: {
      auto ptr = reinterpret_cast<mindspore::schema::SigmoidCrossEntropyWithLogitsT *>(value);
      delete ptr;
      break;
    }
    case PrimitiveType_SigmoidCrossEntropyWithLogitsGrad: {
      auto ptr = reinterpret_cast<mindspore::schema::SigmoidCrossEntropyWithLogitsGradT *>(value);
      delete ptr;
      break;
    }
    case PrimitiveType_Sin: {
      auto ptr = reinterpret_cast<mindspore::schema::SinT *>(value);
      delete ptr;
      break;
    }
    case PrimitiveType_SkipGram: {
      auto ptr = reinterpret_cast<mindspore::schema::SkipGramT *>(value);
      delete ptr;
      break;
    }
    case PrimitiveType_SliceFusion: {
      auto ptr = reinterpret_cast<mindspore::schema::SliceFusionT *>(value);
      delete ptr;
      break;
    }
    case PrimitiveType_SmoothL1Loss: {
      auto ptr = reinterpret_cast<mindspore::schema::SmoothL1LossT *>(value);
      delete ptr;
      break;
    }
    case PrimitiveType_SmoothL1LossGrad: {
      auto ptr = reinterpret_cast<mindspore::schema::SmoothL1LossGradT *>(value);
      delete ptr;
      break;
    }
    case PrimitiveType_Softmax: {
      auto ptr = reinterpret_cast<mindspore::schema::SoftmaxT *>(value);
      delete ptr;
      break;
    }
    case PrimitiveType_SoftmaxCrossEntropyWithLogits: {
      auto ptr = reinterpret_cast<mindspore::schema::SoftmaxCrossEntropyWithLogitsT *>(value);
      delete ptr;
      break;
    }
    case PrimitiveType_SpaceToBatch: {
      auto ptr = reinterpret_cast<mindspore::schema::SpaceToBatchT *>(value);
      delete ptr;
      break;
    }
    case PrimitiveType_SpaceToBatchND: {
      auto ptr = reinterpret_cast<mindspore::schema::SpaceToBatchNDT *>(value);
      delete ptr;
      break;
    }
    case PrimitiveType_SpaceToDepth: {
      auto ptr = reinterpret_cast<mindspore::schema::SpaceToDepthT *>(value);
      delete ptr;
      break;
    }
    case PrimitiveType_SparseSoftmaxCrossEntropyWithLogits: {
      auto ptr = reinterpret_cast<mindspore::schema::SparseSoftmaxCrossEntropyWithLogitsT *>(value);
      delete ptr;
      break;
    }
    case PrimitiveType_SparseToDense: {
      auto ptr = reinterpret_cast<mindspore::schema::SparseToDenseT *>(value);
      delete ptr;
      break;
    }
    case PrimitiveType_Split: {
      auto ptr = reinterpret_cast<mindspore::schema::SplitT *>(value);
      delete ptr;
      break;
    }
    case PrimitiveType_Sqrt: {
      auto ptr = reinterpret_cast<mindspore::schema::SqrtT *>(value);
      delete ptr;
      break;
    }
    case PrimitiveType_Squeeze: {
      auto ptr = reinterpret_cast<mindspore::schema::SqueezeT *>(value);
      delete ptr;
      break;
    }
    case PrimitiveType_Square: {
      auto ptr = reinterpret_cast<mindspore::schema::SquareT *>(value);
      delete ptr;
      break;
    }
    case PrimitiveType_SquaredDifference: {
      auto ptr = reinterpret_cast<mindspore::schema::SquaredDifferenceT *>(value);
      delete ptr;
      break;
    }
    case PrimitiveType_Stack: {
      auto ptr = reinterpret_cast<mindspore::schema::StackT *>(value);
      delete ptr;
      break;
    }
    case PrimitiveType_StridedSlice: {
      auto ptr = reinterpret_cast<mindspore::schema::StridedSliceT *>(value);
      delete ptr;
      break;
    }
    case PrimitiveType_SubFusion: {
      auto ptr = reinterpret_cast<mindspore::schema::SubFusionT *>(value);
      delete ptr;
      break;
    }
    case PrimitiveType_SubGrad: {
      auto ptr = reinterpret_cast<mindspore::schema::SubGradT *>(value);
      delete ptr;
      break;
    }
    case PrimitiveType_Switch: {
      auto ptr = reinterpret_cast<mindspore::schema::SwitchT *>(value);
      delete ptr;
      break;
    }
    case PrimitiveType_TensorListFromTensor: {
      auto ptr = reinterpret_cast<mindspore::schema::TensorListFromTensorT *>(value);
      delete ptr;
      break;
    }
    case PrimitiveType_TensorListGetItem: {
      auto ptr = reinterpret_cast<mindspore::schema::TensorListGetItemT *>(value);
      delete ptr;
      break;
    }
    case PrimitiveType_TensorListReserve: {
      auto ptr = reinterpret_cast<mindspore::schema::TensorListReserveT *>(value);
      delete ptr;
      break;
    }
    case PrimitiveType_TensorListSetItem: {
      auto ptr = reinterpret_cast<mindspore::schema::TensorListSetItemT *>(value);
      delete ptr;
      break;
    }
    case PrimitiveType_TensorListStack: {
      auto ptr = reinterpret_cast<mindspore::schema::TensorListStackT *>(value);
      delete ptr;
      break;
    }
    case PrimitiveType_TileFusion: {
      auto ptr = reinterpret_cast<mindspore::schema::TileFusionT *>(value);
      delete ptr;
      break;
    }
    case PrimitiveType_TopKFusion: {
      auto ptr = reinterpret_cast<mindspore::schema::TopKFusionT *>(value);
      delete ptr;
      break;
    }
    case PrimitiveType_Transpose: {
      auto ptr = reinterpret_cast<mindspore::schema::TransposeT *>(value);
      delete ptr;
      break;
    }
    case PrimitiveType_Unique: {
      auto ptr = reinterpret_cast<mindspore::schema::UniqueT *>(value);
      delete ptr;
      break;
    }
    case PrimitiveType_UnsortedSegmentSum: {
      auto ptr = reinterpret_cast<mindspore::schema::UnsortedSegmentSumT *>(value);
      delete ptr;
      break;
    }
    case PrimitiveType_Unsqueeze: {
      auto ptr = reinterpret_cast<mindspore::schema::UnsqueezeT *>(value);
      delete ptr;
      break;
    }
    case PrimitiveType_Unstack: {
      auto ptr = reinterpret_cast<mindspore::schema::UnstackT *>(value);
      delete ptr;
      break;
    }
    case PrimitiveType_LSTMGrad: {
      auto ptr = reinterpret_cast<mindspore::schema::LSTMGradT *>(value);
      delete ptr;
      break;
    }
    case PrimitiveType_Where: {
      auto ptr = reinterpret_cast<mindspore::schema::WhereT *>(value);
      delete ptr;
      break;
    }
    case PrimitiveType_ZerosLike: {
      auto ptr = reinterpret_cast<mindspore::schema::ZerosLikeT *>(value);
      delete ptr;
      break;
    }
    case PrimitiveType_Select: {
      auto ptr = reinterpret_cast<mindspore::schema::SelectT *>(value);
      delete ptr;
      break;
    }
    case PrimitiveType_ScatterNdUpdate: {
      auto ptr = reinterpret_cast<mindspore::schema::ScatterNdUpdateT *>(value);
      delete ptr;
      break;
    }
    case PrimitiveType_GRU: {
      auto ptr = reinterpret_cast<mindspore::schema::GRUT *>(value);
      delete ptr;
      break;
    }
    case PrimitiveType_NonZero: {
      auto ptr = reinterpret_cast<mindspore::schema::NonZeroT *>(value);
      delete ptr;
      break;
    }
    case PrimitiveType_InvertPermutation: {
      auto ptr = reinterpret_cast<mindspore::schema::InvertPermutationT *>(value);
      delete ptr;
      break;
    }
    case PrimitiveType_Size: {
      auto ptr = reinterpret_cast<mindspore::schema::SizeT *>(value);
      delete ptr;
      break;
    }
    case PrimitiveType_RandomStandardNormal: {
      auto ptr = reinterpret_cast<mindspore::schema::RandomStandardNormalT *>(value);
      delete ptr;
      break;
    }
    case PrimitiveType_CropAndResize: {
      auto ptr = reinterpret_cast<mindspore::schema::CropAndResizeT *>(value);
      delete ptr;
      break;
    }
    case PrimitiveType_Erf: {
      auto ptr = reinterpret_cast<mindspore::schema::ErfT *>(value);
      delete ptr;
      break;
    }
    case PrimitiveType_StridedSliceGrad: {
      auto ptr = reinterpret_cast<mindspore::schema::StridedSliceGradT *>(value);
      delete ptr;
      break;
    }
    case PrimitiveType_IsFinite: {
      auto ptr = reinterpret_cast<mindspore::schema::IsFiniteT *>(value);
      delete ptr;
      break;
    }
    case PrimitiveType_LinSpace: {
      auto ptr = reinterpret_cast<mindspore::schema::LinSpaceT *>(value);
      delete ptr;
      break;
    }
    case PrimitiveType_UniformReal: {
      auto ptr = reinterpret_cast<mindspore::schema::UniformRealT *>(value);
      delete ptr;
      break;
    }
    case PrimitiveType_AbsGrad: {
      auto ptr = reinterpret_cast<mindspore::schema::AbsGradT *>(value);
      delete ptr;
      break;
    }
    case PrimitiveType_RsqrtGrad: {
      auto ptr = reinterpret_cast<mindspore::schema::RsqrtGradT *>(value);
      delete ptr;
      break;
    }
    case PrimitiveType_SqrtGrad: {
      auto ptr = reinterpret_cast<mindspore::schema::SqrtGradT *>(value);
      delete ptr;
      break;
    }
    case PrimitiveType_LayerNormGrad: {
      auto ptr = reinterpret_cast<mindspore::schema::LayerNormGradT *>(value);
      delete ptr;
      break;
    }
    case PrimitiveType_ResizeGrad: {
      auto ptr = reinterpret_cast<mindspore::schema::ResizeGradT *>(value);
      delete ptr;
      break;
    }
    case PrimitiveType_Splice: {
      auto ptr = reinterpret_cast<mindspore::schema::SpliceT *>(value);
      delete ptr;
      break;
    }
    case PrimitiveType_LogSoftmax: {
      auto ptr = reinterpret_cast<mindspore::schema::LogSoftmaxT *>(value);
      delete ptr;
      break;
    }
    case PrimitiveType_Call: {
      auto ptr = reinterpret_cast<mindspore::schema::CallT *>(value);
      delete ptr;
      break;
    }
    case PrimitiveType_Custom: {
      auto ptr = reinterpret_cast<mindspore::schema::CustomT *>(value);
      delete ptr;
      break;
    }
    case PrimitiveType_CumSum: {
      auto ptr = reinterpret_cast<mindspore::schema::CumSumT *>(value);
      delete ptr;
      break;
    }
    case PrimitiveType_SplitWithOverlap: {
      auto ptr = reinterpret_cast<mindspore::schema::SplitWithOverlapT *>(value);
      delete ptr;
      break;
    }
    case PrimitiveType_GenOP: {
      auto ptr = reinterpret_cast<mindspore::schema::GenOPT *>(value);
      delete ptr;
      break;
    }
    case PrimitiveType_RaggedRange: {
      auto ptr = reinterpret_cast<mindspore::schema::RaggedRangeT *>(value);
      delete ptr;
      break;
    }
    case PrimitiveType_GLU: {
      auto ptr = reinterpret_cast<mindspore::schema::GLUT *>(value);
      delete ptr;
      break;
    }
    case PrimitiveType_TensorArray: {
      auto ptr = reinterpret_cast<mindspore::schema::TensorArrayT *>(value);
      delete ptr;
      break;
    }
    case PrimitiveType_TensorArrayRead: {
      auto ptr = reinterpret_cast<mindspore::schema::TensorArrayReadT *>(value);
      delete ptr;
      break;
    }
    case PrimitiveType_TensorArrayWrite: {
      auto ptr = reinterpret_cast<mindspore::schema::TensorArrayWriteT *>(value);
      delete ptr;
      break;
    }
    case PrimitiveType_Affine: {
      auto ptr = reinterpret_cast<mindspore::schema::AffineT *>(value);
      delete ptr;
      break;
    }
    default: break;
  }
  value = nullptr;
  type = PrimitiveType_NONE;
}

inline const flatbuffers::TypeTable *PrimitiveTypeTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_SEQUENCE, 0, -1 },
    { flatbuffers::ET_SEQUENCE, 0, 0 },
    { flatbuffers::ET_SEQUENCE, 0, 1 },
    { flatbuffers::ET_SEQUENCE, 0, 2 },
    { flatbuffers::ET_SEQUENCE, 0, 3 },
    { flatbuffers::ET_SEQUENCE, 0, 4 },
    { flatbuffers::ET_SEQUENCE, 0, 5 },
    { flatbuffers::ET_SEQUENCE, 0, 6 },
    { flatbuffers::ET_SEQUENCE, 0, 7 },
    { flatbuffers::ET_SEQUENCE, 0, 8 },
    { flatbuffers::ET_SEQUENCE, 0, 9 },
    { flatbuffers::ET_SEQUENCE, 0, 10 },
    { flatbuffers::ET_SEQUENCE, 0, 11 },
    { flatbuffers::ET_SEQUENCE, 0, 12 },
    { flatbuffers::ET_SEQUENCE, 0, 13 },
    { flatbuffers::ET_SEQUENCE, 0, 14 },
    { flatbuffers::ET_SEQUENCE, 0, 15 },
    { flatbuffers::ET_SEQUENCE, 0, 16 },
    { flatbuffers::ET_SEQUENCE, 0, 17 },
    { flatbuffers::ET_SEQUENCE, 0, 18 },
    { flatbuffers::ET_SEQUENCE, 0, 19 },
    { flatbuffers::ET_SEQUENCE, 0, 20 },
    { flatbuffers::ET_SEQUENCE, 0, 21 },
    { flatbuffers::ET_SEQUENCE, 0, 22 },
    { flatbuffers::ET_SEQUENCE, 0, 23 },
    { flatbuffers::ET_SEQUENCE, 0, 24 },
    { flatbuffers::ET_SEQUENCE, 0, 25 },
    { flatbuffers::ET_SEQUENCE, 0, 26 },
    { flatbuffers::ET_SEQUENCE, 0, 27 },
    { flatbuffers::ET_SEQUENCE, 0, 28 },
    { flatbuffers::ET_SEQUENCE, 0, 29 },
    { flatbuffers::ET_SEQUENCE, 0, 30 },
    { flatbuffers::ET_SEQUENCE, 0, 31 },
    { flatbuffers::ET_SEQUENCE, 0, 32 },
    { flatbuffers::ET_SEQUENCE, 0, 33 },
    { flatbuffers::ET_SEQUENCE, 0, 34 },
    { flatbuffers::ET_SEQUENCE, 0, 35 },
    { flatbuffers::ET_SEQUENCE, 0, 36 },
    { flatbuffers::ET_SEQUENCE, 0, 37 },
    { flatbuffers::ET_SEQUENCE, 0, 38 },
    { flatbuffers::ET_SEQUENCE, 0, 39 },
    { flatbuffers::ET_SEQUENCE, 0, 40 },
    { flatbuffers::ET_SEQUENCE, 0, 41 },
    { flatbuffers::ET_SEQUENCE, 0, 42 },
    { flatbuffers::ET_SEQUENCE, 0, 43 },
    { flatbuffers::ET_SEQUENCE, 0, 44 },
    { flatbuffers::ET_SEQUENCE, 0, 45 },
    { flatbuffers::ET_SEQUENCE, 0, 46 },
    { flatbuffers::ET_SEQUENCE, 0, 47 },
    { flatbuffers::ET_SEQUENCE, 0, 48 },
    { flatbuffers::ET_SEQUENCE, 0, 49 },
    { flatbuffers::ET_SEQUENCE, 0, 50 },
    { flatbuffers::ET_SEQUENCE, 0, 51 },
    { flatbuffers::ET_SEQUENCE, 0, 52 },
    { flatbuffers::ET_SEQUENCE, 0, 53 },
    { flatbuffers::ET_SEQUENCE, 0, 54 },
    { flatbuffers::ET_SEQUENCE, 0, 55 },
    { flatbuffers::ET_SEQUENCE, 0, 56 },
    { flatbuffers::ET_SEQUENCE, 0, 57 },
    { flatbuffers::ET_SEQUENCE, 0, 58 },
    { flatbuffers::ET_SEQUENCE, 0, 59 },
    { flatbuffers::ET_SEQUENCE, 0, 60 },
    { flatbuffers::ET_SEQUENCE, 0, 61 },
    { flatbuffers::ET_SEQUENCE, 0, 62 },
    { flatbuffers::ET_SEQUENCE, 0, 63 },
    { flatbuffers::ET_SEQUENCE, 0, 64 },
    { flatbuffers::ET_SEQUENCE, 0, 65 },
    { flatbuffers::ET_SEQUENCE, 0, 66 },
    { flatbuffers::ET_SEQUENCE, 0, 67 },
    { flatbuffers::ET_SEQUENCE, 0, 68 },
    { flatbuffers::ET_SEQUENCE, 0, 69 },
    { flatbuffers::ET_SEQUENCE, 0, 70 },
    { flatbuffers::ET_SEQUENCE, 0, 71 },
    { flatbuffers::ET_SEQUENCE, 0, 72 },
    { flatbuffers::ET_SEQUENCE, 0, 73 },
    { flatbuffers::ET_SEQUENCE, 0, 74 },
    { flatbuffers::ET_SEQUENCE, 0, 75 },
    { flatbuffers::ET_SEQUENCE, 0, 76 },
    { flatbuffers::ET_SEQUENCE, 0, 77 },
    { flatbuffers::ET_SEQUENCE, 0, 78 },
    { flatbuffers::ET_SEQUENCE, 0, 79 },
    { flatbuffers::ET_SEQUENCE, 0, 80 },
    { flatbuffers::ET_SEQUENCE, 0, 81 },
    { flatbuffers::ET_SEQUENCE, 0, 82 },
    { flatbuffers::ET_SEQUENCE, 0, 83 },
    { flatbuffers::ET_SEQUENCE, 0, 84 },
    { flatbuffers::ET_SEQUENCE, 0, 85 },
    { flatbuffers::ET_SEQUENCE, 0, 86 },
    { flatbuffers::ET_SEQUENCE, 0, 87 },
    { flatbuffers::ET_SEQUENCE, 0, 88 },
    { flatbuffers::ET_SEQUENCE, 0, 89 },
    { flatbuffers::ET_SEQUENCE, 0, 90 },
    { flatbuffers::ET_SEQUENCE, 0, 91 },
    { flatbuffers::ET_SEQUENCE, 0, 92 },
    { flatbuffers::ET_SEQUENCE, 0, 93 },
    { flatbuffers::ET_SEQUENCE, 0, 94 },
    { flatbuffers::ET_SEQUENCE, 0, 95 },
    { flatbuffers::ET_SEQUENCE, 0, 96 },
    { flatbuffers::ET_SEQUENCE, 0, 97 },
    { flatbuffers::ET_SEQUENCE, 0, 98 },
    { flatbuffers::ET_SEQUENCE, 0, 99 },
    { flatbuffers::ET_SEQUENCE, 0, 100 },
    { flatbuffers::ET_SEQUENCE, 0, 101 },
    { flatbuffers::ET_SEQUENCE, 0, 102 },
    { flatbuffers::ET_SEQUENCE, 0, 103 },
    { flatbuffers::ET_SEQUENCE, 0, 104 },
    { flatbuffers::ET_SEQUENCE, 0, 105 },
    { flatbuffers::ET_SEQUENCE, 0, 106 },
    { flatbuffers::ET_SEQUENCE, 0, 107 },
    { flatbuffers::ET_SEQUENCE, 0, 108 },
    { flatbuffers::ET_SEQUENCE, 0, 109 },
    { flatbuffers::ET_SEQUENCE, 0, 110 },
    { flatbuffers::ET_SEQUENCE, 0, 111 },
    { flatbuffers::ET_SEQUENCE, 0, 112 },
    { flatbuffers::ET_SEQUENCE, 0, 113 },
    { flatbuffers::ET_SEQUENCE, 0, 114 },
    { flatbuffers::ET_SEQUENCE, 0, 115 },
    { flatbuffers::ET_SEQUENCE, 0, 116 },
    { flatbuffers::ET_SEQUENCE, 0, 117 },
    { flatbuffers::ET_SEQUENCE, 0, 118 },
    { flatbuffers::ET_SEQUENCE, 0, 119 },
    { flatbuffers::ET_SEQUENCE, 0, 120 },
    { flatbuffers::ET_SEQUENCE, 0, 121 },
    { flatbuffers::ET_SEQUENCE, 0, 122 },
    { flatbuffers::ET_SEQUENCE, 0, 123 },
    { flatbuffers::ET_SEQUENCE, 0, 124 },
    { flatbuffers::ET_SEQUENCE, 0, 125 },
    { flatbuffers::ET_SEQUENCE, 0, 126 },
    { flatbuffers::ET_SEQUENCE, 0, 127 },
    { flatbuffers::ET_SEQUENCE, 0, 128 },
    { flatbuffers::ET_SEQUENCE, 0, 129 },
    { flatbuffers::ET_SEQUENCE, 0, 130 },
    { flatbuffers::ET_SEQUENCE, 0, 131 },
    { flatbuffers::ET_SEQUENCE, 0, 132 },
    { flatbuffers::ET_SEQUENCE, 0, 133 },
    { flatbuffers::ET_SEQUENCE, 0, 134 },
    { flatbuffers::ET_SEQUENCE, 0, 135 },
    { flatbuffers::ET_SEQUENCE, 0, 136 },
    { flatbuffers::ET_SEQUENCE, 0, 137 },
    { flatbuffers::ET_SEQUENCE, 0, 138 },
    { flatbuffers::ET_SEQUENCE, 0, 139 },
    { flatbuffers::ET_SEQUENCE, 0, 140 },
    { flatbuffers::ET_SEQUENCE, 0, 141 },
    { flatbuffers::ET_SEQUENCE, 0, 142 },
    { flatbuffers::ET_SEQUENCE, 0, 143 },
    { flatbuffers::ET_SEQUENCE, 0, 144 },
    { flatbuffers::ET_SEQUENCE, 0, 145 },
    { flatbuffers::ET_SEQUENCE, 0, 146 },
    { flatbuffers::ET_SEQUENCE, 0, 147 },
    { flatbuffers::ET_SEQUENCE, 0, 148 },
    { flatbuffers::ET_SEQUENCE, 0, 149 },
    { flatbuffers::ET_SEQUENCE, 0, 150 },
    { flatbuffers::ET_SEQUENCE, 0, 151 },
    { flatbuffers::ET_SEQUENCE, 0, 152 },
    { flatbuffers::ET_SEQUENCE, 0, 153 },
    { flatbuffers::ET_SEQUENCE, 0, 154 },
    { flatbuffers::ET_SEQUENCE, 0, 155 },
    { flatbuffers::ET_SEQUENCE, 0, 156 },
    { flatbuffers::ET_SEQUENCE, 0, 157 },
    { flatbuffers::ET_SEQUENCE, 0, 158 },
    { flatbuffers::ET_SEQUENCE, 0, 159 },
    { flatbuffers::ET_SEQUENCE, 0, 160 },
    { flatbuffers::ET_SEQUENCE, 0, 161 },
    { flatbuffers::ET_SEQUENCE, 0, 162 },
    { flatbuffers::ET_SEQUENCE, 0, 163 },
    { flatbuffers::ET_SEQUENCE, 0, 164 },
    { flatbuffers::ET_SEQUENCE, 0, 165 },
    { flatbuffers::ET_SEQUENCE, 0, 166 },
    { flatbuffers::ET_SEQUENCE, 0, 167 },
    { flatbuffers::ET_SEQUENCE, 0, 168 },
    { flatbuffers::ET_SEQUENCE, 0, 169 },
    { flatbuffers::ET_SEQUENCE, 0, 170 },
    { flatbuffers::ET_SEQUENCE, 0, 171 },
    { flatbuffers::ET_SEQUENCE, 0, 172 },
    { flatbuffers::ET_SEQUENCE, 0, 173 },
    { flatbuffers::ET_SEQUENCE, 0, 174 },
    { flatbuffers::ET_SEQUENCE, 0, 175 },
    { flatbuffers::ET_SEQUENCE, 0, 176 },
    { flatbuffers::ET_SEQUENCE, 0, 177 },
    { flatbuffers::ET_SEQUENCE, 0, 178 },
    { flatbuffers::ET_SEQUENCE, 0, 179 },
    { flatbuffers::ET_SEQUENCE, 0, 180 },
    { flatbuffers::ET_SEQUENCE, 0, 181 },
    { flatbuffers::ET_SEQUENCE, 0, 182 },
    { flatbuffers::ET_SEQUENCE, 0, 183 },
    { flatbuffers::ET_SEQUENCE, 0, 184 },
    { flatbuffers::ET_SEQUENCE, 0, 185 },
    { flatbuffers::ET_SEQUENCE, 0, 186 },
    { flatbuffers::ET_SEQUENCE, 0, 187 },
    { flatbuffers::ET_SEQUENCE, 0, 188 },
    { flatbuffers::ET_SEQUENCE, 0, 189 },
    { flatbuffers::ET_SEQUENCE, 0, 190 },
    { flatbuffers::ET_SEQUENCE, 0, 191 },
    { flatbuffers::ET_SEQUENCE, 0, 192 },
    { flatbuffers::ET_SEQUENCE, 0, 193 },
    { flatbuffers::ET_SEQUENCE, 0, 194 },
    { flatbuffers::ET_SEQUENCE, 0, 195 },
    { flatbuffers::ET_SEQUENCE, 0, 196 },
    { flatbuffers::ET_SEQUENCE, 0, 197 },
    { flatbuffers::ET_SEQUENCE, 0, 198 },
    { flatbuffers::ET_SEQUENCE, 0, 199 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    mindspore::schema::AbsTypeTable,
    mindspore::schema::ActivationTypeTable,
    mindspore::schema::ActivationGradTypeTable,
    mindspore::schema::AdamTypeTable,
    mindspore::schema::AddFusionTypeTable,
    mindspore::schema::AdderFusionTypeTable,
    mindspore::schema::AddGradTypeTable,
    mindspore::schema::AddNTypeTable,
    mindspore::schema::AllTypeTable,
    mindspore::schema::ApplyMomentumTypeTable,
    mindspore::schema::ArgMaxFusionTypeTable,
    mindspore::schema::ArgMinFusionTypeTable,
    mindspore::schema::AssertTypeTable,
    mindspore::schema::AssignTypeTable,
    mindspore::schema::AssignAddTypeTable,
    mindspore::schema::AudioSpectrogramTypeTable,
    mindspore::schema::AvgPoolFusionTypeTable,
    mindspore::schema::AvgPoolGradTypeTable,
    mindspore::schema::BatchNormTypeTable,
    mindspore::schema::BatchNormGradTypeTable,
    mindspore::schema::BatchToSpaceTypeTable,
    mindspore::schema::BatchToSpaceNDTypeTable,
    mindspore::schema::BiasAddTypeTable,
    mindspore::schema::BinaryCrossEntropyTypeTable,
    mindspore::schema::BinaryCrossEntropyGradTypeTable,
    mindspore::schema::BiasAddGradTypeTable,
    mindspore::schema::BroadcastToTypeTable,
    mindspore::schema::CastTypeTable,
    mindspore::schema::CeilTypeTable,
    mindspore::schema::ClipTypeTable,
    mindspore::schema::ConcatTypeTable,
    mindspore::schema::AttentionTypeTable,
    mindspore::schema::Conv2DBackpropFilterFusionTypeTable,
    mindspore::schema::Conv2DBackpropInputFusionTypeTable,
    mindspore::schema::Conv2DFusionTypeTable,
    mindspore::schema::Conv2dTransposeFusionTypeTable,
    mindspore::schema::CosTypeTable,
    mindspore::schema::ConstantOfShapeTypeTable,
    mindspore::schema::CropTypeTable,
    mindspore::schema::CustomExtractFeaturesTypeTable,
    mindspore::schema::CustomNormalizeTypeTable,
    mindspore::schema::CustomPredictTypeTable,
    mindspore::schema::DeConv2DGradFilterTypeTable,
    mindspore::schema::DependTypeTable,
    mindspore::schema::DepthToSpaceTypeTable,
    mindspore::schema::DetectionPostProcessTypeTable,
    mindspore::schema::DivFusionTypeTable,
    mindspore::schema::DivGradTypeTable,
    mindspore::schema::DropoutTypeTable,
    mindspore::schema::DropoutGradTypeTable,
    mindspore::schema::EluTypeTable,
    mindspore::schema::EltwiseTypeTable,
    mindspore::schema::EqualTypeTable,
    mindspore::schema::EmbeddingLookupFusionTypeTable,
    mindspore::schema::ExpFusionTypeTable,
    mindspore::schema::ExpandDimsTypeTable,
    mindspore::schema::FakeQuantWithMinMaxVarsTypeTable,
    mindspore::schema::FakeQuantWithMinMaxVarsPerChannelTypeTable,
    mindspore::schema::FftRealTypeTable,
    mindspore::schema::FftImagTypeTable,
    mindspore::schema::FlattenTypeTable,
    mindspore::schema::FlattenGradTypeTable,
    mindspore::schema::FloorTypeTable,
    mindspore::schema::FloorDivTypeTable,
    mindspore::schema::FloorModTypeTable,
    mindspore::schema::FillTypeTable,
    mindspore::schema::FullConnectionTypeTable,
    mindspore::schema::FusedBatchNormTypeTable,
    mindspore::schema::GatherTypeTable,
    mindspore::schema::GatherNdTypeTable,
    mindspore::schema::GreaterTypeTable,
    mindspore::schema::GreaterEqualTypeTable,
    mindspore::schema::HashtableLookupTypeTable,
    mindspore::schema::InstanceNormTypeTable,
    mindspore::schema::LayerNormFusionTypeTable,
    mindspore::schema::LeakyReluTypeTable,
    mindspore::schema::LessTypeTable,
    mindspore::schema::LessEqualTypeTable,
    mindspore::schema::LogTypeTable,
    mindspore::schema::LogGradTypeTable,
    mindspore::schema::LogicalAndTypeTable,
    mindspore::schema::LogicalNotTypeTable,
    mindspore::schema::LogicalOrTypeTable,
    mindspore::schema::LpNormalizationTypeTable,
    mindspore::schema::LRNTypeTable,
    mindspore::schema::LshProjectionTypeTable,
    mindspore::schema::LSTMTypeTable,
    mindspore::schema::L2NormalizeFusionTypeTable,
    mindspore::schema::MatMulFusionTypeTable,
    mindspore::schema::MaximumTypeTable,
    mindspore::schema::MaximumGradTypeTable,
    mindspore::schema::MaxPoolFusionTypeTable,
    mindspore::schema::MaxPoolGradTypeTable,
    mindspore::schema::MergeTypeTable,
    mindspore::schema::MfccTypeTable,
    mindspore::schema::MinimumTypeTable,
    mindspore::schema::MinimumGradTypeTable,
    mindspore::schema::ModTypeTable,
    mindspore::schema::MulFusionTypeTable,
    mindspore::schema::MulGradTypeTable,
    mindspore::schema::NegTypeTable,
    mindspore::schema::NegGradTypeTable,
    mindspore::schema::NotEqualTypeTable,
    mindspore::schema::NonMaxSuppressionTypeTable,
    mindspore::schema::OneHotTypeTable,
    mindspore::schema::OnesLikeTypeTable,
    mindspore::schema::PadFusionTypeTable,
    mindspore::schema::PartialFusionTypeTable,
    mindspore::schema::PowerGradTypeTable,
    mindspore::schema::PowFusionTypeTable,
    mindspore::schema::PriorBoxTypeTable,
    mindspore::schema::PReLUFusionTypeTable,
    mindspore::schema::QuantDTypeCastTypeTable,
    mindspore::schema::RankTypeTable,
    mindspore::schema::RangeTypeTable,
    mindspore::schema::ReciprocalTypeTable,
    mindspore::schema::RealDivTypeTable,
    mindspore::schema::ReduceFusionTypeTable,
    mindspore::schema::ReshapeTypeTable,
    mindspore::schema::ResizeTypeTable,
    mindspore::schema::ReverseSequenceTypeTable,
    mindspore::schema::ReverseV2TypeTable,
    mindspore::schema::RfftTypeTable,
    mindspore::schema::ROIPoolingTypeTable,
    mindspore::schema::RoundTypeTable,
    mindspore::schema::RsqrtTypeTable,
    mindspore::schema::ScaleFusionTypeTable,
    mindspore::schema::ScatterNdTypeTable,
    mindspore::schema::SGDTypeTable,
    mindspore::schema::ShapeTypeTable,
    mindspore::schema::SigmoidCrossEntropyWithLogitsTypeTable,
    mindspore::schema::SigmoidCrossEntropyWithLogitsGradTypeTable,
    mindspore::schema::SinTypeTable,
    mindspore::schema::SkipGramTypeTable,
    mindspore::schema::SliceFusionTypeTable,
    mindspore::schema::SmoothL1LossTypeTable,
    mindspore::schema::SmoothL1LossGradTypeTable,
    mindspore::schema::SoftmaxTypeTable,
    mindspore::schema::SoftmaxCrossEntropyWithLogitsTypeTable,
    mindspore::schema::SpaceToBatchTypeTable,
    mindspore::schema::SpaceToBatchNDTypeTable,
    mindspore::schema::SpaceToDepthTypeTable,
    mindspore::schema::SparseSoftmaxCrossEntropyWithLogitsTypeTable,
    mindspore::schema::SparseToDenseTypeTable,
    mindspore::schema::SplitTypeTable,
    mindspore::schema::SqrtTypeTable,
    mindspore::schema::SqueezeTypeTable,
    mindspore::schema::SquareTypeTable,
    mindspore::schema::SquaredDifferenceTypeTable,
    mindspore::schema::StackTypeTable,
    mindspore::schema::StridedSliceTypeTable,
    mindspore::schema::SubFusionTypeTable,
    mindspore::schema::SubGradTypeTable,
    mindspore::schema::SwitchTypeTable,
    mindspore::schema::TensorListFromTensorTypeTable,
    mindspore::schema::TensorListGetItemTypeTable,
    mindspore::schema::TensorListReserveTypeTable,
    mindspore::schema::TensorListSetItemTypeTable,
    mindspore::schema::TensorListStackTypeTable,
    mindspore::schema::TileFusionTypeTable,
    mindspore::schema::TopKFusionTypeTable,
    mindspore::schema::TransposeTypeTable,
    mindspore::schema::UniqueTypeTable,
    mindspore::schema::UnsortedSegmentSumTypeTable,
    mindspore::schema::UnsqueezeTypeTable,
    mindspore::schema::UnstackTypeTable,
    mindspore::schema::LSTMGradTypeTable,
    mindspore::schema::WhereTypeTable,
    mindspore::schema::ZerosLikeTypeTable,
    mindspore::schema::SelectTypeTable,
    mindspore::schema::ScatterNdUpdateTypeTable,
    mindspore::schema::GRUTypeTable,
    mindspore::schema::NonZeroTypeTable,
    mindspore::schema::InvertPermutationTypeTable,
    mindspore::schema::SizeTypeTable,
    mindspore::schema::RandomStandardNormalTypeTable,
    mindspore::schema::CropAndResizeTypeTable,
    mindspore::schema::ErfTypeTable,
    mindspore::schema::StridedSliceGradTypeTable,
    mindspore::schema::IsFiniteTypeTable,
    mindspore::schema::LinSpaceTypeTable,
    mindspore::schema::UniformRealTypeTable,
    mindspore::schema::AbsGradTypeTable,
    mindspore::schema::RsqrtGradTypeTable,
    mindspore::schema::SqrtGradTypeTable,
    mindspore::schema::LayerNormGradTypeTable,
    mindspore::schema::ResizeGradTypeTable,
    mindspore::schema::SpliceTypeTable,
    mindspore::schema::LogSoftmaxTypeTable,
    mindspore::schema::CallTypeTable,
    mindspore::schema::CustomTypeTable,
    mindspore::schema::CumSumTypeTable,
    mindspore::schema::SplitWithOverlapTypeTable,
    mindspore::schema::GenOPTypeTable,
    mindspore::schema::RaggedRangeTypeTable,
    mindspore::schema::GLUTypeTable,
    mindspore::schema::TensorArrayTypeTable,
    mindspore::schema::TensorArrayReadTypeTable,
    mindspore::schema::TensorArrayWriteTypeTable,
    mindspore::schema::AffineTypeTable
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_UNION, 201, type_codes, type_refs, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *AbsTypeTable() {
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *ActivationTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_FLOAT, 0, -1 },
    { flatbuffers::ET_FLOAT, 0, -1 },
    { flatbuffers::ET_FLOAT, 0, -1 },
    { flatbuffers::ET_BOOL, 0, -1 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    mindspore::schema::ActivationTypeTypeTable
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 5, type_codes, type_refs, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *ActivationGradTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_FLOAT, 0, -1 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    mindspore::schema::ActivationTypeTypeTable
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 2, type_codes, type_refs, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *AdamTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_BOOL, 0, -1 },
    { flatbuffers::ET_BOOL, 0, -1 }
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 2, type_codes, nullptr, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *AddFusionTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_CHAR, 0, 0 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    mindspore::schema::ActivationTypeTypeTable
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 1, type_codes, type_refs, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *AdderFusionTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_LONG, 1, -1 },
    { flatbuffers::ET_LONG, 1, -1 },
    { flatbuffers::ET_LONG, 1, -1 },
    { flatbuffers::ET_CHAR, 0, 1 },
    { flatbuffers::ET_LONG, 1, -1 },
    { flatbuffers::ET_LONG, 0, -1 },
    { flatbuffers::ET_LONG, 0, -1 },
    { flatbuffers::ET_LONG, 0, -1 },
    { flatbuffers::ET_CHAR, 0, 2 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    mindspore::schema::FormatTypeTable,
    mindspore::schema::PadModeTypeTable,
    mindspore::schema::ActivationTypeTypeTable
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 10, type_codes, type_refs, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *AddGradTypeTable() {
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *AddNTypeTable() {
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *AllTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_LONG, 0, -1 }
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 1, type_codes, nullptr, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *ApplyMomentumTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_BOOL, 0, -1 },
    { flatbuffers::ET_BOOL, 0, -1 },
    { flatbuffers::ET_FLOAT, 0, -1 }
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 3, type_codes, nullptr, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *ArgMaxFusionTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_LONG, 0, -1 },
    { flatbuffers::ET_LONG, 0, -1 },
    { flatbuffers::ET_BOOL, 0, -1 },
    { flatbuffers::ET_BOOL, 0, -1 }
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 4, type_codes, nullptr, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *ArgMinFusionTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_LONG, 0, -1 },
    { flatbuffers::ET_LONG, 0, -1 },
    { flatbuffers::ET_BOOL, 0, -1 },
    { flatbuffers::ET_BOOL, 0, -1 }
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 4, type_codes, nullptr, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *AssertTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_LONG, 0, -1 }
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 1, type_codes, nullptr, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *AssignTypeTable() {
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *AssignAddTypeTable() {
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *AudioSpectrogramTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_LONG, 0, -1 },
    { flatbuffers::ET_LONG, 0, -1 },
    { flatbuffers::ET_BOOL, 0, -1 }
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 3, type_codes, nullptr, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *AvgPoolFusionTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_LONG, 1, -1 },
    { flatbuffers::ET_LONG, 1, -1 },
    { flatbuffers::ET_LONG, 1, -1 },
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 1 },
    { flatbuffers::ET_INT, 0, 2 },
    { flatbuffers::ET_BOOL, 0, -1 },
    { flatbuffers::ET_CHAR, 0, 3 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    mindspore::schema::PadModeTypeTable,
    mindspore::schema::RoundModeTypeTable,
    mindspore::schema::FormatTypeTable,
    mindspore::schema::ActivationTypeTypeTable
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 8, type_codes, type_refs, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *AvgPoolGradTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_LONG, 1, -1 },
    { flatbuffers::ET_LONG, 1, -1 },
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_INT, 0, 1 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    mindspore::schema::PadModeTypeTable,
    mindspore::schema::FormatTypeTable
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 4, type_codes, type_refs, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *BatchNormTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_FLOAT, 0, -1 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_BOOL, 0, -1 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    mindspore::schema::FormatTypeTable
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 3, type_codes, type_refs, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *BatchNormGradTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_FLOAT, 0, -1 }
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 1, type_codes, nullptr, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *BatchToSpaceTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_LONG, 1, -1 },
    { flatbuffers::ET_SEQUENCE, 0, 0 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    mindspore::schema::Vec2DTypeTable
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 2, type_codes, type_refs, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *BatchToSpaceNDTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_LONG, 1, -1 },
    { flatbuffers::ET_SEQUENCE, 0, 0 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    mindspore::schema::Vec2DTypeTable
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 2, type_codes, type_refs, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *BiasAddTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_INT, 0, 0 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    mindspore::schema::FormatTypeTable
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 1, type_codes, type_refs, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *BinaryCrossEntropyTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_CHAR, 0, 0 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    mindspore::schema::ReductionTypeTable
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 1, type_codes, type_refs, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *BinaryCrossEntropyGradTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_CHAR, 0, 0 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    mindspore::schema::ReductionTypeTable
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 1, type_codes, type_refs, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *BiasAddGradTypeTable() {
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *BroadcastToTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_LONG, 1, -1 }
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 1, type_codes, nullptr, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *CastTypeTable() {
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *CeilTypeTable() {
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *ClipTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_FLOAT, 0, -1 },
    { flatbuffers::ET_FLOAT, 0, -1 }
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 2, type_codes, nullptr, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *ConcatTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_LONG, 0, -1 }
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 1, type_codes, nullptr, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *AttentionTypeTable() {
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *Conv2DBackpropFilterFusionTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_LONG, 1, -1 },
    { flatbuffers::ET_LONG, 1, -1 },
    { flatbuffers::ET_LONG, 1, -1 },
    { flatbuffers::ET_CHAR, 0, 1 },
    { flatbuffers::ET_LONG, 1, -1 },
    { flatbuffers::ET_LONG, 0, -1 },
    { flatbuffers::ET_LONG, 0, -1 },
    { flatbuffers::ET_LONG, 0, -1 },
    { flatbuffers::ET_LONG, 0, -1 },
    { flatbuffers::ET_CHAR, 0, 2 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    mindspore::schema::FormatTypeTable,
    mindspore::schema::PadModeTypeTable,
    mindspore::schema::ActivationTypeTypeTable
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 11, type_codes, type_refs, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *Conv2DBackpropInputFusionTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_LONG, 1, -1 },
    { flatbuffers::ET_LONG, 1, -1 },
    { flatbuffers::ET_LONG, 1, -1 },
    { flatbuffers::ET_CHAR, 0, 1 },
    { flatbuffers::ET_LONG, 1, -1 },
    { flatbuffers::ET_LONG, 1, -1 },
    { flatbuffers::ET_LONG, 0, -1 },
    { flatbuffers::ET_LONG, 0, -1 },
    { flatbuffers::ET_LONG, 0, -1 },
    { flatbuffers::ET_LONG, 0, -1 },
    { flatbuffers::ET_CHAR, 0, 2 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    mindspore::schema::FormatTypeTable,
    mindspore::schema::PadModeTypeTable,
    mindspore::schema::ActivationTypeTypeTable
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 12, type_codes, type_refs, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *Conv2DFusionTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_LONG, 1, -1 },
    { flatbuffers::ET_LONG, 1, -1 },
    { flatbuffers::ET_LONG, 1, -1 },
    { flatbuffers::ET_CHAR, 0, 1 },
    { flatbuffers::ET_LONG, 1, -1 },
    { flatbuffers::ET_LONG, 0, -1 },
    { flatbuffers::ET_LONG, 0, -1 },
    { flatbuffers::ET_LONG, 0, -1 },
    { flatbuffers::ET_LONG, 0, -1 },
    { flatbuffers::ET_CHAR, 0, 2 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    mindspore::schema::FormatTypeTable,
    mindspore::schema::PadModeTypeTable,
    mindspore::schema::ActivationTypeTypeTable
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 11, type_codes, type_refs, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *Conv2dTransposeFusionTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_LONG, 1, -1 },
    { flatbuffers::ET_LONG, 1, -1 },
    { flatbuffers::ET_LONG, 1, -1 },
    { flatbuffers::ET_CHAR, 0, 1 },
    { flatbuffers::ET_LONG, 1, -1 },
    { flatbuffers::ET_LONG, 1, -1 },
    { flatbuffers::ET_LONG, 0, -1 },
    { flatbuffers::ET_LONG, 0, -1 },
    { flatbuffers::ET_LONG, 0, -1 },
    { flatbuffers::ET_LONG, 0, -1 },
    { flatbuffers::ET_CHAR, 0, 2 },
    { flatbuffers::ET_LONG, 1, -1 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    mindspore::schema::FormatTypeTable,
    mindspore::schema::PadModeTypeTable,
    mindspore::schema::ActivationTypeTypeTable
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 13, type_codes, type_refs, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *CosTypeTable() {
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *ConstantOfShapeTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_LONG, 0, -1 },
    { flatbuffers::ET_FLOAT, 1, -1 }
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 2, type_codes, nullptr, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *CropTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_LONG, 0, -1 },
    { flatbuffers::ET_LONG, 1, -1 }
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 2, type_codes, nullptr, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *CustomExtractFeaturesTypeTable() {
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *CustomNormalizeTypeTable() {
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *CustomPredictTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_LONG, 0, -1 },
    { flatbuffers::ET_FLOAT, 0, -1 }
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 2, type_codes, nullptr, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *DeConv2DGradFilterTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_LONG, 0, -1 },
    { flatbuffers::ET_LONG, 0, -1 },
    { flatbuffers::ET_LONG, 1, -1 },
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_LONG, 1, -1 },
    { flatbuffers::ET_LONG, 1, -1 },
    { flatbuffers::ET_LONG, 1, -1 },
    { flatbuffers::ET_LONG, 0, -1 },
    { flatbuffers::ET_INT, 0, 1 },
    { flatbuffers::ET_CHAR, 0, 2 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    mindspore::schema::PadModeTypeTable,
    mindspore::schema::FormatTypeTable,
    mindspore::schema::ActivationTypeTypeTable
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 10, type_codes, type_refs, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *DependTypeTable() {
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *DepthToSpaceTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_LONG, 0, -1 },
    { flatbuffers::ET_INT, 0, 0 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    mindspore::schema::FormatTypeTable
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 2, type_codes, type_refs, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *DetectionPostProcessTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_LONG, 0, -1 },
    { flatbuffers::ET_FLOAT, 1, -1 },
    { flatbuffers::ET_FLOAT, 0, -1 },
    { flatbuffers::ET_FLOAT, 0, -1 },
    { flatbuffers::ET_LONG, 0, -1 },
    { flatbuffers::ET_LONG, 0, -1 },
    { flatbuffers::ET_LONG, 0, -1 },
    { flatbuffers::ET_LONG, 0, -1 },
    { flatbuffers::ET_BOOL, 0, -1 },
    { flatbuffers::ET_BOOL, 0, -1 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    mindspore::schema::FormatTypeTable
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 11, type_codes, type_refs, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *DivFusionTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_CHAR, 0, 0 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    mindspore::schema::ActivationTypeTypeTable
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 1, type_codes, type_refs, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *DivGradTypeTable() {
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *DropoutTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_FLOAT, 0, -1 }
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 1, type_codes, nullptr, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *DropoutGradTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_FLOAT, 0, -1 }
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 1, type_codes, nullptr, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *EluTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_FLOAT, 0, -1 }
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 1, type_codes, nullptr, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *EltwiseTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_CHAR, 0, 0 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    mindspore::schema::EltwiseModeTypeTable
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 1, type_codes, type_refs, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *EqualTypeTable() {
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *EmbeddingLookupFusionTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_FLOAT, 0, -1 }
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 1, type_codes, nullptr, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *ExpFusionTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_FLOAT, 0, -1 },
    { flatbuffers::ET_FLOAT, 0, -1 },
    { flatbuffers::ET_FLOAT, 0, -1 }
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 3, type_codes, nullptr, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *ExpandDimsTypeTable() {
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *FakeQuantWithMinMaxVarsTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_LONG, 0, -1 },
    { flatbuffers::ET_BOOL, 0, -1 }
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 2, type_codes, nullptr, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *FakeQuantWithMinMaxVarsPerChannelTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_LONG, 0, -1 },
    { flatbuffers::ET_BOOL, 0, -1 }
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 2, type_codes, nullptr, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *FftRealTypeTable() {
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *FftImagTypeTable() {
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *FlattenTypeTable() {
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *FlattenGradTypeTable() {
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *FloorTypeTable() {
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *FloorDivTypeTable() {
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *FloorModTypeTable() {
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *FillTypeTable() {
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *FullConnectionTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_BOOL, 0, -1 },
    { flatbuffers::ET_BOOL, 0, -1 },
    { flatbuffers::ET_LONG, 0, -1 },
    { flatbuffers::ET_CHAR, 0, 0 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    mindspore::schema::ActivationTypeTypeTable
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 4, type_codes, type_refs, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *FusedBatchNormTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_FLOAT, 0, -1 },
    { flatbuffers::ET_FLOAT, 0, -1 },
    { flatbuffers::ET_LONG, 0, -1 }
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 3, type_codes, nullptr, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *GatherTypeTable() {
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *GatherNdTypeTable() {
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *GreaterTypeTable() {
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *GreaterEqualTypeTable() {
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *HashtableLookupTypeTable() {
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *InstanceNormTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_FLOAT, 0, -1 }
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 1, type_codes, nullptr, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *LayerNormFusionTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_LONG, 0, -1 },
    { flatbuffers::ET_FLOAT, 0, -1 },
    { flatbuffers::ET_BOOL, 0, -1 },
    { flatbuffers::ET_LONG, 0, -1 }
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 4, type_codes, nullptr, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *LeakyReluTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_FLOAT, 0, -1 }
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 1, type_codes, nullptr, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *LessTypeTable() {
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *LessEqualTypeTable() {
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *LogTypeTable() {
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *LogGradTypeTable() {
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *LogicalAndTypeTable() {
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *LogicalNotTypeTable() {
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *LogicalOrTypeTable() {
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *LpNormalizationTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_LONG, 0, -1 },
    { flatbuffers::ET_LONG, 0, -1 }
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 2, type_codes, nullptr, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *LRNTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_LONG, 0, -1 },
    { flatbuffers::ET_FLOAT, 0, -1 },
    { flatbuffers::ET_FLOAT, 0, -1 },
    { flatbuffers::ET_FLOAT, 0, -1 },
    { flatbuffers::ET_STRING, 0, -1 }
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 5, type_codes, nullptr, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *LshProjectionTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_CHAR, 0, 0 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    mindspore::schema::LshProjectionTypeTypeTable
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 1, type_codes, type_refs, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *LSTMTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_BOOL, 0, -1 },
    { flatbuffers::ET_BOOL, 0, -1 },
    { flatbuffers::ET_LONG, 0, -1 },
    { flatbuffers::ET_LONG, 0, -1 },
    { flatbuffers::ET_LONG, 0, -1 },
    { flatbuffers::ET_LONG, 0, -1 },
    { flatbuffers::ET_FLOAT, 0, -1 },
    { flatbuffers::ET_FLOAT, 0, -1 },
    { flatbuffers::ET_FLOAT, 0, -1 }
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 9, type_codes, nullptr, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *LSTMGradTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_BOOL, 0, -1 },
    { flatbuffers::ET_BOOL, 0, -1 },
    { flatbuffers::ET_LONG, 0, -1 },
    { flatbuffers::ET_LONG, 0, -1 },
    { flatbuffers::ET_LONG, 0, -1 },
    { flatbuffers::ET_LONG, 0, -1 },
    { flatbuffers::ET_FLOAT, 0, -1 },
    { flatbuffers::ET_FLOAT, 0, -1 },
    { flatbuffers::ET_FLOAT, 0, -1 }
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 9, type_codes, nullptr, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *L2NormalizeFusionTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_LONG, 1, -1 },
    { flatbuffers::ET_FLOAT, 0, -1 },
    { flatbuffers::ET_CHAR, 0, 0 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    mindspore::schema::ActivationTypeTypeTable
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 3, type_codes, type_refs, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *MatMulFusionTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_BOOL, 0, -1 },
    { flatbuffers::ET_BOOL, 0, -1 },
    { flatbuffers::ET_CHAR, 0, 0 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    mindspore::schema::ActivationTypeTypeTable
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 3, type_codes, type_refs, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *MaximumTypeTable() {
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *MaximumGradTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_BOOL, 0, -1 },
    { flatbuffers::ET_BOOL, 0, -1 }
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 2, type_codes, nullptr, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *MaxPoolFusionTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_LONG, 1, -1 },
    { flatbuffers::ET_LONG, 1, -1 },
    { flatbuffers::ET_LONG, 1, -1 },
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 1 },
    { flatbuffers::ET_INT, 0, 2 },
    { flatbuffers::ET_BOOL, 0, -1 },
    { flatbuffers::ET_CHAR, 0, 3 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    mindspore::schema::PadModeTypeTable,
    mindspore::schema::RoundModeTypeTable,
    mindspore::schema::FormatTypeTable,
    mindspore::schema::ActivationTypeTypeTable
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 8, type_codes, type_refs, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *MaxPoolGradTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_LONG, 1, -1 },
    { flatbuffers::ET_LONG, 1, -1 },
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_INT, 0, 1 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    mindspore::schema::PadModeTypeTable,
    mindspore::schema::FormatTypeTable
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 4, type_codes, type_refs, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *MergeTypeTable() {
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *MfccTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_FLOAT, 0, -1 },
    { flatbuffers::ET_FLOAT, 0, -1 },
    { flatbuffers::ET_LONG, 0, -1 },
    { flatbuffers::ET_LONG, 0, -1 }
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 4, type_codes, nullptr, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *MinimumTypeTable() {
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *MinimumGradTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_BOOL, 0, -1 },
    { flatbuffers::ET_BOOL, 0, -1 }
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 2, type_codes, nullptr, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *ModTypeTable() {
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *MulFusionTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_CHAR, 0, 0 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    mindspore::schema::ActivationTypeTypeTable
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 1, type_codes, type_refs, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *MulGradTypeTable() {
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *NegTypeTable() {
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *NegGradTypeTable() {
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *NotEqualTypeTable() {
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *NonMaxSuppressionTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_LONG, 0, -1 }
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 1, type_codes, nullptr, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *OneHotTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_LONG, 0, -1 }
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 1, type_codes, nullptr, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *OnesLikeTypeTable() {
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *PadFusionTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_SEQUENCE, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 1 },
    { flatbuffers::ET_FLOAT, 0, -1 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    mindspore::schema::Vec2DTypeTable,
    mindspore::schema::PaddingModeTypeTable
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 3, type_codes, type_refs, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *PartialFusionTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_LONG, 0, -1 }
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 1, type_codes, nullptr, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *PowerGradTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_FLOAT, 0, -1 },
    { flatbuffers::ET_FLOAT, 0, -1 },
    { flatbuffers::ET_FLOAT, 0, -1 }
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 3, type_codes, nullptr, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *PowFusionTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_FLOAT, 0, -1 },
    { flatbuffers::ET_FLOAT, 0, -1 }
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 2, type_codes, nullptr, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *PriorBoxTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_LONG, 1, -1 },
    { flatbuffers::ET_LONG, 1, -1 },
    { flatbuffers::ET_FLOAT, 1, -1 },
    { flatbuffers::ET_FLOAT, 1, -1 },
    { flatbuffers::ET_LONG, 0, -1 },
    { flatbuffers::ET_LONG, 0, -1 },
    { flatbuffers::ET_FLOAT, 0, -1 },
    { flatbuffers::ET_FLOAT, 0, -1 },
    { flatbuffers::ET_BOOL, 0, -1 },
    { flatbuffers::ET_BOOL, 0, -1 },
    { flatbuffers::ET_FLOAT, 0, -1 }
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 11, type_codes, nullptr, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *PReLUFusionTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_BOOL, 0, -1 }
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 1, type_codes, nullptr, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *RankTypeTable() {
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *RangeTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_LONG, 0, -1 },
    { flatbuffers::ET_LONG, 0, -1 },
    { flatbuffers::ET_LONG, 0, -1 },
    { flatbuffers::ET_LONG, 0, -1 }
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 4, type_codes, nullptr, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *ReciprocalTypeTable() {
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *RealDivTypeTable() {
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *ReduceFusionTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_BOOL, 0, -1 },
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_BOOL, 0, -1 },
    { flatbuffers::ET_FLOAT, 0, -1 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    mindspore::schema::ReduceModeTypeTable
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 4, type_codes, type_refs, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *ReshapeTypeTable() {
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *ResizeTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 1 },
    { flatbuffers::ET_LONG, 0, -1 },
    { flatbuffers::ET_LONG, 0, -1 },
    { flatbuffers::ET_BOOL, 0, -1 },
    { flatbuffers::ET_CHAR, 0, 2 },
    { flatbuffers::ET_FLOAT, 0, -1 },
    { flatbuffers::ET_LONG, 0, -1 },
    { flatbuffers::ET_FLOAT, 0, -1 },
    { flatbuffers::ET_CHAR, 0, 3 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    mindspore::schema::FormatTypeTable,
    mindspore::schema::ResizeMethodTypeTable,
    mindspore::schema::CoordinateTransformModeTypeTable,
    mindspore::schema::NearestModeTypeTable
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 10, type_codes, type_refs, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *ReverseSequenceTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_LONG, 0, -1 },
    { flatbuffers::ET_LONG, 0, -1 }
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 2, type_codes, nullptr, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *ReverseV2TypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_LONG, 1, -1 }
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 1, type_codes, nullptr, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *RfftTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_LONG, 0, -1 }
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 1, type_codes, nullptr, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *ROIPoolingTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_LONG, 0, -1 },
    { flatbuffers::ET_LONG, 0, -1 },
    { flatbuffers::ET_FLOAT, 0, -1 }
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 3, type_codes, nullptr, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *RoundTypeTable() {
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *RsqrtTypeTable() {
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *QuantDTypeCastTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_LONG, 0, -1 },
    { flatbuffers::ET_LONG, 0, -1 }
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 2, type_codes, nullptr, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *ScaleFusionTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_LONG, 0, -1 },
    { flatbuffers::ET_CHAR, 0, 0 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    mindspore::schema::ActivationTypeTypeTable
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 2, type_codes, type_refs, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *ScatterNdTypeTable() {
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *SGDTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_BOOL, 0, -1 },
    { flatbuffers::ET_FLOAT, 0, -1 },
    { flatbuffers::ET_FLOAT, 0, -1 }
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 3, type_codes, nullptr, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *ShapeTypeTable() {
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *SigmoidCrossEntropyWithLogitsTypeTable() {
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *SigmoidCrossEntropyWithLogitsGradTypeTable() {
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *SinTypeTable() {
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *SkipGramTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_BOOL, 0, -1 },
    { flatbuffers::ET_LONG, 0, -1 },
    { flatbuffers::ET_LONG, 0, -1 }
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 3, type_codes, nullptr, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *SliceFusionTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_LONG, 1, -1 }
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 1, type_codes, nullptr, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *SmoothL1LossTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_FLOAT, 0, -1 }
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 1, type_codes, nullptr, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *SmoothL1LossGradTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_FLOAT, 0, -1 }
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 1, type_codes, nullptr, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *SoftmaxTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_LONG, 1, -1 }
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 1, type_codes, nullptr, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *SoftmaxCrossEntropyWithLogitsTypeTable() {
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *SpaceToBatchTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_LONG, 1, -1 },
    { flatbuffers::ET_SEQUENCE, 0, 0 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    mindspore::schema::Vec2DTypeTable
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 2, type_codes, type_refs, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *SpaceToBatchNDTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_LONG, 1, -1 },
    { flatbuffers::ET_SEQUENCE, 0, 0 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    mindspore::schema::Vec2DTypeTable
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 2, type_codes, type_refs, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *SpaceToDepthTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_LONG, 0, -1 },
    { flatbuffers::ET_INT, 0, 0 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    mindspore::schema::FormatTypeTable
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 2, type_codes, type_refs, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *SparseSoftmaxCrossEntropyWithLogitsTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_BOOL, 0, -1 }
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 1, type_codes, nullptr, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *SparseToDenseTypeTable() {
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *SplitTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_LONG, 0, -1 },
    { flatbuffers::ET_LONG, 1, -1 },
    { flatbuffers::ET_LONG, 0, -1 }
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 3, type_codes, nullptr, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *SqrtTypeTable() {
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *SqueezeTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_LONG, 1, -1 }
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 1, type_codes, nullptr, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *SquareTypeTable() {
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *SquaredDifferenceTypeTable() {
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *StackTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_LONG, 0, -1 }
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 1, type_codes, nullptr, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *StridedSliceTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_LONG, 0, -1 },
    { flatbuffers::ET_LONG, 0, -1 },
    { flatbuffers::ET_LONG, 0, -1 },
    { flatbuffers::ET_LONG, 0, -1 },
    { flatbuffers::ET_LONG, 0, -1 }
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 5, type_codes, nullptr, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *SubFusionTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_CHAR, 0, 0 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    mindspore::schema::ActivationTypeTypeTable
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 1, type_codes, type_refs, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *SubGradTypeTable() {
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *SwitchTypeTable() {
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *TensorListFromTensorTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_LONG, 0, -1 },
    { flatbuffers::ET_LONG, 0, -1 }
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 2, type_codes, nullptr, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *TensorListGetItemTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_LONG, 0, -1 }
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 1, type_codes, nullptr, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *TensorListReserveTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_LONG, 0, -1 },
    { flatbuffers::ET_LONG, 0, -1 }
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 2, type_codes, nullptr, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *TensorListSetItemTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_LONG, 0, -1 }
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 1, type_codes, nullptr, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *TensorListStackTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_LONG, 0, -1 },
    { flatbuffers::ET_LONG, 0, -1 }
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 2, type_codes, nullptr, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *TileFusionTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_LONG, 1, -1 }
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 1, type_codes, nullptr, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *TopKFusionTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_BOOL, 0, -1 },
    { flatbuffers::ET_LONG, 0, -1 },
    { flatbuffers::ET_LONG, 0, -1 }
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 3, type_codes, nullptr, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *TransposeTypeTable() {
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *UniqueTypeTable() {
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *UnsortedSegmentSumTypeTable() {
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *UnsqueezeTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_LONG, 1, -1 }
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 1, type_codes, nullptr, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *UnstackTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_LONG, 0, -1 }
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 1, type_codes, nullptr, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *WhereTypeTable() {
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *ZerosLikeTypeTable() {
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *SelectTypeTable() {
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *GRUTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_BOOL, 0, -1 }
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 1, type_codes, nullptr, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *NonZeroTypeTable() {
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *InvertPermutationTypeTable() {
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *SizeTypeTable() {
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *RandomStandardNormalTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_LONG, 0, -1 },
    { flatbuffers::ET_LONG, 0, -1 }
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 2, type_codes, nullptr, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *CropAndResizeTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_FLOAT, 0, -1 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    mindspore::schema::ResizeMethodTypeTable
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 2, type_codes, type_refs, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *ErfTypeTable() {
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *StridedSliceGradTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_LONG, 0, -1 },
    { flatbuffers::ET_LONG, 0, -1 },
    { flatbuffers::ET_LONG, 0, -1 },
    { flatbuffers::ET_LONG, 0, -1 },
    { flatbuffers::ET_LONG, 0, -1 }
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 5, type_codes, nullptr, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *IsFiniteTypeTable() {
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *LinSpaceTypeTable() {
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *UniformRealTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_LONG, 0, -1 },
    { flatbuffers::ET_LONG, 0, -1 }
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 2, type_codes, nullptr, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *AbsGradTypeTable() {
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *RsqrtGradTypeTable() {
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *SqrtGradTypeTable() {
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *LayerNormGradTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_LONG, 0, -1 },
    { flatbuffers::ET_LONG, 0, -1 }
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 2, type_codes, nullptr, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *ResizeGradTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_BOOL, 0, -1 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    mindspore::schema::ResizeMethodTypeTable
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 2, type_codes, type_refs, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *SpliceTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_LONG, 1, -1 },
    { flatbuffers::ET_LONG, 1, -1 },
    { flatbuffers::ET_LONG, 0, -1 }
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 3, type_codes, nullptr, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *LogSoftmaxTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_LONG, 0, -1 }
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 1, type_codes, nullptr, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *CallTypeTable() {
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *CumSumTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_BOOL, 0, -1 },
    { flatbuffers::ET_BOOL, 0, -1 }
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 2, type_codes, nullptr, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *CustomTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_STRING, 0, -1 },
    { flatbuffers::ET_SEQUENCE, 1, 0 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    mindspore::schema::AttributeTypeTable
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 2, type_codes, type_refs, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *SplitWithOverlapTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_LONG, 0, -1 },
    { flatbuffers::ET_LONG, 0, -1 },
    { flatbuffers::ET_LONG, 1, -1 },
    { flatbuffers::ET_LONG, 1, -1 },
    { flatbuffers::ET_LONG, 1, -1 }
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 5, type_codes, nullptr, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *GenOPTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_FLOAT, 0, -1 },
    { flatbuffers::ET_FLOAT, 0, -1 },
    { flatbuffers::ET_FLOAT, 0, -1 },
    { flatbuffers::ET_BOOL, 0, -1 },
    { flatbuffers::ET_INT, 0, 1 },
    { flatbuffers::ET_LONG, 1, -1 },
    { flatbuffers::ET_LONG, 1, -1 },
    { flatbuffers::ET_LONG, 1, -1 },
    { flatbuffers::ET_CHAR, 0, 2 },
    { flatbuffers::ET_LONG, 1, -1 },
    { flatbuffers::ET_LONG, 0, -1 },
    { flatbuffers::ET_LONG, 0, -1 },
    { flatbuffers::ET_LONG, 0, -1 },
    { flatbuffers::ET_LONG, 0, -1 },
    { flatbuffers::ET_CHAR, 0, 3 },
    { flatbuffers::ET_BOOL, 0, -1 },
    { flatbuffers::ET_BOOL, 0, -1 },
    { flatbuffers::ET_LONG, 0, -1 },
    { flatbuffers::ET_FLOAT, 0, -1 },
    { flatbuffers::ET_FLOAT, 0, -1 },
    { flatbuffers::ET_BOOL, 0, -1 },
    { flatbuffers::ET_BOOL, 0, -1 },
    { flatbuffers::ET_LONG, 1, -1 },
    { flatbuffers::ET_CHAR, 0, 4 },
    { flatbuffers::ET_BOOL, 0, -1 },
    { flatbuffers::ET_BOOL, 0, -1 },
    { flatbuffers::ET_LONG, 1, -1 },
    { flatbuffers::ET_BOOL, 0, -1 },
    { flatbuffers::ET_CHAR, 0, 5 },
    { flatbuffers::ET_BOOL, 0, -1 },
    { flatbuffers::ET_FLOAT, 0, -1 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    mindspore::schema::ActivationTypeTypeTable,
    mindspore::schema::FormatTypeTable,
    mindspore::schema::PadModeTypeTable,
    mindspore::schema::EltwiseModeTypeTable,
    mindspore::schema::RoundModeTypeTable,
    mindspore::schema::ReduceModeTypeTable
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 32, type_codes, type_refs, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *RaggedRangeTypeTable() {
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *GLUTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_LONG, 0, -1 }
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 1, type_codes, nullptr, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *TensorArrayTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_BOOL, 0, -1 },
    { flatbuffers::ET_BOOL, 0, -1 },
    { flatbuffers::ET_INT, 1, -1 },
    { flatbuffers::ET_INT, 0, -1 }
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 4, type_codes, nullptr, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *TensorArrayReadTypeTable() {
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *TensorArrayWriteTypeTable() {
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *AffineTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_LONG, 1, -1 },
    { flatbuffers::ET_LONG, 0, -1 },
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_BOOL, 0, -1 },
    { flatbuffers::ET_BOOL, 0, -1 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    mindspore::schema::ActivationTypeTypeTable
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 5, type_codes, type_refs, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *ScatterNdUpdateTypeTable() {
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr, nullptr
  };
  return &tt;
}

}  // namespace schema
}  // namespace mindspore

#endif  // FLATBUFFERS_GENERATED_OPS_MINDSPORE_SCHEMA_H_
