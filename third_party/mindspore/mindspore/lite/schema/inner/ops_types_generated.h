// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_OPSTYPES_MINDSPORE_SCHEMA_H_
#define FLATBUFFERS_GENERATED_OPSTYPES_MINDSPORE_SCHEMA_H_

#include "flatbuffers/flatbuffers.h"

namespace mindspore {
namespace schema {

struct Vec;
struct VecBuilder;
struct VecT;

struct Vec2D;
struct Vec2DBuilder;
struct Vec2DT;

struct Attribute;
struct AttributeBuilder;
struct AttributeT;

inline const flatbuffers::TypeTable *VecTypeTable();

inline const flatbuffers::TypeTable *Vec2DTypeTable();

inline const flatbuffers::TypeTable *AttributeTypeTable();

enum ResizeMethod : int8_t {
  ResizeMethod_UNKNOWN = -1,
  ResizeMethod_LINEAR = 0,
  ResizeMethod_NEAREST = 1,
  ResizeMethod_CUBIC = 2,
  ResizeMethod_MIN = ResizeMethod_UNKNOWN,
  ResizeMethod_MAX = ResizeMethod_CUBIC
};

inline const ResizeMethod (&EnumValuesResizeMethod())[4] {
  static const ResizeMethod values[] = {
    ResizeMethod_UNKNOWN,
    ResizeMethod_LINEAR,
    ResizeMethod_NEAREST,
    ResizeMethod_CUBIC
  };
  return values;
}

inline const char * const *EnumNamesResizeMethod() {
  static const char * const names[5] = {
    "UNKNOWN",
    "LINEAR",
    "NEAREST",
    "CUBIC",
    nullptr
  };
  return names;
}

inline const char *EnumNameResizeMethod(ResizeMethod e) {
  if (flatbuffers::IsOutRange(e, ResizeMethod_UNKNOWN, ResizeMethod_CUBIC)) return "";
  const size_t index = static_cast<size_t>(e) - static_cast<size_t>(ResizeMethod_UNKNOWN);
  return EnumNamesResizeMethod()[index];
}

enum CoordinateTransformMode : int8_t {
  CoordinateTransformMode_ASYMMETRIC = 0,
  CoordinateTransformMode_ALIGN_CORNERS = 1,
  CoordinateTransformMode_HALF_PIXEL = 2,
  CoordinateTransformMode_MIN = CoordinateTransformMode_ASYMMETRIC,
  CoordinateTransformMode_MAX = CoordinateTransformMode_HALF_PIXEL
};

inline const CoordinateTransformMode (&EnumValuesCoordinateTransformMode())[3] {
  static const CoordinateTransformMode values[] = {
    CoordinateTransformMode_ASYMMETRIC,
    CoordinateTransformMode_ALIGN_CORNERS,
    CoordinateTransformMode_HALF_PIXEL
  };
  return values;
}

inline const char * const *EnumNamesCoordinateTransformMode() {
  static const char * const names[4] = {
    "ASYMMETRIC",
    "ALIGN_CORNERS",
    "HALF_PIXEL",
    nullptr
  };
  return names;
}

inline const char *EnumNameCoordinateTransformMode(CoordinateTransformMode e) {
  if (flatbuffers::IsOutRange(e, CoordinateTransformMode_ASYMMETRIC, CoordinateTransformMode_HALF_PIXEL)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesCoordinateTransformMode()[index];
}

enum NearestMode : int8_t {
  NearestMode_NORMAL = 0,
  NearestMode_ROUND_HALF_DOWN = 1,
  NearestMode_ROUND_HALF_UP = 2,
  NearestMode_FLOOR = 3,
  NearestMode_CEIL = 4,
  NearestMode_MIN = NearestMode_NORMAL,
  NearestMode_MAX = NearestMode_CEIL
};

inline const NearestMode (&EnumValuesNearestMode())[5] {
  static const NearestMode values[] = {
    NearestMode_NORMAL,
    NearestMode_ROUND_HALF_DOWN,
    NearestMode_ROUND_HALF_UP,
    NearestMode_FLOOR,
    NearestMode_CEIL
  };
  return values;
}

inline const char * const *EnumNamesNearestMode() {
  static const char * const names[6] = {
    "NORMAL",
    "ROUND_HALF_DOWN",
    "ROUND_HALF_UP",
    "FLOOR",
    "CEIL",
    nullptr
  };
  return names;
}

inline const char *EnumNameNearestMode(NearestMode e) {
  if (flatbuffers::IsOutRange(e, NearestMode_NORMAL, NearestMode_CEIL)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesNearestMode()[index];
}

enum Format : int32_t {
  Format_NCHW = 0,
  Format_NHWC = 1,
  Format_NHWC4 = 2,
  Format_HWKC = 3,
  Format_HWCK = 4,
  Format_KCHW = 5,
  Format_CKHW = 6,
  Format_KHWC = 7,
  Format_CHWK = 8,
  Format_HW = 9,
  Format_HW4 = 10,
  Format_NC = 11,
  Format_NC4 = 12,
  Format_NC4HW4 = 13,
  Format_NUM_OF_FORMAT = 14,
  Format_NCDHW = 15,
  Format_NWC = 16,
  Format_NCW = 17,
  Format_MIN = Format_NCHW,
  Format_MAX = Format_NCW
};

inline const Format (&EnumValuesFormat())[18] {
  static const Format values[] = {
    Format_NCHW,
    Format_NHWC,
    Format_NHWC4,
    Format_HWKC,
    Format_HWCK,
    Format_KCHW,
    Format_CKHW,
    Format_KHWC,
    Format_CHWK,
    Format_HW,
    Format_HW4,
    Format_NC,
    Format_NC4,
    Format_NC4HW4,
    Format_NUM_OF_FORMAT,
    Format_NCDHW,
    Format_NWC,
    Format_NCW
  };
  return values;
}

inline const char * const *EnumNamesFormat() {
  static const char * const names[19] = {
    "NCHW",
    "NHWC",
    "NHWC4",
    "HWKC",
    "HWCK",
    "KCHW",
    "CKHW",
    "KHWC",
    "CHWK",
    "HW",
    "HW4",
    "NC",
    "NC4",
    "NC4HW4",
    "NUM_OF_FORMAT",
    "NCDHW",
    "NWC",
    "NCW",
    nullptr
  };
  return names;
}

inline const char *EnumNameFormat(Format e) {
  if (flatbuffers::IsOutRange(e, Format_NCHW, Format_NCW)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesFormat()[index];
}

enum ActivationType : int8_t {
  ActivationType_NO_ACTIVATION = 0,
  ActivationType_RELU = 1,
  ActivationType_SIGMOID = 2,
  ActivationType_RELU6 = 3,
  ActivationType_ELU = 4,
  ActivationType_LEAKY_RELU = 5,
  ActivationType_ABS = 6,
  ActivationType_RELU1 = 7,
  ActivationType_SOFTSIGN = 8,
  ActivationType_SOFTPLUS = 9,
  ActivationType_TANH = 10,
  ActivationType_SELU = 11,
  ActivationType_HSWISH = 12,
  ActivationType_HSIGMOID = 13,
  ActivationType_THRESHOLDRELU = 14,
  ActivationType_LINEAR = 15,
  ActivationType_HARD_TANH = 16,
  ActivationType_SIGN = 17,
  ActivationType_SWISH = 18,
  ActivationType_GELU = 19,
  ActivationType_UNKNOWN = 20,
  ActivationType_MIN = ActivationType_NO_ACTIVATION,
  ActivationType_MAX = ActivationType_UNKNOWN
};

inline const ActivationType (&EnumValuesActivationType())[21] {
  static const ActivationType values[] = {
    ActivationType_NO_ACTIVATION,
    ActivationType_RELU,
    ActivationType_SIGMOID,
    ActivationType_RELU6,
    ActivationType_ELU,
    ActivationType_LEAKY_RELU,
    ActivationType_ABS,
    ActivationType_RELU1,
    ActivationType_SOFTSIGN,
    ActivationType_SOFTPLUS,
    ActivationType_TANH,
    ActivationType_SELU,
    ActivationType_HSWISH,
    ActivationType_HSIGMOID,
    ActivationType_THRESHOLDRELU,
    ActivationType_LINEAR,
    ActivationType_HARD_TANH,
    ActivationType_SIGN,
    ActivationType_SWISH,
    ActivationType_GELU,
    ActivationType_UNKNOWN
  };
  return values;
}

inline const char * const *EnumNamesActivationType() {
  static const char * const names[22] = {
    "NO_ACTIVATION",
    "RELU",
    "SIGMOID",
    "RELU6",
    "ELU",
    "LEAKY_RELU",
    "ABS",
    "RELU1",
    "SOFTSIGN",
    "SOFTPLUS",
    "TANH",
    "SELU",
    "HSWISH",
    "HSIGMOID",
    "THRESHOLDRELU",
    "LINEAR",
    "HARD_TANH",
    "SIGN",
    "SWISH",
    "GELU",
    "UNKNOWN",
    nullptr
  };
  return names;
}

inline const char *EnumNameActivationType(ActivationType e) {
  if (flatbuffers::IsOutRange(e, ActivationType_NO_ACTIVATION, ActivationType_UNKNOWN)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesActivationType()[index];
}

enum ReduceMode : int8_t {
  ReduceMode_ReduceMean = 0,
  ReduceMode_ReduceMax = 1,
  ReduceMode_ReduceMin = 2,
  ReduceMode_ReduceProd = 3,
  ReduceMode_ReduceSum = 4,
  ReduceMode_ReduceSumSquare = 5,
  ReduceMode_ReduceASum = 6,
  ReduceMode_ReduceAll = 7,
  ReduceMode_MIN = ReduceMode_ReduceMean,
  ReduceMode_MAX = ReduceMode_ReduceAll
};

inline const ReduceMode (&EnumValuesReduceMode())[8] {
  static const ReduceMode values[] = {
    ReduceMode_ReduceMean,
    ReduceMode_ReduceMax,
    ReduceMode_ReduceMin,
    ReduceMode_ReduceProd,
    ReduceMode_ReduceSum,
    ReduceMode_ReduceSumSquare,
    ReduceMode_ReduceASum,
    ReduceMode_ReduceAll
  };
  return values;
}

inline const char * const *EnumNamesReduceMode() {
  static const char * const names[9] = {
    "ReduceMean",
    "ReduceMax",
    "ReduceMin",
    "ReduceProd",
    "ReduceSum",
    "ReduceSumSquare",
    "ReduceASum",
    "ReduceAll",
    nullptr
  };
  return names;
}

inline const char *EnumNameReduceMode(ReduceMode e) {
  if (flatbuffers::IsOutRange(e, ReduceMode_ReduceMean, ReduceMode_ReduceAll)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesReduceMode()[index];
}

enum PoolMode : int8_t {
  PoolMode_MAX_POOLING = 0,
  PoolMode_MEAN_POOLING = 1,
  PoolMode_MIN = PoolMode_MAX_POOLING,
  PoolMode_MAX = PoolMode_MEAN_POOLING
};

inline const PoolMode (&EnumValuesPoolMode())[2] {
  static const PoolMode values[] = {
    PoolMode_MAX_POOLING,
    PoolMode_MEAN_POOLING
  };
  return values;
}

inline const char * const *EnumNamesPoolMode() {
  static const char * const names[3] = {
    "MAX_POOLING",
    "MEAN_POOLING",
    nullptr
  };
  return names;
}

inline const char *EnumNamePoolMode(PoolMode e) {
  if (flatbuffers::IsOutRange(e, PoolMode_MAX_POOLING, PoolMode_MEAN_POOLING)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesPoolMode()[index];
}

enum EltwiseMode : int8_t {
  EltwiseMode_PROD = 0,
  EltwiseMode_SUM = 1,
  EltwiseMode_MAXIMUM = 2,
  EltwiseMode_UNKNOWN = 3,
  EltwiseMode_MIN = EltwiseMode_PROD,
  EltwiseMode_MAX = EltwiseMode_UNKNOWN
};

inline const EltwiseMode (&EnumValuesEltwiseMode())[4] {
  static const EltwiseMode values[] = {
    EltwiseMode_PROD,
    EltwiseMode_SUM,
    EltwiseMode_MAXIMUM,
    EltwiseMode_UNKNOWN
  };
  return values;
}

inline const char * const *EnumNamesEltwiseMode() {
  static const char * const names[5] = {
    "PROD",
    "SUM",
    "MAXIMUM",
    "UNKNOWN",
    nullptr
  };
  return names;
}

inline const char *EnumNameEltwiseMode(EltwiseMode e) {
  if (flatbuffers::IsOutRange(e, EltwiseMode_PROD, EltwiseMode_UNKNOWN)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesEltwiseMode()[index];
}

enum PadMode : int8_t {
  PadMode_PAD = 0,
  PadMode_SAME = 1,
  PadMode_VALID = 2,
  PadMode_MIN = PadMode_PAD,
  PadMode_MAX = PadMode_VALID
};

inline const PadMode (&EnumValuesPadMode())[3] {
  static const PadMode values[] = {
    PadMode_PAD,
    PadMode_SAME,
    PadMode_VALID
  };
  return values;
}

inline const char * const *EnumNamesPadMode() {
  static const char * const names[4] = {
    "PAD",
    "SAME",
    "VALID",
    nullptr
  };
  return names;
}

inline const char *EnumNamePadMode(PadMode e) {
  if (flatbuffers::IsOutRange(e, PadMode_PAD, PadMode_VALID)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesPadMode()[index];
}

enum RoundMode : int8_t {
  RoundMode_FLOOR = 0,
  RoundMode_CEIL = 1,
  RoundMode_MIN = RoundMode_FLOOR,
  RoundMode_MAX = RoundMode_CEIL
};

inline const RoundMode (&EnumValuesRoundMode())[2] {
  static const RoundMode values[] = {
    RoundMode_FLOOR,
    RoundMode_CEIL
  };
  return values;
}

inline const char * const *EnumNamesRoundMode() {
  static const char * const names[3] = {
    "FLOOR",
    "CEIL",
    nullptr
  };
  return names;
}

inline const char *EnumNameRoundMode(RoundMode e) {
  if (flatbuffers::IsOutRange(e, RoundMode_FLOOR, RoundMode_CEIL)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesRoundMode()[index];
}

enum PaddingMode : int8_t {
  PaddingMode_CONSTANT = 0,
  PaddingMode_REFLECT = 1,
  PaddingMode_SYMMETRIC = 2,
  PaddingMode_MODE_RESERVED = 3,
  PaddingMode_MIN = PaddingMode_CONSTANT,
  PaddingMode_MAX = PaddingMode_MODE_RESERVED
};

inline const PaddingMode (&EnumValuesPaddingMode())[4] {
  static const PaddingMode values[] = {
    PaddingMode_CONSTANT,
    PaddingMode_REFLECT,
    PaddingMode_SYMMETRIC,
    PaddingMode_MODE_RESERVED
  };
  return values;
}

inline const char * const *EnumNamesPaddingMode() {
  static const char * const names[5] = {
    "CONSTANT",
    "REFLECT",
    "SYMMETRIC",
    "MODE_RESERVED",
    nullptr
  };
  return names;
}

inline const char *EnumNamePaddingMode(PaddingMode e) {
  if (flatbuffers::IsOutRange(e, PaddingMode_CONSTANT, PaddingMode_MODE_RESERVED)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesPaddingMode()[index];
}

enum LshProjectionType : int8_t {
  LshProjectionType_UNKNOWN = 0,
  LshProjectionType_SPARSE = 1,
  LshProjectionType_DENSE = 2,
  LshProjectionType_MIN = LshProjectionType_UNKNOWN,
  LshProjectionType_MAX = LshProjectionType_DENSE
};

inline const LshProjectionType (&EnumValuesLshProjectionType())[3] {
  static const LshProjectionType values[] = {
    LshProjectionType_UNKNOWN,
    LshProjectionType_SPARSE,
    LshProjectionType_DENSE
  };
  return values;
}

inline const char * const *EnumNamesLshProjectionType() {
  static const char * const names[4] = {
    "UNKNOWN",
    "SPARSE",
    "DENSE",
    nullptr
  };
  return names;
}

inline const char *EnumNameLshProjectionType(LshProjectionType e) {
  if (flatbuffers::IsOutRange(e, LshProjectionType_UNKNOWN, LshProjectionType_DENSE)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesLshProjectionType()[index];
}

enum Reduction : int8_t {
  Reduction_REDUCTION_SUM = 0,
  Reduction_MEAN = 1,
  Reduction_NONE = 2,
  Reduction_MIN = Reduction_REDUCTION_SUM,
  Reduction_MAX = Reduction_NONE
};

inline const Reduction (&EnumValuesReduction())[3] {
  static const Reduction values[] = {
    Reduction_REDUCTION_SUM,
    Reduction_MEAN,
    Reduction_NONE
  };
  return values;
}

inline const char * const *EnumNamesReduction() {
  static const char * const names[4] = {
    "REDUCTION_SUM",
    "MEAN",
    "NONE",
    nullptr
  };
  return names;
}

inline const char *EnumNameReduction(Reduction e) {
  if (flatbuffers::IsOutRange(e, Reduction_REDUCTION_SUM, Reduction_NONE)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesReduction()[index];
}

struct VecT : public flatbuffers::NativeTable {
  typedef Vec TableType;
  std::vector<int64_t> data{};
};

struct Vec FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef VecT NativeTableType;
  typedef VecBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return VecTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_DATA = 4
  };
  const flatbuffers::Vector<int64_t> *data() const {
    return GetPointer<const flatbuffers::Vector<int64_t> *>(VT_DATA);
  }
  flatbuffers::Vector<int64_t> *mutable_data() {
    return GetPointer<flatbuffers::Vector<int64_t> *>(VT_DATA);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_DATA) &&
           verifier.VerifyVector(data()) &&
           verifier.EndTable();
  }
  VecT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(VecT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Vec> Pack(flatbuffers::FlatBufferBuilder &_fbb, const VecT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct VecBuilder {
  typedef Vec Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_data(flatbuffers::Offset<flatbuffers::Vector<int64_t>> data) {
    fbb_.AddOffset(Vec::VT_DATA, data);
  }
  explicit VecBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Vec> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Vec>(end);
    return o;
  }
};

inline flatbuffers::Offset<Vec> CreateVec(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<int64_t>> data = 0) {
  VecBuilder builder_(_fbb);
  builder_.add_data(data);
  return builder_.Finish();
}

inline flatbuffers::Offset<Vec> CreateVecDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<int64_t> *data = nullptr) {
  auto data__ = data ? _fbb.CreateVector<int64_t>(*data) : 0;
  return mindspore::schema::CreateVec(
      _fbb,
      data__);
}

flatbuffers::Offset<Vec> CreateVec(flatbuffers::FlatBufferBuilder &_fbb, const VecT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct Vec2DT : public flatbuffers::NativeTable {
  typedef Vec2D TableType;
  std::vector<std::unique_ptr<mindspore::schema::VecT>> data{};
};

struct Vec2D FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef Vec2DT NativeTableType;
  typedef Vec2DBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return Vec2DTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_DATA = 4
  };
  const flatbuffers::Vector<flatbuffers::Offset<mindspore::schema::Vec>> *data() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<mindspore::schema::Vec>> *>(VT_DATA);
  }
  flatbuffers::Vector<flatbuffers::Offset<mindspore::schema::Vec>> *mutable_data() {
    return GetPointer<flatbuffers::Vector<flatbuffers::Offset<mindspore::schema::Vec>> *>(VT_DATA);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_DATA) &&
           verifier.VerifyVector(data()) &&
           verifier.VerifyVectorOfTables(data()) &&
           verifier.EndTable();
  }
  Vec2DT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(Vec2DT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Vec2D> Pack(flatbuffers::FlatBufferBuilder &_fbb, const Vec2DT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct Vec2DBuilder {
  typedef Vec2D Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_data(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<mindspore::schema::Vec>>> data) {
    fbb_.AddOffset(Vec2D::VT_DATA, data);
  }
  explicit Vec2DBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Vec2D> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Vec2D>(end);
    return o;
  }
};

inline flatbuffers::Offset<Vec2D> CreateVec2D(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<mindspore::schema::Vec>>> data = 0) {
  Vec2DBuilder builder_(_fbb);
  builder_.add_data(data);
  return builder_.Finish();
}

inline flatbuffers::Offset<Vec2D> CreateVec2DDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<mindspore::schema::Vec>> *data = nullptr) {
  auto data__ = data ? _fbb.CreateVector<flatbuffers::Offset<mindspore::schema::Vec>>(*data) : 0;
  return mindspore::schema::CreateVec2D(
      _fbb,
      data__);
}

flatbuffers::Offset<Vec2D> CreateVec2D(flatbuffers::FlatBufferBuilder &_fbb, const Vec2DT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct AttributeT : public flatbuffers::NativeTable {
  typedef Attribute TableType;
  std::string name{};
  std::vector<uint8_t> data{};
};

struct Attribute FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef AttributeT NativeTableType;
  typedef AttributeBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return AttributeTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NAME = 4,
    VT_DATA = 6
  };
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  flatbuffers::String *mutable_name() {
    return GetPointer<flatbuffers::String *>(VT_NAME);
  }
  const flatbuffers::Vector<uint8_t> *data() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_DATA);
  }
  flatbuffers::Vector<uint8_t> *mutable_data() {
    return GetPointer<flatbuffers::Vector<uint8_t> *>(VT_DATA);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyOffset(verifier, VT_DATA) &&
           verifier.VerifyVector(data()) &&
           verifier.EndTable();
  }
  AttributeT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(AttributeT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Attribute> Pack(flatbuffers::FlatBufferBuilder &_fbb, const AttributeT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct AttributeBuilder {
  typedef Attribute Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(Attribute::VT_NAME, name);
  }
  void add_data(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> data) {
    fbb_.AddOffset(Attribute::VT_DATA, data);
  }
  explicit AttributeBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Attribute> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Attribute>(end);
    return o;
  }
};

inline flatbuffers::Offset<Attribute> CreateAttribute(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> data = 0) {
  AttributeBuilder builder_(_fbb);
  builder_.add_data(data);
  builder_.add_name(name);
  return builder_.Finish();
}

inline flatbuffers::Offset<Attribute> CreateAttributeDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *name = nullptr,
    const std::vector<uint8_t> *data = nullptr) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  auto data__ = data ? _fbb.CreateVector<uint8_t>(*data) : 0;
  return mindspore::schema::CreateAttribute(
      _fbb,
      name__,
      data__);
}

flatbuffers::Offset<Attribute> CreateAttribute(flatbuffers::FlatBufferBuilder &_fbb, const AttributeT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

inline VecT *Vec::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<VecT>(new VecT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Vec::UnPackTo(VecT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = data(); if (_e) { _o->data.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->data[_i] = _e->Get(_i); } } }
}

inline flatbuffers::Offset<Vec> Vec::Pack(flatbuffers::FlatBufferBuilder &_fbb, const VecT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateVec(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Vec> CreateVec(flatbuffers::FlatBufferBuilder &_fbb, const VecT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const VecT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _data = _o->data.size() ? _fbb.CreateVector(_o->data) : 0;
  return mindspore::schema::CreateVec(
      _fbb,
      _data);
}

inline Vec2DT *Vec2D::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<Vec2DT>(new Vec2DT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Vec2D::UnPackTo(Vec2DT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = data(); if (_e) { _o->data.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->data[_i] = std::unique_ptr<mindspore::schema::VecT>(_e->Get(_i)->UnPack(_resolver)); } } }
}

inline flatbuffers::Offset<Vec2D> Vec2D::Pack(flatbuffers::FlatBufferBuilder &_fbb, const Vec2DT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateVec2D(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Vec2D> CreateVec2D(flatbuffers::FlatBufferBuilder &_fbb, const Vec2DT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const Vec2DT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _data = _o->data.size() ? _fbb.CreateVector<flatbuffers::Offset<mindspore::schema::Vec>> (_o->data.size(), [](size_t i, _VectorArgs *__va) { return CreateVec(*__va->__fbb, __va->__o->data[i].get(), __va->__rehasher); }, &_va ) : 0;
  return mindspore::schema::CreateVec2D(
      _fbb,
      _data);
}

inline AttributeT *Attribute::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<AttributeT>(new AttributeT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Attribute::UnPackTo(AttributeT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = name(); if (_e) _o->name = _e->str(); }
  { auto _e = data(); if (_e) { _o->data.resize(_e->size()); std::copy(_e->begin(), _e->end(), _o->data.begin()); } }
}

inline flatbuffers::Offset<Attribute> Attribute::Pack(flatbuffers::FlatBufferBuilder &_fbb, const AttributeT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateAttribute(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Attribute> CreateAttribute(flatbuffers::FlatBufferBuilder &_fbb, const AttributeT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const AttributeT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _name = _o->name.empty() ? 0 : _fbb.CreateString(_o->name);
  auto _data = _o->data.size() ? _fbb.CreateVector(_o->data) : 0;
  return mindspore::schema::CreateAttribute(
      _fbb,
      _name,
      _data);
}

inline const flatbuffers::TypeTable *ResizeMethodTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    mindspore::schema::ResizeMethodTypeTable
  };
  static const int64_t values[] = { -1, 0, 1, 2 };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_ENUM, 4, type_codes, type_refs, nullptr, values, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *CoordinateTransformModeTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    mindspore::schema::CoordinateTransformModeTypeTable
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_ENUM, 3, type_codes, type_refs, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *NearestModeTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    mindspore::schema::NearestModeTypeTable
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_ENUM, 5, type_codes, type_refs, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *FormatTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    mindspore::schema::FormatTypeTable
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_ENUM, 18, type_codes, type_refs, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *ActivationTypeTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    mindspore::schema::ActivationTypeTypeTable
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_ENUM, 21, type_codes, type_refs, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *ReduceModeTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    mindspore::schema::ReduceModeTypeTable
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_ENUM, 8, type_codes, type_refs, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *PoolModeTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    mindspore::schema::PoolModeTypeTable
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_ENUM, 2, type_codes, type_refs, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *EltwiseModeTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    mindspore::schema::EltwiseModeTypeTable
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_ENUM, 4, type_codes, type_refs, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *PadModeTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    mindspore::schema::PadModeTypeTable
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_ENUM, 3, type_codes, type_refs, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *RoundModeTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    mindspore::schema::RoundModeTypeTable
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_ENUM, 2, type_codes, type_refs, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *PaddingModeTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    mindspore::schema::PaddingModeTypeTable
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_ENUM, 4, type_codes, type_refs, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *LshProjectionTypeTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    mindspore::schema::LshProjectionTypeTypeTable
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_ENUM, 3, type_codes, type_refs, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *ReductionTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    mindspore::schema::ReductionTypeTable
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_ENUM, 3, type_codes, type_refs, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *VecTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_LONG, 1, -1 }
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 1, type_codes, nullptr, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *Vec2DTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_SEQUENCE, 1, 0 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    mindspore::schema::VecTypeTable
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 1, type_codes, type_refs, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *AttributeTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_STRING, 0, -1 },
    { flatbuffers::ET_UCHAR, 1, -1 }
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 2, type_codes, nullptr, nullptr, nullptr, nullptr
  };
  return &tt;
}

}  // namespace schema
}  // namespace mindspore

#endif  // FLATBUFFERS_GENERATED_OPSTYPES_MINDSPORE_SCHEMA_H_
