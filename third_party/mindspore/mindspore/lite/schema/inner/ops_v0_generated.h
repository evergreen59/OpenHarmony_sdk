// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_OPSV0_MINDSPORE_SCHEMA_V0_H_
#define FLATBUFFERS_GENERATED_OPSV0_MINDSPORE_SCHEMA_V0_H_

#include "flatbuffers/flatbuffers.h"

namespace mindspore {
namespace schema {
namespace v0 {

struct Pad;
struct PadBuilder;
struct PadT;

struct Maximum;
struct MaximumBuilder;
struct MaximumT;

struct Minimum;
struct MinimumBuilder;
struct MinimumT;

struct Flatten;
struct FlattenBuilder;
struct FlattenT;

struct FlattenGrad;
struct FlattenGradBuilder;
struct FlattenGradT;

struct Concat;
struct ConcatBuilder;
struct ConcatT;

struct SoftMax;
struct SoftMaxBuilder;
struct SoftMaxT;

struct Activation;
struct ActivationBuilder;
struct ActivationT;

struct ActivationGrad;
struct ActivationGradBuilder;
struct ActivationGradT;

struct Conv2D;
struct Conv2DBuilder;
struct Conv2DT;

struct Adder;
struct AdderBuilder;
struct AdderT;

struct Conv2DGradFilter;
struct Conv2DGradFilterBuilder;
struct Conv2DGradFilterT;

struct Conv2DGradInput;
struct Conv2DGradInputBuilder;
struct Conv2DGradInputT;

struct GroupConv2DGradInput;
struct GroupConv2DGradInputBuilder;
struct GroupConv2DGradInputT;

struct FusedBatchNorm;
struct FusedBatchNormBuilder;
struct FusedBatchNormT;

struct BatchNorm;
struct BatchNormBuilder;
struct BatchNormT;

struct BiasGrad;
struct BiasGradBuilder;
struct BiasGradT;

struct SoftmaxCrossEntropy;
struct SoftmaxCrossEntropyBuilder;
struct SoftmaxCrossEntropyT;

struct SparseSoftmaxCrossEntropy;
struct SparseSoftmaxCrossEntropyBuilder;
struct SparseSoftmaxCrossEntropyT;

struct make_tuple;
struct make_tupleBuilder;
struct make_tupleT;

struct PoolingGrad;
struct PoolingGradBuilder;
struct PoolingGradT;

struct Shape;
struct ShapeBuilder;
struct ShapeT;

struct ConstantOfShape;
struct ConstantOfShapeBuilder;
struct ConstantOfShapeT;

struct Nchw2Nhwc;
struct Nchw2NhwcBuilder;
struct Nchw2NhwcT;

struct Nhwc2Nchw;
struct Nhwc2NchwBuilder;
struct Nhwc2NchwT;

struct FakeQuantWithMinMaxVars;
struct FakeQuantWithMinMaxVarsBuilder;
struct FakeQuantWithMinMaxVarsT;

struct BiasAdd;
struct BiasAddBuilder;
struct BiasAddT;

struct ROIPooling;
struct ROIPoolingBuilder;
struct ROIPoolingT;

struct Pooling;
struct PoolingBuilder;
struct PoolingT;

struct DepthwiseConv2D;
struct DepthwiseConv2DBuilder;
struct DepthwiseConv2DT;

struct DeDepthwiseConv2D;
struct DeDepthwiseConv2DBuilder;
struct DeDepthwiseConv2DT;

struct Resize;
struct ResizeBuilder;
struct ResizeT;

struct DetectionPostProcess;
struct DetectionPostProcessBuilder;
struct DetectionPostProcessT;

struct FullConnection;
struct FullConnectionBuilder;
struct FullConnectionT;

struct Mean;
struct MeanBuilder;
struct MeanT;

struct DeConv2D;
struct DeConv2DBuilder;
struct DeConv2DT;

struct DeConv2DGradFilter;
struct DeConv2DGradFilterBuilder;
struct DeConv2DGradFilterT;

struct BNGrad;
struct BNGradBuilder;
struct BNGradT;

struct Scale;
struct ScaleBuilder;
struct ScaleT;

struct Eltwise;
struct EltwiseBuilder;
struct EltwiseT;

struct Add;
struct AddBuilder;
struct AddT;

struct Sub;
struct SubBuilder;
struct SubT;

struct Mul;
struct MulBuilder;
struct MulT;

struct Div;
struct DivBuilder;
struct DivT;

struct AddGrad;
struct AddGradBuilder;
struct AddGradT;

struct SubGrad;
struct SubGradBuilder;
struct SubGradT;

struct MulGrad;
struct MulGradBuilder;
struct MulGradT;

struct DivGrad;
struct DivGradBuilder;
struct DivGradT;

struct RealDiv;
struct RealDivBuilder;
struct RealDivT;

struct Rsqrt;
struct RsqrtBuilder;
struct RsqrtT;

struct Equal;
struct EqualBuilder;
struct EqualT;

struct Less;
struct LessBuilder;
struct LessT;

struct Greater;
struct GreaterBuilder;
struct GreaterT;

struct NotEqual;
struct NotEqualBuilder;
struct NotEqualT;

struct LessEqual;
struct LessEqualBuilder;
struct LessEqualT;

struct GreaterEqual;
struct GreaterEqualBuilder;
struct GreaterEqualT;

struct Min;
struct MinBuilder;
struct MinT;

struct Slice;
struct SliceBuilder;
struct SliceT;

struct Floor;
struct FloorBuilder;
struct FloorT;

struct Abs;
struct AbsBuilder;
struct AbsT;

struct Neg;
struct NegBuilder;
struct NegT;

struct NegGrad;
struct NegGradBuilder;
struct NegGradT;

struct Exp;
struct ExpBuilder;
struct ExpT;

struct Cos;
struct CosBuilder;
struct CosT;

struct Sin;
struct SinBuilder;
struct SinT;

struct Sqrt;
struct SqrtBuilder;
struct SqrtT;

struct Square;
struct SquareBuilder;
struct SquareT;

struct Ceil;
struct CeilBuilder;
struct CeilT;

struct Log;
struct LogBuilder;
struct LogT;

struct LogGrad;
struct LogGradBuilder;
struct LogGradT;

struct Tan;
struct TanBuilder;
struct TanT;

struct Atan;
struct AtanBuilder;
struct AtanT;

struct Asin;
struct AsinBuilder;
struct AsinT;

struct Reshape;
struct ReshapeBuilder;
struct ReshapeT;

struct Power;
struct PowerBuilder;
struct PowerT;

struct PowerGrad;
struct PowerGradBuilder;
struct PowerGradT;

struct ArgMax;
struct ArgMaxBuilder;
struct ArgMaxT;

struct ArgMin;
struct ArgMinBuilder;
struct ArgMinT;

struct NetOutput;
struct NetOutputBuilder;
struct NetOutputT;

struct MatMul;
struct MatMulBuilder;
struct MatMulT;

struct PReLU;
struct PReLUBuilder;
struct PReLUT;

struct LeakyReLU;
struct LeakyReLUBuilder;
struct LeakyReLUT;

struct StridedSlice;
struct StridedSliceBuilder;
struct StridedSliceT;

struct Stack;
struct StackBuilder;
struct StackT;

struct Range;
struct RangeBuilder;
struct RangeT;

struct ExpandDims;
struct ExpandDimsBuilder;
struct ExpandDimsT;

struct Tile;
struct TileBuilder;
struct TileT;

struct Cast;
struct CastBuilder;
struct CastT;

struct QuantDTypeCast;
struct QuantDTypeCastBuilder;
struct QuantDTypeCastT;

struct Split;
struct SplitBuilder;
struct SplitT;

struct Crop;
struct CropBuilder;
struct CropT;

struct Permute;
struct PermuteBuilder;
struct PermuteT;

struct Clip;
struct ClipBuilder;
struct ClipT;

struct Constant;
struct ConstantBuilder;
struct ConstantT;

struct Elu;
struct EluBuilder;
struct EluT;

struct Broadcast;
struct BroadcastBuilder;
struct BroadcastT;

struct BroadcastTo;
struct BroadcastToBuilder;
struct BroadcastToT;

struct Lrn;
struct LrnBuilder;
struct LrnT;

struct Reduce;
struct ReduceBuilder;
struct ReduceT;

struct Transpose;
struct TransposeBuilder;
struct TransposeT;

struct Squeeze;
struct SqueezeBuilder;
struct SqueezeT;

struct Unsqueeze;
struct UnsqueezeBuilder;
struct UnsqueezeT;

struct Upsample;
struct UpsampleBuilder;
struct UpsampleT;

struct Dropout;
struct DropoutBuilder;
struct DropoutT;

struct LocalResponseNormalization;
struct LocalResponseNormalizationBuilder;
struct LocalResponseNormalizationT;

struct ZerosLike;
struct ZerosLikeBuilder;
struct ZerosLikeT;

struct TopK;
struct TopKBuilder;
struct TopKT;

struct SpaceToDepth;
struct SpaceToDepthBuilder;
struct SpaceToDepthT;

struct SpaceToBatch;
struct SpaceToBatchBuilder;
struct SpaceToBatchT;

struct SparseToDense;
struct SparseToDenseBuilder;
struct SparseToDenseT;

struct ReverseSequence;
struct ReverseSequenceBuilder;
struct ReverseSequenceT;

struct Rank;
struct RankBuilder;
struct RankT;

struct Gather;
struct GatherBuilder;
struct GatherT;

struct GatherNd;
struct GatherNdBuilder;
struct GatherNdT;

struct Fill;
struct FillBuilder;
struct FillT;

struct DepthToSpace;
struct DepthToSpaceBuilder;
struct DepthToSpaceT;

struct BatchToSpace;
struct BatchToSpaceBuilder;
struct BatchToSpaceT;

struct BatchToSpaceND;
struct BatchToSpaceNDBuilder;
struct BatchToSpaceNDT;

struct AddN;
struct AddNBuilder;
struct AddNT;

struct EmbeddingLookup;
struct EmbeddingLookupBuilder;
struct EmbeddingLookupT;

struct EmbeddingLookupSparse;
struct EmbeddingLookupSparseBuilder;
struct EmbeddingLookupSparseT;

struct FloorDiv;
struct FloorDivBuilder;
struct FloorDivT;

struct FloorMod;
struct FloorModBuilder;
struct FloorModT;

struct Mod;
struct ModBuilder;
struct ModT;

struct L2Norm;
struct L2NormBuilder;
struct L2NormT;

struct LogicalAnd;
struct LogicalAndBuilder;
struct LogicalAndT;

struct LogicalOr;
struct LogicalOrBuilder;
struct LogicalOrT;

struct LogicalXor;
struct LogicalXorBuilder;
struct LogicalXorT;

struct LogicalNot;
struct LogicalNotBuilder;
struct LogicalNotT;

struct MatrixDiag;
struct MatrixDiagBuilder;
struct MatrixDiagT;

struct Select;
struct SelectBuilder;
struct SelectT;

struct TfReduce;
struct TfReduceBuilder;
struct TfReduceT;

struct Reverse;
struct ReverseBuilder;
struct ReverseT;

struct Round;
struct RoundBuilder;
struct RoundT;

struct Scatter;
struct ScatterBuilder;
struct ScatterT;

struct ScatterND;
struct ScatterNDBuilder;
struct ScatterNDT;

struct Unique;
struct UniqueBuilder;
struct UniqueT;

struct Unstack;
struct UnstackBuilder;
struct UnstackT;

struct OnnxInt8Quantize;
struct OnnxInt8QuantizeBuilder;
struct OnnxInt8QuantizeT;

struct OnnxInt8Dequantize;
struct OnnxInt8DequantizeBuilder;
struct OnnxInt8DequantizeT;

struct FakeQuantWithMinMax;
struct FakeQuantWithMinMaxBuilder;
struct FakeQuantWithMinMaxT;

struct FakeQuantWithMinMaxPerChannel;
struct FakeQuantWithMinMaxPerChannelBuilder;
struct FakeQuantWithMinMaxPerChannelT;

struct BatchNormFold;
struct BatchNormFoldBuilder;
struct BatchNormFoldT;

struct MulFold;
struct MulFoldBuilder;
struct MulFoldT;

struct AddFold;
struct AddFoldBuilder;
struct AddFoldT;

struct SquaredDifference;
struct SquaredDifferenceBuilder;
struct SquaredDifferenceT;

struct TupleGetItem;
struct TupleGetItemBuilder;
struct TupleGetItemT;

struct ApplyMomentum;
struct ApplyMomentumBuilder;
struct ApplyMomentumT;

struct Sgd;
struct SgdBuilder;
struct SgdT;

struct Adam;
struct AdamBuilder;
struct AdamT;

struct Assign;
struct AssignBuilder;
struct AssignT;

struct AssignAdd;
struct AssignAddBuilder;
struct AssignAddT;

struct Where;
struct WhereBuilder;
struct WhereT;

struct OneHot;
struct OneHotBuilder;
struct OneHotT;

struct Lstm;
struct LstmBuilder;
struct LstmT;

struct PriorBox;
struct PriorBoxBuilder;
struct PriorBoxT;

struct SpaceToBatchND;
struct SpaceToBatchNDBuilder;
struct SpaceToBatchNDT;

struct MakeTuple;
struct MakeTupleBuilder;
struct MakeTupleT;

struct ToFormat;
struct ToFormatBuilder;
struct ToFormatT;

struct Depend;
struct DependBuilder;
struct DependT;

struct ControlDepend;
struct ControlDependBuilder;
struct ControlDependT;

struct Return;
struct ReturnBuilder;
struct ReturnT;

struct Proposal;
struct ProposalBuilder;
struct ProposalT;

struct Custom;
struct CustomBuilder;
struct CustomT;

struct BlackBox;
struct BlackBoxBuilder;
struct BlackBoxT;

struct LshProjection;
struct LshProjectionBuilder;
struct LshProjectionT;

struct HashtableLookup;
struct HashtableLookupBuilder;
struct HashtableLookupT;

struct SkipGram;
struct SkipGramBuilder;
struct SkipGramT;

struct CustomPredict;
struct CustomPredictBuilder;
struct CustomPredictT;

struct CustomNormalize;
struct CustomNormalizeBuilder;
struct CustomNormalizeT;

struct CustomExtractFeatures;
struct CustomExtractFeaturesBuilder;
struct CustomExtractFeaturesT;

struct AudioSpectrogram;
struct AudioSpectrogramBuilder;
struct AudioSpectrogramT;

struct Mfcc;
struct MfccBuilder;
struct MfccT;

struct Rfft;
struct RfftBuilder;
struct RfftT;

struct FftReal;
struct FftRealBuilder;
struct FftRealT;

struct FftImag;
struct FftImagBuilder;
struct FftImagT;

struct DropoutGrad;
struct DropoutGradBuilder;
struct DropoutGradT;

struct MaximumGrad;
struct MaximumGradBuilder;
struct MaximumGradT;

struct MinimumGrad;
struct MinimumGradBuilder;
struct MinimumGradT;

struct NonMaxSuppression;
struct NonMaxSuppressionBuilder;
struct NonMaxSuppressionT;

struct InstanceNorm;
struct InstanceNormBuilder;
struct InstanceNormT;

struct Loop;
struct LoopBuilder;
struct LoopT;

struct Identity;
struct IdentityBuilder;
struct IdentityT;

struct LayerNorm;
struct LayerNormBuilder;
struct LayerNormT;

struct While;
struct WhileBuilder;
struct WhileT;

struct UnsortedSegmentSum;
struct UnsortedSegmentSumBuilder;
struct UnsortedSegmentSumT;

struct OnesLike;
struct OnesLikeBuilder;
struct OnesLikeT;

struct BinaryCrossEntropy;
struct BinaryCrossEntropyBuilder;
struct BinaryCrossEntropyT;

struct BinaryCrossEntropyGrad;
struct BinaryCrossEntropyGradBuilder;
struct BinaryCrossEntropyGradT;

struct LpNormalization;
struct LpNormalizationBuilder;
struct LpNormalizationT;

struct Switch;
struct SwitchBuilder;
struct SwitchT;

struct Partial;
struct PartialBuilder;
struct PartialT;

struct TensorListFromTensor;
struct TensorListFromTensorBuilder;
struct TensorListFromTensorT;

struct TensorListStack;
struct TensorListStackBuilder;
struct TensorListStackT;

struct TensorListGetItem;
struct TensorListGetItemBuilder;
struct TensorListGetItemT;

struct TensorListSetItem;
struct TensorListSetItemBuilder;
struct TensorListSetItemT;

struct TensorListReserve;
struct TensorListReserveBuilder;
struct TensorListReserveT;

struct All;
struct AllBuilder;
struct AllT;

struct Assert;
struct AssertBuilder;
struct AssertT;

struct SmoothL1Loss;
struct SmoothL1LossBuilder;
struct SmoothL1LossT;

struct SmoothL1LossGrad;
struct SmoothL1LossGradBuilder;
struct SmoothL1LossGradT;

struct SigmoidCrossEntropyWithLogits;
struct SigmoidCrossEntropyWithLogitsBuilder;
struct SigmoidCrossEntropyWithLogitsT;

struct SigmoidCrossEntropyWithLogitsGrad;
struct SigmoidCrossEntropyWithLogitsGradBuilder;
struct SigmoidCrossEntropyWithLogitsGradT;

struct Reciprocal;
struct ReciprocalBuilder;
struct ReciprocalT;

struct Merge;
struct MergeBuilder;
struct MergeT;

struct GeLU;
struct GeLUBuilder;
struct GeLUT;

inline const flatbuffers::TypeTable *PadTypeTable();

inline const flatbuffers::TypeTable *MaximumTypeTable();

inline const flatbuffers::TypeTable *MinimumTypeTable();

inline const flatbuffers::TypeTable *FlattenTypeTable();

inline const flatbuffers::TypeTable *FlattenGradTypeTable();

inline const flatbuffers::TypeTable *ConcatTypeTable();

inline const flatbuffers::TypeTable *SoftMaxTypeTable();

inline const flatbuffers::TypeTable *ActivationTypeTable();

inline const flatbuffers::TypeTable *ActivationGradTypeTable();

inline const flatbuffers::TypeTable *Conv2DTypeTable();

inline const flatbuffers::TypeTable *AdderTypeTable();

inline const flatbuffers::TypeTable *Conv2DGradFilterTypeTable();

inline const flatbuffers::TypeTable *Conv2DGradInputTypeTable();

inline const flatbuffers::TypeTable *GroupConv2DGradInputTypeTable();

inline const flatbuffers::TypeTable *FusedBatchNormTypeTable();

inline const flatbuffers::TypeTable *BatchNormTypeTable();

inline const flatbuffers::TypeTable *BiasGradTypeTable();

inline const flatbuffers::TypeTable *SoftmaxCrossEntropyTypeTable();

inline const flatbuffers::TypeTable *SparseSoftmaxCrossEntropyTypeTable();

inline const flatbuffers::TypeTable *make_tupleTypeTable();

inline const flatbuffers::TypeTable *PoolingGradTypeTable();

inline const flatbuffers::TypeTable *ShapeTypeTable();

inline const flatbuffers::TypeTable *ConstantOfShapeTypeTable();

inline const flatbuffers::TypeTable *Nchw2NhwcTypeTable();

inline const flatbuffers::TypeTable *Nhwc2NchwTypeTable();

inline const flatbuffers::TypeTable *FakeQuantWithMinMaxVarsTypeTable();

inline const flatbuffers::TypeTable *BiasAddTypeTable();

inline const flatbuffers::TypeTable *ROIPoolingTypeTable();

inline const flatbuffers::TypeTable *PoolingTypeTable();

inline const flatbuffers::TypeTable *DepthwiseConv2DTypeTable();

inline const flatbuffers::TypeTable *DeDepthwiseConv2DTypeTable();

inline const flatbuffers::TypeTable *ResizeTypeTable();

inline const flatbuffers::TypeTable *DetectionPostProcessTypeTable();

inline const flatbuffers::TypeTable *FullConnectionTypeTable();

inline const flatbuffers::TypeTable *MeanTypeTable();

inline const flatbuffers::TypeTable *DeConv2DTypeTable();

inline const flatbuffers::TypeTable *DeConv2DGradFilterTypeTable();

inline const flatbuffers::TypeTable *BNGradTypeTable();

inline const flatbuffers::TypeTable *ScaleTypeTable();

inline const flatbuffers::TypeTable *EltwiseTypeTable();

inline const flatbuffers::TypeTable *AddTypeTable();

inline const flatbuffers::TypeTable *SubTypeTable();

inline const flatbuffers::TypeTable *MulTypeTable();

inline const flatbuffers::TypeTable *DivTypeTable();

inline const flatbuffers::TypeTable *AddGradTypeTable();

inline const flatbuffers::TypeTable *SubGradTypeTable();

inline const flatbuffers::TypeTable *MulGradTypeTable();

inline const flatbuffers::TypeTable *DivGradTypeTable();

inline const flatbuffers::TypeTable *RealDivTypeTable();

inline const flatbuffers::TypeTable *RsqrtTypeTable();

inline const flatbuffers::TypeTable *EqualTypeTable();

inline const flatbuffers::TypeTable *LessTypeTable();

inline const flatbuffers::TypeTable *GreaterTypeTable();

inline const flatbuffers::TypeTable *NotEqualTypeTable();

inline const flatbuffers::TypeTable *LessEqualTypeTable();

inline const flatbuffers::TypeTable *GreaterEqualTypeTable();

inline const flatbuffers::TypeTable *MinTypeTable();

inline const flatbuffers::TypeTable *SliceTypeTable();

inline const flatbuffers::TypeTable *FloorTypeTable();

inline const flatbuffers::TypeTable *AbsTypeTable();

inline const flatbuffers::TypeTable *NegTypeTable();

inline const flatbuffers::TypeTable *NegGradTypeTable();

inline const flatbuffers::TypeTable *ExpTypeTable();

inline const flatbuffers::TypeTable *CosTypeTable();

inline const flatbuffers::TypeTable *SinTypeTable();

inline const flatbuffers::TypeTable *SqrtTypeTable();

inline const flatbuffers::TypeTable *SquareTypeTable();

inline const flatbuffers::TypeTable *CeilTypeTable();

inline const flatbuffers::TypeTable *LogTypeTable();

inline const flatbuffers::TypeTable *LogGradTypeTable();

inline const flatbuffers::TypeTable *TanTypeTable();

inline const flatbuffers::TypeTable *AtanTypeTable();

inline const flatbuffers::TypeTable *AsinTypeTable();

inline const flatbuffers::TypeTable *ReshapeTypeTable();

inline const flatbuffers::TypeTable *PowerTypeTable();

inline const flatbuffers::TypeTable *PowerGradTypeTable();

inline const flatbuffers::TypeTable *ArgMaxTypeTable();

inline const flatbuffers::TypeTable *ArgMinTypeTable();

inline const flatbuffers::TypeTable *NetOutputTypeTable();

inline const flatbuffers::TypeTable *MatMulTypeTable();

inline const flatbuffers::TypeTable *PReLUTypeTable();

inline const flatbuffers::TypeTable *LeakyReLUTypeTable();

inline const flatbuffers::TypeTable *StridedSliceTypeTable();

inline const flatbuffers::TypeTable *StackTypeTable();

inline const flatbuffers::TypeTable *RangeTypeTable();

inline const flatbuffers::TypeTable *ExpandDimsTypeTable();

inline const flatbuffers::TypeTable *TileTypeTable();

inline const flatbuffers::TypeTable *CastTypeTable();

inline const flatbuffers::TypeTable *QuantDTypeCastTypeTable();

inline const flatbuffers::TypeTable *SplitTypeTable();

inline const flatbuffers::TypeTable *CropTypeTable();

inline const flatbuffers::TypeTable *PermuteTypeTable();

inline const flatbuffers::TypeTable *ClipTypeTable();

inline const flatbuffers::TypeTable *ConstantTypeTable();

inline const flatbuffers::TypeTable *EluTypeTable();

inline const flatbuffers::TypeTable *BroadcastTypeTable();

inline const flatbuffers::TypeTable *BroadcastToTypeTable();

inline const flatbuffers::TypeTable *LrnTypeTable();

inline const flatbuffers::TypeTable *ReduceTypeTable();

inline const flatbuffers::TypeTable *TransposeTypeTable();

inline const flatbuffers::TypeTable *SqueezeTypeTable();

inline const flatbuffers::TypeTable *UnsqueezeTypeTable();

inline const flatbuffers::TypeTable *UpsampleTypeTable();

inline const flatbuffers::TypeTable *DropoutTypeTable();

inline const flatbuffers::TypeTable *LocalResponseNormalizationTypeTable();

inline const flatbuffers::TypeTable *ZerosLikeTypeTable();

inline const flatbuffers::TypeTable *TopKTypeTable();

inline const flatbuffers::TypeTable *SpaceToDepthTypeTable();

inline const flatbuffers::TypeTable *SpaceToBatchTypeTable();

inline const flatbuffers::TypeTable *SparseToDenseTypeTable();

inline const flatbuffers::TypeTable *ReverseSequenceTypeTable();

inline const flatbuffers::TypeTable *RankTypeTable();

inline const flatbuffers::TypeTable *GatherTypeTable();

inline const flatbuffers::TypeTable *GatherNdTypeTable();

inline const flatbuffers::TypeTable *FillTypeTable();

inline const flatbuffers::TypeTable *DepthToSpaceTypeTable();

inline const flatbuffers::TypeTable *BatchToSpaceTypeTable();

inline const flatbuffers::TypeTable *BatchToSpaceNDTypeTable();

inline const flatbuffers::TypeTable *AddNTypeTable();

inline const flatbuffers::TypeTable *EmbeddingLookupTypeTable();

inline const flatbuffers::TypeTable *EmbeddingLookupSparseTypeTable();

inline const flatbuffers::TypeTable *FloorDivTypeTable();

inline const flatbuffers::TypeTable *FloorModTypeTable();

inline const flatbuffers::TypeTable *ModTypeTable();

inline const flatbuffers::TypeTable *L2NormTypeTable();

inline const flatbuffers::TypeTable *LogicalAndTypeTable();

inline const flatbuffers::TypeTable *LogicalOrTypeTable();

inline const flatbuffers::TypeTable *LogicalXorTypeTable();

inline const flatbuffers::TypeTable *LogicalNotTypeTable();

inline const flatbuffers::TypeTable *MatrixDiagTypeTable();

inline const flatbuffers::TypeTable *SelectTypeTable();

inline const flatbuffers::TypeTable *TfReduceTypeTable();

inline const flatbuffers::TypeTable *ReverseTypeTable();

inline const flatbuffers::TypeTable *RoundTypeTable();

inline const flatbuffers::TypeTable *ScatterTypeTable();

inline const flatbuffers::TypeTable *ScatterNDTypeTable();

inline const flatbuffers::TypeTable *UniqueTypeTable();

inline const flatbuffers::TypeTable *UnstackTypeTable();

inline const flatbuffers::TypeTable *OnnxInt8QuantizeTypeTable();

inline const flatbuffers::TypeTable *OnnxInt8DequantizeTypeTable();

inline const flatbuffers::TypeTable *FakeQuantWithMinMaxTypeTable();

inline const flatbuffers::TypeTable *FakeQuantWithMinMaxPerChannelTypeTable();

inline const flatbuffers::TypeTable *BatchNormFoldTypeTable();

inline const flatbuffers::TypeTable *MulFoldTypeTable();

inline const flatbuffers::TypeTable *AddFoldTypeTable();

inline const flatbuffers::TypeTable *SquaredDifferenceTypeTable();

inline const flatbuffers::TypeTable *TupleGetItemTypeTable();

inline const flatbuffers::TypeTable *ApplyMomentumTypeTable();

inline const flatbuffers::TypeTable *SgdTypeTable();

inline const flatbuffers::TypeTable *AdamTypeTable();

inline const flatbuffers::TypeTable *AssignTypeTable();

inline const flatbuffers::TypeTable *AssignAddTypeTable();

inline const flatbuffers::TypeTable *WhereTypeTable();

inline const flatbuffers::TypeTable *OneHotTypeTable();

inline const flatbuffers::TypeTable *LstmTypeTable();

inline const flatbuffers::TypeTable *PriorBoxTypeTable();

inline const flatbuffers::TypeTable *SpaceToBatchNDTypeTable();

inline const flatbuffers::TypeTable *MakeTupleTypeTable();

inline const flatbuffers::TypeTable *ToFormatTypeTable();

inline const flatbuffers::TypeTable *DependTypeTable();

inline const flatbuffers::TypeTable *ControlDependTypeTable();

inline const flatbuffers::TypeTable *ReturnTypeTable();

inline const flatbuffers::TypeTable *ProposalTypeTable();

inline const flatbuffers::TypeTable *CustomTypeTable();

inline const flatbuffers::TypeTable *BlackBoxTypeTable();

inline const flatbuffers::TypeTable *LshProjectionTypeTable();

inline const flatbuffers::TypeTable *HashtableLookupTypeTable();

inline const flatbuffers::TypeTable *SkipGramTypeTable();

inline const flatbuffers::TypeTable *CustomPredictTypeTable();

inline const flatbuffers::TypeTable *CustomNormalizeTypeTable();

inline const flatbuffers::TypeTable *CustomExtractFeaturesTypeTable();

inline const flatbuffers::TypeTable *AudioSpectrogramTypeTable();

inline const flatbuffers::TypeTable *MfccTypeTable();

inline const flatbuffers::TypeTable *RfftTypeTable();

inline const flatbuffers::TypeTable *FftRealTypeTable();

inline const flatbuffers::TypeTable *FftImagTypeTable();

inline const flatbuffers::TypeTable *DropoutGradTypeTable();

inline const flatbuffers::TypeTable *MaximumGradTypeTable();

inline const flatbuffers::TypeTable *MinimumGradTypeTable();

inline const flatbuffers::TypeTable *NonMaxSuppressionTypeTable();

inline const flatbuffers::TypeTable *InstanceNormTypeTable();

inline const flatbuffers::TypeTable *LoopTypeTable();

inline const flatbuffers::TypeTable *IdentityTypeTable();

inline const flatbuffers::TypeTable *LayerNormTypeTable();

inline const flatbuffers::TypeTable *WhileTypeTable();

inline const flatbuffers::TypeTable *UnsortedSegmentSumTypeTable();

inline const flatbuffers::TypeTable *OnesLikeTypeTable();

inline const flatbuffers::TypeTable *BinaryCrossEntropyTypeTable();

inline const flatbuffers::TypeTable *BinaryCrossEntropyGradTypeTable();

inline const flatbuffers::TypeTable *LpNormalizationTypeTable();

inline const flatbuffers::TypeTable *SwitchTypeTable();

inline const flatbuffers::TypeTable *PartialTypeTable();

inline const flatbuffers::TypeTable *TensorListFromTensorTypeTable();

inline const flatbuffers::TypeTable *TensorListStackTypeTable();

inline const flatbuffers::TypeTable *TensorListGetItemTypeTable();

inline const flatbuffers::TypeTable *TensorListSetItemTypeTable();

inline const flatbuffers::TypeTable *TensorListReserveTypeTable();

inline const flatbuffers::TypeTable *AllTypeTable();

inline const flatbuffers::TypeTable *AssertTypeTable();

inline const flatbuffers::TypeTable *SmoothL1LossTypeTable();

inline const flatbuffers::TypeTable *SmoothL1LossGradTypeTable();

inline const flatbuffers::TypeTable *SigmoidCrossEntropyWithLogitsTypeTable();

inline const flatbuffers::TypeTable *SigmoidCrossEntropyWithLogitsGradTypeTable();

inline const flatbuffers::TypeTable *ReciprocalTypeTable();

inline const flatbuffers::TypeTable *MergeTypeTable();

inline const flatbuffers::TypeTable *GeLUTypeTable();

enum ResizeMethod : int8_t {
  ResizeMethod_UNKNOWN = -1,
  ResizeMethod_LINEAR = 0,
  ResizeMethod_NEAREST = 1,
  ResizeMethod_CUBIC = 2,
  ResizeMethod_MIN = ResizeMethod_UNKNOWN,
  ResizeMethod_MAX = ResizeMethod_CUBIC
};

inline const ResizeMethod (&EnumValuesResizeMethod())[4] {
  static const ResizeMethod values[] = {
    ResizeMethod_UNKNOWN,
    ResizeMethod_LINEAR,
    ResizeMethod_NEAREST,
    ResizeMethod_CUBIC
  };
  return values;
}

inline const char * const *EnumNamesResizeMethod() {
  static const char * const names[5] = {
    "UNKNOWN",
    "LINEAR",
    "NEAREST",
    "CUBIC",
    nullptr
  };
  return names;
}

inline const char *EnumNameResizeMethod(ResizeMethod e) {
  if (flatbuffers::IsOutRange(e, ResizeMethod_UNKNOWN, ResizeMethod_CUBIC)) return "";
  const size_t index = static_cast<size_t>(e) - static_cast<size_t>(ResizeMethod_UNKNOWN);
  return EnumNamesResizeMethod()[index];
}

enum CoordinateTransformMode : int8_t {
  CoordinateTransformMode_COMMON = 0,
  CoordinateTransformMode_HALF_PIXEL = 1,
  CoordinateTransformMode_PYTORCH_HALF_PIXEL = 2,
  CoordinateTransformMode_TF_HALF_PIXEL = 3,
  CoordinateTransformMode_TF_CROP_AND_RESIZE = 4,
  CoordinateTransformMode_ALIGN_CORNERS = 5,
  CoordinateTransformMode_ASYMMETRIC = 6,
  CoordinateTransformMode_ALIGN_CORNERS_WITH_HALF_PIEXL = 7,
  CoordinateTransformMode_MIN = CoordinateTransformMode_COMMON,
  CoordinateTransformMode_MAX = CoordinateTransformMode_ALIGN_CORNERS_WITH_HALF_PIEXL
};

inline const CoordinateTransformMode (&EnumValuesCoordinateTransformMode())[8] {
  static const CoordinateTransformMode values[] = {
    CoordinateTransformMode_COMMON,
    CoordinateTransformMode_HALF_PIXEL,
    CoordinateTransformMode_PYTORCH_HALF_PIXEL,
    CoordinateTransformMode_TF_HALF_PIXEL,
    CoordinateTransformMode_TF_CROP_AND_RESIZE,
    CoordinateTransformMode_ALIGN_CORNERS,
    CoordinateTransformMode_ASYMMETRIC,
    CoordinateTransformMode_ALIGN_CORNERS_WITH_HALF_PIEXL
  };
  return values;
}

inline const char * const *EnumNamesCoordinateTransformMode() {
  static const char * const names[9] = {
    "COMMON",
    "HALF_PIXEL",
    "PYTORCH_HALF_PIXEL",
    "TF_HALF_PIXEL",
    "TF_CROP_AND_RESIZE",
    "ALIGN_CORNERS",
    "ASYMMETRIC",
    "ALIGN_CORNERS_WITH_HALF_PIEXL",
    nullptr
  };
  return names;
}

inline const char *EnumNameCoordinateTransformMode(CoordinateTransformMode e) {
  if (flatbuffers::IsOutRange(e, CoordinateTransformMode_COMMON, CoordinateTransformMode_ALIGN_CORNERS_WITH_HALF_PIEXL)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesCoordinateTransformMode()[index];
}

enum NearestMode : int8_t {
  NearestMode_NORMAL = 0,
  NearestMode_ROUND_HALF_DOWN = 1,
  NearestMode_ROUND_HALF_UP = 2,
  NearestMode_FLOOR = 3,
  NearestMode_CEIL = 4,
  NearestMode_MIN = NearestMode_NORMAL,
  NearestMode_MAX = NearestMode_CEIL
};

inline const NearestMode (&EnumValuesNearestMode())[5] {
  static const NearestMode values[] = {
    NearestMode_NORMAL,
    NearestMode_ROUND_HALF_DOWN,
    NearestMode_ROUND_HALF_UP,
    NearestMode_FLOOR,
    NearestMode_CEIL
  };
  return values;
}

inline const char * const *EnumNamesNearestMode() {
  static const char * const names[6] = {
    "NORMAL",
    "ROUND_HALF_DOWN",
    "ROUND_HALF_UP",
    "FLOOR",
    "CEIL",
    nullptr
  };
  return names;
}

inline const char *EnumNameNearestMode(NearestMode e) {
  if (flatbuffers::IsOutRange(e, NearestMode_NORMAL, NearestMode_CEIL)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesNearestMode()[index];
}

enum Format : int32_t {
  Format_NCHW = 0,
  Format_NHWC = 1,
  Format_NHWC4 = 2,
  Format_HWKC = 3,
  Format_HWCK = 4,
  Format_KCHW = 5,
  Format_CKHW = 6,
  Format_KHWC = 7,
  Format_CHWK = 8,
  Format_HW = 9,
  Format_HW4 = 10,
  Format_NC = 11,
  Format_NC4 = 12,
  Format_NC4HW4 = 100,
  Format_NUM_OF_FORMAT = 101,
  Format_MIN = Format_NCHW,
  Format_MAX = Format_NUM_OF_FORMAT
};

inline const Format (&EnumValuesFormat())[15] {
  static const Format values[] = {
    Format_NCHW,
    Format_NHWC,
    Format_NHWC4,
    Format_HWKC,
    Format_HWCK,
    Format_KCHW,
    Format_CKHW,
    Format_KHWC,
    Format_CHWK,
    Format_HW,
    Format_HW4,
    Format_NC,
    Format_NC4,
    Format_NC4HW4,
    Format_NUM_OF_FORMAT
  };
  return values;
}

inline const char *EnumNameFormat(Format e) {
  switch (e) {
    case Format_NCHW: return "NCHW";
    case Format_NHWC: return "NHWC";
    case Format_NHWC4: return "NHWC4";
    case Format_HWKC: return "HWKC";
    case Format_HWCK: return "HWCK";
    case Format_KCHW: return "KCHW";
    case Format_CKHW: return "CKHW";
    case Format_KHWC: return "KHWC";
    case Format_CHWK: return "CHWK";
    case Format_HW: return "HW";
    case Format_HW4: return "HW4";
    case Format_NC: return "NC";
    case Format_NC4: return "NC4";
    case Format_NC4HW4: return "NC4HW4";
    case Format_NUM_OF_FORMAT: return "NUM_OF_FORMAT";
    default: return "";
  }
}

enum ActivationType : int8_t {
  ActivationType_NO_ACTIVATION = 0,
  ActivationType_RELU = 1,
  ActivationType_SIGMOID = 2,
  ActivationType_RELU6 = 3,
  ActivationType_ELU = 4,
  ActivationType_LEAKY_RELU = 5,
  ActivationType_ABS = 6,
  ActivationType_RELU1 = 7,
  ActivationType_SOFTSIGN = 8,
  ActivationType_SOFTPLUS = 9,
  ActivationType_TANH = 10,
  ActivationType_SELU = 11,
  ActivationType_HSWISH = 12,
  ActivationType_HSIGMOID = 13,
  ActivationType_THRESHOLDRELU = 14,
  ActivationType_LINEAR = 15,
  ActivationType_HARD_TANH = 16,
  ActivationType_SIGN = 17,
  ActivationType_SWISH = 18,
  ActivationType_UNKNOWN = 19,
  ActivationType_MIN = ActivationType_NO_ACTIVATION,
  ActivationType_MAX = ActivationType_UNKNOWN
};

inline const ActivationType (&EnumValuesActivationType())[20] {
  static const ActivationType values[] = {
    ActivationType_NO_ACTIVATION,
    ActivationType_RELU,
    ActivationType_SIGMOID,
    ActivationType_RELU6,
    ActivationType_ELU,
    ActivationType_LEAKY_RELU,
    ActivationType_ABS,
    ActivationType_RELU1,
    ActivationType_SOFTSIGN,
    ActivationType_SOFTPLUS,
    ActivationType_TANH,
    ActivationType_SELU,
    ActivationType_HSWISH,
    ActivationType_HSIGMOID,
    ActivationType_THRESHOLDRELU,
    ActivationType_LINEAR,
    ActivationType_HARD_TANH,
    ActivationType_SIGN,
    ActivationType_SWISH,
    ActivationType_UNKNOWN
  };
  return values;
}

inline const char * const *EnumNamesActivationType() {
  static const char * const names[21] = {
    "NO_ACTIVATION",
    "RELU",
    "SIGMOID",
    "RELU6",
    "ELU",
    "LEAKY_RELU",
    "ABS",
    "RELU1",
    "SOFTSIGN",
    "SOFTPLUS",
    "TANH",
    "SELU",
    "HSWISH",
    "HSIGMOID",
    "THRESHOLDRELU",
    "LINEAR",
    "HARD_TANH",
    "SIGN",
    "SWISH",
    "UNKNOWN",
    nullptr
  };
  return names;
}

inline const char *EnumNameActivationType(ActivationType e) {
  if (flatbuffers::IsOutRange(e, ActivationType_NO_ACTIVATION, ActivationType_UNKNOWN)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesActivationType()[index];
}

enum ReduceType : int8_t {
  ReduceType_REDUCE_MAX = 0,
  ReduceType_REDUCE_MEAN = 1,
  ReduceType_REDUCE_ALL = 2,
  ReduceType_REDUCE_ANY = 3,
  ReduceType_REDUCE_LOG_SUM_EXP = 4,
  ReduceType_REDUCE_PROD = 5,
  ReduceType_REDUCE_SUM = 6,
  ReduceType_UNKNOWN = 7,
  ReduceType_MIN = ReduceType_REDUCE_MAX,
  ReduceType_MAX = ReduceType_UNKNOWN
};

inline const ReduceType (&EnumValuesReduceType())[8] {
  static const ReduceType values[] = {
    ReduceType_REDUCE_MAX,
    ReduceType_REDUCE_MEAN,
    ReduceType_REDUCE_ALL,
    ReduceType_REDUCE_ANY,
    ReduceType_REDUCE_LOG_SUM_EXP,
    ReduceType_REDUCE_PROD,
    ReduceType_REDUCE_SUM,
    ReduceType_UNKNOWN
  };
  return values;
}

inline const char * const *EnumNamesReduceType() {
  static const char * const names[9] = {
    "REDUCE_MAX",
    "REDUCE_MEAN",
    "REDUCE_ALL",
    "REDUCE_ANY",
    "REDUCE_LOG_SUM_EXP",
    "REDUCE_PROD",
    "REDUCE_SUM",
    "UNKNOWN",
    nullptr
  };
  return names;
}

inline const char *EnumNameReduceType(ReduceType e) {
  if (flatbuffers::IsOutRange(e, ReduceType_REDUCE_MAX, ReduceType_UNKNOWN)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesReduceType()[index];
}

enum PoolMode : int8_t {
  PoolMode_MAX_POOLING = 0,
  PoolMode_MEAN_POOLING = 1,
  PoolMode_MIN = PoolMode_MAX_POOLING,
  PoolMode_MAX = PoolMode_MEAN_POOLING
};

inline const PoolMode (&EnumValuesPoolMode())[2] {
  static const PoolMode values[] = {
    PoolMode_MAX_POOLING,
    PoolMode_MEAN_POOLING
  };
  return values;
}

inline const char * const *EnumNamesPoolMode() {
  static const char * const names[3] = {
    "MAX_POOLING",
    "MEAN_POOLING",
    nullptr
  };
  return names;
}

inline const char *EnumNamePoolMode(PoolMode e) {
  if (flatbuffers::IsOutRange(e, PoolMode_MAX_POOLING, PoolMode_MEAN_POOLING)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesPoolMode()[index];
}

enum EltwiseMode : int8_t {
  EltwiseMode_PROD = 0,
  EltwiseMode_SUM = 1,
  EltwiseMode_MAXIMUM = 2,
  EltwiseMode_UNKNOWN = 3,
  EltwiseMode_MIN = EltwiseMode_PROD,
  EltwiseMode_MAX = EltwiseMode_UNKNOWN
};

inline const EltwiseMode (&EnumValuesEltwiseMode())[4] {
  static const EltwiseMode values[] = {
    EltwiseMode_PROD,
    EltwiseMode_SUM,
    EltwiseMode_MAXIMUM,
    EltwiseMode_UNKNOWN
  };
  return values;
}

inline const char * const *EnumNamesEltwiseMode() {
  static const char * const names[5] = {
    "PROD",
    "SUM",
    "MAXIMUM",
    "UNKNOWN",
    nullptr
  };
  return names;
}

inline const char *EnumNameEltwiseMode(EltwiseMode e) {
  if (flatbuffers::IsOutRange(e, EltwiseMode_PROD, EltwiseMode_UNKNOWN)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesEltwiseMode()[index];
}

enum PadMode : int8_t {
  PadMode_NOTSET = 0,
  PadMode_SAME_UPPER = 1,
  PadMode_VALID = 2,
  PadMode_CAFFE = 4,
  PadMode_SAME_LOWER = 5,
  PadMode_MIN = PadMode_NOTSET,
  PadMode_MAX = PadMode_SAME_LOWER
};

inline const PadMode (&EnumValuesPadMode())[5] {
  static const PadMode values[] = {
    PadMode_NOTSET,
    PadMode_SAME_UPPER,
    PadMode_VALID,
    PadMode_CAFFE,
    PadMode_SAME_LOWER
  };
  return values;
}

inline const char * const *EnumNamesPadMode() {
  static const char * const names[7] = {
    "NOTSET",
    "SAME_UPPER",
    "VALID",
    "",
    "CAFFE",
    "SAME_LOWER",
    nullptr
  };
  return names;
}

inline const char *EnumNamePadMode(PadMode e) {
  if (flatbuffers::IsOutRange(e, PadMode_NOTSET, PadMode_SAME_LOWER)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesPadMode()[index];
}

enum RoundMode : int8_t {
  RoundMode_FLOOR = 0,
  RoundMode_CEIL = 1,
  RoundMode_MIN = RoundMode_FLOOR,
  RoundMode_MAX = RoundMode_CEIL
};

inline const RoundMode (&EnumValuesRoundMode())[2] {
  static const RoundMode values[] = {
    RoundMode_FLOOR,
    RoundMode_CEIL
  };
  return values;
}

inline const char * const *EnumNamesRoundMode() {
  static const char * const names[3] = {
    "FLOOR",
    "CEIL",
    nullptr
  };
  return names;
}

inline const char *EnumNameRoundMode(RoundMode e) {
  if (flatbuffers::IsOutRange(e, RoundMode_FLOOR, RoundMode_CEIL)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesRoundMode()[index];
}

enum PaddingMode : int8_t {
  PaddingMode_CONSTANT = 0,
  PaddingMode_REFLECT = 1,
  PaddingMode_SYMMETRIC = 2,
  PaddingMode_MODE_RESERVED = 3,
  PaddingMode_MIN = PaddingMode_CONSTANT,
  PaddingMode_MAX = PaddingMode_MODE_RESERVED
};

inline const PaddingMode (&EnumValuesPaddingMode())[4] {
  static const PaddingMode values[] = {
    PaddingMode_CONSTANT,
    PaddingMode_REFLECT,
    PaddingMode_SYMMETRIC,
    PaddingMode_MODE_RESERVED
  };
  return values;
}

inline const char * const *EnumNamesPaddingMode() {
  static const char * const names[5] = {
    "CONSTANT",
    "REFLECT",
    "SYMMETRIC",
    "MODE_RESERVED",
    nullptr
  };
  return names;
}

inline const char *EnumNamePaddingMode(PaddingMode e) {
  if (flatbuffers::IsOutRange(e, PaddingMode_CONSTANT, PaddingMode_MODE_RESERVED)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesPaddingMode()[index];
}

enum LshProjectionType : int8_t {
  LshProjectionType_UNKNOWN = 0,
  LshProjectionType_SPARSE = 1,
  LshProjectionType_DENSE = 2,
  LshProjectionType_MIN = LshProjectionType_UNKNOWN,
  LshProjectionType_MAX = LshProjectionType_DENSE
};

inline const LshProjectionType (&EnumValuesLshProjectionType())[3] {
  static const LshProjectionType values[] = {
    LshProjectionType_UNKNOWN,
    LshProjectionType_SPARSE,
    LshProjectionType_DENSE
  };
  return values;
}

inline const char * const *EnumNamesLshProjectionType() {
  static const char * const names[4] = {
    "UNKNOWN",
    "SPARSE",
    "DENSE",
    nullptr
  };
  return names;
}

inline const char *EnumNameLshProjectionType(LshProjectionType e) {
  if (flatbuffers::IsOutRange(e, LshProjectionType_UNKNOWN, LshProjectionType_DENSE)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesLshProjectionType()[index];
}

enum ReduceMode : int8_t {
  ReduceMode_ReduceMean = 0,
  ReduceMode_ReduceMax = 1,
  ReduceMode_ReduceMin = 2,
  ReduceMode_ReduceProd = 3,
  ReduceMode_ReduceSum = 4,
  ReduceMode_ReduceSumSquare = 5,
  ReduceMode_ReduceASum = 6,
  ReduceMode_ReduceAll = 7,
  ReduceMode_MIN = ReduceMode_ReduceMean,
  ReduceMode_MAX = ReduceMode_ReduceAll
};

inline const ReduceMode (&EnumValuesReduceMode())[8] {
  static const ReduceMode values[] = {
    ReduceMode_ReduceMean,
    ReduceMode_ReduceMax,
    ReduceMode_ReduceMin,
    ReduceMode_ReduceProd,
    ReduceMode_ReduceSum,
    ReduceMode_ReduceSumSquare,
    ReduceMode_ReduceASum,
    ReduceMode_ReduceAll
  };
  return values;
}

inline const char * const *EnumNamesReduceMode() {
  static const char * const names[9] = {
    "ReduceMean",
    "ReduceMax",
    "ReduceMin",
    "ReduceProd",
    "ReduceSum",
    "ReduceSumSquare",
    "ReduceASum",
    "ReduceAll",
    nullptr
  };
  return names;
}

inline const char *EnumNameReduceMode(ReduceMode e) {
  if (flatbuffers::IsOutRange(e, ReduceMode_ReduceMean, ReduceMode_ReduceAll)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesReduceMode()[index];
}

struct PadT : public flatbuffers::NativeTable {
  typedef Pad TableType;
  std::vector<int32_t> paddings{};
  mindspore::schema::v0::PaddingMode paddingMode = mindspore::schema::v0::PaddingMode_CONSTANT;
  float constantValue = 0.0f;
};

struct Pad FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef PadT NativeTableType;
  typedef PadBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return PadTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_PADDINGS = 4,
    VT_PADDINGMODE = 6,
    VT_CONSTANTVALUE = 8
  };
  const flatbuffers::Vector<int32_t> *paddings() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_PADDINGS);
  }
  flatbuffers::Vector<int32_t> *mutable_paddings() {
    return GetPointer<flatbuffers::Vector<int32_t> *>(VT_PADDINGS);
  }
  mindspore::schema::v0::PaddingMode paddingMode() const {
    return static_cast<mindspore::schema::v0::PaddingMode>(GetField<int8_t>(VT_PADDINGMODE, 0));
  }
  bool mutate_paddingMode(mindspore::schema::v0::PaddingMode _paddingMode) {
    return SetField<int8_t>(VT_PADDINGMODE, static_cast<int8_t>(_paddingMode), 0);
  }
  float constantValue() const {
    return GetField<float>(VT_CONSTANTVALUE, 0.0f);
  }
  bool mutate_constantValue(float _constantValue) {
    return SetField<float>(VT_CONSTANTVALUE, _constantValue, 0.0f);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_PADDINGS) &&
           verifier.VerifyVector(paddings()) &&
           VerifyField<int8_t>(verifier, VT_PADDINGMODE) &&
           VerifyField<float>(verifier, VT_CONSTANTVALUE) &&
           verifier.EndTable();
  }
  PadT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(PadT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Pad> Pack(flatbuffers::FlatBufferBuilder &_fbb, const PadT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct PadBuilder {
  typedef Pad Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_paddings(flatbuffers::Offset<flatbuffers::Vector<int32_t>> paddings) {
    fbb_.AddOffset(Pad::VT_PADDINGS, paddings);
  }
  void add_paddingMode(mindspore::schema::v0::PaddingMode paddingMode) {
    fbb_.AddElement<int8_t>(Pad::VT_PADDINGMODE, static_cast<int8_t>(paddingMode), 0);
  }
  void add_constantValue(float constantValue) {
    fbb_.AddElement<float>(Pad::VT_CONSTANTVALUE, constantValue, 0.0f);
  }
  explicit PadBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Pad> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Pad>(end);
    return o;
  }
};

inline flatbuffers::Offset<Pad> CreatePad(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> paddings = 0,
    mindspore::schema::v0::PaddingMode paddingMode = mindspore::schema::v0::PaddingMode_CONSTANT,
    float constantValue = 0.0f) {
  PadBuilder builder_(_fbb);
  builder_.add_constantValue(constantValue);
  builder_.add_paddings(paddings);
  builder_.add_paddingMode(paddingMode);
  return builder_.Finish();
}

inline flatbuffers::Offset<Pad> CreatePadDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<int32_t> *paddings = nullptr,
    mindspore::schema::v0::PaddingMode paddingMode = mindspore::schema::v0::PaddingMode_CONSTANT,
    float constantValue = 0.0f) {
  auto paddings__ = paddings ? _fbb.CreateVector<int32_t>(*paddings) : 0;
  return mindspore::schema::v0::CreatePad(
      _fbb,
      paddings__,
      paddingMode,
      constantValue);
}

flatbuffers::Offset<Pad> CreatePad(flatbuffers::FlatBufferBuilder &_fbb, const PadT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct MaximumT : public flatbuffers::NativeTable {
  typedef Maximum TableType;
};

struct Maximum FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef MaximumT NativeTableType;
  typedef MaximumBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return MaximumTypeTable();
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  MaximumT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(MaximumT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Maximum> Pack(flatbuffers::FlatBufferBuilder &_fbb, const MaximumT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct MaximumBuilder {
  typedef Maximum Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit MaximumBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Maximum> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Maximum>(end);
    return o;
  }
};

inline flatbuffers::Offset<Maximum> CreateMaximum(
    flatbuffers::FlatBufferBuilder &_fbb) {
  MaximumBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<Maximum> CreateMaximum(flatbuffers::FlatBufferBuilder &_fbb, const MaximumT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct MinimumT : public flatbuffers::NativeTable {
  typedef Minimum TableType;
};

struct Minimum FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef MinimumT NativeTableType;
  typedef MinimumBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return MinimumTypeTable();
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  MinimumT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(MinimumT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Minimum> Pack(flatbuffers::FlatBufferBuilder &_fbb, const MinimumT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct MinimumBuilder {
  typedef Minimum Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit MinimumBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Minimum> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Minimum>(end);
    return o;
  }
};

inline flatbuffers::Offset<Minimum> CreateMinimum(
    flatbuffers::FlatBufferBuilder &_fbb) {
  MinimumBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<Minimum> CreateMinimum(flatbuffers::FlatBufferBuilder &_fbb, const MinimumT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct FlattenT : public flatbuffers::NativeTable {
  typedef Flatten TableType;
};

struct Flatten FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef FlattenT NativeTableType;
  typedef FlattenBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return FlattenTypeTable();
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  FlattenT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(FlattenT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Flatten> Pack(flatbuffers::FlatBufferBuilder &_fbb, const FlattenT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct FlattenBuilder {
  typedef Flatten Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit FlattenBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Flatten> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Flatten>(end);
    return o;
  }
};

inline flatbuffers::Offset<Flatten> CreateFlatten(
    flatbuffers::FlatBufferBuilder &_fbb) {
  FlattenBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<Flatten> CreateFlatten(flatbuffers::FlatBufferBuilder &_fbb, const FlattenT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct FlattenGradT : public flatbuffers::NativeTable {
  typedef FlattenGrad TableType;
};

struct FlattenGrad FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef FlattenGradT NativeTableType;
  typedef FlattenGradBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return FlattenGradTypeTable();
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  FlattenGradT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(FlattenGradT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<FlattenGrad> Pack(flatbuffers::FlatBufferBuilder &_fbb, const FlattenGradT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct FlattenGradBuilder {
  typedef FlattenGrad Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit FlattenGradBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<FlattenGrad> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<FlattenGrad>(end);
    return o;
  }
};

inline flatbuffers::Offset<FlattenGrad> CreateFlattenGrad(
    flatbuffers::FlatBufferBuilder &_fbb) {
  FlattenGradBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<FlattenGrad> CreateFlattenGrad(flatbuffers::FlatBufferBuilder &_fbb, const FlattenGradT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ConcatT : public flatbuffers::NativeTable {
  typedef Concat TableType;
  int32_t axis = 0;
  int32_t n = 0;
};

struct Concat FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ConcatT NativeTableType;
  typedef ConcatBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return ConcatTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_AXIS = 4,
    VT_N = 6
  };
  int32_t axis() const {
    return GetField<int32_t>(VT_AXIS, 0);
  }
  bool mutate_axis(int32_t _axis) {
    return SetField<int32_t>(VT_AXIS, _axis, 0);
  }
  int32_t n() const {
    return GetField<int32_t>(VT_N, 0);
  }
  bool mutate_n(int32_t _n) {
    return SetField<int32_t>(VT_N, _n, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_AXIS) &&
           VerifyField<int32_t>(verifier, VT_N) &&
           verifier.EndTable();
  }
  ConcatT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ConcatT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Concat> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ConcatT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ConcatBuilder {
  typedef Concat Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_axis(int32_t axis) {
    fbb_.AddElement<int32_t>(Concat::VT_AXIS, axis, 0);
  }
  void add_n(int32_t n) {
    fbb_.AddElement<int32_t>(Concat::VT_N, n, 0);
  }
  explicit ConcatBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Concat> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Concat>(end);
    return o;
  }
};

inline flatbuffers::Offset<Concat> CreateConcat(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t axis = 0,
    int32_t n = 0) {
  ConcatBuilder builder_(_fbb);
  builder_.add_n(n);
  builder_.add_axis(axis);
  return builder_.Finish();
}

flatbuffers::Offset<Concat> CreateConcat(flatbuffers::FlatBufferBuilder &_fbb, const ConcatT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct SoftMaxT : public flatbuffers::NativeTable {
  typedef SoftMax TableType;
  int32_t axis = -1;
};

struct SoftMax FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef SoftMaxT NativeTableType;
  typedef SoftMaxBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return SoftMaxTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_AXIS = 4
  };
  int32_t axis() const {
    return GetField<int32_t>(VT_AXIS, -1);
  }
  bool mutate_axis(int32_t _axis) {
    return SetField<int32_t>(VT_AXIS, _axis, -1);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_AXIS) &&
           verifier.EndTable();
  }
  SoftMaxT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(SoftMaxT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<SoftMax> Pack(flatbuffers::FlatBufferBuilder &_fbb, const SoftMaxT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct SoftMaxBuilder {
  typedef SoftMax Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_axis(int32_t axis) {
    fbb_.AddElement<int32_t>(SoftMax::VT_AXIS, axis, -1);
  }
  explicit SoftMaxBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<SoftMax> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SoftMax>(end);
    return o;
  }
};

inline flatbuffers::Offset<SoftMax> CreateSoftMax(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t axis = -1) {
  SoftMaxBuilder builder_(_fbb);
  builder_.add_axis(axis);
  return builder_.Finish();
}

flatbuffers::Offset<SoftMax> CreateSoftMax(flatbuffers::FlatBufferBuilder &_fbb, const SoftMaxT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ActivationT : public flatbuffers::NativeTable {
  typedef Activation TableType;
  mindspore::schema::v0::ActivationType type = mindspore::schema::v0::ActivationType_NO_ACTIVATION;
  float alpha = 0.2f;
  float min_val = -1.0f;
  float max_val = 1.0f;
};

struct Activation FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ActivationT NativeTableType;
  typedef ActivationBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return ActivationTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TYPE = 4,
    VT_ALPHA = 6,
    VT_MIN_VAL = 8,
    VT_MAX_VAL = 10
  };
  mindspore::schema::v0::ActivationType type() const {
    return static_cast<mindspore::schema::v0::ActivationType>(GetField<int8_t>(VT_TYPE, 0));
  }
  bool mutate_type(mindspore::schema::v0::ActivationType _type) {
    return SetField<int8_t>(VT_TYPE, static_cast<int8_t>(_type), 0);
  }
  float alpha() const {
    return GetField<float>(VT_ALPHA, 0.2f);
  }
  bool mutate_alpha(float _alpha) {
    return SetField<float>(VT_ALPHA, _alpha, 0.2f);
  }
  float min_val() const {
    return GetField<float>(VT_MIN_VAL, -1.0f);
  }
  bool mutate_min_val(float _min_val) {
    return SetField<float>(VT_MIN_VAL, _min_val, -1.0f);
  }
  float max_val() const {
    return GetField<float>(VT_MAX_VAL, 1.0f);
  }
  bool mutate_max_val(float _max_val) {
    return SetField<float>(VT_MAX_VAL, _max_val, 1.0f);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_TYPE) &&
           VerifyField<float>(verifier, VT_ALPHA) &&
           VerifyField<float>(verifier, VT_MIN_VAL) &&
           VerifyField<float>(verifier, VT_MAX_VAL) &&
           verifier.EndTable();
  }
  ActivationT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ActivationT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Activation> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ActivationT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ActivationBuilder {
  typedef Activation Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_type(mindspore::schema::v0::ActivationType type) {
    fbb_.AddElement<int8_t>(Activation::VT_TYPE, static_cast<int8_t>(type), 0);
  }
  void add_alpha(float alpha) {
    fbb_.AddElement<float>(Activation::VT_ALPHA, alpha, 0.2f);
  }
  void add_min_val(float min_val) {
    fbb_.AddElement<float>(Activation::VT_MIN_VAL, min_val, -1.0f);
  }
  void add_max_val(float max_val) {
    fbb_.AddElement<float>(Activation::VT_MAX_VAL, max_val, 1.0f);
  }
  explicit ActivationBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Activation> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Activation>(end);
    return o;
  }
};

inline flatbuffers::Offset<Activation> CreateActivation(
    flatbuffers::FlatBufferBuilder &_fbb,
    mindspore::schema::v0::ActivationType type = mindspore::schema::v0::ActivationType_NO_ACTIVATION,
    float alpha = 0.2f,
    float min_val = -1.0f,
    float max_val = 1.0f) {
  ActivationBuilder builder_(_fbb);
  builder_.add_max_val(max_val);
  builder_.add_min_val(min_val);
  builder_.add_alpha(alpha);
  builder_.add_type(type);
  return builder_.Finish();
}

flatbuffers::Offset<Activation> CreateActivation(flatbuffers::FlatBufferBuilder &_fbb, const ActivationT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ActivationGradT : public flatbuffers::NativeTable {
  typedef ActivationGrad TableType;
  mindspore::schema::v0::ActivationType type = mindspore::schema::v0::ActivationType_NO_ACTIVATION;
  float alpha = 0.2f;
};

struct ActivationGrad FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ActivationGradT NativeTableType;
  typedef ActivationGradBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return ActivationGradTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TYPE = 4,
    VT_ALPHA = 6
  };
  mindspore::schema::v0::ActivationType type() const {
    return static_cast<mindspore::schema::v0::ActivationType>(GetField<int8_t>(VT_TYPE, 0));
  }
  bool mutate_type(mindspore::schema::v0::ActivationType _type) {
    return SetField<int8_t>(VT_TYPE, static_cast<int8_t>(_type), 0);
  }
  float alpha() const {
    return GetField<float>(VT_ALPHA, 0.2f);
  }
  bool mutate_alpha(float _alpha) {
    return SetField<float>(VT_ALPHA, _alpha, 0.2f);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_TYPE) &&
           VerifyField<float>(verifier, VT_ALPHA) &&
           verifier.EndTable();
  }
  ActivationGradT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ActivationGradT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<ActivationGrad> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ActivationGradT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ActivationGradBuilder {
  typedef ActivationGrad Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_type(mindspore::schema::v0::ActivationType type) {
    fbb_.AddElement<int8_t>(ActivationGrad::VT_TYPE, static_cast<int8_t>(type), 0);
  }
  void add_alpha(float alpha) {
    fbb_.AddElement<float>(ActivationGrad::VT_ALPHA, alpha, 0.2f);
  }
  explicit ActivationGradBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<ActivationGrad> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ActivationGrad>(end);
    return o;
  }
};

inline flatbuffers::Offset<ActivationGrad> CreateActivationGrad(
    flatbuffers::FlatBufferBuilder &_fbb,
    mindspore::schema::v0::ActivationType type = mindspore::schema::v0::ActivationType_NO_ACTIVATION,
    float alpha = 0.2f) {
  ActivationGradBuilder builder_(_fbb);
  builder_.add_alpha(alpha);
  builder_.add_type(type);
  return builder_.Finish();
}

flatbuffers::Offset<ActivationGrad> CreateActivationGrad(flatbuffers::FlatBufferBuilder &_fbb, const ActivationGradT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct Conv2DT : public flatbuffers::NativeTable {
  typedef Conv2D TableType;
  mindspore::schema::v0::Format format = mindspore::schema::v0::Format_NCHW;
  int32_t group = 0;
  int32_t channelIn = 0;
  int32_t channelOut = 0;
  int32_t kernelW = 0;
  int32_t kernelH = 0;
  int32_t strideW = 0;
  int32_t strideH = 0;
  mindspore::schema::v0::PadMode padMode = mindspore::schema::v0::PadMode_NOTSET;
  int32_t padUp = 0;
  int32_t padDown = 0;
  int32_t padLeft = 0;
  int32_t padRight = 0;
  int32_t dilateW = 0;
  int32_t dilateH = 0;
  bool hasBias = false;
  mindspore::schema::v0::ActivationType activationType = mindspore::schema::v0::ActivationType_NO_ACTIVATION;
};

struct Conv2D FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef Conv2DT NativeTableType;
  typedef Conv2DBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return Conv2DTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_FORMAT = 4,
    VT_GROUP = 6,
    VT_CHANNELIN = 8,
    VT_CHANNELOUT = 10,
    VT_KERNELW = 12,
    VT_KERNELH = 14,
    VT_STRIDEW = 16,
    VT_STRIDEH = 18,
    VT_PADMODE = 20,
    VT_PADUP = 22,
    VT_PADDOWN = 24,
    VT_PADLEFT = 26,
    VT_PADRIGHT = 28,
    VT_DILATEW = 30,
    VT_DILATEH = 32,
    VT_HASBIAS = 34,
    VT_ACTIVATIONTYPE = 36
  };
  mindspore::schema::v0::Format format() const {
    return static_cast<mindspore::schema::v0::Format>(GetField<int32_t>(VT_FORMAT, 0));
  }
  bool mutate_format(mindspore::schema::v0::Format _format) {
    return SetField<int32_t>(VT_FORMAT, static_cast<int32_t>(_format), 0);
  }
  int32_t group() const {
    return GetField<int32_t>(VT_GROUP, 0);
  }
  bool mutate_group(int32_t _group) {
    return SetField<int32_t>(VT_GROUP, _group, 0);
  }
  int32_t channelIn() const {
    return GetField<int32_t>(VT_CHANNELIN, 0);
  }
  bool mutate_channelIn(int32_t _channelIn) {
    return SetField<int32_t>(VT_CHANNELIN, _channelIn, 0);
  }
  int32_t channelOut() const {
    return GetField<int32_t>(VT_CHANNELOUT, 0);
  }
  bool mutate_channelOut(int32_t _channelOut) {
    return SetField<int32_t>(VT_CHANNELOUT, _channelOut, 0);
  }
  int32_t kernelW() const {
    return GetField<int32_t>(VT_KERNELW, 0);
  }
  bool mutate_kernelW(int32_t _kernelW) {
    return SetField<int32_t>(VT_KERNELW, _kernelW, 0);
  }
  int32_t kernelH() const {
    return GetField<int32_t>(VT_KERNELH, 0);
  }
  bool mutate_kernelH(int32_t _kernelH) {
    return SetField<int32_t>(VT_KERNELH, _kernelH, 0);
  }
  int32_t strideW() const {
    return GetField<int32_t>(VT_STRIDEW, 0);
  }
  bool mutate_strideW(int32_t _strideW) {
    return SetField<int32_t>(VT_STRIDEW, _strideW, 0);
  }
  int32_t strideH() const {
    return GetField<int32_t>(VT_STRIDEH, 0);
  }
  bool mutate_strideH(int32_t _strideH) {
    return SetField<int32_t>(VT_STRIDEH, _strideH, 0);
  }
  mindspore::schema::v0::PadMode padMode() const {
    return static_cast<mindspore::schema::v0::PadMode>(GetField<int8_t>(VT_PADMODE, 0));
  }
  bool mutate_padMode(mindspore::schema::v0::PadMode _padMode) {
    return SetField<int8_t>(VT_PADMODE, static_cast<int8_t>(_padMode), 0);
  }
  int32_t padUp() const {
    return GetField<int32_t>(VT_PADUP, 0);
  }
  bool mutate_padUp(int32_t _padUp) {
    return SetField<int32_t>(VT_PADUP, _padUp, 0);
  }
  int32_t padDown() const {
    return GetField<int32_t>(VT_PADDOWN, 0);
  }
  bool mutate_padDown(int32_t _padDown) {
    return SetField<int32_t>(VT_PADDOWN, _padDown, 0);
  }
  int32_t padLeft() const {
    return GetField<int32_t>(VT_PADLEFT, 0);
  }
  bool mutate_padLeft(int32_t _padLeft) {
    return SetField<int32_t>(VT_PADLEFT, _padLeft, 0);
  }
  int32_t padRight() const {
    return GetField<int32_t>(VT_PADRIGHT, 0);
  }
  bool mutate_padRight(int32_t _padRight) {
    return SetField<int32_t>(VT_PADRIGHT, _padRight, 0);
  }
  int32_t dilateW() const {
    return GetField<int32_t>(VT_DILATEW, 0);
  }
  bool mutate_dilateW(int32_t _dilateW) {
    return SetField<int32_t>(VT_DILATEW, _dilateW, 0);
  }
  int32_t dilateH() const {
    return GetField<int32_t>(VT_DILATEH, 0);
  }
  bool mutate_dilateH(int32_t _dilateH) {
    return SetField<int32_t>(VT_DILATEH, _dilateH, 0);
  }
  bool hasBias() const {
    return GetField<uint8_t>(VT_HASBIAS, 0) != 0;
  }
  bool mutate_hasBias(bool _hasBias) {
    return SetField<uint8_t>(VT_HASBIAS, static_cast<uint8_t>(_hasBias), 0);
  }
  mindspore::schema::v0::ActivationType activationType() const {
    return static_cast<mindspore::schema::v0::ActivationType>(GetField<int8_t>(VT_ACTIVATIONTYPE, 0));
  }
  bool mutate_activationType(mindspore::schema::v0::ActivationType _activationType) {
    return SetField<int8_t>(VT_ACTIVATIONTYPE, static_cast<int8_t>(_activationType), 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_FORMAT) &&
           VerifyField<int32_t>(verifier, VT_GROUP) &&
           VerifyField<int32_t>(verifier, VT_CHANNELIN) &&
           VerifyField<int32_t>(verifier, VT_CHANNELOUT) &&
           VerifyField<int32_t>(verifier, VT_KERNELW) &&
           VerifyField<int32_t>(verifier, VT_KERNELH) &&
           VerifyField<int32_t>(verifier, VT_STRIDEW) &&
           VerifyField<int32_t>(verifier, VT_STRIDEH) &&
           VerifyField<int8_t>(verifier, VT_PADMODE) &&
           VerifyField<int32_t>(verifier, VT_PADUP) &&
           VerifyField<int32_t>(verifier, VT_PADDOWN) &&
           VerifyField<int32_t>(verifier, VT_PADLEFT) &&
           VerifyField<int32_t>(verifier, VT_PADRIGHT) &&
           VerifyField<int32_t>(verifier, VT_DILATEW) &&
           VerifyField<int32_t>(verifier, VT_DILATEH) &&
           VerifyField<uint8_t>(verifier, VT_HASBIAS) &&
           VerifyField<int8_t>(verifier, VT_ACTIVATIONTYPE) &&
           verifier.EndTable();
  }
  Conv2DT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(Conv2DT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Conv2D> Pack(flatbuffers::FlatBufferBuilder &_fbb, const Conv2DT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct Conv2DBuilder {
  typedef Conv2D Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_format(mindspore::schema::v0::Format format) {
    fbb_.AddElement<int32_t>(Conv2D::VT_FORMAT, static_cast<int32_t>(format), 0);
  }
  void add_group(int32_t group) {
    fbb_.AddElement<int32_t>(Conv2D::VT_GROUP, group, 0);
  }
  void add_channelIn(int32_t channelIn) {
    fbb_.AddElement<int32_t>(Conv2D::VT_CHANNELIN, channelIn, 0);
  }
  void add_channelOut(int32_t channelOut) {
    fbb_.AddElement<int32_t>(Conv2D::VT_CHANNELOUT, channelOut, 0);
  }
  void add_kernelW(int32_t kernelW) {
    fbb_.AddElement<int32_t>(Conv2D::VT_KERNELW, kernelW, 0);
  }
  void add_kernelH(int32_t kernelH) {
    fbb_.AddElement<int32_t>(Conv2D::VT_KERNELH, kernelH, 0);
  }
  void add_strideW(int32_t strideW) {
    fbb_.AddElement<int32_t>(Conv2D::VT_STRIDEW, strideW, 0);
  }
  void add_strideH(int32_t strideH) {
    fbb_.AddElement<int32_t>(Conv2D::VT_STRIDEH, strideH, 0);
  }
  void add_padMode(mindspore::schema::v0::PadMode padMode) {
    fbb_.AddElement<int8_t>(Conv2D::VT_PADMODE, static_cast<int8_t>(padMode), 0);
  }
  void add_padUp(int32_t padUp) {
    fbb_.AddElement<int32_t>(Conv2D::VT_PADUP, padUp, 0);
  }
  void add_padDown(int32_t padDown) {
    fbb_.AddElement<int32_t>(Conv2D::VT_PADDOWN, padDown, 0);
  }
  void add_padLeft(int32_t padLeft) {
    fbb_.AddElement<int32_t>(Conv2D::VT_PADLEFT, padLeft, 0);
  }
  void add_padRight(int32_t padRight) {
    fbb_.AddElement<int32_t>(Conv2D::VT_PADRIGHT, padRight, 0);
  }
  void add_dilateW(int32_t dilateW) {
    fbb_.AddElement<int32_t>(Conv2D::VT_DILATEW, dilateW, 0);
  }
  void add_dilateH(int32_t dilateH) {
    fbb_.AddElement<int32_t>(Conv2D::VT_DILATEH, dilateH, 0);
  }
  void add_hasBias(bool hasBias) {
    fbb_.AddElement<uint8_t>(Conv2D::VT_HASBIAS, static_cast<uint8_t>(hasBias), 0);
  }
  void add_activationType(mindspore::schema::v0::ActivationType activationType) {
    fbb_.AddElement<int8_t>(Conv2D::VT_ACTIVATIONTYPE, static_cast<int8_t>(activationType), 0);
  }
  explicit Conv2DBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Conv2D> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Conv2D>(end);
    return o;
  }
};

inline flatbuffers::Offset<Conv2D> CreateConv2D(
    flatbuffers::FlatBufferBuilder &_fbb,
    mindspore::schema::v0::Format format = mindspore::schema::v0::Format_NCHW,
    int32_t group = 0,
    int32_t channelIn = 0,
    int32_t channelOut = 0,
    int32_t kernelW = 0,
    int32_t kernelH = 0,
    int32_t strideW = 0,
    int32_t strideH = 0,
    mindspore::schema::v0::PadMode padMode = mindspore::schema::v0::PadMode_NOTSET,
    int32_t padUp = 0,
    int32_t padDown = 0,
    int32_t padLeft = 0,
    int32_t padRight = 0,
    int32_t dilateW = 0,
    int32_t dilateH = 0,
    bool hasBias = false,
    mindspore::schema::v0::ActivationType activationType = mindspore::schema::v0::ActivationType_NO_ACTIVATION) {
  Conv2DBuilder builder_(_fbb);
  builder_.add_dilateH(dilateH);
  builder_.add_dilateW(dilateW);
  builder_.add_padRight(padRight);
  builder_.add_padLeft(padLeft);
  builder_.add_padDown(padDown);
  builder_.add_padUp(padUp);
  builder_.add_strideH(strideH);
  builder_.add_strideW(strideW);
  builder_.add_kernelH(kernelH);
  builder_.add_kernelW(kernelW);
  builder_.add_channelOut(channelOut);
  builder_.add_channelIn(channelIn);
  builder_.add_group(group);
  builder_.add_format(format);
  builder_.add_activationType(activationType);
  builder_.add_hasBias(hasBias);
  builder_.add_padMode(padMode);
  return builder_.Finish();
}

flatbuffers::Offset<Conv2D> CreateConv2D(flatbuffers::FlatBufferBuilder &_fbb, const Conv2DT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct AdderT : public flatbuffers::NativeTable {
  typedef Adder TableType;
  mindspore::schema::v0::Format format = mindspore::schema::v0::Format_NCHW;
  int32_t group = 0;
  int32_t channelIn = 0;
  int32_t channelOut = 0;
  int32_t kernelW = 0;
  int32_t kernelH = 0;
  int32_t strideW = 0;
  int32_t strideH = 0;
  mindspore::schema::v0::PadMode padMode = mindspore::schema::v0::PadMode_NOTSET;
  int32_t padUp = 0;
  int32_t padDown = 0;
  int32_t padLeft = 0;
  int32_t padRight = 0;
  int32_t dilateW = 0;
  int32_t dilateH = 0;
  bool hasBias = false;
  mindspore::schema::v0::ActivationType activationType = mindspore::schema::v0::ActivationType_NO_ACTIVATION;
};

struct Adder FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef AdderT NativeTableType;
  typedef AdderBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return AdderTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_FORMAT = 4,
    VT_GROUP = 6,
    VT_CHANNELIN = 8,
    VT_CHANNELOUT = 10,
    VT_KERNELW = 12,
    VT_KERNELH = 14,
    VT_STRIDEW = 16,
    VT_STRIDEH = 18,
    VT_PADMODE = 20,
    VT_PADUP = 22,
    VT_PADDOWN = 24,
    VT_PADLEFT = 26,
    VT_PADRIGHT = 28,
    VT_DILATEW = 30,
    VT_DILATEH = 32,
    VT_HASBIAS = 34,
    VT_ACTIVATIONTYPE = 36
  };
  mindspore::schema::v0::Format format() const {
    return static_cast<mindspore::schema::v0::Format>(GetField<int32_t>(VT_FORMAT, 0));
  }
  bool mutate_format(mindspore::schema::v0::Format _format) {
    return SetField<int32_t>(VT_FORMAT, static_cast<int32_t>(_format), 0);
  }
  int32_t group() const {
    return GetField<int32_t>(VT_GROUP, 0);
  }
  bool mutate_group(int32_t _group) {
    return SetField<int32_t>(VT_GROUP, _group, 0);
  }
  int32_t channelIn() const {
    return GetField<int32_t>(VT_CHANNELIN, 0);
  }
  bool mutate_channelIn(int32_t _channelIn) {
    return SetField<int32_t>(VT_CHANNELIN, _channelIn, 0);
  }
  int32_t channelOut() const {
    return GetField<int32_t>(VT_CHANNELOUT, 0);
  }
  bool mutate_channelOut(int32_t _channelOut) {
    return SetField<int32_t>(VT_CHANNELOUT, _channelOut, 0);
  }
  int32_t kernelW() const {
    return GetField<int32_t>(VT_KERNELW, 0);
  }
  bool mutate_kernelW(int32_t _kernelW) {
    return SetField<int32_t>(VT_KERNELW, _kernelW, 0);
  }
  int32_t kernelH() const {
    return GetField<int32_t>(VT_KERNELH, 0);
  }
  bool mutate_kernelH(int32_t _kernelH) {
    return SetField<int32_t>(VT_KERNELH, _kernelH, 0);
  }
  int32_t strideW() const {
    return GetField<int32_t>(VT_STRIDEW, 0);
  }
  bool mutate_strideW(int32_t _strideW) {
    return SetField<int32_t>(VT_STRIDEW, _strideW, 0);
  }
  int32_t strideH() const {
    return GetField<int32_t>(VT_STRIDEH, 0);
  }
  bool mutate_strideH(int32_t _strideH) {
    return SetField<int32_t>(VT_STRIDEH, _strideH, 0);
  }
  mindspore::schema::v0::PadMode padMode() const {
    return static_cast<mindspore::schema::v0::PadMode>(GetField<int8_t>(VT_PADMODE, 0));
  }
  bool mutate_padMode(mindspore::schema::v0::PadMode _padMode) {
    return SetField<int8_t>(VT_PADMODE, static_cast<int8_t>(_padMode), 0);
  }
  int32_t padUp() const {
    return GetField<int32_t>(VT_PADUP, 0);
  }
  bool mutate_padUp(int32_t _padUp) {
    return SetField<int32_t>(VT_PADUP, _padUp, 0);
  }
  int32_t padDown() const {
    return GetField<int32_t>(VT_PADDOWN, 0);
  }
  bool mutate_padDown(int32_t _padDown) {
    return SetField<int32_t>(VT_PADDOWN, _padDown, 0);
  }
  int32_t padLeft() const {
    return GetField<int32_t>(VT_PADLEFT, 0);
  }
  bool mutate_padLeft(int32_t _padLeft) {
    return SetField<int32_t>(VT_PADLEFT, _padLeft, 0);
  }
  int32_t padRight() const {
    return GetField<int32_t>(VT_PADRIGHT, 0);
  }
  bool mutate_padRight(int32_t _padRight) {
    return SetField<int32_t>(VT_PADRIGHT, _padRight, 0);
  }
  int32_t dilateW() const {
    return GetField<int32_t>(VT_DILATEW, 0);
  }
  bool mutate_dilateW(int32_t _dilateW) {
    return SetField<int32_t>(VT_DILATEW, _dilateW, 0);
  }
  int32_t dilateH() const {
    return GetField<int32_t>(VT_DILATEH, 0);
  }
  bool mutate_dilateH(int32_t _dilateH) {
    return SetField<int32_t>(VT_DILATEH, _dilateH, 0);
  }
  bool hasBias() const {
    return GetField<uint8_t>(VT_HASBIAS, 0) != 0;
  }
  bool mutate_hasBias(bool _hasBias) {
    return SetField<uint8_t>(VT_HASBIAS, static_cast<uint8_t>(_hasBias), 0);
  }
  mindspore::schema::v0::ActivationType activationType() const {
    return static_cast<mindspore::schema::v0::ActivationType>(GetField<int8_t>(VT_ACTIVATIONTYPE, 0));
  }
  bool mutate_activationType(mindspore::schema::v0::ActivationType _activationType) {
    return SetField<int8_t>(VT_ACTIVATIONTYPE, static_cast<int8_t>(_activationType), 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_FORMAT) &&
           VerifyField<int32_t>(verifier, VT_GROUP) &&
           VerifyField<int32_t>(verifier, VT_CHANNELIN) &&
           VerifyField<int32_t>(verifier, VT_CHANNELOUT) &&
           VerifyField<int32_t>(verifier, VT_KERNELW) &&
           VerifyField<int32_t>(verifier, VT_KERNELH) &&
           VerifyField<int32_t>(verifier, VT_STRIDEW) &&
           VerifyField<int32_t>(verifier, VT_STRIDEH) &&
           VerifyField<int8_t>(verifier, VT_PADMODE) &&
           VerifyField<int32_t>(verifier, VT_PADUP) &&
           VerifyField<int32_t>(verifier, VT_PADDOWN) &&
           VerifyField<int32_t>(verifier, VT_PADLEFT) &&
           VerifyField<int32_t>(verifier, VT_PADRIGHT) &&
           VerifyField<int32_t>(verifier, VT_DILATEW) &&
           VerifyField<int32_t>(verifier, VT_DILATEH) &&
           VerifyField<uint8_t>(verifier, VT_HASBIAS) &&
           VerifyField<int8_t>(verifier, VT_ACTIVATIONTYPE) &&
           verifier.EndTable();
  }
  AdderT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(AdderT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Adder> Pack(flatbuffers::FlatBufferBuilder &_fbb, const AdderT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct AdderBuilder {
  typedef Adder Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_format(mindspore::schema::v0::Format format) {
    fbb_.AddElement<int32_t>(Adder::VT_FORMAT, static_cast<int32_t>(format), 0);
  }
  void add_group(int32_t group) {
    fbb_.AddElement<int32_t>(Adder::VT_GROUP, group, 0);
  }
  void add_channelIn(int32_t channelIn) {
    fbb_.AddElement<int32_t>(Adder::VT_CHANNELIN, channelIn, 0);
  }
  void add_channelOut(int32_t channelOut) {
    fbb_.AddElement<int32_t>(Adder::VT_CHANNELOUT, channelOut, 0);
  }
  void add_kernelW(int32_t kernelW) {
    fbb_.AddElement<int32_t>(Adder::VT_KERNELW, kernelW, 0);
  }
  void add_kernelH(int32_t kernelH) {
    fbb_.AddElement<int32_t>(Adder::VT_KERNELH, kernelH, 0);
  }
  void add_strideW(int32_t strideW) {
    fbb_.AddElement<int32_t>(Adder::VT_STRIDEW, strideW, 0);
  }
  void add_strideH(int32_t strideH) {
    fbb_.AddElement<int32_t>(Adder::VT_STRIDEH, strideH, 0);
  }
  void add_padMode(mindspore::schema::v0::PadMode padMode) {
    fbb_.AddElement<int8_t>(Adder::VT_PADMODE, static_cast<int8_t>(padMode), 0);
  }
  void add_padUp(int32_t padUp) {
    fbb_.AddElement<int32_t>(Adder::VT_PADUP, padUp, 0);
  }
  void add_padDown(int32_t padDown) {
    fbb_.AddElement<int32_t>(Adder::VT_PADDOWN, padDown, 0);
  }
  void add_padLeft(int32_t padLeft) {
    fbb_.AddElement<int32_t>(Adder::VT_PADLEFT, padLeft, 0);
  }
  void add_padRight(int32_t padRight) {
    fbb_.AddElement<int32_t>(Adder::VT_PADRIGHT, padRight, 0);
  }
  void add_dilateW(int32_t dilateW) {
    fbb_.AddElement<int32_t>(Adder::VT_DILATEW, dilateW, 0);
  }
  void add_dilateH(int32_t dilateH) {
    fbb_.AddElement<int32_t>(Adder::VT_DILATEH, dilateH, 0);
  }
  void add_hasBias(bool hasBias) {
    fbb_.AddElement<uint8_t>(Adder::VT_HASBIAS, static_cast<uint8_t>(hasBias), 0);
  }
  void add_activationType(mindspore::schema::v0::ActivationType activationType) {
    fbb_.AddElement<int8_t>(Adder::VT_ACTIVATIONTYPE, static_cast<int8_t>(activationType), 0);
  }
  explicit AdderBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Adder> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Adder>(end);
    return o;
  }
};

inline flatbuffers::Offset<Adder> CreateAdder(
    flatbuffers::FlatBufferBuilder &_fbb,
    mindspore::schema::v0::Format format = mindspore::schema::v0::Format_NCHW,
    int32_t group = 0,
    int32_t channelIn = 0,
    int32_t channelOut = 0,
    int32_t kernelW = 0,
    int32_t kernelH = 0,
    int32_t strideW = 0,
    int32_t strideH = 0,
    mindspore::schema::v0::PadMode padMode = mindspore::schema::v0::PadMode_NOTSET,
    int32_t padUp = 0,
    int32_t padDown = 0,
    int32_t padLeft = 0,
    int32_t padRight = 0,
    int32_t dilateW = 0,
    int32_t dilateH = 0,
    bool hasBias = false,
    mindspore::schema::v0::ActivationType activationType = mindspore::schema::v0::ActivationType_NO_ACTIVATION) {
  AdderBuilder builder_(_fbb);
  builder_.add_dilateH(dilateH);
  builder_.add_dilateW(dilateW);
  builder_.add_padRight(padRight);
  builder_.add_padLeft(padLeft);
  builder_.add_padDown(padDown);
  builder_.add_padUp(padUp);
  builder_.add_strideH(strideH);
  builder_.add_strideW(strideW);
  builder_.add_kernelH(kernelH);
  builder_.add_kernelW(kernelW);
  builder_.add_channelOut(channelOut);
  builder_.add_channelIn(channelIn);
  builder_.add_group(group);
  builder_.add_format(format);
  builder_.add_activationType(activationType);
  builder_.add_hasBias(hasBias);
  builder_.add_padMode(padMode);
  return builder_.Finish();
}

flatbuffers::Offset<Adder> CreateAdder(flatbuffers::FlatBufferBuilder &_fbb, const AdderT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct Conv2DGradFilterT : public flatbuffers::NativeTable {
  typedef Conv2DGradFilter TableType;
  mindspore::schema::v0::Format format = mindspore::schema::v0::Format_NCHW;
  int32_t group = 0;
  int32_t channelIn = 0;
  int32_t channelOut = 0;
  int32_t kernelW = 0;
  int32_t kernelH = 0;
  int32_t strideW = 0;
  int32_t strideH = 0;
  mindspore::schema::v0::PadMode padMode = mindspore::schema::v0::PadMode_NOTSET;
  int32_t padUp = 0;
  int32_t padDown = 0;
  int32_t padLeft = 0;
  int32_t padRight = 0;
  int32_t dilateW = 0;
  int32_t dilateH = 0;
  bool hasBias = false;
  std::vector<int32_t> filter_shape{};
  mindspore::schema::v0::ActivationType activationType = mindspore::schema::v0::ActivationType_NO_ACTIVATION;
};

struct Conv2DGradFilter FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef Conv2DGradFilterT NativeTableType;
  typedef Conv2DGradFilterBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return Conv2DGradFilterTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_FORMAT = 4,
    VT_GROUP = 6,
    VT_CHANNELIN = 8,
    VT_CHANNELOUT = 10,
    VT_KERNELW = 12,
    VT_KERNELH = 14,
    VT_STRIDEW = 16,
    VT_STRIDEH = 18,
    VT_PADMODE = 20,
    VT_PADUP = 22,
    VT_PADDOWN = 24,
    VT_PADLEFT = 26,
    VT_PADRIGHT = 28,
    VT_DILATEW = 30,
    VT_DILATEH = 32,
    VT_HASBIAS = 34,
    VT_FILTER_SHAPE = 36,
    VT_ACTIVATIONTYPE = 38
  };
  mindspore::schema::v0::Format format() const {
    return static_cast<mindspore::schema::v0::Format>(GetField<int32_t>(VT_FORMAT, 0));
  }
  bool mutate_format(mindspore::schema::v0::Format _format) {
    return SetField<int32_t>(VT_FORMAT, static_cast<int32_t>(_format), 0);
  }
  int32_t group() const {
    return GetField<int32_t>(VT_GROUP, 0);
  }
  bool mutate_group(int32_t _group) {
    return SetField<int32_t>(VT_GROUP, _group, 0);
  }
  int32_t channelIn() const {
    return GetField<int32_t>(VT_CHANNELIN, 0);
  }
  bool mutate_channelIn(int32_t _channelIn) {
    return SetField<int32_t>(VT_CHANNELIN, _channelIn, 0);
  }
  int32_t channelOut() const {
    return GetField<int32_t>(VT_CHANNELOUT, 0);
  }
  bool mutate_channelOut(int32_t _channelOut) {
    return SetField<int32_t>(VT_CHANNELOUT, _channelOut, 0);
  }
  int32_t kernelW() const {
    return GetField<int32_t>(VT_KERNELW, 0);
  }
  bool mutate_kernelW(int32_t _kernelW) {
    return SetField<int32_t>(VT_KERNELW, _kernelW, 0);
  }
  int32_t kernelH() const {
    return GetField<int32_t>(VT_KERNELH, 0);
  }
  bool mutate_kernelH(int32_t _kernelH) {
    return SetField<int32_t>(VT_KERNELH, _kernelH, 0);
  }
  int32_t strideW() const {
    return GetField<int32_t>(VT_STRIDEW, 0);
  }
  bool mutate_strideW(int32_t _strideW) {
    return SetField<int32_t>(VT_STRIDEW, _strideW, 0);
  }
  int32_t strideH() const {
    return GetField<int32_t>(VT_STRIDEH, 0);
  }
  bool mutate_strideH(int32_t _strideH) {
    return SetField<int32_t>(VT_STRIDEH, _strideH, 0);
  }
  mindspore::schema::v0::PadMode padMode() const {
    return static_cast<mindspore::schema::v0::PadMode>(GetField<int8_t>(VT_PADMODE, 0));
  }
  bool mutate_padMode(mindspore::schema::v0::PadMode _padMode) {
    return SetField<int8_t>(VT_PADMODE, static_cast<int8_t>(_padMode), 0);
  }
  int32_t padUp() const {
    return GetField<int32_t>(VT_PADUP, 0);
  }
  bool mutate_padUp(int32_t _padUp) {
    return SetField<int32_t>(VT_PADUP, _padUp, 0);
  }
  int32_t padDown() const {
    return GetField<int32_t>(VT_PADDOWN, 0);
  }
  bool mutate_padDown(int32_t _padDown) {
    return SetField<int32_t>(VT_PADDOWN, _padDown, 0);
  }
  int32_t padLeft() const {
    return GetField<int32_t>(VT_PADLEFT, 0);
  }
  bool mutate_padLeft(int32_t _padLeft) {
    return SetField<int32_t>(VT_PADLEFT, _padLeft, 0);
  }
  int32_t padRight() const {
    return GetField<int32_t>(VT_PADRIGHT, 0);
  }
  bool mutate_padRight(int32_t _padRight) {
    return SetField<int32_t>(VT_PADRIGHT, _padRight, 0);
  }
  int32_t dilateW() const {
    return GetField<int32_t>(VT_DILATEW, 0);
  }
  bool mutate_dilateW(int32_t _dilateW) {
    return SetField<int32_t>(VT_DILATEW, _dilateW, 0);
  }
  int32_t dilateH() const {
    return GetField<int32_t>(VT_DILATEH, 0);
  }
  bool mutate_dilateH(int32_t _dilateH) {
    return SetField<int32_t>(VT_DILATEH, _dilateH, 0);
  }
  bool hasBias() const {
    return GetField<uint8_t>(VT_HASBIAS, 0) != 0;
  }
  bool mutate_hasBias(bool _hasBias) {
    return SetField<uint8_t>(VT_HASBIAS, static_cast<uint8_t>(_hasBias), 0);
  }
  const flatbuffers::Vector<int32_t> *filter_shape() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_FILTER_SHAPE);
  }
  flatbuffers::Vector<int32_t> *mutable_filter_shape() {
    return GetPointer<flatbuffers::Vector<int32_t> *>(VT_FILTER_SHAPE);
  }
  mindspore::schema::v0::ActivationType activationType() const {
    return static_cast<mindspore::schema::v0::ActivationType>(GetField<int8_t>(VT_ACTIVATIONTYPE, 0));
  }
  bool mutate_activationType(mindspore::schema::v0::ActivationType _activationType) {
    return SetField<int8_t>(VT_ACTIVATIONTYPE, static_cast<int8_t>(_activationType), 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_FORMAT) &&
           VerifyField<int32_t>(verifier, VT_GROUP) &&
           VerifyField<int32_t>(verifier, VT_CHANNELIN) &&
           VerifyField<int32_t>(verifier, VT_CHANNELOUT) &&
           VerifyField<int32_t>(verifier, VT_KERNELW) &&
           VerifyField<int32_t>(verifier, VT_KERNELH) &&
           VerifyField<int32_t>(verifier, VT_STRIDEW) &&
           VerifyField<int32_t>(verifier, VT_STRIDEH) &&
           VerifyField<int8_t>(verifier, VT_PADMODE) &&
           VerifyField<int32_t>(verifier, VT_PADUP) &&
           VerifyField<int32_t>(verifier, VT_PADDOWN) &&
           VerifyField<int32_t>(verifier, VT_PADLEFT) &&
           VerifyField<int32_t>(verifier, VT_PADRIGHT) &&
           VerifyField<int32_t>(verifier, VT_DILATEW) &&
           VerifyField<int32_t>(verifier, VT_DILATEH) &&
           VerifyField<uint8_t>(verifier, VT_HASBIAS) &&
           VerifyOffset(verifier, VT_FILTER_SHAPE) &&
           verifier.VerifyVector(filter_shape()) &&
           VerifyField<int8_t>(verifier, VT_ACTIVATIONTYPE) &&
           verifier.EndTable();
  }
  Conv2DGradFilterT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(Conv2DGradFilterT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Conv2DGradFilter> Pack(flatbuffers::FlatBufferBuilder &_fbb, const Conv2DGradFilterT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct Conv2DGradFilterBuilder {
  typedef Conv2DGradFilter Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_format(mindspore::schema::v0::Format format) {
    fbb_.AddElement<int32_t>(Conv2DGradFilter::VT_FORMAT, static_cast<int32_t>(format), 0);
  }
  void add_group(int32_t group) {
    fbb_.AddElement<int32_t>(Conv2DGradFilter::VT_GROUP, group, 0);
  }
  void add_channelIn(int32_t channelIn) {
    fbb_.AddElement<int32_t>(Conv2DGradFilter::VT_CHANNELIN, channelIn, 0);
  }
  void add_channelOut(int32_t channelOut) {
    fbb_.AddElement<int32_t>(Conv2DGradFilter::VT_CHANNELOUT, channelOut, 0);
  }
  void add_kernelW(int32_t kernelW) {
    fbb_.AddElement<int32_t>(Conv2DGradFilter::VT_KERNELW, kernelW, 0);
  }
  void add_kernelH(int32_t kernelH) {
    fbb_.AddElement<int32_t>(Conv2DGradFilter::VT_KERNELH, kernelH, 0);
  }
  void add_strideW(int32_t strideW) {
    fbb_.AddElement<int32_t>(Conv2DGradFilter::VT_STRIDEW, strideW, 0);
  }
  void add_strideH(int32_t strideH) {
    fbb_.AddElement<int32_t>(Conv2DGradFilter::VT_STRIDEH, strideH, 0);
  }
  void add_padMode(mindspore::schema::v0::PadMode padMode) {
    fbb_.AddElement<int8_t>(Conv2DGradFilter::VT_PADMODE, static_cast<int8_t>(padMode), 0);
  }
  void add_padUp(int32_t padUp) {
    fbb_.AddElement<int32_t>(Conv2DGradFilter::VT_PADUP, padUp, 0);
  }
  void add_padDown(int32_t padDown) {
    fbb_.AddElement<int32_t>(Conv2DGradFilter::VT_PADDOWN, padDown, 0);
  }
  void add_padLeft(int32_t padLeft) {
    fbb_.AddElement<int32_t>(Conv2DGradFilter::VT_PADLEFT, padLeft, 0);
  }
  void add_padRight(int32_t padRight) {
    fbb_.AddElement<int32_t>(Conv2DGradFilter::VT_PADRIGHT, padRight, 0);
  }
  void add_dilateW(int32_t dilateW) {
    fbb_.AddElement<int32_t>(Conv2DGradFilter::VT_DILATEW, dilateW, 0);
  }
  void add_dilateH(int32_t dilateH) {
    fbb_.AddElement<int32_t>(Conv2DGradFilter::VT_DILATEH, dilateH, 0);
  }
  void add_hasBias(bool hasBias) {
    fbb_.AddElement<uint8_t>(Conv2DGradFilter::VT_HASBIAS, static_cast<uint8_t>(hasBias), 0);
  }
  void add_filter_shape(flatbuffers::Offset<flatbuffers::Vector<int32_t>> filter_shape) {
    fbb_.AddOffset(Conv2DGradFilter::VT_FILTER_SHAPE, filter_shape);
  }
  void add_activationType(mindspore::schema::v0::ActivationType activationType) {
    fbb_.AddElement<int8_t>(Conv2DGradFilter::VT_ACTIVATIONTYPE, static_cast<int8_t>(activationType), 0);
  }
  explicit Conv2DGradFilterBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Conv2DGradFilter> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Conv2DGradFilter>(end);
    return o;
  }
};

inline flatbuffers::Offset<Conv2DGradFilter> CreateConv2DGradFilter(
    flatbuffers::FlatBufferBuilder &_fbb,
    mindspore::schema::v0::Format format = mindspore::schema::v0::Format_NCHW,
    int32_t group = 0,
    int32_t channelIn = 0,
    int32_t channelOut = 0,
    int32_t kernelW = 0,
    int32_t kernelH = 0,
    int32_t strideW = 0,
    int32_t strideH = 0,
    mindspore::schema::v0::PadMode padMode = mindspore::schema::v0::PadMode_NOTSET,
    int32_t padUp = 0,
    int32_t padDown = 0,
    int32_t padLeft = 0,
    int32_t padRight = 0,
    int32_t dilateW = 0,
    int32_t dilateH = 0,
    bool hasBias = false,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> filter_shape = 0,
    mindspore::schema::v0::ActivationType activationType = mindspore::schema::v0::ActivationType_NO_ACTIVATION) {
  Conv2DGradFilterBuilder builder_(_fbb);
  builder_.add_filter_shape(filter_shape);
  builder_.add_dilateH(dilateH);
  builder_.add_dilateW(dilateW);
  builder_.add_padRight(padRight);
  builder_.add_padLeft(padLeft);
  builder_.add_padDown(padDown);
  builder_.add_padUp(padUp);
  builder_.add_strideH(strideH);
  builder_.add_strideW(strideW);
  builder_.add_kernelH(kernelH);
  builder_.add_kernelW(kernelW);
  builder_.add_channelOut(channelOut);
  builder_.add_channelIn(channelIn);
  builder_.add_group(group);
  builder_.add_format(format);
  builder_.add_activationType(activationType);
  builder_.add_hasBias(hasBias);
  builder_.add_padMode(padMode);
  return builder_.Finish();
}

inline flatbuffers::Offset<Conv2DGradFilter> CreateConv2DGradFilterDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    mindspore::schema::v0::Format format = mindspore::schema::v0::Format_NCHW,
    int32_t group = 0,
    int32_t channelIn = 0,
    int32_t channelOut = 0,
    int32_t kernelW = 0,
    int32_t kernelH = 0,
    int32_t strideW = 0,
    int32_t strideH = 0,
    mindspore::schema::v0::PadMode padMode = mindspore::schema::v0::PadMode_NOTSET,
    int32_t padUp = 0,
    int32_t padDown = 0,
    int32_t padLeft = 0,
    int32_t padRight = 0,
    int32_t dilateW = 0,
    int32_t dilateH = 0,
    bool hasBias = false,
    const std::vector<int32_t> *filter_shape = nullptr,
    mindspore::schema::v0::ActivationType activationType = mindspore::schema::v0::ActivationType_NO_ACTIVATION) {
  auto filter_shape__ = filter_shape ? _fbb.CreateVector<int32_t>(*filter_shape) : 0;
  return mindspore::schema::v0::CreateConv2DGradFilter(
      _fbb,
      format,
      group,
      channelIn,
      channelOut,
      kernelW,
      kernelH,
      strideW,
      strideH,
      padMode,
      padUp,
      padDown,
      padLeft,
      padRight,
      dilateW,
      dilateH,
      hasBias,
      filter_shape__,
      activationType);
}

flatbuffers::Offset<Conv2DGradFilter> CreateConv2DGradFilter(flatbuffers::FlatBufferBuilder &_fbb, const Conv2DGradFilterT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct Conv2DGradInputT : public flatbuffers::NativeTable {
  typedef Conv2DGradInput TableType;
  mindspore::schema::v0::Format format = mindspore::schema::v0::Format_NCHW;
  int32_t group = 0;
  int32_t channelIn = 0;
  int32_t channelOut = 0;
  int32_t kernelW = 0;
  int32_t kernelH = 0;
  int32_t strideW = 0;
  int32_t strideH = 0;
  mindspore::schema::v0::PadMode padMode = mindspore::schema::v0::PadMode_NOTSET;
  int32_t padUp = 0;
  int32_t padDown = 0;
  int32_t padLeft = 0;
  int32_t padRight = 0;
  int32_t dilateW = 0;
  int32_t dilateH = 0;
  bool hasBias = false;
  std::vector<int32_t> input_shape{};
  mindspore::schema::v0::ActivationType activationType = mindspore::schema::v0::ActivationType_NO_ACTIVATION;
};

struct Conv2DGradInput FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef Conv2DGradInputT NativeTableType;
  typedef Conv2DGradInputBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return Conv2DGradInputTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_FORMAT = 4,
    VT_GROUP = 6,
    VT_CHANNELIN = 8,
    VT_CHANNELOUT = 10,
    VT_KERNELW = 12,
    VT_KERNELH = 14,
    VT_STRIDEW = 16,
    VT_STRIDEH = 18,
    VT_PADMODE = 20,
    VT_PADUP = 22,
    VT_PADDOWN = 24,
    VT_PADLEFT = 26,
    VT_PADRIGHT = 28,
    VT_DILATEW = 30,
    VT_DILATEH = 32,
    VT_HASBIAS = 34,
    VT_INPUT_SHAPE = 36,
    VT_ACTIVATIONTYPE = 38
  };
  mindspore::schema::v0::Format format() const {
    return static_cast<mindspore::schema::v0::Format>(GetField<int32_t>(VT_FORMAT, 0));
  }
  bool mutate_format(mindspore::schema::v0::Format _format) {
    return SetField<int32_t>(VT_FORMAT, static_cast<int32_t>(_format), 0);
  }
  int32_t group() const {
    return GetField<int32_t>(VT_GROUP, 0);
  }
  bool mutate_group(int32_t _group) {
    return SetField<int32_t>(VT_GROUP, _group, 0);
  }
  int32_t channelIn() const {
    return GetField<int32_t>(VT_CHANNELIN, 0);
  }
  bool mutate_channelIn(int32_t _channelIn) {
    return SetField<int32_t>(VT_CHANNELIN, _channelIn, 0);
  }
  int32_t channelOut() const {
    return GetField<int32_t>(VT_CHANNELOUT, 0);
  }
  bool mutate_channelOut(int32_t _channelOut) {
    return SetField<int32_t>(VT_CHANNELOUT, _channelOut, 0);
  }
  int32_t kernelW() const {
    return GetField<int32_t>(VT_KERNELW, 0);
  }
  bool mutate_kernelW(int32_t _kernelW) {
    return SetField<int32_t>(VT_KERNELW, _kernelW, 0);
  }
  int32_t kernelH() const {
    return GetField<int32_t>(VT_KERNELH, 0);
  }
  bool mutate_kernelH(int32_t _kernelH) {
    return SetField<int32_t>(VT_KERNELH, _kernelH, 0);
  }
  int32_t strideW() const {
    return GetField<int32_t>(VT_STRIDEW, 0);
  }
  bool mutate_strideW(int32_t _strideW) {
    return SetField<int32_t>(VT_STRIDEW, _strideW, 0);
  }
  int32_t strideH() const {
    return GetField<int32_t>(VT_STRIDEH, 0);
  }
  bool mutate_strideH(int32_t _strideH) {
    return SetField<int32_t>(VT_STRIDEH, _strideH, 0);
  }
  mindspore::schema::v0::PadMode padMode() const {
    return static_cast<mindspore::schema::v0::PadMode>(GetField<int8_t>(VT_PADMODE, 0));
  }
  bool mutate_padMode(mindspore::schema::v0::PadMode _padMode) {
    return SetField<int8_t>(VT_PADMODE, static_cast<int8_t>(_padMode), 0);
  }
  int32_t padUp() const {
    return GetField<int32_t>(VT_PADUP, 0);
  }
  bool mutate_padUp(int32_t _padUp) {
    return SetField<int32_t>(VT_PADUP, _padUp, 0);
  }
  int32_t padDown() const {
    return GetField<int32_t>(VT_PADDOWN, 0);
  }
  bool mutate_padDown(int32_t _padDown) {
    return SetField<int32_t>(VT_PADDOWN, _padDown, 0);
  }
  int32_t padLeft() const {
    return GetField<int32_t>(VT_PADLEFT, 0);
  }
  bool mutate_padLeft(int32_t _padLeft) {
    return SetField<int32_t>(VT_PADLEFT, _padLeft, 0);
  }
  int32_t padRight() const {
    return GetField<int32_t>(VT_PADRIGHT, 0);
  }
  bool mutate_padRight(int32_t _padRight) {
    return SetField<int32_t>(VT_PADRIGHT, _padRight, 0);
  }
  int32_t dilateW() const {
    return GetField<int32_t>(VT_DILATEW, 0);
  }
  bool mutate_dilateW(int32_t _dilateW) {
    return SetField<int32_t>(VT_DILATEW, _dilateW, 0);
  }
  int32_t dilateH() const {
    return GetField<int32_t>(VT_DILATEH, 0);
  }
  bool mutate_dilateH(int32_t _dilateH) {
    return SetField<int32_t>(VT_DILATEH, _dilateH, 0);
  }
  bool hasBias() const {
    return GetField<uint8_t>(VT_HASBIAS, 0) != 0;
  }
  bool mutate_hasBias(bool _hasBias) {
    return SetField<uint8_t>(VT_HASBIAS, static_cast<uint8_t>(_hasBias), 0);
  }
  const flatbuffers::Vector<int32_t> *input_shape() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_INPUT_SHAPE);
  }
  flatbuffers::Vector<int32_t> *mutable_input_shape() {
    return GetPointer<flatbuffers::Vector<int32_t> *>(VT_INPUT_SHAPE);
  }
  mindspore::schema::v0::ActivationType activationType() const {
    return static_cast<mindspore::schema::v0::ActivationType>(GetField<int8_t>(VT_ACTIVATIONTYPE, 0));
  }
  bool mutate_activationType(mindspore::schema::v0::ActivationType _activationType) {
    return SetField<int8_t>(VT_ACTIVATIONTYPE, static_cast<int8_t>(_activationType), 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_FORMAT) &&
           VerifyField<int32_t>(verifier, VT_GROUP) &&
           VerifyField<int32_t>(verifier, VT_CHANNELIN) &&
           VerifyField<int32_t>(verifier, VT_CHANNELOUT) &&
           VerifyField<int32_t>(verifier, VT_KERNELW) &&
           VerifyField<int32_t>(verifier, VT_KERNELH) &&
           VerifyField<int32_t>(verifier, VT_STRIDEW) &&
           VerifyField<int32_t>(verifier, VT_STRIDEH) &&
           VerifyField<int8_t>(verifier, VT_PADMODE) &&
           VerifyField<int32_t>(verifier, VT_PADUP) &&
           VerifyField<int32_t>(verifier, VT_PADDOWN) &&
           VerifyField<int32_t>(verifier, VT_PADLEFT) &&
           VerifyField<int32_t>(verifier, VT_PADRIGHT) &&
           VerifyField<int32_t>(verifier, VT_DILATEW) &&
           VerifyField<int32_t>(verifier, VT_DILATEH) &&
           VerifyField<uint8_t>(verifier, VT_HASBIAS) &&
           VerifyOffset(verifier, VT_INPUT_SHAPE) &&
           verifier.VerifyVector(input_shape()) &&
           VerifyField<int8_t>(verifier, VT_ACTIVATIONTYPE) &&
           verifier.EndTable();
  }
  Conv2DGradInputT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(Conv2DGradInputT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Conv2DGradInput> Pack(flatbuffers::FlatBufferBuilder &_fbb, const Conv2DGradInputT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct Conv2DGradInputBuilder {
  typedef Conv2DGradInput Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_format(mindspore::schema::v0::Format format) {
    fbb_.AddElement<int32_t>(Conv2DGradInput::VT_FORMAT, static_cast<int32_t>(format), 0);
  }
  void add_group(int32_t group) {
    fbb_.AddElement<int32_t>(Conv2DGradInput::VT_GROUP, group, 0);
  }
  void add_channelIn(int32_t channelIn) {
    fbb_.AddElement<int32_t>(Conv2DGradInput::VT_CHANNELIN, channelIn, 0);
  }
  void add_channelOut(int32_t channelOut) {
    fbb_.AddElement<int32_t>(Conv2DGradInput::VT_CHANNELOUT, channelOut, 0);
  }
  void add_kernelW(int32_t kernelW) {
    fbb_.AddElement<int32_t>(Conv2DGradInput::VT_KERNELW, kernelW, 0);
  }
  void add_kernelH(int32_t kernelH) {
    fbb_.AddElement<int32_t>(Conv2DGradInput::VT_KERNELH, kernelH, 0);
  }
  void add_strideW(int32_t strideW) {
    fbb_.AddElement<int32_t>(Conv2DGradInput::VT_STRIDEW, strideW, 0);
  }
  void add_strideH(int32_t strideH) {
    fbb_.AddElement<int32_t>(Conv2DGradInput::VT_STRIDEH, strideH, 0);
  }
  void add_padMode(mindspore::schema::v0::PadMode padMode) {
    fbb_.AddElement<int8_t>(Conv2DGradInput::VT_PADMODE, static_cast<int8_t>(padMode), 0);
  }
  void add_padUp(int32_t padUp) {
    fbb_.AddElement<int32_t>(Conv2DGradInput::VT_PADUP, padUp, 0);
  }
  void add_padDown(int32_t padDown) {
    fbb_.AddElement<int32_t>(Conv2DGradInput::VT_PADDOWN, padDown, 0);
  }
  void add_padLeft(int32_t padLeft) {
    fbb_.AddElement<int32_t>(Conv2DGradInput::VT_PADLEFT, padLeft, 0);
  }
  void add_padRight(int32_t padRight) {
    fbb_.AddElement<int32_t>(Conv2DGradInput::VT_PADRIGHT, padRight, 0);
  }
  void add_dilateW(int32_t dilateW) {
    fbb_.AddElement<int32_t>(Conv2DGradInput::VT_DILATEW, dilateW, 0);
  }
  void add_dilateH(int32_t dilateH) {
    fbb_.AddElement<int32_t>(Conv2DGradInput::VT_DILATEH, dilateH, 0);
  }
  void add_hasBias(bool hasBias) {
    fbb_.AddElement<uint8_t>(Conv2DGradInput::VT_HASBIAS, static_cast<uint8_t>(hasBias), 0);
  }
  void add_input_shape(flatbuffers::Offset<flatbuffers::Vector<int32_t>> input_shape) {
    fbb_.AddOffset(Conv2DGradInput::VT_INPUT_SHAPE, input_shape);
  }
  void add_activationType(mindspore::schema::v0::ActivationType activationType) {
    fbb_.AddElement<int8_t>(Conv2DGradInput::VT_ACTIVATIONTYPE, static_cast<int8_t>(activationType), 0);
  }
  explicit Conv2DGradInputBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Conv2DGradInput> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Conv2DGradInput>(end);
    return o;
  }
};

inline flatbuffers::Offset<Conv2DGradInput> CreateConv2DGradInput(
    flatbuffers::FlatBufferBuilder &_fbb,
    mindspore::schema::v0::Format format = mindspore::schema::v0::Format_NCHW,
    int32_t group = 0,
    int32_t channelIn = 0,
    int32_t channelOut = 0,
    int32_t kernelW = 0,
    int32_t kernelH = 0,
    int32_t strideW = 0,
    int32_t strideH = 0,
    mindspore::schema::v0::PadMode padMode = mindspore::schema::v0::PadMode_NOTSET,
    int32_t padUp = 0,
    int32_t padDown = 0,
    int32_t padLeft = 0,
    int32_t padRight = 0,
    int32_t dilateW = 0,
    int32_t dilateH = 0,
    bool hasBias = false,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> input_shape = 0,
    mindspore::schema::v0::ActivationType activationType = mindspore::schema::v0::ActivationType_NO_ACTIVATION) {
  Conv2DGradInputBuilder builder_(_fbb);
  builder_.add_input_shape(input_shape);
  builder_.add_dilateH(dilateH);
  builder_.add_dilateW(dilateW);
  builder_.add_padRight(padRight);
  builder_.add_padLeft(padLeft);
  builder_.add_padDown(padDown);
  builder_.add_padUp(padUp);
  builder_.add_strideH(strideH);
  builder_.add_strideW(strideW);
  builder_.add_kernelH(kernelH);
  builder_.add_kernelW(kernelW);
  builder_.add_channelOut(channelOut);
  builder_.add_channelIn(channelIn);
  builder_.add_group(group);
  builder_.add_format(format);
  builder_.add_activationType(activationType);
  builder_.add_hasBias(hasBias);
  builder_.add_padMode(padMode);
  return builder_.Finish();
}

inline flatbuffers::Offset<Conv2DGradInput> CreateConv2DGradInputDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    mindspore::schema::v0::Format format = mindspore::schema::v0::Format_NCHW,
    int32_t group = 0,
    int32_t channelIn = 0,
    int32_t channelOut = 0,
    int32_t kernelW = 0,
    int32_t kernelH = 0,
    int32_t strideW = 0,
    int32_t strideH = 0,
    mindspore::schema::v0::PadMode padMode = mindspore::schema::v0::PadMode_NOTSET,
    int32_t padUp = 0,
    int32_t padDown = 0,
    int32_t padLeft = 0,
    int32_t padRight = 0,
    int32_t dilateW = 0,
    int32_t dilateH = 0,
    bool hasBias = false,
    const std::vector<int32_t> *input_shape = nullptr,
    mindspore::schema::v0::ActivationType activationType = mindspore::schema::v0::ActivationType_NO_ACTIVATION) {
  auto input_shape__ = input_shape ? _fbb.CreateVector<int32_t>(*input_shape) : 0;
  return mindspore::schema::v0::CreateConv2DGradInput(
      _fbb,
      format,
      group,
      channelIn,
      channelOut,
      kernelW,
      kernelH,
      strideW,
      strideH,
      padMode,
      padUp,
      padDown,
      padLeft,
      padRight,
      dilateW,
      dilateH,
      hasBias,
      input_shape__,
      activationType);
}

flatbuffers::Offset<Conv2DGradInput> CreateConv2DGradInput(flatbuffers::FlatBufferBuilder &_fbb, const Conv2DGradInputT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct GroupConv2DGradInputT : public flatbuffers::NativeTable {
  typedef GroupConv2DGradInput TableType;
  mindspore::schema::v0::Format format = mindspore::schema::v0::Format_NCHW;
  int32_t group = 0;
  int32_t channelIn = 0;
  int32_t channelOut = 0;
  int32_t kernelW = 0;
  int32_t kernelH = 0;
  int32_t strideW = 0;
  int32_t strideH = 0;
  mindspore::schema::v0::PadMode padMode = mindspore::schema::v0::PadMode_NOTSET;
  int32_t padUp = 0;
  int32_t padDown = 0;
  int32_t padLeft = 0;
  int32_t padRight = 0;
  int32_t dilateW = 0;
  int32_t dilateH = 0;
  bool hasBias = false;
  std::vector<int32_t> input_shape{};
  mindspore::schema::v0::ActivationType activationType = mindspore::schema::v0::ActivationType_NO_ACTIVATION;
};

struct GroupConv2DGradInput FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef GroupConv2DGradInputT NativeTableType;
  typedef GroupConv2DGradInputBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return GroupConv2DGradInputTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_FORMAT = 4,
    VT_GROUP = 6,
    VT_CHANNELIN = 8,
    VT_CHANNELOUT = 10,
    VT_KERNELW = 12,
    VT_KERNELH = 14,
    VT_STRIDEW = 16,
    VT_STRIDEH = 18,
    VT_PADMODE = 20,
    VT_PADUP = 22,
    VT_PADDOWN = 24,
    VT_PADLEFT = 26,
    VT_PADRIGHT = 28,
    VT_DILATEW = 30,
    VT_DILATEH = 32,
    VT_HASBIAS = 34,
    VT_INPUT_SHAPE = 36,
    VT_ACTIVATIONTYPE = 38
  };
  mindspore::schema::v0::Format format() const {
    return static_cast<mindspore::schema::v0::Format>(GetField<int32_t>(VT_FORMAT, 0));
  }
  bool mutate_format(mindspore::schema::v0::Format _format) {
    return SetField<int32_t>(VT_FORMAT, static_cast<int32_t>(_format), 0);
  }
  int32_t group() const {
    return GetField<int32_t>(VT_GROUP, 0);
  }
  bool mutate_group(int32_t _group) {
    return SetField<int32_t>(VT_GROUP, _group, 0);
  }
  int32_t channelIn() const {
    return GetField<int32_t>(VT_CHANNELIN, 0);
  }
  bool mutate_channelIn(int32_t _channelIn) {
    return SetField<int32_t>(VT_CHANNELIN, _channelIn, 0);
  }
  int32_t channelOut() const {
    return GetField<int32_t>(VT_CHANNELOUT, 0);
  }
  bool mutate_channelOut(int32_t _channelOut) {
    return SetField<int32_t>(VT_CHANNELOUT, _channelOut, 0);
  }
  int32_t kernelW() const {
    return GetField<int32_t>(VT_KERNELW, 0);
  }
  bool mutate_kernelW(int32_t _kernelW) {
    return SetField<int32_t>(VT_KERNELW, _kernelW, 0);
  }
  int32_t kernelH() const {
    return GetField<int32_t>(VT_KERNELH, 0);
  }
  bool mutate_kernelH(int32_t _kernelH) {
    return SetField<int32_t>(VT_KERNELH, _kernelH, 0);
  }
  int32_t strideW() const {
    return GetField<int32_t>(VT_STRIDEW, 0);
  }
  bool mutate_strideW(int32_t _strideW) {
    return SetField<int32_t>(VT_STRIDEW, _strideW, 0);
  }
  int32_t strideH() const {
    return GetField<int32_t>(VT_STRIDEH, 0);
  }
  bool mutate_strideH(int32_t _strideH) {
    return SetField<int32_t>(VT_STRIDEH, _strideH, 0);
  }
  mindspore::schema::v0::PadMode padMode() const {
    return static_cast<mindspore::schema::v0::PadMode>(GetField<int8_t>(VT_PADMODE, 0));
  }
  bool mutate_padMode(mindspore::schema::v0::PadMode _padMode) {
    return SetField<int8_t>(VT_PADMODE, static_cast<int8_t>(_padMode), 0);
  }
  int32_t padUp() const {
    return GetField<int32_t>(VT_PADUP, 0);
  }
  bool mutate_padUp(int32_t _padUp) {
    return SetField<int32_t>(VT_PADUP, _padUp, 0);
  }
  int32_t padDown() const {
    return GetField<int32_t>(VT_PADDOWN, 0);
  }
  bool mutate_padDown(int32_t _padDown) {
    return SetField<int32_t>(VT_PADDOWN, _padDown, 0);
  }
  int32_t padLeft() const {
    return GetField<int32_t>(VT_PADLEFT, 0);
  }
  bool mutate_padLeft(int32_t _padLeft) {
    return SetField<int32_t>(VT_PADLEFT, _padLeft, 0);
  }
  int32_t padRight() const {
    return GetField<int32_t>(VT_PADRIGHT, 0);
  }
  bool mutate_padRight(int32_t _padRight) {
    return SetField<int32_t>(VT_PADRIGHT, _padRight, 0);
  }
  int32_t dilateW() const {
    return GetField<int32_t>(VT_DILATEW, 0);
  }
  bool mutate_dilateW(int32_t _dilateW) {
    return SetField<int32_t>(VT_DILATEW, _dilateW, 0);
  }
  int32_t dilateH() const {
    return GetField<int32_t>(VT_DILATEH, 0);
  }
  bool mutate_dilateH(int32_t _dilateH) {
    return SetField<int32_t>(VT_DILATEH, _dilateH, 0);
  }
  bool hasBias() const {
    return GetField<uint8_t>(VT_HASBIAS, 0) != 0;
  }
  bool mutate_hasBias(bool _hasBias) {
    return SetField<uint8_t>(VT_HASBIAS, static_cast<uint8_t>(_hasBias), 0);
  }
  const flatbuffers::Vector<int32_t> *input_shape() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_INPUT_SHAPE);
  }
  flatbuffers::Vector<int32_t> *mutable_input_shape() {
    return GetPointer<flatbuffers::Vector<int32_t> *>(VT_INPUT_SHAPE);
  }
  mindspore::schema::v0::ActivationType activationType() const {
    return static_cast<mindspore::schema::v0::ActivationType>(GetField<int8_t>(VT_ACTIVATIONTYPE, 0));
  }
  bool mutate_activationType(mindspore::schema::v0::ActivationType _activationType) {
    return SetField<int8_t>(VT_ACTIVATIONTYPE, static_cast<int8_t>(_activationType), 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_FORMAT) &&
           VerifyField<int32_t>(verifier, VT_GROUP) &&
           VerifyField<int32_t>(verifier, VT_CHANNELIN) &&
           VerifyField<int32_t>(verifier, VT_CHANNELOUT) &&
           VerifyField<int32_t>(verifier, VT_KERNELW) &&
           VerifyField<int32_t>(verifier, VT_KERNELH) &&
           VerifyField<int32_t>(verifier, VT_STRIDEW) &&
           VerifyField<int32_t>(verifier, VT_STRIDEH) &&
           VerifyField<int8_t>(verifier, VT_PADMODE) &&
           VerifyField<int32_t>(verifier, VT_PADUP) &&
           VerifyField<int32_t>(verifier, VT_PADDOWN) &&
           VerifyField<int32_t>(verifier, VT_PADLEFT) &&
           VerifyField<int32_t>(verifier, VT_PADRIGHT) &&
           VerifyField<int32_t>(verifier, VT_DILATEW) &&
           VerifyField<int32_t>(verifier, VT_DILATEH) &&
           VerifyField<uint8_t>(verifier, VT_HASBIAS) &&
           VerifyOffset(verifier, VT_INPUT_SHAPE) &&
           verifier.VerifyVector(input_shape()) &&
           VerifyField<int8_t>(verifier, VT_ACTIVATIONTYPE) &&
           verifier.EndTable();
  }
  GroupConv2DGradInputT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(GroupConv2DGradInputT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<GroupConv2DGradInput> Pack(flatbuffers::FlatBufferBuilder &_fbb, const GroupConv2DGradInputT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct GroupConv2DGradInputBuilder {
  typedef GroupConv2DGradInput Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_format(mindspore::schema::v0::Format format) {
    fbb_.AddElement<int32_t>(GroupConv2DGradInput::VT_FORMAT, static_cast<int32_t>(format), 0);
  }
  void add_group(int32_t group) {
    fbb_.AddElement<int32_t>(GroupConv2DGradInput::VT_GROUP, group, 0);
  }
  void add_channelIn(int32_t channelIn) {
    fbb_.AddElement<int32_t>(GroupConv2DGradInput::VT_CHANNELIN, channelIn, 0);
  }
  void add_channelOut(int32_t channelOut) {
    fbb_.AddElement<int32_t>(GroupConv2DGradInput::VT_CHANNELOUT, channelOut, 0);
  }
  void add_kernelW(int32_t kernelW) {
    fbb_.AddElement<int32_t>(GroupConv2DGradInput::VT_KERNELW, kernelW, 0);
  }
  void add_kernelH(int32_t kernelH) {
    fbb_.AddElement<int32_t>(GroupConv2DGradInput::VT_KERNELH, kernelH, 0);
  }
  void add_strideW(int32_t strideW) {
    fbb_.AddElement<int32_t>(GroupConv2DGradInput::VT_STRIDEW, strideW, 0);
  }
  void add_strideH(int32_t strideH) {
    fbb_.AddElement<int32_t>(GroupConv2DGradInput::VT_STRIDEH, strideH, 0);
  }
  void add_padMode(mindspore::schema::v0::PadMode padMode) {
    fbb_.AddElement<int8_t>(GroupConv2DGradInput::VT_PADMODE, static_cast<int8_t>(padMode), 0);
  }
  void add_padUp(int32_t padUp) {
    fbb_.AddElement<int32_t>(GroupConv2DGradInput::VT_PADUP, padUp, 0);
  }
  void add_padDown(int32_t padDown) {
    fbb_.AddElement<int32_t>(GroupConv2DGradInput::VT_PADDOWN, padDown, 0);
  }
  void add_padLeft(int32_t padLeft) {
    fbb_.AddElement<int32_t>(GroupConv2DGradInput::VT_PADLEFT, padLeft, 0);
  }
  void add_padRight(int32_t padRight) {
    fbb_.AddElement<int32_t>(GroupConv2DGradInput::VT_PADRIGHT, padRight, 0);
  }
  void add_dilateW(int32_t dilateW) {
    fbb_.AddElement<int32_t>(GroupConv2DGradInput::VT_DILATEW, dilateW, 0);
  }
  void add_dilateH(int32_t dilateH) {
    fbb_.AddElement<int32_t>(GroupConv2DGradInput::VT_DILATEH, dilateH, 0);
  }
  void add_hasBias(bool hasBias) {
    fbb_.AddElement<uint8_t>(GroupConv2DGradInput::VT_HASBIAS, static_cast<uint8_t>(hasBias), 0);
  }
  void add_input_shape(flatbuffers::Offset<flatbuffers::Vector<int32_t>> input_shape) {
    fbb_.AddOffset(GroupConv2DGradInput::VT_INPUT_SHAPE, input_shape);
  }
  void add_activationType(mindspore::schema::v0::ActivationType activationType) {
    fbb_.AddElement<int8_t>(GroupConv2DGradInput::VT_ACTIVATIONTYPE, static_cast<int8_t>(activationType), 0);
  }
  explicit GroupConv2DGradInputBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<GroupConv2DGradInput> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<GroupConv2DGradInput>(end);
    return o;
  }
};

inline flatbuffers::Offset<GroupConv2DGradInput> CreateGroupConv2DGradInput(
    flatbuffers::FlatBufferBuilder &_fbb,
    mindspore::schema::v0::Format format = mindspore::schema::v0::Format_NCHW,
    int32_t group = 0,
    int32_t channelIn = 0,
    int32_t channelOut = 0,
    int32_t kernelW = 0,
    int32_t kernelH = 0,
    int32_t strideW = 0,
    int32_t strideH = 0,
    mindspore::schema::v0::PadMode padMode = mindspore::schema::v0::PadMode_NOTSET,
    int32_t padUp = 0,
    int32_t padDown = 0,
    int32_t padLeft = 0,
    int32_t padRight = 0,
    int32_t dilateW = 0,
    int32_t dilateH = 0,
    bool hasBias = false,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> input_shape = 0,
    mindspore::schema::v0::ActivationType activationType = mindspore::schema::v0::ActivationType_NO_ACTIVATION) {
  GroupConv2DGradInputBuilder builder_(_fbb);
  builder_.add_input_shape(input_shape);
  builder_.add_dilateH(dilateH);
  builder_.add_dilateW(dilateW);
  builder_.add_padRight(padRight);
  builder_.add_padLeft(padLeft);
  builder_.add_padDown(padDown);
  builder_.add_padUp(padUp);
  builder_.add_strideH(strideH);
  builder_.add_strideW(strideW);
  builder_.add_kernelH(kernelH);
  builder_.add_kernelW(kernelW);
  builder_.add_channelOut(channelOut);
  builder_.add_channelIn(channelIn);
  builder_.add_group(group);
  builder_.add_format(format);
  builder_.add_activationType(activationType);
  builder_.add_hasBias(hasBias);
  builder_.add_padMode(padMode);
  return builder_.Finish();
}

inline flatbuffers::Offset<GroupConv2DGradInput> CreateGroupConv2DGradInputDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    mindspore::schema::v0::Format format = mindspore::schema::v0::Format_NCHW,
    int32_t group = 0,
    int32_t channelIn = 0,
    int32_t channelOut = 0,
    int32_t kernelW = 0,
    int32_t kernelH = 0,
    int32_t strideW = 0,
    int32_t strideH = 0,
    mindspore::schema::v0::PadMode padMode = mindspore::schema::v0::PadMode_NOTSET,
    int32_t padUp = 0,
    int32_t padDown = 0,
    int32_t padLeft = 0,
    int32_t padRight = 0,
    int32_t dilateW = 0,
    int32_t dilateH = 0,
    bool hasBias = false,
    const std::vector<int32_t> *input_shape = nullptr,
    mindspore::schema::v0::ActivationType activationType = mindspore::schema::v0::ActivationType_NO_ACTIVATION) {
  auto input_shape__ = input_shape ? _fbb.CreateVector<int32_t>(*input_shape) : 0;
  return mindspore::schema::v0::CreateGroupConv2DGradInput(
      _fbb,
      format,
      group,
      channelIn,
      channelOut,
      kernelW,
      kernelH,
      strideW,
      strideH,
      padMode,
      padUp,
      padDown,
      padLeft,
      padRight,
      dilateW,
      dilateH,
      hasBias,
      input_shape__,
      activationType);
}

flatbuffers::Offset<GroupConv2DGradInput> CreateGroupConv2DGradInput(flatbuffers::FlatBufferBuilder &_fbb, const GroupConv2DGradInputT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct FusedBatchNormT : public flatbuffers::NativeTable {
  typedef FusedBatchNorm TableType;
  float epsilon = 0.00001f;
  float momentum = 0.9f;
  int32_t spatial = 1;
};

struct FusedBatchNorm FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef FusedBatchNormT NativeTableType;
  typedef FusedBatchNormBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return FusedBatchNormTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_EPSILON = 4,
    VT_MOMENTUM = 6,
    VT_SPATIAL = 8
  };
  float epsilon() const {
    return GetField<float>(VT_EPSILON, 0.00001f);
  }
  bool mutate_epsilon(float _epsilon) {
    return SetField<float>(VT_EPSILON, _epsilon, 0.00001f);
  }
  float momentum() const {
    return GetField<float>(VT_MOMENTUM, 0.9f);
  }
  bool mutate_momentum(float _momentum) {
    return SetField<float>(VT_MOMENTUM, _momentum, 0.9f);
  }
  int32_t spatial() const {
    return GetField<int32_t>(VT_SPATIAL, 1);
  }
  bool mutate_spatial(int32_t _spatial) {
    return SetField<int32_t>(VT_SPATIAL, _spatial, 1);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<float>(verifier, VT_EPSILON) &&
           VerifyField<float>(verifier, VT_MOMENTUM) &&
           VerifyField<int32_t>(verifier, VT_SPATIAL) &&
           verifier.EndTable();
  }
  FusedBatchNormT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(FusedBatchNormT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<FusedBatchNorm> Pack(flatbuffers::FlatBufferBuilder &_fbb, const FusedBatchNormT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct FusedBatchNormBuilder {
  typedef FusedBatchNorm Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_epsilon(float epsilon) {
    fbb_.AddElement<float>(FusedBatchNorm::VT_EPSILON, epsilon, 0.00001f);
  }
  void add_momentum(float momentum) {
    fbb_.AddElement<float>(FusedBatchNorm::VT_MOMENTUM, momentum, 0.9f);
  }
  void add_spatial(int32_t spatial) {
    fbb_.AddElement<int32_t>(FusedBatchNorm::VT_SPATIAL, spatial, 1);
  }
  explicit FusedBatchNormBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<FusedBatchNorm> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<FusedBatchNorm>(end);
    return o;
  }
};

inline flatbuffers::Offset<FusedBatchNorm> CreateFusedBatchNorm(
    flatbuffers::FlatBufferBuilder &_fbb,
    float epsilon = 0.00001f,
    float momentum = 0.9f,
    int32_t spatial = 1) {
  FusedBatchNormBuilder builder_(_fbb);
  builder_.add_spatial(spatial);
  builder_.add_momentum(momentum);
  builder_.add_epsilon(epsilon);
  return builder_.Finish();
}

flatbuffers::Offset<FusedBatchNorm> CreateFusedBatchNorm(flatbuffers::FlatBufferBuilder &_fbb, const FusedBatchNormT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct BatchNormT : public flatbuffers::NativeTable {
  typedef BatchNorm TableType;
  float epsilon = 0.00001f;
};

struct BatchNorm FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef BatchNormT NativeTableType;
  typedef BatchNormBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return BatchNormTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_EPSILON = 4
  };
  float epsilon() const {
    return GetField<float>(VT_EPSILON, 0.00001f);
  }
  bool mutate_epsilon(float _epsilon) {
    return SetField<float>(VT_EPSILON, _epsilon, 0.00001f);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<float>(verifier, VT_EPSILON) &&
           verifier.EndTable();
  }
  BatchNormT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(BatchNormT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<BatchNorm> Pack(flatbuffers::FlatBufferBuilder &_fbb, const BatchNormT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct BatchNormBuilder {
  typedef BatchNorm Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_epsilon(float epsilon) {
    fbb_.AddElement<float>(BatchNorm::VT_EPSILON, epsilon, 0.00001f);
  }
  explicit BatchNormBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<BatchNorm> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<BatchNorm>(end);
    return o;
  }
};

inline flatbuffers::Offset<BatchNorm> CreateBatchNorm(
    flatbuffers::FlatBufferBuilder &_fbb,
    float epsilon = 0.00001f) {
  BatchNormBuilder builder_(_fbb);
  builder_.add_epsilon(epsilon);
  return builder_.Finish();
}

flatbuffers::Offset<BatchNorm> CreateBatchNorm(flatbuffers::FlatBufferBuilder &_fbb, const BatchNormT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct BiasGradT : public flatbuffers::NativeTable {
  typedef BiasGrad TableType;
  std::vector<int32_t> axis{};
};

struct BiasGrad FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef BiasGradT NativeTableType;
  typedef BiasGradBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return BiasGradTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_AXIS = 4
  };
  const flatbuffers::Vector<int32_t> *axis() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_AXIS);
  }
  flatbuffers::Vector<int32_t> *mutable_axis() {
    return GetPointer<flatbuffers::Vector<int32_t> *>(VT_AXIS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_AXIS) &&
           verifier.VerifyVector(axis()) &&
           verifier.EndTable();
  }
  BiasGradT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(BiasGradT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<BiasGrad> Pack(flatbuffers::FlatBufferBuilder &_fbb, const BiasGradT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct BiasGradBuilder {
  typedef BiasGrad Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_axis(flatbuffers::Offset<flatbuffers::Vector<int32_t>> axis) {
    fbb_.AddOffset(BiasGrad::VT_AXIS, axis);
  }
  explicit BiasGradBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<BiasGrad> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<BiasGrad>(end);
    return o;
  }
};

inline flatbuffers::Offset<BiasGrad> CreateBiasGrad(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> axis = 0) {
  BiasGradBuilder builder_(_fbb);
  builder_.add_axis(axis);
  return builder_.Finish();
}

inline flatbuffers::Offset<BiasGrad> CreateBiasGradDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<int32_t> *axis = nullptr) {
  auto axis__ = axis ? _fbb.CreateVector<int32_t>(*axis) : 0;
  return mindspore::schema::v0::CreateBiasGrad(
      _fbb,
      axis__);
}

flatbuffers::Offset<BiasGrad> CreateBiasGrad(flatbuffers::FlatBufferBuilder &_fbb, const BiasGradT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct SoftmaxCrossEntropyT : public flatbuffers::NativeTable {
  typedef SoftmaxCrossEntropy TableType;
  std::vector<int32_t> axis{};
};

struct SoftmaxCrossEntropy FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef SoftmaxCrossEntropyT NativeTableType;
  typedef SoftmaxCrossEntropyBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return SoftmaxCrossEntropyTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_AXIS = 4
  };
  const flatbuffers::Vector<int32_t> *axis() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_AXIS);
  }
  flatbuffers::Vector<int32_t> *mutable_axis() {
    return GetPointer<flatbuffers::Vector<int32_t> *>(VT_AXIS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_AXIS) &&
           verifier.VerifyVector(axis()) &&
           verifier.EndTable();
  }
  SoftmaxCrossEntropyT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(SoftmaxCrossEntropyT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<SoftmaxCrossEntropy> Pack(flatbuffers::FlatBufferBuilder &_fbb, const SoftmaxCrossEntropyT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct SoftmaxCrossEntropyBuilder {
  typedef SoftmaxCrossEntropy Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_axis(flatbuffers::Offset<flatbuffers::Vector<int32_t>> axis) {
    fbb_.AddOffset(SoftmaxCrossEntropy::VT_AXIS, axis);
  }
  explicit SoftmaxCrossEntropyBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<SoftmaxCrossEntropy> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SoftmaxCrossEntropy>(end);
    return o;
  }
};

inline flatbuffers::Offset<SoftmaxCrossEntropy> CreateSoftmaxCrossEntropy(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> axis = 0) {
  SoftmaxCrossEntropyBuilder builder_(_fbb);
  builder_.add_axis(axis);
  return builder_.Finish();
}

inline flatbuffers::Offset<SoftmaxCrossEntropy> CreateSoftmaxCrossEntropyDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<int32_t> *axis = nullptr) {
  auto axis__ = axis ? _fbb.CreateVector<int32_t>(*axis) : 0;
  return mindspore::schema::v0::CreateSoftmaxCrossEntropy(
      _fbb,
      axis__);
}

flatbuffers::Offset<SoftmaxCrossEntropy> CreateSoftmaxCrossEntropy(flatbuffers::FlatBufferBuilder &_fbb, const SoftmaxCrossEntropyT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct SparseSoftmaxCrossEntropyT : public flatbuffers::NativeTable {
  typedef SparseSoftmaxCrossEntropy TableType;
  int32_t isGrad = 0;
};

struct SparseSoftmaxCrossEntropy FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef SparseSoftmaxCrossEntropyT NativeTableType;
  typedef SparseSoftmaxCrossEntropyBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return SparseSoftmaxCrossEntropyTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ISGRAD = 4
  };
  int32_t isGrad() const {
    return GetField<int32_t>(VT_ISGRAD, 0);
  }
  bool mutate_isGrad(int32_t _isGrad) {
    return SetField<int32_t>(VT_ISGRAD, _isGrad, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_ISGRAD) &&
           verifier.EndTable();
  }
  SparseSoftmaxCrossEntropyT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(SparseSoftmaxCrossEntropyT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<SparseSoftmaxCrossEntropy> Pack(flatbuffers::FlatBufferBuilder &_fbb, const SparseSoftmaxCrossEntropyT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct SparseSoftmaxCrossEntropyBuilder {
  typedef SparseSoftmaxCrossEntropy Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_isGrad(int32_t isGrad) {
    fbb_.AddElement<int32_t>(SparseSoftmaxCrossEntropy::VT_ISGRAD, isGrad, 0);
  }
  explicit SparseSoftmaxCrossEntropyBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<SparseSoftmaxCrossEntropy> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SparseSoftmaxCrossEntropy>(end);
    return o;
  }
};

inline flatbuffers::Offset<SparseSoftmaxCrossEntropy> CreateSparseSoftmaxCrossEntropy(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t isGrad = 0) {
  SparseSoftmaxCrossEntropyBuilder builder_(_fbb);
  builder_.add_isGrad(isGrad);
  return builder_.Finish();
}

flatbuffers::Offset<SparseSoftmaxCrossEntropy> CreateSparseSoftmaxCrossEntropy(flatbuffers::FlatBufferBuilder &_fbb, const SparseSoftmaxCrossEntropyT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct make_tupleT : public flatbuffers::NativeTable {
  typedef make_tuple TableType;
};

struct make_tuple FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef make_tupleT NativeTableType;
  typedef make_tupleBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return make_tupleTypeTable();
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  make_tupleT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(make_tupleT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<make_tuple> Pack(flatbuffers::FlatBufferBuilder &_fbb, const make_tupleT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct make_tupleBuilder {
  typedef make_tuple Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit make_tupleBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<make_tuple> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<make_tuple>(end);
    return o;
  }
};

inline flatbuffers::Offset<make_tuple> Createmake_tuple(
    flatbuffers::FlatBufferBuilder &_fbb) {
  make_tupleBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<make_tuple> Createmake_tuple(flatbuffers::FlatBufferBuilder &_fbb, const make_tupleT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct PoolingGradT : public flatbuffers::NativeTable {
  typedef PoolingGrad TableType;
  mindspore::schema::v0::Format format = mindspore::schema::v0::Format_NCHW;
  mindspore::schema::v0::PoolMode poolingMode = mindspore::schema::v0::PoolMode_MAX_POOLING;
  bool global = false;
  int32_t windowW = 0;
  int32_t windowH = 0;
  int32_t strideW = 0;
  int32_t strideH = 0;
  mindspore::schema::v0::PadMode padMode = mindspore::schema::v0::PadMode_NOTSET;
  int32_t padUp = 0;
  int32_t padDown = 0;
  int32_t padLeft = 0;
  int32_t padRight = 0;
  mindspore::schema::v0::RoundMode roundMode = mindspore::schema::v0::RoundMode_FLOOR;
};

struct PoolingGrad FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef PoolingGradT NativeTableType;
  typedef PoolingGradBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return PoolingGradTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_FORMAT = 4,
    VT_POOLINGMODE = 6,
    VT_GLOBAL = 8,
    VT_WINDOWW = 10,
    VT_WINDOWH = 12,
    VT_STRIDEW = 14,
    VT_STRIDEH = 16,
    VT_PADMODE = 18,
    VT_PADUP = 20,
    VT_PADDOWN = 22,
    VT_PADLEFT = 24,
    VT_PADRIGHT = 26,
    VT_ROUNDMODE = 28
  };
  mindspore::schema::v0::Format format() const {
    return static_cast<mindspore::schema::v0::Format>(GetField<int32_t>(VT_FORMAT, 0));
  }
  bool mutate_format(mindspore::schema::v0::Format _format) {
    return SetField<int32_t>(VT_FORMAT, static_cast<int32_t>(_format), 0);
  }
  mindspore::schema::v0::PoolMode poolingMode() const {
    return static_cast<mindspore::schema::v0::PoolMode>(GetField<int8_t>(VT_POOLINGMODE, 0));
  }
  bool mutate_poolingMode(mindspore::schema::v0::PoolMode _poolingMode) {
    return SetField<int8_t>(VT_POOLINGMODE, static_cast<int8_t>(_poolingMode), 0);
  }
  bool global() const {
    return GetField<uint8_t>(VT_GLOBAL, 0) != 0;
  }
  bool mutate_global(bool _global) {
    return SetField<uint8_t>(VT_GLOBAL, static_cast<uint8_t>(_global), 0);
  }
  int32_t windowW() const {
    return GetField<int32_t>(VT_WINDOWW, 0);
  }
  bool mutate_windowW(int32_t _windowW) {
    return SetField<int32_t>(VT_WINDOWW, _windowW, 0);
  }
  int32_t windowH() const {
    return GetField<int32_t>(VT_WINDOWH, 0);
  }
  bool mutate_windowH(int32_t _windowH) {
    return SetField<int32_t>(VT_WINDOWH, _windowH, 0);
  }
  int32_t strideW() const {
    return GetField<int32_t>(VT_STRIDEW, 0);
  }
  bool mutate_strideW(int32_t _strideW) {
    return SetField<int32_t>(VT_STRIDEW, _strideW, 0);
  }
  int32_t strideH() const {
    return GetField<int32_t>(VT_STRIDEH, 0);
  }
  bool mutate_strideH(int32_t _strideH) {
    return SetField<int32_t>(VT_STRIDEH, _strideH, 0);
  }
  mindspore::schema::v0::PadMode padMode() const {
    return static_cast<mindspore::schema::v0::PadMode>(GetField<int8_t>(VT_PADMODE, 0));
  }
  bool mutate_padMode(mindspore::schema::v0::PadMode _padMode) {
    return SetField<int8_t>(VT_PADMODE, static_cast<int8_t>(_padMode), 0);
  }
  int32_t padUp() const {
    return GetField<int32_t>(VT_PADUP, 0);
  }
  bool mutate_padUp(int32_t _padUp) {
    return SetField<int32_t>(VT_PADUP, _padUp, 0);
  }
  int32_t padDown() const {
    return GetField<int32_t>(VT_PADDOWN, 0);
  }
  bool mutate_padDown(int32_t _padDown) {
    return SetField<int32_t>(VT_PADDOWN, _padDown, 0);
  }
  int32_t padLeft() const {
    return GetField<int32_t>(VT_PADLEFT, 0);
  }
  bool mutate_padLeft(int32_t _padLeft) {
    return SetField<int32_t>(VT_PADLEFT, _padLeft, 0);
  }
  int32_t padRight() const {
    return GetField<int32_t>(VT_PADRIGHT, 0);
  }
  bool mutate_padRight(int32_t _padRight) {
    return SetField<int32_t>(VT_PADRIGHT, _padRight, 0);
  }
  mindspore::schema::v0::RoundMode roundMode() const {
    return static_cast<mindspore::schema::v0::RoundMode>(GetField<int8_t>(VT_ROUNDMODE, 0));
  }
  bool mutate_roundMode(mindspore::schema::v0::RoundMode _roundMode) {
    return SetField<int8_t>(VT_ROUNDMODE, static_cast<int8_t>(_roundMode), 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_FORMAT) &&
           VerifyField<int8_t>(verifier, VT_POOLINGMODE) &&
           VerifyField<uint8_t>(verifier, VT_GLOBAL) &&
           VerifyField<int32_t>(verifier, VT_WINDOWW) &&
           VerifyField<int32_t>(verifier, VT_WINDOWH) &&
           VerifyField<int32_t>(verifier, VT_STRIDEW) &&
           VerifyField<int32_t>(verifier, VT_STRIDEH) &&
           VerifyField<int8_t>(verifier, VT_PADMODE) &&
           VerifyField<int32_t>(verifier, VT_PADUP) &&
           VerifyField<int32_t>(verifier, VT_PADDOWN) &&
           VerifyField<int32_t>(verifier, VT_PADLEFT) &&
           VerifyField<int32_t>(verifier, VT_PADRIGHT) &&
           VerifyField<int8_t>(verifier, VT_ROUNDMODE) &&
           verifier.EndTable();
  }
  PoolingGradT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(PoolingGradT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<PoolingGrad> Pack(flatbuffers::FlatBufferBuilder &_fbb, const PoolingGradT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct PoolingGradBuilder {
  typedef PoolingGrad Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_format(mindspore::schema::v0::Format format) {
    fbb_.AddElement<int32_t>(PoolingGrad::VT_FORMAT, static_cast<int32_t>(format), 0);
  }
  void add_poolingMode(mindspore::schema::v0::PoolMode poolingMode) {
    fbb_.AddElement<int8_t>(PoolingGrad::VT_POOLINGMODE, static_cast<int8_t>(poolingMode), 0);
  }
  void add_global(bool global) {
    fbb_.AddElement<uint8_t>(PoolingGrad::VT_GLOBAL, static_cast<uint8_t>(global), 0);
  }
  void add_windowW(int32_t windowW) {
    fbb_.AddElement<int32_t>(PoolingGrad::VT_WINDOWW, windowW, 0);
  }
  void add_windowH(int32_t windowH) {
    fbb_.AddElement<int32_t>(PoolingGrad::VT_WINDOWH, windowH, 0);
  }
  void add_strideW(int32_t strideW) {
    fbb_.AddElement<int32_t>(PoolingGrad::VT_STRIDEW, strideW, 0);
  }
  void add_strideH(int32_t strideH) {
    fbb_.AddElement<int32_t>(PoolingGrad::VT_STRIDEH, strideH, 0);
  }
  void add_padMode(mindspore::schema::v0::PadMode padMode) {
    fbb_.AddElement<int8_t>(PoolingGrad::VT_PADMODE, static_cast<int8_t>(padMode), 0);
  }
  void add_padUp(int32_t padUp) {
    fbb_.AddElement<int32_t>(PoolingGrad::VT_PADUP, padUp, 0);
  }
  void add_padDown(int32_t padDown) {
    fbb_.AddElement<int32_t>(PoolingGrad::VT_PADDOWN, padDown, 0);
  }
  void add_padLeft(int32_t padLeft) {
    fbb_.AddElement<int32_t>(PoolingGrad::VT_PADLEFT, padLeft, 0);
  }
  void add_padRight(int32_t padRight) {
    fbb_.AddElement<int32_t>(PoolingGrad::VT_PADRIGHT, padRight, 0);
  }
  void add_roundMode(mindspore::schema::v0::RoundMode roundMode) {
    fbb_.AddElement<int8_t>(PoolingGrad::VT_ROUNDMODE, static_cast<int8_t>(roundMode), 0);
  }
  explicit PoolingGradBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<PoolingGrad> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<PoolingGrad>(end);
    return o;
  }
};

inline flatbuffers::Offset<PoolingGrad> CreatePoolingGrad(
    flatbuffers::FlatBufferBuilder &_fbb,
    mindspore::schema::v0::Format format = mindspore::schema::v0::Format_NCHW,
    mindspore::schema::v0::PoolMode poolingMode = mindspore::schema::v0::PoolMode_MAX_POOLING,
    bool global = false,
    int32_t windowW = 0,
    int32_t windowH = 0,
    int32_t strideW = 0,
    int32_t strideH = 0,
    mindspore::schema::v0::PadMode padMode = mindspore::schema::v0::PadMode_NOTSET,
    int32_t padUp = 0,
    int32_t padDown = 0,
    int32_t padLeft = 0,
    int32_t padRight = 0,
    mindspore::schema::v0::RoundMode roundMode = mindspore::schema::v0::RoundMode_FLOOR) {
  PoolingGradBuilder builder_(_fbb);
  builder_.add_padRight(padRight);
  builder_.add_padLeft(padLeft);
  builder_.add_padDown(padDown);
  builder_.add_padUp(padUp);
  builder_.add_strideH(strideH);
  builder_.add_strideW(strideW);
  builder_.add_windowH(windowH);
  builder_.add_windowW(windowW);
  builder_.add_format(format);
  builder_.add_roundMode(roundMode);
  builder_.add_padMode(padMode);
  builder_.add_global(global);
  builder_.add_poolingMode(poolingMode);
  return builder_.Finish();
}

flatbuffers::Offset<PoolingGrad> CreatePoolingGrad(flatbuffers::FlatBufferBuilder &_fbb, const PoolingGradT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ShapeT : public flatbuffers::NativeTable {
  typedef Shape TableType;
};

struct Shape FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ShapeT NativeTableType;
  typedef ShapeBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return ShapeTypeTable();
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  ShapeT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ShapeT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Shape> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ShapeT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ShapeBuilder {
  typedef Shape Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit ShapeBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Shape> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Shape>(end);
    return o;
  }
};

inline flatbuffers::Offset<Shape> CreateShape(
    flatbuffers::FlatBufferBuilder &_fbb) {
  ShapeBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<Shape> CreateShape(flatbuffers::FlatBufferBuilder &_fbb, const ShapeT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ConstantOfShapeT : public flatbuffers::NativeTable {
  typedef ConstantOfShape TableType;
  int32_t dataType = 0;
  std::vector<float> value{};
};

struct ConstantOfShape FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ConstantOfShapeT NativeTableType;
  typedef ConstantOfShapeBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return ConstantOfShapeTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_DATATYPE = 4,
    VT_VALUE = 6
  };
  int32_t dataType() const {
    return GetField<int32_t>(VT_DATATYPE, 0);
  }
  bool mutate_dataType(int32_t _dataType) {
    return SetField<int32_t>(VT_DATATYPE, _dataType, 0);
  }
  const flatbuffers::Vector<float> *value() const {
    return GetPointer<const flatbuffers::Vector<float> *>(VT_VALUE);
  }
  flatbuffers::Vector<float> *mutable_value() {
    return GetPointer<flatbuffers::Vector<float> *>(VT_VALUE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_DATATYPE) &&
           VerifyOffset(verifier, VT_VALUE) &&
           verifier.VerifyVector(value()) &&
           verifier.EndTable();
  }
  ConstantOfShapeT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ConstantOfShapeT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<ConstantOfShape> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ConstantOfShapeT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ConstantOfShapeBuilder {
  typedef ConstantOfShape Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_dataType(int32_t dataType) {
    fbb_.AddElement<int32_t>(ConstantOfShape::VT_DATATYPE, dataType, 0);
  }
  void add_value(flatbuffers::Offset<flatbuffers::Vector<float>> value) {
    fbb_.AddOffset(ConstantOfShape::VT_VALUE, value);
  }
  explicit ConstantOfShapeBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<ConstantOfShape> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ConstantOfShape>(end);
    return o;
  }
};

inline flatbuffers::Offset<ConstantOfShape> CreateConstantOfShape(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t dataType = 0,
    flatbuffers::Offset<flatbuffers::Vector<float>> value = 0) {
  ConstantOfShapeBuilder builder_(_fbb);
  builder_.add_value(value);
  builder_.add_dataType(dataType);
  return builder_.Finish();
}

inline flatbuffers::Offset<ConstantOfShape> CreateConstantOfShapeDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t dataType = 0,
    const std::vector<float> *value = nullptr) {
  auto value__ = value ? _fbb.CreateVector<float>(*value) : 0;
  return mindspore::schema::v0::CreateConstantOfShape(
      _fbb,
      dataType,
      value__);
}

flatbuffers::Offset<ConstantOfShape> CreateConstantOfShape(flatbuffers::FlatBufferBuilder &_fbb, const ConstantOfShapeT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct Nchw2NhwcT : public flatbuffers::NativeTable {
  typedef Nchw2Nhwc TableType;
};

struct Nchw2Nhwc FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef Nchw2NhwcT NativeTableType;
  typedef Nchw2NhwcBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return Nchw2NhwcTypeTable();
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  Nchw2NhwcT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(Nchw2NhwcT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Nchw2Nhwc> Pack(flatbuffers::FlatBufferBuilder &_fbb, const Nchw2NhwcT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct Nchw2NhwcBuilder {
  typedef Nchw2Nhwc Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit Nchw2NhwcBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Nchw2Nhwc> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Nchw2Nhwc>(end);
    return o;
  }
};

inline flatbuffers::Offset<Nchw2Nhwc> CreateNchw2Nhwc(
    flatbuffers::FlatBufferBuilder &_fbb) {
  Nchw2NhwcBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<Nchw2Nhwc> CreateNchw2Nhwc(flatbuffers::FlatBufferBuilder &_fbb, const Nchw2NhwcT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct Nhwc2NchwT : public flatbuffers::NativeTable {
  typedef Nhwc2Nchw TableType;
};

struct Nhwc2Nchw FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef Nhwc2NchwT NativeTableType;
  typedef Nhwc2NchwBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return Nhwc2NchwTypeTable();
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  Nhwc2NchwT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(Nhwc2NchwT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Nhwc2Nchw> Pack(flatbuffers::FlatBufferBuilder &_fbb, const Nhwc2NchwT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct Nhwc2NchwBuilder {
  typedef Nhwc2Nchw Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit Nhwc2NchwBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Nhwc2Nchw> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Nhwc2Nchw>(end);
    return o;
  }
};

inline flatbuffers::Offset<Nhwc2Nchw> CreateNhwc2Nchw(
    flatbuffers::FlatBufferBuilder &_fbb) {
  Nhwc2NchwBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<Nhwc2Nchw> CreateNhwc2Nchw(flatbuffers::FlatBufferBuilder &_fbb, const Nhwc2NchwT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct FakeQuantWithMinMaxVarsT : public flatbuffers::NativeTable {
  typedef FakeQuantWithMinMaxVars TableType;
  bool narrowRange = false;
  int32_t numBits = 0;
};

struct FakeQuantWithMinMaxVars FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef FakeQuantWithMinMaxVarsT NativeTableType;
  typedef FakeQuantWithMinMaxVarsBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return FakeQuantWithMinMaxVarsTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NARROWRANGE = 4,
    VT_NUMBITS = 6
  };
  bool narrowRange() const {
    return GetField<uint8_t>(VT_NARROWRANGE, 0) != 0;
  }
  bool mutate_narrowRange(bool _narrowRange) {
    return SetField<uint8_t>(VT_NARROWRANGE, static_cast<uint8_t>(_narrowRange), 0);
  }
  int32_t numBits() const {
    return GetField<int32_t>(VT_NUMBITS, 0);
  }
  bool mutate_numBits(int32_t _numBits) {
    return SetField<int32_t>(VT_NUMBITS, _numBits, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_NARROWRANGE) &&
           VerifyField<int32_t>(verifier, VT_NUMBITS) &&
           verifier.EndTable();
  }
  FakeQuantWithMinMaxVarsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(FakeQuantWithMinMaxVarsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<FakeQuantWithMinMaxVars> Pack(flatbuffers::FlatBufferBuilder &_fbb, const FakeQuantWithMinMaxVarsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct FakeQuantWithMinMaxVarsBuilder {
  typedef FakeQuantWithMinMaxVars Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_narrowRange(bool narrowRange) {
    fbb_.AddElement<uint8_t>(FakeQuantWithMinMaxVars::VT_NARROWRANGE, static_cast<uint8_t>(narrowRange), 0);
  }
  void add_numBits(int32_t numBits) {
    fbb_.AddElement<int32_t>(FakeQuantWithMinMaxVars::VT_NUMBITS, numBits, 0);
  }
  explicit FakeQuantWithMinMaxVarsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<FakeQuantWithMinMaxVars> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<FakeQuantWithMinMaxVars>(end);
    return o;
  }
};

inline flatbuffers::Offset<FakeQuantWithMinMaxVars> CreateFakeQuantWithMinMaxVars(
    flatbuffers::FlatBufferBuilder &_fbb,
    bool narrowRange = false,
    int32_t numBits = 0) {
  FakeQuantWithMinMaxVarsBuilder builder_(_fbb);
  builder_.add_numBits(numBits);
  builder_.add_narrowRange(narrowRange);
  return builder_.Finish();
}

flatbuffers::Offset<FakeQuantWithMinMaxVars> CreateFakeQuantWithMinMaxVars(flatbuffers::FlatBufferBuilder &_fbb, const FakeQuantWithMinMaxVarsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct BiasAddT : public flatbuffers::NativeTable {
  typedef BiasAdd TableType;
  std::vector<int32_t> axis{};
};

struct BiasAdd FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef BiasAddT NativeTableType;
  typedef BiasAddBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return BiasAddTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_AXIS = 4
  };
  const flatbuffers::Vector<int32_t> *axis() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_AXIS);
  }
  flatbuffers::Vector<int32_t> *mutable_axis() {
    return GetPointer<flatbuffers::Vector<int32_t> *>(VT_AXIS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_AXIS) &&
           verifier.VerifyVector(axis()) &&
           verifier.EndTable();
  }
  BiasAddT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(BiasAddT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<BiasAdd> Pack(flatbuffers::FlatBufferBuilder &_fbb, const BiasAddT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct BiasAddBuilder {
  typedef BiasAdd Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_axis(flatbuffers::Offset<flatbuffers::Vector<int32_t>> axis) {
    fbb_.AddOffset(BiasAdd::VT_AXIS, axis);
  }
  explicit BiasAddBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<BiasAdd> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<BiasAdd>(end);
    return o;
  }
};

inline flatbuffers::Offset<BiasAdd> CreateBiasAdd(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> axis = 0) {
  BiasAddBuilder builder_(_fbb);
  builder_.add_axis(axis);
  return builder_.Finish();
}

inline flatbuffers::Offset<BiasAdd> CreateBiasAddDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<int32_t> *axis = nullptr) {
  auto axis__ = axis ? _fbb.CreateVector<int32_t>(*axis) : 0;
  return mindspore::schema::v0::CreateBiasAdd(
      _fbb,
      axis__);
}

flatbuffers::Offset<BiasAdd> CreateBiasAdd(flatbuffers::FlatBufferBuilder &_fbb, const BiasAddT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ROIPoolingT : public flatbuffers::NativeTable {
  typedef ROIPooling TableType;
  int32_t pooledH = 0;
  int32_t pooledW = 0;
  float scale = 0.0f;
};

struct ROIPooling FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ROIPoolingT NativeTableType;
  typedef ROIPoolingBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return ROIPoolingTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_POOLEDH = 4,
    VT_POOLEDW = 6,
    VT_SCALE = 8
  };
  int32_t pooledH() const {
    return GetField<int32_t>(VT_POOLEDH, 0);
  }
  bool mutate_pooledH(int32_t _pooledH) {
    return SetField<int32_t>(VT_POOLEDH, _pooledH, 0);
  }
  int32_t pooledW() const {
    return GetField<int32_t>(VT_POOLEDW, 0);
  }
  bool mutate_pooledW(int32_t _pooledW) {
    return SetField<int32_t>(VT_POOLEDW, _pooledW, 0);
  }
  float scale() const {
    return GetField<float>(VT_SCALE, 0.0f);
  }
  bool mutate_scale(float _scale) {
    return SetField<float>(VT_SCALE, _scale, 0.0f);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_POOLEDH) &&
           VerifyField<int32_t>(verifier, VT_POOLEDW) &&
           VerifyField<float>(verifier, VT_SCALE) &&
           verifier.EndTable();
  }
  ROIPoolingT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ROIPoolingT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<ROIPooling> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ROIPoolingT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ROIPoolingBuilder {
  typedef ROIPooling Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_pooledH(int32_t pooledH) {
    fbb_.AddElement<int32_t>(ROIPooling::VT_POOLEDH, pooledH, 0);
  }
  void add_pooledW(int32_t pooledW) {
    fbb_.AddElement<int32_t>(ROIPooling::VT_POOLEDW, pooledW, 0);
  }
  void add_scale(float scale) {
    fbb_.AddElement<float>(ROIPooling::VT_SCALE, scale, 0.0f);
  }
  explicit ROIPoolingBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<ROIPooling> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ROIPooling>(end);
    return o;
  }
};

inline flatbuffers::Offset<ROIPooling> CreateROIPooling(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t pooledH = 0,
    int32_t pooledW = 0,
    float scale = 0.0f) {
  ROIPoolingBuilder builder_(_fbb);
  builder_.add_scale(scale);
  builder_.add_pooledW(pooledW);
  builder_.add_pooledH(pooledH);
  return builder_.Finish();
}

flatbuffers::Offset<ROIPooling> CreateROIPooling(flatbuffers::FlatBufferBuilder &_fbb, const ROIPoolingT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct PoolingT : public flatbuffers::NativeTable {
  typedef Pooling TableType;
  mindspore::schema::v0::Format format = mindspore::schema::v0::Format_NCHW;
  mindspore::schema::v0::PoolMode poolingMode = mindspore::schema::v0::PoolMode_MAX_POOLING;
  bool global = false;
  int32_t windowW = 0;
  int32_t windowH = 0;
  int32_t strideW = 0;
  int32_t strideH = 0;
  mindspore::schema::v0::PadMode padMode = mindspore::schema::v0::PadMode_NOTSET;
  int32_t padUp = 0;
  int32_t padDown = 0;
  int32_t padLeft = 0;
  int32_t padRight = 0;
  mindspore::schema::v0::RoundMode roundMode = mindspore::schema::v0::RoundMode_FLOOR;
  mindspore::schema::v0::ActivationType activationType = mindspore::schema::v0::ActivationType_NO_ACTIVATION;
  int32_t avgMode = 0;
};

struct Pooling FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef PoolingT NativeTableType;
  typedef PoolingBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return PoolingTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_FORMAT = 4,
    VT_POOLINGMODE = 6,
    VT_GLOBAL = 8,
    VT_WINDOWW = 10,
    VT_WINDOWH = 12,
    VT_STRIDEW = 14,
    VT_STRIDEH = 16,
    VT_PADMODE = 18,
    VT_PADUP = 20,
    VT_PADDOWN = 22,
    VT_PADLEFT = 24,
    VT_PADRIGHT = 26,
    VT_ROUNDMODE = 28,
    VT_ACTIVATIONTYPE = 30,
    VT_AVGMODE = 32
  };
  mindspore::schema::v0::Format format() const {
    return static_cast<mindspore::schema::v0::Format>(GetField<int32_t>(VT_FORMAT, 0));
  }
  bool mutate_format(mindspore::schema::v0::Format _format) {
    return SetField<int32_t>(VT_FORMAT, static_cast<int32_t>(_format), 0);
  }
  mindspore::schema::v0::PoolMode poolingMode() const {
    return static_cast<mindspore::schema::v0::PoolMode>(GetField<int8_t>(VT_POOLINGMODE, 0));
  }
  bool mutate_poolingMode(mindspore::schema::v0::PoolMode _poolingMode) {
    return SetField<int8_t>(VT_POOLINGMODE, static_cast<int8_t>(_poolingMode), 0);
  }
  bool global() const {
    return GetField<uint8_t>(VT_GLOBAL, 0) != 0;
  }
  bool mutate_global(bool _global) {
    return SetField<uint8_t>(VT_GLOBAL, static_cast<uint8_t>(_global), 0);
  }
  int32_t windowW() const {
    return GetField<int32_t>(VT_WINDOWW, 0);
  }
  bool mutate_windowW(int32_t _windowW) {
    return SetField<int32_t>(VT_WINDOWW, _windowW, 0);
  }
  int32_t windowH() const {
    return GetField<int32_t>(VT_WINDOWH, 0);
  }
  bool mutate_windowH(int32_t _windowH) {
    return SetField<int32_t>(VT_WINDOWH, _windowH, 0);
  }
  int32_t strideW() const {
    return GetField<int32_t>(VT_STRIDEW, 0);
  }
  bool mutate_strideW(int32_t _strideW) {
    return SetField<int32_t>(VT_STRIDEW, _strideW, 0);
  }
  int32_t strideH() const {
    return GetField<int32_t>(VT_STRIDEH, 0);
  }
  bool mutate_strideH(int32_t _strideH) {
    return SetField<int32_t>(VT_STRIDEH, _strideH, 0);
  }
  mindspore::schema::v0::PadMode padMode() const {
    return static_cast<mindspore::schema::v0::PadMode>(GetField<int8_t>(VT_PADMODE, 0));
  }
  bool mutate_padMode(mindspore::schema::v0::PadMode _padMode) {
    return SetField<int8_t>(VT_PADMODE, static_cast<int8_t>(_padMode), 0);
  }
  int32_t padUp() const {
    return GetField<int32_t>(VT_PADUP, 0);
  }
  bool mutate_padUp(int32_t _padUp) {
    return SetField<int32_t>(VT_PADUP, _padUp, 0);
  }
  int32_t padDown() const {
    return GetField<int32_t>(VT_PADDOWN, 0);
  }
  bool mutate_padDown(int32_t _padDown) {
    return SetField<int32_t>(VT_PADDOWN, _padDown, 0);
  }
  int32_t padLeft() const {
    return GetField<int32_t>(VT_PADLEFT, 0);
  }
  bool mutate_padLeft(int32_t _padLeft) {
    return SetField<int32_t>(VT_PADLEFT, _padLeft, 0);
  }
  int32_t padRight() const {
    return GetField<int32_t>(VT_PADRIGHT, 0);
  }
  bool mutate_padRight(int32_t _padRight) {
    return SetField<int32_t>(VT_PADRIGHT, _padRight, 0);
  }
  mindspore::schema::v0::RoundMode roundMode() const {
    return static_cast<mindspore::schema::v0::RoundMode>(GetField<int8_t>(VT_ROUNDMODE, 0));
  }
  bool mutate_roundMode(mindspore::schema::v0::RoundMode _roundMode) {
    return SetField<int8_t>(VT_ROUNDMODE, static_cast<int8_t>(_roundMode), 0);
  }
  mindspore::schema::v0::ActivationType activationType() const {
    return static_cast<mindspore::schema::v0::ActivationType>(GetField<int8_t>(VT_ACTIVATIONTYPE, 0));
  }
  bool mutate_activationType(mindspore::schema::v0::ActivationType _activationType) {
    return SetField<int8_t>(VT_ACTIVATIONTYPE, static_cast<int8_t>(_activationType), 0);
  }
  int32_t avgMode() const {
    return GetField<int32_t>(VT_AVGMODE, 0);
  }
  bool mutate_avgMode(int32_t _avgMode) {
    return SetField<int32_t>(VT_AVGMODE, _avgMode, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_FORMAT) &&
           VerifyField<int8_t>(verifier, VT_POOLINGMODE) &&
           VerifyField<uint8_t>(verifier, VT_GLOBAL) &&
           VerifyField<int32_t>(verifier, VT_WINDOWW) &&
           VerifyField<int32_t>(verifier, VT_WINDOWH) &&
           VerifyField<int32_t>(verifier, VT_STRIDEW) &&
           VerifyField<int32_t>(verifier, VT_STRIDEH) &&
           VerifyField<int8_t>(verifier, VT_PADMODE) &&
           VerifyField<int32_t>(verifier, VT_PADUP) &&
           VerifyField<int32_t>(verifier, VT_PADDOWN) &&
           VerifyField<int32_t>(verifier, VT_PADLEFT) &&
           VerifyField<int32_t>(verifier, VT_PADRIGHT) &&
           VerifyField<int8_t>(verifier, VT_ROUNDMODE) &&
           VerifyField<int8_t>(verifier, VT_ACTIVATIONTYPE) &&
           VerifyField<int32_t>(verifier, VT_AVGMODE) &&
           verifier.EndTable();
  }
  PoolingT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(PoolingT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Pooling> Pack(flatbuffers::FlatBufferBuilder &_fbb, const PoolingT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct PoolingBuilder {
  typedef Pooling Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_format(mindspore::schema::v0::Format format) {
    fbb_.AddElement<int32_t>(Pooling::VT_FORMAT, static_cast<int32_t>(format), 0);
  }
  void add_poolingMode(mindspore::schema::v0::PoolMode poolingMode) {
    fbb_.AddElement<int8_t>(Pooling::VT_POOLINGMODE, static_cast<int8_t>(poolingMode), 0);
  }
  void add_global(bool global) {
    fbb_.AddElement<uint8_t>(Pooling::VT_GLOBAL, static_cast<uint8_t>(global), 0);
  }
  void add_windowW(int32_t windowW) {
    fbb_.AddElement<int32_t>(Pooling::VT_WINDOWW, windowW, 0);
  }
  void add_windowH(int32_t windowH) {
    fbb_.AddElement<int32_t>(Pooling::VT_WINDOWH, windowH, 0);
  }
  void add_strideW(int32_t strideW) {
    fbb_.AddElement<int32_t>(Pooling::VT_STRIDEW, strideW, 0);
  }
  void add_strideH(int32_t strideH) {
    fbb_.AddElement<int32_t>(Pooling::VT_STRIDEH, strideH, 0);
  }
  void add_padMode(mindspore::schema::v0::PadMode padMode) {
    fbb_.AddElement<int8_t>(Pooling::VT_PADMODE, static_cast<int8_t>(padMode), 0);
  }
  void add_padUp(int32_t padUp) {
    fbb_.AddElement<int32_t>(Pooling::VT_PADUP, padUp, 0);
  }
  void add_padDown(int32_t padDown) {
    fbb_.AddElement<int32_t>(Pooling::VT_PADDOWN, padDown, 0);
  }
  void add_padLeft(int32_t padLeft) {
    fbb_.AddElement<int32_t>(Pooling::VT_PADLEFT, padLeft, 0);
  }
  void add_padRight(int32_t padRight) {
    fbb_.AddElement<int32_t>(Pooling::VT_PADRIGHT, padRight, 0);
  }
  void add_roundMode(mindspore::schema::v0::RoundMode roundMode) {
    fbb_.AddElement<int8_t>(Pooling::VT_ROUNDMODE, static_cast<int8_t>(roundMode), 0);
  }
  void add_activationType(mindspore::schema::v0::ActivationType activationType) {
    fbb_.AddElement<int8_t>(Pooling::VT_ACTIVATIONTYPE, static_cast<int8_t>(activationType), 0);
  }
  void add_avgMode(int32_t avgMode) {
    fbb_.AddElement<int32_t>(Pooling::VT_AVGMODE, avgMode, 0);
  }
  explicit PoolingBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Pooling> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Pooling>(end);
    return o;
  }
};

inline flatbuffers::Offset<Pooling> CreatePooling(
    flatbuffers::FlatBufferBuilder &_fbb,
    mindspore::schema::v0::Format format = mindspore::schema::v0::Format_NCHW,
    mindspore::schema::v0::PoolMode poolingMode = mindspore::schema::v0::PoolMode_MAX_POOLING,
    bool global = false,
    int32_t windowW = 0,
    int32_t windowH = 0,
    int32_t strideW = 0,
    int32_t strideH = 0,
    mindspore::schema::v0::PadMode padMode = mindspore::schema::v0::PadMode_NOTSET,
    int32_t padUp = 0,
    int32_t padDown = 0,
    int32_t padLeft = 0,
    int32_t padRight = 0,
    mindspore::schema::v0::RoundMode roundMode = mindspore::schema::v0::RoundMode_FLOOR,
    mindspore::schema::v0::ActivationType activationType = mindspore::schema::v0::ActivationType_NO_ACTIVATION,
    int32_t avgMode = 0) {
  PoolingBuilder builder_(_fbb);
  builder_.add_avgMode(avgMode);
  builder_.add_padRight(padRight);
  builder_.add_padLeft(padLeft);
  builder_.add_padDown(padDown);
  builder_.add_padUp(padUp);
  builder_.add_strideH(strideH);
  builder_.add_strideW(strideW);
  builder_.add_windowH(windowH);
  builder_.add_windowW(windowW);
  builder_.add_format(format);
  builder_.add_activationType(activationType);
  builder_.add_roundMode(roundMode);
  builder_.add_padMode(padMode);
  builder_.add_global(global);
  builder_.add_poolingMode(poolingMode);
  return builder_.Finish();
}

flatbuffers::Offset<Pooling> CreatePooling(flatbuffers::FlatBufferBuilder &_fbb, const PoolingT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct DepthwiseConv2DT : public flatbuffers::NativeTable {
  typedef DepthwiseConv2D TableType;
  mindspore::schema::v0::Format format = mindspore::schema::v0::Format_NCHW;
  int32_t channelIn = 0;
  int32_t channelMultiplier = 0;
  int32_t kernelW = 0;
  int32_t kernelH = 0;
  int32_t strideW = 0;
  int32_t strideH = 0;
  mindspore::schema::v0::PadMode padMode = mindspore::schema::v0::PadMode_NOTSET;
  int32_t padUp = 0;
  int32_t padDown = 0;
  int32_t padLeft = 0;
  int32_t padRight = 0;
  int32_t dilateW = 0;
  int32_t dilateH = 0;
  bool hasBias = false;
  mindspore::schema::v0::ActivationType activationType = mindspore::schema::v0::ActivationType_NO_ACTIVATION;
};

struct DepthwiseConv2D FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef DepthwiseConv2DT NativeTableType;
  typedef DepthwiseConv2DBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return DepthwiseConv2DTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_FORMAT = 4,
    VT_CHANNELIN = 6,
    VT_CHANNELMULTIPLIER = 8,
    VT_KERNELW = 10,
    VT_KERNELH = 12,
    VT_STRIDEW = 14,
    VT_STRIDEH = 16,
    VT_PADMODE = 18,
    VT_PADUP = 20,
    VT_PADDOWN = 22,
    VT_PADLEFT = 24,
    VT_PADRIGHT = 26,
    VT_DILATEW = 28,
    VT_DILATEH = 30,
    VT_HASBIAS = 32,
    VT_ACTIVATIONTYPE = 34
  };
  mindspore::schema::v0::Format format() const {
    return static_cast<mindspore::schema::v0::Format>(GetField<int32_t>(VT_FORMAT, 0));
  }
  bool mutate_format(mindspore::schema::v0::Format _format) {
    return SetField<int32_t>(VT_FORMAT, static_cast<int32_t>(_format), 0);
  }
  int32_t channelIn() const {
    return GetField<int32_t>(VT_CHANNELIN, 0);
  }
  bool mutate_channelIn(int32_t _channelIn) {
    return SetField<int32_t>(VT_CHANNELIN, _channelIn, 0);
  }
  int32_t channelMultiplier() const {
    return GetField<int32_t>(VT_CHANNELMULTIPLIER, 0);
  }
  bool mutate_channelMultiplier(int32_t _channelMultiplier) {
    return SetField<int32_t>(VT_CHANNELMULTIPLIER, _channelMultiplier, 0);
  }
  int32_t kernelW() const {
    return GetField<int32_t>(VT_KERNELW, 0);
  }
  bool mutate_kernelW(int32_t _kernelW) {
    return SetField<int32_t>(VT_KERNELW, _kernelW, 0);
  }
  int32_t kernelH() const {
    return GetField<int32_t>(VT_KERNELH, 0);
  }
  bool mutate_kernelH(int32_t _kernelH) {
    return SetField<int32_t>(VT_KERNELH, _kernelH, 0);
  }
  int32_t strideW() const {
    return GetField<int32_t>(VT_STRIDEW, 0);
  }
  bool mutate_strideW(int32_t _strideW) {
    return SetField<int32_t>(VT_STRIDEW, _strideW, 0);
  }
  int32_t strideH() const {
    return GetField<int32_t>(VT_STRIDEH, 0);
  }
  bool mutate_strideH(int32_t _strideH) {
    return SetField<int32_t>(VT_STRIDEH, _strideH, 0);
  }
  mindspore::schema::v0::PadMode padMode() const {
    return static_cast<mindspore::schema::v0::PadMode>(GetField<int8_t>(VT_PADMODE, 0));
  }
  bool mutate_padMode(mindspore::schema::v0::PadMode _padMode) {
    return SetField<int8_t>(VT_PADMODE, static_cast<int8_t>(_padMode), 0);
  }
  int32_t padUp() const {
    return GetField<int32_t>(VT_PADUP, 0);
  }
  bool mutate_padUp(int32_t _padUp) {
    return SetField<int32_t>(VT_PADUP, _padUp, 0);
  }
  int32_t padDown() const {
    return GetField<int32_t>(VT_PADDOWN, 0);
  }
  bool mutate_padDown(int32_t _padDown) {
    return SetField<int32_t>(VT_PADDOWN, _padDown, 0);
  }
  int32_t padLeft() const {
    return GetField<int32_t>(VT_PADLEFT, 0);
  }
  bool mutate_padLeft(int32_t _padLeft) {
    return SetField<int32_t>(VT_PADLEFT, _padLeft, 0);
  }
  int32_t padRight() const {
    return GetField<int32_t>(VT_PADRIGHT, 0);
  }
  bool mutate_padRight(int32_t _padRight) {
    return SetField<int32_t>(VT_PADRIGHT, _padRight, 0);
  }
  int32_t dilateW() const {
    return GetField<int32_t>(VT_DILATEW, 0);
  }
  bool mutate_dilateW(int32_t _dilateW) {
    return SetField<int32_t>(VT_DILATEW, _dilateW, 0);
  }
  int32_t dilateH() const {
    return GetField<int32_t>(VT_DILATEH, 0);
  }
  bool mutate_dilateH(int32_t _dilateH) {
    return SetField<int32_t>(VT_DILATEH, _dilateH, 0);
  }
  bool hasBias() const {
    return GetField<uint8_t>(VT_HASBIAS, 0) != 0;
  }
  bool mutate_hasBias(bool _hasBias) {
    return SetField<uint8_t>(VT_HASBIAS, static_cast<uint8_t>(_hasBias), 0);
  }
  mindspore::schema::v0::ActivationType activationType() const {
    return static_cast<mindspore::schema::v0::ActivationType>(GetField<int8_t>(VT_ACTIVATIONTYPE, 0));
  }
  bool mutate_activationType(mindspore::schema::v0::ActivationType _activationType) {
    return SetField<int8_t>(VT_ACTIVATIONTYPE, static_cast<int8_t>(_activationType), 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_FORMAT) &&
           VerifyField<int32_t>(verifier, VT_CHANNELIN) &&
           VerifyField<int32_t>(verifier, VT_CHANNELMULTIPLIER) &&
           VerifyField<int32_t>(verifier, VT_KERNELW) &&
           VerifyField<int32_t>(verifier, VT_KERNELH) &&
           VerifyField<int32_t>(verifier, VT_STRIDEW) &&
           VerifyField<int32_t>(verifier, VT_STRIDEH) &&
           VerifyField<int8_t>(verifier, VT_PADMODE) &&
           VerifyField<int32_t>(verifier, VT_PADUP) &&
           VerifyField<int32_t>(verifier, VT_PADDOWN) &&
           VerifyField<int32_t>(verifier, VT_PADLEFT) &&
           VerifyField<int32_t>(verifier, VT_PADRIGHT) &&
           VerifyField<int32_t>(verifier, VT_DILATEW) &&
           VerifyField<int32_t>(verifier, VT_DILATEH) &&
           VerifyField<uint8_t>(verifier, VT_HASBIAS) &&
           VerifyField<int8_t>(verifier, VT_ACTIVATIONTYPE) &&
           verifier.EndTable();
  }
  DepthwiseConv2DT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(DepthwiseConv2DT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<DepthwiseConv2D> Pack(flatbuffers::FlatBufferBuilder &_fbb, const DepthwiseConv2DT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct DepthwiseConv2DBuilder {
  typedef DepthwiseConv2D Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_format(mindspore::schema::v0::Format format) {
    fbb_.AddElement<int32_t>(DepthwiseConv2D::VT_FORMAT, static_cast<int32_t>(format), 0);
  }
  void add_channelIn(int32_t channelIn) {
    fbb_.AddElement<int32_t>(DepthwiseConv2D::VT_CHANNELIN, channelIn, 0);
  }
  void add_channelMultiplier(int32_t channelMultiplier) {
    fbb_.AddElement<int32_t>(DepthwiseConv2D::VT_CHANNELMULTIPLIER, channelMultiplier, 0);
  }
  void add_kernelW(int32_t kernelW) {
    fbb_.AddElement<int32_t>(DepthwiseConv2D::VT_KERNELW, kernelW, 0);
  }
  void add_kernelH(int32_t kernelH) {
    fbb_.AddElement<int32_t>(DepthwiseConv2D::VT_KERNELH, kernelH, 0);
  }
  void add_strideW(int32_t strideW) {
    fbb_.AddElement<int32_t>(DepthwiseConv2D::VT_STRIDEW, strideW, 0);
  }
  void add_strideH(int32_t strideH) {
    fbb_.AddElement<int32_t>(DepthwiseConv2D::VT_STRIDEH, strideH, 0);
  }
  void add_padMode(mindspore::schema::v0::PadMode padMode) {
    fbb_.AddElement<int8_t>(DepthwiseConv2D::VT_PADMODE, static_cast<int8_t>(padMode), 0);
  }
  void add_padUp(int32_t padUp) {
    fbb_.AddElement<int32_t>(DepthwiseConv2D::VT_PADUP, padUp, 0);
  }
  void add_padDown(int32_t padDown) {
    fbb_.AddElement<int32_t>(DepthwiseConv2D::VT_PADDOWN, padDown, 0);
  }
  void add_padLeft(int32_t padLeft) {
    fbb_.AddElement<int32_t>(DepthwiseConv2D::VT_PADLEFT, padLeft, 0);
  }
  void add_padRight(int32_t padRight) {
    fbb_.AddElement<int32_t>(DepthwiseConv2D::VT_PADRIGHT, padRight, 0);
  }
  void add_dilateW(int32_t dilateW) {
    fbb_.AddElement<int32_t>(DepthwiseConv2D::VT_DILATEW, dilateW, 0);
  }
  void add_dilateH(int32_t dilateH) {
    fbb_.AddElement<int32_t>(DepthwiseConv2D::VT_DILATEH, dilateH, 0);
  }
  void add_hasBias(bool hasBias) {
    fbb_.AddElement<uint8_t>(DepthwiseConv2D::VT_HASBIAS, static_cast<uint8_t>(hasBias), 0);
  }
  void add_activationType(mindspore::schema::v0::ActivationType activationType) {
    fbb_.AddElement<int8_t>(DepthwiseConv2D::VT_ACTIVATIONTYPE, static_cast<int8_t>(activationType), 0);
  }
  explicit DepthwiseConv2DBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<DepthwiseConv2D> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<DepthwiseConv2D>(end);
    return o;
  }
};

inline flatbuffers::Offset<DepthwiseConv2D> CreateDepthwiseConv2D(
    flatbuffers::FlatBufferBuilder &_fbb,
    mindspore::schema::v0::Format format = mindspore::schema::v0::Format_NCHW,
    int32_t channelIn = 0,
    int32_t channelMultiplier = 0,
    int32_t kernelW = 0,
    int32_t kernelH = 0,
    int32_t strideW = 0,
    int32_t strideH = 0,
    mindspore::schema::v0::PadMode padMode = mindspore::schema::v0::PadMode_NOTSET,
    int32_t padUp = 0,
    int32_t padDown = 0,
    int32_t padLeft = 0,
    int32_t padRight = 0,
    int32_t dilateW = 0,
    int32_t dilateH = 0,
    bool hasBias = false,
    mindspore::schema::v0::ActivationType activationType = mindspore::schema::v0::ActivationType_NO_ACTIVATION) {
  DepthwiseConv2DBuilder builder_(_fbb);
  builder_.add_dilateH(dilateH);
  builder_.add_dilateW(dilateW);
  builder_.add_padRight(padRight);
  builder_.add_padLeft(padLeft);
  builder_.add_padDown(padDown);
  builder_.add_padUp(padUp);
  builder_.add_strideH(strideH);
  builder_.add_strideW(strideW);
  builder_.add_kernelH(kernelH);
  builder_.add_kernelW(kernelW);
  builder_.add_channelMultiplier(channelMultiplier);
  builder_.add_channelIn(channelIn);
  builder_.add_format(format);
  builder_.add_activationType(activationType);
  builder_.add_hasBias(hasBias);
  builder_.add_padMode(padMode);
  return builder_.Finish();
}

flatbuffers::Offset<DepthwiseConv2D> CreateDepthwiseConv2D(flatbuffers::FlatBufferBuilder &_fbb, const DepthwiseConv2DT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct DeDepthwiseConv2DT : public flatbuffers::NativeTable {
  typedef DeDepthwiseConv2D TableType;
  mindspore::schema::v0::Format format = mindspore::schema::v0::Format_NCHW;
  int32_t channelIn = 0;
  int32_t channelMultiplier = 0;
  int32_t kernelW = 0;
  int32_t kernelH = 0;
  int32_t strideW = 0;
  int32_t strideH = 0;
  mindspore::schema::v0::PadMode padMode = mindspore::schema::v0::PadMode_NOTSET;
  int32_t padUp = 0;
  int32_t padDown = 0;
  int32_t padLeft = 0;
  int32_t padRight = 0;
  int32_t dilateW = 0;
  int32_t dilateH = 0;
  bool hasBias = false;
  mindspore::schema::v0::ActivationType activationType = mindspore::schema::v0::ActivationType_NO_ACTIVATION;
};

struct DeDepthwiseConv2D FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef DeDepthwiseConv2DT NativeTableType;
  typedef DeDepthwiseConv2DBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return DeDepthwiseConv2DTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_FORMAT = 4,
    VT_CHANNELIN = 6,
    VT_CHANNELMULTIPLIER = 8,
    VT_KERNELW = 10,
    VT_KERNELH = 12,
    VT_STRIDEW = 14,
    VT_STRIDEH = 16,
    VT_PADMODE = 18,
    VT_PADUP = 20,
    VT_PADDOWN = 22,
    VT_PADLEFT = 24,
    VT_PADRIGHT = 26,
    VT_DILATEW = 28,
    VT_DILATEH = 30,
    VT_HASBIAS = 32,
    VT_ACTIVATIONTYPE = 34
  };
  mindspore::schema::v0::Format format() const {
    return static_cast<mindspore::schema::v0::Format>(GetField<int32_t>(VT_FORMAT, 0));
  }
  bool mutate_format(mindspore::schema::v0::Format _format) {
    return SetField<int32_t>(VT_FORMAT, static_cast<int32_t>(_format), 0);
  }
  int32_t channelIn() const {
    return GetField<int32_t>(VT_CHANNELIN, 0);
  }
  bool mutate_channelIn(int32_t _channelIn) {
    return SetField<int32_t>(VT_CHANNELIN, _channelIn, 0);
  }
  int32_t channelMultiplier() const {
    return GetField<int32_t>(VT_CHANNELMULTIPLIER, 0);
  }
  bool mutate_channelMultiplier(int32_t _channelMultiplier) {
    return SetField<int32_t>(VT_CHANNELMULTIPLIER, _channelMultiplier, 0);
  }
  int32_t kernelW() const {
    return GetField<int32_t>(VT_KERNELW, 0);
  }
  bool mutate_kernelW(int32_t _kernelW) {
    return SetField<int32_t>(VT_KERNELW, _kernelW, 0);
  }
  int32_t kernelH() const {
    return GetField<int32_t>(VT_KERNELH, 0);
  }
  bool mutate_kernelH(int32_t _kernelH) {
    return SetField<int32_t>(VT_KERNELH, _kernelH, 0);
  }
  int32_t strideW() const {
    return GetField<int32_t>(VT_STRIDEW, 0);
  }
  bool mutate_strideW(int32_t _strideW) {
    return SetField<int32_t>(VT_STRIDEW, _strideW, 0);
  }
  int32_t strideH() const {
    return GetField<int32_t>(VT_STRIDEH, 0);
  }
  bool mutate_strideH(int32_t _strideH) {
    return SetField<int32_t>(VT_STRIDEH, _strideH, 0);
  }
  mindspore::schema::v0::PadMode padMode() const {
    return static_cast<mindspore::schema::v0::PadMode>(GetField<int8_t>(VT_PADMODE, 0));
  }
  bool mutate_padMode(mindspore::schema::v0::PadMode _padMode) {
    return SetField<int8_t>(VT_PADMODE, static_cast<int8_t>(_padMode), 0);
  }
  int32_t padUp() const {
    return GetField<int32_t>(VT_PADUP, 0);
  }
  bool mutate_padUp(int32_t _padUp) {
    return SetField<int32_t>(VT_PADUP, _padUp, 0);
  }
  int32_t padDown() const {
    return GetField<int32_t>(VT_PADDOWN, 0);
  }
  bool mutate_padDown(int32_t _padDown) {
    return SetField<int32_t>(VT_PADDOWN, _padDown, 0);
  }
  int32_t padLeft() const {
    return GetField<int32_t>(VT_PADLEFT, 0);
  }
  bool mutate_padLeft(int32_t _padLeft) {
    return SetField<int32_t>(VT_PADLEFT, _padLeft, 0);
  }
  int32_t padRight() const {
    return GetField<int32_t>(VT_PADRIGHT, 0);
  }
  bool mutate_padRight(int32_t _padRight) {
    return SetField<int32_t>(VT_PADRIGHT, _padRight, 0);
  }
  int32_t dilateW() const {
    return GetField<int32_t>(VT_DILATEW, 0);
  }
  bool mutate_dilateW(int32_t _dilateW) {
    return SetField<int32_t>(VT_DILATEW, _dilateW, 0);
  }
  int32_t dilateH() const {
    return GetField<int32_t>(VT_DILATEH, 0);
  }
  bool mutate_dilateH(int32_t _dilateH) {
    return SetField<int32_t>(VT_DILATEH, _dilateH, 0);
  }
  bool hasBias() const {
    return GetField<uint8_t>(VT_HASBIAS, 0) != 0;
  }
  bool mutate_hasBias(bool _hasBias) {
    return SetField<uint8_t>(VT_HASBIAS, static_cast<uint8_t>(_hasBias), 0);
  }
  mindspore::schema::v0::ActivationType activationType() const {
    return static_cast<mindspore::schema::v0::ActivationType>(GetField<int8_t>(VT_ACTIVATIONTYPE, 0));
  }
  bool mutate_activationType(mindspore::schema::v0::ActivationType _activationType) {
    return SetField<int8_t>(VT_ACTIVATIONTYPE, static_cast<int8_t>(_activationType), 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_FORMAT) &&
           VerifyField<int32_t>(verifier, VT_CHANNELIN) &&
           VerifyField<int32_t>(verifier, VT_CHANNELMULTIPLIER) &&
           VerifyField<int32_t>(verifier, VT_KERNELW) &&
           VerifyField<int32_t>(verifier, VT_KERNELH) &&
           VerifyField<int32_t>(verifier, VT_STRIDEW) &&
           VerifyField<int32_t>(verifier, VT_STRIDEH) &&
           VerifyField<int8_t>(verifier, VT_PADMODE) &&
           VerifyField<int32_t>(verifier, VT_PADUP) &&
           VerifyField<int32_t>(verifier, VT_PADDOWN) &&
           VerifyField<int32_t>(verifier, VT_PADLEFT) &&
           VerifyField<int32_t>(verifier, VT_PADRIGHT) &&
           VerifyField<int32_t>(verifier, VT_DILATEW) &&
           VerifyField<int32_t>(verifier, VT_DILATEH) &&
           VerifyField<uint8_t>(verifier, VT_HASBIAS) &&
           VerifyField<int8_t>(verifier, VT_ACTIVATIONTYPE) &&
           verifier.EndTable();
  }
  DeDepthwiseConv2DT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(DeDepthwiseConv2DT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<DeDepthwiseConv2D> Pack(flatbuffers::FlatBufferBuilder &_fbb, const DeDepthwiseConv2DT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct DeDepthwiseConv2DBuilder {
  typedef DeDepthwiseConv2D Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_format(mindspore::schema::v0::Format format) {
    fbb_.AddElement<int32_t>(DeDepthwiseConv2D::VT_FORMAT, static_cast<int32_t>(format), 0);
  }
  void add_channelIn(int32_t channelIn) {
    fbb_.AddElement<int32_t>(DeDepthwiseConv2D::VT_CHANNELIN, channelIn, 0);
  }
  void add_channelMultiplier(int32_t channelMultiplier) {
    fbb_.AddElement<int32_t>(DeDepthwiseConv2D::VT_CHANNELMULTIPLIER, channelMultiplier, 0);
  }
  void add_kernelW(int32_t kernelW) {
    fbb_.AddElement<int32_t>(DeDepthwiseConv2D::VT_KERNELW, kernelW, 0);
  }
  void add_kernelH(int32_t kernelH) {
    fbb_.AddElement<int32_t>(DeDepthwiseConv2D::VT_KERNELH, kernelH, 0);
  }
  void add_strideW(int32_t strideW) {
    fbb_.AddElement<int32_t>(DeDepthwiseConv2D::VT_STRIDEW, strideW, 0);
  }
  void add_strideH(int32_t strideH) {
    fbb_.AddElement<int32_t>(DeDepthwiseConv2D::VT_STRIDEH, strideH, 0);
  }
  void add_padMode(mindspore::schema::v0::PadMode padMode) {
    fbb_.AddElement<int8_t>(DeDepthwiseConv2D::VT_PADMODE, static_cast<int8_t>(padMode), 0);
  }
  void add_padUp(int32_t padUp) {
    fbb_.AddElement<int32_t>(DeDepthwiseConv2D::VT_PADUP, padUp, 0);
  }
  void add_padDown(int32_t padDown) {
    fbb_.AddElement<int32_t>(DeDepthwiseConv2D::VT_PADDOWN, padDown, 0);
  }
  void add_padLeft(int32_t padLeft) {
    fbb_.AddElement<int32_t>(DeDepthwiseConv2D::VT_PADLEFT, padLeft, 0);
  }
  void add_padRight(int32_t padRight) {
    fbb_.AddElement<int32_t>(DeDepthwiseConv2D::VT_PADRIGHT, padRight, 0);
  }
  void add_dilateW(int32_t dilateW) {
    fbb_.AddElement<int32_t>(DeDepthwiseConv2D::VT_DILATEW, dilateW, 0);
  }
  void add_dilateH(int32_t dilateH) {
    fbb_.AddElement<int32_t>(DeDepthwiseConv2D::VT_DILATEH, dilateH, 0);
  }
  void add_hasBias(bool hasBias) {
    fbb_.AddElement<uint8_t>(DeDepthwiseConv2D::VT_HASBIAS, static_cast<uint8_t>(hasBias), 0);
  }
  void add_activationType(mindspore::schema::v0::ActivationType activationType) {
    fbb_.AddElement<int8_t>(DeDepthwiseConv2D::VT_ACTIVATIONTYPE, static_cast<int8_t>(activationType), 0);
  }
  explicit DeDepthwiseConv2DBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<DeDepthwiseConv2D> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<DeDepthwiseConv2D>(end);
    return o;
  }
};

inline flatbuffers::Offset<DeDepthwiseConv2D> CreateDeDepthwiseConv2D(
    flatbuffers::FlatBufferBuilder &_fbb,
    mindspore::schema::v0::Format format = mindspore::schema::v0::Format_NCHW,
    int32_t channelIn = 0,
    int32_t channelMultiplier = 0,
    int32_t kernelW = 0,
    int32_t kernelH = 0,
    int32_t strideW = 0,
    int32_t strideH = 0,
    mindspore::schema::v0::PadMode padMode = mindspore::schema::v0::PadMode_NOTSET,
    int32_t padUp = 0,
    int32_t padDown = 0,
    int32_t padLeft = 0,
    int32_t padRight = 0,
    int32_t dilateW = 0,
    int32_t dilateH = 0,
    bool hasBias = false,
    mindspore::schema::v0::ActivationType activationType = mindspore::schema::v0::ActivationType_NO_ACTIVATION) {
  DeDepthwiseConv2DBuilder builder_(_fbb);
  builder_.add_dilateH(dilateH);
  builder_.add_dilateW(dilateW);
  builder_.add_padRight(padRight);
  builder_.add_padLeft(padLeft);
  builder_.add_padDown(padDown);
  builder_.add_padUp(padUp);
  builder_.add_strideH(strideH);
  builder_.add_strideW(strideW);
  builder_.add_kernelH(kernelH);
  builder_.add_kernelW(kernelW);
  builder_.add_channelMultiplier(channelMultiplier);
  builder_.add_channelIn(channelIn);
  builder_.add_format(format);
  builder_.add_activationType(activationType);
  builder_.add_hasBias(hasBias);
  builder_.add_padMode(padMode);
  return builder_.Finish();
}

flatbuffers::Offset<DeDepthwiseConv2D> CreateDeDepthwiseConv2D(flatbuffers::FlatBufferBuilder &_fbb, const DeDepthwiseConv2DT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ResizeT : public flatbuffers::NativeTable {
  typedef Resize TableType;
  mindspore::schema::v0::Format format = mindspore::schema::v0::Format_NCHW;
  mindspore::schema::v0::ResizeMethod method = mindspore::schema::v0::ResizeMethod_LINEAR;
  int64_t newHeight = 0;
  int64_t newWidth = 0;
  bool alignCorners = false;
  bool preserveAspectRatio = false;
  mindspore::schema::v0::CoordinateTransformMode coordinateTransformMode = mindspore::schema::v0::CoordinateTransformMode_COMMON;
  float cubicCoeff = 0.0f;
  int32_t excludeOutside = 0;
  float extrapolationValue = 0.0f;
  mindspore::schema::v0::NearestMode nearestMode = mindspore::schema::v0::NearestMode_NORMAL;
};

struct Resize FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ResizeT NativeTableType;
  typedef ResizeBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return ResizeTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_FORMAT = 4,
    VT_METHOD = 6,
    VT_NEWHEIGHT = 8,
    VT_NEWWIDTH = 10,
    VT_ALIGNCORNERS = 12,
    VT_PRESERVEASPECTRATIO = 14,
    VT_COORDINATETRANSFORMMODE = 16,
    VT_CUBICCOEFF = 18,
    VT_EXCLUDEOUTSIDE = 20,
    VT_EXTRAPOLATIONVALUE = 22,
    VT_NEARESTMODE = 24
  };
  mindspore::schema::v0::Format format() const {
    return static_cast<mindspore::schema::v0::Format>(GetField<int32_t>(VT_FORMAT, 0));
  }
  bool mutate_format(mindspore::schema::v0::Format _format) {
    return SetField<int32_t>(VT_FORMAT, static_cast<int32_t>(_format), 0);
  }
  mindspore::schema::v0::ResizeMethod method() const {
    return static_cast<mindspore::schema::v0::ResizeMethod>(GetField<int8_t>(VT_METHOD, 0));
  }
  bool mutate_method(mindspore::schema::v0::ResizeMethod _method) {
    return SetField<int8_t>(VT_METHOD, static_cast<int8_t>(_method), 0);
  }
  int64_t newHeight() const {
    return GetField<int64_t>(VT_NEWHEIGHT, 0);
  }
  bool mutate_newHeight(int64_t _newHeight) {
    return SetField<int64_t>(VT_NEWHEIGHT, _newHeight, 0);
  }
  int64_t newWidth() const {
    return GetField<int64_t>(VT_NEWWIDTH, 0);
  }
  bool mutate_newWidth(int64_t _newWidth) {
    return SetField<int64_t>(VT_NEWWIDTH, _newWidth, 0);
  }
  bool alignCorners() const {
    return GetField<uint8_t>(VT_ALIGNCORNERS, 0) != 0;
  }
  bool mutate_alignCorners(bool _alignCorners) {
    return SetField<uint8_t>(VT_ALIGNCORNERS, static_cast<uint8_t>(_alignCorners), 0);
  }
  bool preserveAspectRatio() const {
    return GetField<uint8_t>(VT_PRESERVEASPECTRATIO, 0) != 0;
  }
  bool mutate_preserveAspectRatio(bool _preserveAspectRatio) {
    return SetField<uint8_t>(VT_PRESERVEASPECTRATIO, static_cast<uint8_t>(_preserveAspectRatio), 0);
  }
  mindspore::schema::v0::CoordinateTransformMode coordinateTransformMode() const {
    return static_cast<mindspore::schema::v0::CoordinateTransformMode>(GetField<int8_t>(VT_COORDINATETRANSFORMMODE, 0));
  }
  bool mutate_coordinateTransformMode(mindspore::schema::v0::CoordinateTransformMode _coordinateTransformMode) {
    return SetField<int8_t>(VT_COORDINATETRANSFORMMODE, static_cast<int8_t>(_coordinateTransformMode), 0);
  }
  float cubicCoeff() const {
    return GetField<float>(VT_CUBICCOEFF, 0.0f);
  }
  bool mutate_cubicCoeff(float _cubicCoeff) {
    return SetField<float>(VT_CUBICCOEFF, _cubicCoeff, 0.0f);
  }
  int32_t excludeOutside() const {
    return GetField<int32_t>(VT_EXCLUDEOUTSIDE, 0);
  }
  bool mutate_excludeOutside(int32_t _excludeOutside) {
    return SetField<int32_t>(VT_EXCLUDEOUTSIDE, _excludeOutside, 0);
  }
  float extrapolationValue() const {
    return GetField<float>(VT_EXTRAPOLATIONVALUE, 0.0f);
  }
  bool mutate_extrapolationValue(float _extrapolationValue) {
    return SetField<float>(VT_EXTRAPOLATIONVALUE, _extrapolationValue, 0.0f);
  }
  mindspore::schema::v0::NearestMode nearestMode() const {
    return static_cast<mindspore::schema::v0::NearestMode>(GetField<int8_t>(VT_NEARESTMODE, 0));
  }
  bool mutate_nearestMode(mindspore::schema::v0::NearestMode _nearestMode) {
    return SetField<int8_t>(VT_NEARESTMODE, static_cast<int8_t>(_nearestMode), 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_FORMAT) &&
           VerifyField<int8_t>(verifier, VT_METHOD) &&
           VerifyField<int64_t>(verifier, VT_NEWHEIGHT) &&
           VerifyField<int64_t>(verifier, VT_NEWWIDTH) &&
           VerifyField<uint8_t>(verifier, VT_ALIGNCORNERS) &&
           VerifyField<uint8_t>(verifier, VT_PRESERVEASPECTRATIO) &&
           VerifyField<int8_t>(verifier, VT_COORDINATETRANSFORMMODE) &&
           VerifyField<float>(verifier, VT_CUBICCOEFF) &&
           VerifyField<int32_t>(verifier, VT_EXCLUDEOUTSIDE) &&
           VerifyField<float>(verifier, VT_EXTRAPOLATIONVALUE) &&
           VerifyField<int8_t>(verifier, VT_NEARESTMODE) &&
           verifier.EndTable();
  }
  ResizeT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ResizeT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Resize> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ResizeT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ResizeBuilder {
  typedef Resize Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_format(mindspore::schema::v0::Format format) {
    fbb_.AddElement<int32_t>(Resize::VT_FORMAT, static_cast<int32_t>(format), 0);
  }
  void add_method(mindspore::schema::v0::ResizeMethod method) {
    fbb_.AddElement<int8_t>(Resize::VT_METHOD, static_cast<int8_t>(method), 0);
  }
  void add_newHeight(int64_t newHeight) {
    fbb_.AddElement<int64_t>(Resize::VT_NEWHEIGHT, newHeight, 0);
  }
  void add_newWidth(int64_t newWidth) {
    fbb_.AddElement<int64_t>(Resize::VT_NEWWIDTH, newWidth, 0);
  }
  void add_alignCorners(bool alignCorners) {
    fbb_.AddElement<uint8_t>(Resize::VT_ALIGNCORNERS, static_cast<uint8_t>(alignCorners), 0);
  }
  void add_preserveAspectRatio(bool preserveAspectRatio) {
    fbb_.AddElement<uint8_t>(Resize::VT_PRESERVEASPECTRATIO, static_cast<uint8_t>(preserveAspectRatio), 0);
  }
  void add_coordinateTransformMode(mindspore::schema::v0::CoordinateTransformMode coordinateTransformMode) {
    fbb_.AddElement<int8_t>(Resize::VT_COORDINATETRANSFORMMODE, static_cast<int8_t>(coordinateTransformMode), 0);
  }
  void add_cubicCoeff(float cubicCoeff) {
    fbb_.AddElement<float>(Resize::VT_CUBICCOEFF, cubicCoeff, 0.0f);
  }
  void add_excludeOutside(int32_t excludeOutside) {
    fbb_.AddElement<int32_t>(Resize::VT_EXCLUDEOUTSIDE, excludeOutside, 0);
  }
  void add_extrapolationValue(float extrapolationValue) {
    fbb_.AddElement<float>(Resize::VT_EXTRAPOLATIONVALUE, extrapolationValue, 0.0f);
  }
  void add_nearestMode(mindspore::schema::v0::NearestMode nearestMode) {
    fbb_.AddElement<int8_t>(Resize::VT_NEARESTMODE, static_cast<int8_t>(nearestMode), 0);
  }
  explicit ResizeBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Resize> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Resize>(end);
    return o;
  }
};

inline flatbuffers::Offset<Resize> CreateResize(
    flatbuffers::FlatBufferBuilder &_fbb,
    mindspore::schema::v0::Format format = mindspore::schema::v0::Format_NCHW,
    mindspore::schema::v0::ResizeMethod method = mindspore::schema::v0::ResizeMethod_LINEAR,
    int64_t newHeight = 0,
    int64_t newWidth = 0,
    bool alignCorners = false,
    bool preserveAspectRatio = false,
    mindspore::schema::v0::CoordinateTransformMode coordinateTransformMode = mindspore::schema::v0::CoordinateTransformMode_COMMON,
    float cubicCoeff = 0.0f,
    int32_t excludeOutside = 0,
    float extrapolationValue = 0.0f,
    mindspore::schema::v0::NearestMode nearestMode = mindspore::schema::v0::NearestMode_NORMAL) {
  ResizeBuilder builder_(_fbb);
  builder_.add_newWidth(newWidth);
  builder_.add_newHeight(newHeight);
  builder_.add_extrapolationValue(extrapolationValue);
  builder_.add_excludeOutside(excludeOutside);
  builder_.add_cubicCoeff(cubicCoeff);
  builder_.add_format(format);
  builder_.add_nearestMode(nearestMode);
  builder_.add_coordinateTransformMode(coordinateTransformMode);
  builder_.add_preserveAspectRatio(preserveAspectRatio);
  builder_.add_alignCorners(alignCorners);
  builder_.add_method(method);
  return builder_.Finish();
}

flatbuffers::Offset<Resize> CreateResize(flatbuffers::FlatBufferBuilder &_fbb, const ResizeT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct DetectionPostProcessT : public flatbuffers::NativeTable {
  typedef DetectionPostProcess TableType;
  mindspore::schema::v0::Format format = mindspore::schema::v0::Format_NCHW;
  int32_t inputSize = 0;
  float hScale = 0.0f;
  float wScale = 0.0f;
  float xScale = 0.0f;
  float yScale = 0.0f;
  float NmsIouThreshold = 0.0f;
  float NmsScoreThreshold = 0.0f;
  int64_t MaxDetections = 0;
  int64_t DetectionsPerClass = 0;
  int64_t MaxClassesPerDetection = 0;
  int64_t NumClasses = 0;
  bool UseRegularNms = false;
  bool OutQuantized = false;
};

struct DetectionPostProcess FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef DetectionPostProcessT NativeTableType;
  typedef DetectionPostProcessBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return DetectionPostProcessTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_FORMAT = 4,
    VT_INPUTSIZE = 6,
    VT_HSCALE = 8,
    VT_WSCALE = 10,
    VT_XSCALE = 12,
    VT_YSCALE = 14,
    VT_NMSIOUTHRESHOLD = 16,
    VT_NMSSCORETHRESHOLD = 18,
    VT_MAXDETECTIONS = 20,
    VT_DETECTIONSPERCLASS = 22,
    VT_MAXCLASSESPERDETECTION = 24,
    VT_NUMCLASSES = 26,
    VT_USEREGULARNMS = 28,
    VT_OUTQUANTIZED = 30
  };
  mindspore::schema::v0::Format format() const {
    return static_cast<mindspore::schema::v0::Format>(GetField<int32_t>(VT_FORMAT, 0));
  }
  bool mutate_format(mindspore::schema::v0::Format _format) {
    return SetField<int32_t>(VT_FORMAT, static_cast<int32_t>(_format), 0);
  }
  int32_t inputSize() const {
    return GetField<int32_t>(VT_INPUTSIZE, 0);
  }
  bool mutate_inputSize(int32_t _inputSize) {
    return SetField<int32_t>(VT_INPUTSIZE, _inputSize, 0);
  }
  float hScale() const {
    return GetField<float>(VT_HSCALE, 0.0f);
  }
  bool mutate_hScale(float _hScale) {
    return SetField<float>(VT_HSCALE, _hScale, 0.0f);
  }
  float wScale() const {
    return GetField<float>(VT_WSCALE, 0.0f);
  }
  bool mutate_wScale(float _wScale) {
    return SetField<float>(VT_WSCALE, _wScale, 0.0f);
  }
  float xScale() const {
    return GetField<float>(VT_XSCALE, 0.0f);
  }
  bool mutate_xScale(float _xScale) {
    return SetField<float>(VT_XSCALE, _xScale, 0.0f);
  }
  float yScale() const {
    return GetField<float>(VT_YSCALE, 0.0f);
  }
  bool mutate_yScale(float _yScale) {
    return SetField<float>(VT_YSCALE, _yScale, 0.0f);
  }
  float NmsIouThreshold() const {
    return GetField<float>(VT_NMSIOUTHRESHOLD, 0.0f);
  }
  bool mutate_NmsIouThreshold(float _NmsIouThreshold) {
    return SetField<float>(VT_NMSIOUTHRESHOLD, _NmsIouThreshold, 0.0f);
  }
  float NmsScoreThreshold() const {
    return GetField<float>(VT_NMSSCORETHRESHOLD, 0.0f);
  }
  bool mutate_NmsScoreThreshold(float _NmsScoreThreshold) {
    return SetField<float>(VT_NMSSCORETHRESHOLD, _NmsScoreThreshold, 0.0f);
  }
  int64_t MaxDetections() const {
    return GetField<int64_t>(VT_MAXDETECTIONS, 0);
  }
  bool mutate_MaxDetections(int64_t _MaxDetections) {
    return SetField<int64_t>(VT_MAXDETECTIONS, _MaxDetections, 0);
  }
  int64_t DetectionsPerClass() const {
    return GetField<int64_t>(VT_DETECTIONSPERCLASS, 0);
  }
  bool mutate_DetectionsPerClass(int64_t _DetectionsPerClass) {
    return SetField<int64_t>(VT_DETECTIONSPERCLASS, _DetectionsPerClass, 0);
  }
  int64_t MaxClassesPerDetection() const {
    return GetField<int64_t>(VT_MAXCLASSESPERDETECTION, 0);
  }
  bool mutate_MaxClassesPerDetection(int64_t _MaxClassesPerDetection) {
    return SetField<int64_t>(VT_MAXCLASSESPERDETECTION, _MaxClassesPerDetection, 0);
  }
  int64_t NumClasses() const {
    return GetField<int64_t>(VT_NUMCLASSES, 0);
  }
  bool mutate_NumClasses(int64_t _NumClasses) {
    return SetField<int64_t>(VT_NUMCLASSES, _NumClasses, 0);
  }
  bool UseRegularNms() const {
    return GetField<uint8_t>(VT_USEREGULARNMS, 0) != 0;
  }
  bool mutate_UseRegularNms(bool _UseRegularNms) {
    return SetField<uint8_t>(VT_USEREGULARNMS, static_cast<uint8_t>(_UseRegularNms), 0);
  }
  bool OutQuantized() const {
    return GetField<uint8_t>(VT_OUTQUANTIZED, 0) != 0;
  }
  bool mutate_OutQuantized(bool _OutQuantized) {
    return SetField<uint8_t>(VT_OUTQUANTIZED, static_cast<uint8_t>(_OutQuantized), 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_FORMAT) &&
           VerifyField<int32_t>(verifier, VT_INPUTSIZE) &&
           VerifyField<float>(verifier, VT_HSCALE) &&
           VerifyField<float>(verifier, VT_WSCALE) &&
           VerifyField<float>(verifier, VT_XSCALE) &&
           VerifyField<float>(verifier, VT_YSCALE) &&
           VerifyField<float>(verifier, VT_NMSIOUTHRESHOLD) &&
           VerifyField<float>(verifier, VT_NMSSCORETHRESHOLD) &&
           VerifyField<int64_t>(verifier, VT_MAXDETECTIONS) &&
           VerifyField<int64_t>(verifier, VT_DETECTIONSPERCLASS) &&
           VerifyField<int64_t>(verifier, VT_MAXCLASSESPERDETECTION) &&
           VerifyField<int64_t>(verifier, VT_NUMCLASSES) &&
           VerifyField<uint8_t>(verifier, VT_USEREGULARNMS) &&
           VerifyField<uint8_t>(verifier, VT_OUTQUANTIZED) &&
           verifier.EndTable();
  }
  DetectionPostProcessT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(DetectionPostProcessT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<DetectionPostProcess> Pack(flatbuffers::FlatBufferBuilder &_fbb, const DetectionPostProcessT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct DetectionPostProcessBuilder {
  typedef DetectionPostProcess Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_format(mindspore::schema::v0::Format format) {
    fbb_.AddElement<int32_t>(DetectionPostProcess::VT_FORMAT, static_cast<int32_t>(format), 0);
  }
  void add_inputSize(int32_t inputSize) {
    fbb_.AddElement<int32_t>(DetectionPostProcess::VT_INPUTSIZE, inputSize, 0);
  }
  void add_hScale(float hScale) {
    fbb_.AddElement<float>(DetectionPostProcess::VT_HSCALE, hScale, 0.0f);
  }
  void add_wScale(float wScale) {
    fbb_.AddElement<float>(DetectionPostProcess::VT_WSCALE, wScale, 0.0f);
  }
  void add_xScale(float xScale) {
    fbb_.AddElement<float>(DetectionPostProcess::VT_XSCALE, xScale, 0.0f);
  }
  void add_yScale(float yScale) {
    fbb_.AddElement<float>(DetectionPostProcess::VT_YSCALE, yScale, 0.0f);
  }
  void add_NmsIouThreshold(float NmsIouThreshold) {
    fbb_.AddElement<float>(DetectionPostProcess::VT_NMSIOUTHRESHOLD, NmsIouThreshold, 0.0f);
  }
  void add_NmsScoreThreshold(float NmsScoreThreshold) {
    fbb_.AddElement<float>(DetectionPostProcess::VT_NMSSCORETHRESHOLD, NmsScoreThreshold, 0.0f);
  }
  void add_MaxDetections(int64_t MaxDetections) {
    fbb_.AddElement<int64_t>(DetectionPostProcess::VT_MAXDETECTIONS, MaxDetections, 0);
  }
  void add_DetectionsPerClass(int64_t DetectionsPerClass) {
    fbb_.AddElement<int64_t>(DetectionPostProcess::VT_DETECTIONSPERCLASS, DetectionsPerClass, 0);
  }
  void add_MaxClassesPerDetection(int64_t MaxClassesPerDetection) {
    fbb_.AddElement<int64_t>(DetectionPostProcess::VT_MAXCLASSESPERDETECTION, MaxClassesPerDetection, 0);
  }
  void add_NumClasses(int64_t NumClasses) {
    fbb_.AddElement<int64_t>(DetectionPostProcess::VT_NUMCLASSES, NumClasses, 0);
  }
  void add_UseRegularNms(bool UseRegularNms) {
    fbb_.AddElement<uint8_t>(DetectionPostProcess::VT_USEREGULARNMS, static_cast<uint8_t>(UseRegularNms), 0);
  }
  void add_OutQuantized(bool OutQuantized) {
    fbb_.AddElement<uint8_t>(DetectionPostProcess::VT_OUTQUANTIZED, static_cast<uint8_t>(OutQuantized), 0);
  }
  explicit DetectionPostProcessBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<DetectionPostProcess> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<DetectionPostProcess>(end);
    return o;
  }
};

inline flatbuffers::Offset<DetectionPostProcess> CreateDetectionPostProcess(
    flatbuffers::FlatBufferBuilder &_fbb,
    mindspore::schema::v0::Format format = mindspore::schema::v0::Format_NCHW,
    int32_t inputSize = 0,
    float hScale = 0.0f,
    float wScale = 0.0f,
    float xScale = 0.0f,
    float yScale = 0.0f,
    float NmsIouThreshold = 0.0f,
    float NmsScoreThreshold = 0.0f,
    int64_t MaxDetections = 0,
    int64_t DetectionsPerClass = 0,
    int64_t MaxClassesPerDetection = 0,
    int64_t NumClasses = 0,
    bool UseRegularNms = false,
    bool OutQuantized = false) {
  DetectionPostProcessBuilder builder_(_fbb);
  builder_.add_NumClasses(NumClasses);
  builder_.add_MaxClassesPerDetection(MaxClassesPerDetection);
  builder_.add_DetectionsPerClass(DetectionsPerClass);
  builder_.add_MaxDetections(MaxDetections);
  builder_.add_NmsScoreThreshold(NmsScoreThreshold);
  builder_.add_NmsIouThreshold(NmsIouThreshold);
  builder_.add_yScale(yScale);
  builder_.add_xScale(xScale);
  builder_.add_wScale(wScale);
  builder_.add_hScale(hScale);
  builder_.add_inputSize(inputSize);
  builder_.add_format(format);
  builder_.add_OutQuantized(OutQuantized);
  builder_.add_UseRegularNms(UseRegularNms);
  return builder_.Finish();
}

flatbuffers::Offset<DetectionPostProcess> CreateDetectionPostProcess(flatbuffers::FlatBufferBuilder &_fbb, const DetectionPostProcessT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct FullConnectionT : public flatbuffers::NativeTable {
  typedef FullConnection TableType;
  bool hasBias = false;
  int32_t axis = 0;
  bool useAxis = false;
  mindspore::schema::v0::ActivationType activationType = mindspore::schema::v0::ActivationType_NO_ACTIVATION;
};

struct FullConnection FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef FullConnectionT NativeTableType;
  typedef FullConnectionBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return FullConnectionTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_HASBIAS = 4,
    VT_AXIS = 6,
    VT_USEAXIS = 8,
    VT_ACTIVATIONTYPE = 10
  };
  bool hasBias() const {
    return GetField<uint8_t>(VT_HASBIAS, 0) != 0;
  }
  bool mutate_hasBias(bool _hasBias) {
    return SetField<uint8_t>(VT_HASBIAS, static_cast<uint8_t>(_hasBias), 0);
  }
  int32_t axis() const {
    return GetField<int32_t>(VT_AXIS, 0);
  }
  bool mutate_axis(int32_t _axis) {
    return SetField<int32_t>(VT_AXIS, _axis, 0);
  }
  bool useAxis() const {
    return GetField<uint8_t>(VT_USEAXIS, 0) != 0;
  }
  bool mutate_useAxis(bool _useAxis) {
    return SetField<uint8_t>(VT_USEAXIS, static_cast<uint8_t>(_useAxis), 0);
  }
  mindspore::schema::v0::ActivationType activationType() const {
    return static_cast<mindspore::schema::v0::ActivationType>(GetField<int8_t>(VT_ACTIVATIONTYPE, 0));
  }
  bool mutate_activationType(mindspore::schema::v0::ActivationType _activationType) {
    return SetField<int8_t>(VT_ACTIVATIONTYPE, static_cast<int8_t>(_activationType), 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_HASBIAS) &&
           VerifyField<int32_t>(verifier, VT_AXIS) &&
           VerifyField<uint8_t>(verifier, VT_USEAXIS) &&
           VerifyField<int8_t>(verifier, VT_ACTIVATIONTYPE) &&
           verifier.EndTable();
  }
  FullConnectionT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(FullConnectionT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<FullConnection> Pack(flatbuffers::FlatBufferBuilder &_fbb, const FullConnectionT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct FullConnectionBuilder {
  typedef FullConnection Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_hasBias(bool hasBias) {
    fbb_.AddElement<uint8_t>(FullConnection::VT_HASBIAS, static_cast<uint8_t>(hasBias), 0);
  }
  void add_axis(int32_t axis) {
    fbb_.AddElement<int32_t>(FullConnection::VT_AXIS, axis, 0);
  }
  void add_useAxis(bool useAxis) {
    fbb_.AddElement<uint8_t>(FullConnection::VT_USEAXIS, static_cast<uint8_t>(useAxis), 0);
  }
  void add_activationType(mindspore::schema::v0::ActivationType activationType) {
    fbb_.AddElement<int8_t>(FullConnection::VT_ACTIVATIONTYPE, static_cast<int8_t>(activationType), 0);
  }
  explicit FullConnectionBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<FullConnection> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<FullConnection>(end);
    return o;
  }
};

inline flatbuffers::Offset<FullConnection> CreateFullConnection(
    flatbuffers::FlatBufferBuilder &_fbb,
    bool hasBias = false,
    int32_t axis = 0,
    bool useAxis = false,
    mindspore::schema::v0::ActivationType activationType = mindspore::schema::v0::ActivationType_NO_ACTIVATION) {
  FullConnectionBuilder builder_(_fbb);
  builder_.add_axis(axis);
  builder_.add_activationType(activationType);
  builder_.add_useAxis(useAxis);
  builder_.add_hasBias(hasBias);
  return builder_.Finish();
}

flatbuffers::Offset<FullConnection> CreateFullConnection(flatbuffers::FlatBufferBuilder &_fbb, const FullConnectionT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct MeanT : public flatbuffers::NativeTable {
  typedef Mean TableType;
  std::vector<int32_t> axis{};
  bool keepDims = false;
};

struct Mean FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef MeanT NativeTableType;
  typedef MeanBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return MeanTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_AXIS = 4,
    VT_KEEPDIMS = 6
  };
  const flatbuffers::Vector<int32_t> *axis() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_AXIS);
  }
  flatbuffers::Vector<int32_t> *mutable_axis() {
    return GetPointer<flatbuffers::Vector<int32_t> *>(VT_AXIS);
  }
  bool keepDims() const {
    return GetField<uint8_t>(VT_KEEPDIMS, 0) != 0;
  }
  bool mutate_keepDims(bool _keepDims) {
    return SetField<uint8_t>(VT_KEEPDIMS, static_cast<uint8_t>(_keepDims), 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_AXIS) &&
           verifier.VerifyVector(axis()) &&
           VerifyField<uint8_t>(verifier, VT_KEEPDIMS) &&
           verifier.EndTable();
  }
  MeanT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(MeanT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Mean> Pack(flatbuffers::FlatBufferBuilder &_fbb, const MeanT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct MeanBuilder {
  typedef Mean Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_axis(flatbuffers::Offset<flatbuffers::Vector<int32_t>> axis) {
    fbb_.AddOffset(Mean::VT_AXIS, axis);
  }
  void add_keepDims(bool keepDims) {
    fbb_.AddElement<uint8_t>(Mean::VT_KEEPDIMS, static_cast<uint8_t>(keepDims), 0);
  }
  explicit MeanBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Mean> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Mean>(end);
    return o;
  }
};

inline flatbuffers::Offset<Mean> CreateMean(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> axis = 0,
    bool keepDims = false) {
  MeanBuilder builder_(_fbb);
  builder_.add_axis(axis);
  builder_.add_keepDims(keepDims);
  return builder_.Finish();
}

inline flatbuffers::Offset<Mean> CreateMeanDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<int32_t> *axis = nullptr,
    bool keepDims = false) {
  auto axis__ = axis ? _fbb.CreateVector<int32_t>(*axis) : 0;
  return mindspore::schema::v0::CreateMean(
      _fbb,
      axis__,
      keepDims);
}

flatbuffers::Offset<Mean> CreateMean(flatbuffers::FlatBufferBuilder &_fbb, const MeanT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct DeConv2DT : public flatbuffers::NativeTable {
  typedef DeConv2D TableType;
  mindspore::schema::v0::Format format = mindspore::schema::v0::Format_NCHW;
  int32_t group = 0;
  int32_t channelIn = 0;
  int32_t channelOut = 0;
  int32_t kernelW = 0;
  int32_t kernelH = 0;
  int32_t strideW = 0;
  int32_t strideH = 0;
  mindspore::schema::v0::PadMode padMode = mindspore::schema::v0::PadMode_NOTSET;
  int32_t padUp = 0;
  int32_t padDown = 0;
  int32_t padLeft = 0;
  int32_t padRight = 0;
  int32_t dilateW = 0;
  int32_t dilateH = 0;
  bool hasBias = false;
  mindspore::schema::v0::ActivationType activationType = mindspore::schema::v0::ActivationType_NO_ACTIVATION;
};

struct DeConv2D FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef DeConv2DT NativeTableType;
  typedef DeConv2DBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return DeConv2DTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_FORMAT = 4,
    VT_GROUP = 6,
    VT_CHANNELIN = 8,
    VT_CHANNELOUT = 10,
    VT_KERNELW = 12,
    VT_KERNELH = 14,
    VT_STRIDEW = 16,
    VT_STRIDEH = 18,
    VT_PADMODE = 20,
    VT_PADUP = 22,
    VT_PADDOWN = 24,
    VT_PADLEFT = 26,
    VT_PADRIGHT = 28,
    VT_DILATEW = 30,
    VT_DILATEH = 32,
    VT_HASBIAS = 34,
    VT_ACTIVATIONTYPE = 36
  };
  mindspore::schema::v0::Format format() const {
    return static_cast<mindspore::schema::v0::Format>(GetField<int32_t>(VT_FORMAT, 0));
  }
  bool mutate_format(mindspore::schema::v0::Format _format) {
    return SetField<int32_t>(VT_FORMAT, static_cast<int32_t>(_format), 0);
  }
  int32_t group() const {
    return GetField<int32_t>(VT_GROUP, 0);
  }
  bool mutate_group(int32_t _group) {
    return SetField<int32_t>(VT_GROUP, _group, 0);
  }
  int32_t channelIn() const {
    return GetField<int32_t>(VT_CHANNELIN, 0);
  }
  bool mutate_channelIn(int32_t _channelIn) {
    return SetField<int32_t>(VT_CHANNELIN, _channelIn, 0);
  }
  int32_t channelOut() const {
    return GetField<int32_t>(VT_CHANNELOUT, 0);
  }
  bool mutate_channelOut(int32_t _channelOut) {
    return SetField<int32_t>(VT_CHANNELOUT, _channelOut, 0);
  }
  int32_t kernelW() const {
    return GetField<int32_t>(VT_KERNELW, 0);
  }
  bool mutate_kernelW(int32_t _kernelW) {
    return SetField<int32_t>(VT_KERNELW, _kernelW, 0);
  }
  int32_t kernelH() const {
    return GetField<int32_t>(VT_KERNELH, 0);
  }
  bool mutate_kernelH(int32_t _kernelH) {
    return SetField<int32_t>(VT_KERNELH, _kernelH, 0);
  }
  int32_t strideW() const {
    return GetField<int32_t>(VT_STRIDEW, 0);
  }
  bool mutate_strideW(int32_t _strideW) {
    return SetField<int32_t>(VT_STRIDEW, _strideW, 0);
  }
  int32_t strideH() const {
    return GetField<int32_t>(VT_STRIDEH, 0);
  }
  bool mutate_strideH(int32_t _strideH) {
    return SetField<int32_t>(VT_STRIDEH, _strideH, 0);
  }
  mindspore::schema::v0::PadMode padMode() const {
    return static_cast<mindspore::schema::v0::PadMode>(GetField<int8_t>(VT_PADMODE, 0));
  }
  bool mutate_padMode(mindspore::schema::v0::PadMode _padMode) {
    return SetField<int8_t>(VT_PADMODE, static_cast<int8_t>(_padMode), 0);
  }
  int32_t padUp() const {
    return GetField<int32_t>(VT_PADUP, 0);
  }
  bool mutate_padUp(int32_t _padUp) {
    return SetField<int32_t>(VT_PADUP, _padUp, 0);
  }
  int32_t padDown() const {
    return GetField<int32_t>(VT_PADDOWN, 0);
  }
  bool mutate_padDown(int32_t _padDown) {
    return SetField<int32_t>(VT_PADDOWN, _padDown, 0);
  }
  int32_t padLeft() const {
    return GetField<int32_t>(VT_PADLEFT, 0);
  }
  bool mutate_padLeft(int32_t _padLeft) {
    return SetField<int32_t>(VT_PADLEFT, _padLeft, 0);
  }
  int32_t padRight() const {
    return GetField<int32_t>(VT_PADRIGHT, 0);
  }
  bool mutate_padRight(int32_t _padRight) {
    return SetField<int32_t>(VT_PADRIGHT, _padRight, 0);
  }
  int32_t dilateW() const {
    return GetField<int32_t>(VT_DILATEW, 0);
  }
  bool mutate_dilateW(int32_t _dilateW) {
    return SetField<int32_t>(VT_DILATEW, _dilateW, 0);
  }
  int32_t dilateH() const {
    return GetField<int32_t>(VT_DILATEH, 0);
  }
  bool mutate_dilateH(int32_t _dilateH) {
    return SetField<int32_t>(VT_DILATEH, _dilateH, 0);
  }
  bool hasBias() const {
    return GetField<uint8_t>(VT_HASBIAS, 0) != 0;
  }
  bool mutate_hasBias(bool _hasBias) {
    return SetField<uint8_t>(VT_HASBIAS, static_cast<uint8_t>(_hasBias), 0);
  }
  mindspore::schema::v0::ActivationType activationType() const {
    return static_cast<mindspore::schema::v0::ActivationType>(GetField<int8_t>(VT_ACTIVATIONTYPE, 0));
  }
  bool mutate_activationType(mindspore::schema::v0::ActivationType _activationType) {
    return SetField<int8_t>(VT_ACTIVATIONTYPE, static_cast<int8_t>(_activationType), 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_FORMAT) &&
           VerifyField<int32_t>(verifier, VT_GROUP) &&
           VerifyField<int32_t>(verifier, VT_CHANNELIN) &&
           VerifyField<int32_t>(verifier, VT_CHANNELOUT) &&
           VerifyField<int32_t>(verifier, VT_KERNELW) &&
           VerifyField<int32_t>(verifier, VT_KERNELH) &&
           VerifyField<int32_t>(verifier, VT_STRIDEW) &&
           VerifyField<int32_t>(verifier, VT_STRIDEH) &&
           VerifyField<int8_t>(verifier, VT_PADMODE) &&
           VerifyField<int32_t>(verifier, VT_PADUP) &&
           VerifyField<int32_t>(verifier, VT_PADDOWN) &&
           VerifyField<int32_t>(verifier, VT_PADLEFT) &&
           VerifyField<int32_t>(verifier, VT_PADRIGHT) &&
           VerifyField<int32_t>(verifier, VT_DILATEW) &&
           VerifyField<int32_t>(verifier, VT_DILATEH) &&
           VerifyField<uint8_t>(verifier, VT_HASBIAS) &&
           VerifyField<int8_t>(verifier, VT_ACTIVATIONTYPE) &&
           verifier.EndTable();
  }
  DeConv2DT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(DeConv2DT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<DeConv2D> Pack(flatbuffers::FlatBufferBuilder &_fbb, const DeConv2DT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct DeConv2DBuilder {
  typedef DeConv2D Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_format(mindspore::schema::v0::Format format) {
    fbb_.AddElement<int32_t>(DeConv2D::VT_FORMAT, static_cast<int32_t>(format), 0);
  }
  void add_group(int32_t group) {
    fbb_.AddElement<int32_t>(DeConv2D::VT_GROUP, group, 0);
  }
  void add_channelIn(int32_t channelIn) {
    fbb_.AddElement<int32_t>(DeConv2D::VT_CHANNELIN, channelIn, 0);
  }
  void add_channelOut(int32_t channelOut) {
    fbb_.AddElement<int32_t>(DeConv2D::VT_CHANNELOUT, channelOut, 0);
  }
  void add_kernelW(int32_t kernelW) {
    fbb_.AddElement<int32_t>(DeConv2D::VT_KERNELW, kernelW, 0);
  }
  void add_kernelH(int32_t kernelH) {
    fbb_.AddElement<int32_t>(DeConv2D::VT_KERNELH, kernelH, 0);
  }
  void add_strideW(int32_t strideW) {
    fbb_.AddElement<int32_t>(DeConv2D::VT_STRIDEW, strideW, 0);
  }
  void add_strideH(int32_t strideH) {
    fbb_.AddElement<int32_t>(DeConv2D::VT_STRIDEH, strideH, 0);
  }
  void add_padMode(mindspore::schema::v0::PadMode padMode) {
    fbb_.AddElement<int8_t>(DeConv2D::VT_PADMODE, static_cast<int8_t>(padMode), 0);
  }
  void add_padUp(int32_t padUp) {
    fbb_.AddElement<int32_t>(DeConv2D::VT_PADUP, padUp, 0);
  }
  void add_padDown(int32_t padDown) {
    fbb_.AddElement<int32_t>(DeConv2D::VT_PADDOWN, padDown, 0);
  }
  void add_padLeft(int32_t padLeft) {
    fbb_.AddElement<int32_t>(DeConv2D::VT_PADLEFT, padLeft, 0);
  }
  void add_padRight(int32_t padRight) {
    fbb_.AddElement<int32_t>(DeConv2D::VT_PADRIGHT, padRight, 0);
  }
  void add_dilateW(int32_t dilateW) {
    fbb_.AddElement<int32_t>(DeConv2D::VT_DILATEW, dilateW, 0);
  }
  void add_dilateH(int32_t dilateH) {
    fbb_.AddElement<int32_t>(DeConv2D::VT_DILATEH, dilateH, 0);
  }
  void add_hasBias(bool hasBias) {
    fbb_.AddElement<uint8_t>(DeConv2D::VT_HASBIAS, static_cast<uint8_t>(hasBias), 0);
  }
  void add_activationType(mindspore::schema::v0::ActivationType activationType) {
    fbb_.AddElement<int8_t>(DeConv2D::VT_ACTIVATIONTYPE, static_cast<int8_t>(activationType), 0);
  }
  explicit DeConv2DBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<DeConv2D> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<DeConv2D>(end);
    return o;
  }
};

inline flatbuffers::Offset<DeConv2D> CreateDeConv2D(
    flatbuffers::FlatBufferBuilder &_fbb,
    mindspore::schema::v0::Format format = mindspore::schema::v0::Format_NCHW,
    int32_t group = 0,
    int32_t channelIn = 0,
    int32_t channelOut = 0,
    int32_t kernelW = 0,
    int32_t kernelH = 0,
    int32_t strideW = 0,
    int32_t strideH = 0,
    mindspore::schema::v0::PadMode padMode = mindspore::schema::v0::PadMode_NOTSET,
    int32_t padUp = 0,
    int32_t padDown = 0,
    int32_t padLeft = 0,
    int32_t padRight = 0,
    int32_t dilateW = 0,
    int32_t dilateH = 0,
    bool hasBias = false,
    mindspore::schema::v0::ActivationType activationType = mindspore::schema::v0::ActivationType_NO_ACTIVATION) {
  DeConv2DBuilder builder_(_fbb);
  builder_.add_dilateH(dilateH);
  builder_.add_dilateW(dilateW);
  builder_.add_padRight(padRight);
  builder_.add_padLeft(padLeft);
  builder_.add_padDown(padDown);
  builder_.add_padUp(padUp);
  builder_.add_strideH(strideH);
  builder_.add_strideW(strideW);
  builder_.add_kernelH(kernelH);
  builder_.add_kernelW(kernelW);
  builder_.add_channelOut(channelOut);
  builder_.add_channelIn(channelIn);
  builder_.add_group(group);
  builder_.add_format(format);
  builder_.add_activationType(activationType);
  builder_.add_hasBias(hasBias);
  builder_.add_padMode(padMode);
  return builder_.Finish();
}

flatbuffers::Offset<DeConv2D> CreateDeConv2D(flatbuffers::FlatBufferBuilder &_fbb, const DeConv2DT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct DeConv2DGradFilterT : public flatbuffers::NativeTable {
  typedef DeConv2DGradFilter TableType;
  mindspore::schema::v0::Format format = mindspore::schema::v0::Format_NCHW;
  int32_t group = 0;
  int32_t channelIn = 0;
  int32_t channelOut = 0;
  int32_t kernelW = 0;
  int32_t kernelH = 0;
  int32_t strideW = 0;
  int32_t strideH = 0;
  mindspore::schema::v0::PadMode padMode = mindspore::schema::v0::PadMode_NOTSET;
  int32_t padUp = 0;
  int32_t padDown = 0;
  int32_t padLeft = 0;
  int32_t padRight = 0;
  int32_t dilateW = 0;
  int32_t dilateH = 0;
  bool hasBias = false;
  mindspore::schema::v0::ActivationType activationType = mindspore::schema::v0::ActivationType_NO_ACTIVATION;
};

struct DeConv2DGradFilter FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef DeConv2DGradFilterT NativeTableType;
  typedef DeConv2DGradFilterBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return DeConv2DGradFilterTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_FORMAT = 4,
    VT_GROUP = 6,
    VT_CHANNELIN = 8,
    VT_CHANNELOUT = 10,
    VT_KERNELW = 12,
    VT_KERNELH = 14,
    VT_STRIDEW = 16,
    VT_STRIDEH = 18,
    VT_PADMODE = 20,
    VT_PADUP = 22,
    VT_PADDOWN = 24,
    VT_PADLEFT = 26,
    VT_PADRIGHT = 28,
    VT_DILATEW = 30,
    VT_DILATEH = 32,
    VT_HASBIAS = 34,
    VT_ACTIVATIONTYPE = 36
  };
  mindspore::schema::v0::Format format() const {
    return static_cast<mindspore::schema::v0::Format>(GetField<int32_t>(VT_FORMAT, 0));
  }
  bool mutate_format(mindspore::schema::v0::Format _format) {
    return SetField<int32_t>(VT_FORMAT, static_cast<int32_t>(_format), 0);
  }
  int32_t group() const {
    return GetField<int32_t>(VT_GROUP, 0);
  }
  bool mutate_group(int32_t _group) {
    return SetField<int32_t>(VT_GROUP, _group, 0);
  }
  int32_t channelIn() const {
    return GetField<int32_t>(VT_CHANNELIN, 0);
  }
  bool mutate_channelIn(int32_t _channelIn) {
    return SetField<int32_t>(VT_CHANNELIN, _channelIn, 0);
  }
  int32_t channelOut() const {
    return GetField<int32_t>(VT_CHANNELOUT, 0);
  }
  bool mutate_channelOut(int32_t _channelOut) {
    return SetField<int32_t>(VT_CHANNELOUT, _channelOut, 0);
  }
  int32_t kernelW() const {
    return GetField<int32_t>(VT_KERNELW, 0);
  }
  bool mutate_kernelW(int32_t _kernelW) {
    return SetField<int32_t>(VT_KERNELW, _kernelW, 0);
  }
  int32_t kernelH() const {
    return GetField<int32_t>(VT_KERNELH, 0);
  }
  bool mutate_kernelH(int32_t _kernelH) {
    return SetField<int32_t>(VT_KERNELH, _kernelH, 0);
  }
  int32_t strideW() const {
    return GetField<int32_t>(VT_STRIDEW, 0);
  }
  bool mutate_strideW(int32_t _strideW) {
    return SetField<int32_t>(VT_STRIDEW, _strideW, 0);
  }
  int32_t strideH() const {
    return GetField<int32_t>(VT_STRIDEH, 0);
  }
  bool mutate_strideH(int32_t _strideH) {
    return SetField<int32_t>(VT_STRIDEH, _strideH, 0);
  }
  mindspore::schema::v0::PadMode padMode() const {
    return static_cast<mindspore::schema::v0::PadMode>(GetField<int8_t>(VT_PADMODE, 0));
  }
  bool mutate_padMode(mindspore::schema::v0::PadMode _padMode) {
    return SetField<int8_t>(VT_PADMODE, static_cast<int8_t>(_padMode), 0);
  }
  int32_t padUp() const {
    return GetField<int32_t>(VT_PADUP, 0);
  }
  bool mutate_padUp(int32_t _padUp) {
    return SetField<int32_t>(VT_PADUP, _padUp, 0);
  }
  int32_t padDown() const {
    return GetField<int32_t>(VT_PADDOWN, 0);
  }
  bool mutate_padDown(int32_t _padDown) {
    return SetField<int32_t>(VT_PADDOWN, _padDown, 0);
  }
  int32_t padLeft() const {
    return GetField<int32_t>(VT_PADLEFT, 0);
  }
  bool mutate_padLeft(int32_t _padLeft) {
    return SetField<int32_t>(VT_PADLEFT, _padLeft, 0);
  }
  int32_t padRight() const {
    return GetField<int32_t>(VT_PADRIGHT, 0);
  }
  bool mutate_padRight(int32_t _padRight) {
    return SetField<int32_t>(VT_PADRIGHT, _padRight, 0);
  }
  int32_t dilateW() const {
    return GetField<int32_t>(VT_DILATEW, 0);
  }
  bool mutate_dilateW(int32_t _dilateW) {
    return SetField<int32_t>(VT_DILATEW, _dilateW, 0);
  }
  int32_t dilateH() const {
    return GetField<int32_t>(VT_DILATEH, 0);
  }
  bool mutate_dilateH(int32_t _dilateH) {
    return SetField<int32_t>(VT_DILATEH, _dilateH, 0);
  }
  bool hasBias() const {
    return GetField<uint8_t>(VT_HASBIAS, 0) != 0;
  }
  bool mutate_hasBias(bool _hasBias) {
    return SetField<uint8_t>(VT_HASBIAS, static_cast<uint8_t>(_hasBias), 0);
  }
  mindspore::schema::v0::ActivationType activationType() const {
    return static_cast<mindspore::schema::v0::ActivationType>(GetField<int8_t>(VT_ACTIVATIONTYPE, 0));
  }
  bool mutate_activationType(mindspore::schema::v0::ActivationType _activationType) {
    return SetField<int8_t>(VT_ACTIVATIONTYPE, static_cast<int8_t>(_activationType), 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_FORMAT) &&
           VerifyField<int32_t>(verifier, VT_GROUP) &&
           VerifyField<int32_t>(verifier, VT_CHANNELIN) &&
           VerifyField<int32_t>(verifier, VT_CHANNELOUT) &&
           VerifyField<int32_t>(verifier, VT_KERNELW) &&
           VerifyField<int32_t>(verifier, VT_KERNELH) &&
           VerifyField<int32_t>(verifier, VT_STRIDEW) &&
           VerifyField<int32_t>(verifier, VT_STRIDEH) &&
           VerifyField<int8_t>(verifier, VT_PADMODE) &&
           VerifyField<int32_t>(verifier, VT_PADUP) &&
           VerifyField<int32_t>(verifier, VT_PADDOWN) &&
           VerifyField<int32_t>(verifier, VT_PADLEFT) &&
           VerifyField<int32_t>(verifier, VT_PADRIGHT) &&
           VerifyField<int32_t>(verifier, VT_DILATEW) &&
           VerifyField<int32_t>(verifier, VT_DILATEH) &&
           VerifyField<uint8_t>(verifier, VT_HASBIAS) &&
           VerifyField<int8_t>(verifier, VT_ACTIVATIONTYPE) &&
           verifier.EndTable();
  }
  DeConv2DGradFilterT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(DeConv2DGradFilterT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<DeConv2DGradFilter> Pack(flatbuffers::FlatBufferBuilder &_fbb, const DeConv2DGradFilterT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct DeConv2DGradFilterBuilder {
  typedef DeConv2DGradFilter Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_format(mindspore::schema::v0::Format format) {
    fbb_.AddElement<int32_t>(DeConv2DGradFilter::VT_FORMAT, static_cast<int32_t>(format), 0);
  }
  void add_group(int32_t group) {
    fbb_.AddElement<int32_t>(DeConv2DGradFilter::VT_GROUP, group, 0);
  }
  void add_channelIn(int32_t channelIn) {
    fbb_.AddElement<int32_t>(DeConv2DGradFilter::VT_CHANNELIN, channelIn, 0);
  }
  void add_channelOut(int32_t channelOut) {
    fbb_.AddElement<int32_t>(DeConv2DGradFilter::VT_CHANNELOUT, channelOut, 0);
  }
  void add_kernelW(int32_t kernelW) {
    fbb_.AddElement<int32_t>(DeConv2DGradFilter::VT_KERNELW, kernelW, 0);
  }
  void add_kernelH(int32_t kernelH) {
    fbb_.AddElement<int32_t>(DeConv2DGradFilter::VT_KERNELH, kernelH, 0);
  }
  void add_strideW(int32_t strideW) {
    fbb_.AddElement<int32_t>(DeConv2DGradFilter::VT_STRIDEW, strideW, 0);
  }
  void add_strideH(int32_t strideH) {
    fbb_.AddElement<int32_t>(DeConv2DGradFilter::VT_STRIDEH, strideH, 0);
  }
  void add_padMode(mindspore::schema::v0::PadMode padMode) {
    fbb_.AddElement<int8_t>(DeConv2DGradFilter::VT_PADMODE, static_cast<int8_t>(padMode), 0);
  }
  void add_padUp(int32_t padUp) {
    fbb_.AddElement<int32_t>(DeConv2DGradFilter::VT_PADUP, padUp, 0);
  }
  void add_padDown(int32_t padDown) {
    fbb_.AddElement<int32_t>(DeConv2DGradFilter::VT_PADDOWN, padDown, 0);
  }
  void add_padLeft(int32_t padLeft) {
    fbb_.AddElement<int32_t>(DeConv2DGradFilter::VT_PADLEFT, padLeft, 0);
  }
  void add_padRight(int32_t padRight) {
    fbb_.AddElement<int32_t>(DeConv2DGradFilter::VT_PADRIGHT, padRight, 0);
  }
  void add_dilateW(int32_t dilateW) {
    fbb_.AddElement<int32_t>(DeConv2DGradFilter::VT_DILATEW, dilateW, 0);
  }
  void add_dilateH(int32_t dilateH) {
    fbb_.AddElement<int32_t>(DeConv2DGradFilter::VT_DILATEH, dilateH, 0);
  }
  void add_hasBias(bool hasBias) {
    fbb_.AddElement<uint8_t>(DeConv2DGradFilter::VT_HASBIAS, static_cast<uint8_t>(hasBias), 0);
  }
  void add_activationType(mindspore::schema::v0::ActivationType activationType) {
    fbb_.AddElement<int8_t>(DeConv2DGradFilter::VT_ACTIVATIONTYPE, static_cast<int8_t>(activationType), 0);
  }
  explicit DeConv2DGradFilterBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<DeConv2DGradFilter> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<DeConv2DGradFilter>(end);
    return o;
  }
};

inline flatbuffers::Offset<DeConv2DGradFilter> CreateDeConv2DGradFilter(
    flatbuffers::FlatBufferBuilder &_fbb,
    mindspore::schema::v0::Format format = mindspore::schema::v0::Format_NCHW,
    int32_t group = 0,
    int32_t channelIn = 0,
    int32_t channelOut = 0,
    int32_t kernelW = 0,
    int32_t kernelH = 0,
    int32_t strideW = 0,
    int32_t strideH = 0,
    mindspore::schema::v0::PadMode padMode = mindspore::schema::v0::PadMode_NOTSET,
    int32_t padUp = 0,
    int32_t padDown = 0,
    int32_t padLeft = 0,
    int32_t padRight = 0,
    int32_t dilateW = 0,
    int32_t dilateH = 0,
    bool hasBias = false,
    mindspore::schema::v0::ActivationType activationType = mindspore::schema::v0::ActivationType_NO_ACTIVATION) {
  DeConv2DGradFilterBuilder builder_(_fbb);
  builder_.add_dilateH(dilateH);
  builder_.add_dilateW(dilateW);
  builder_.add_padRight(padRight);
  builder_.add_padLeft(padLeft);
  builder_.add_padDown(padDown);
  builder_.add_padUp(padUp);
  builder_.add_strideH(strideH);
  builder_.add_strideW(strideW);
  builder_.add_kernelH(kernelH);
  builder_.add_kernelW(kernelW);
  builder_.add_channelOut(channelOut);
  builder_.add_channelIn(channelIn);
  builder_.add_group(group);
  builder_.add_format(format);
  builder_.add_activationType(activationType);
  builder_.add_hasBias(hasBias);
  builder_.add_padMode(padMode);
  return builder_.Finish();
}

flatbuffers::Offset<DeConv2DGradFilter> CreateDeConv2DGradFilter(flatbuffers::FlatBufferBuilder &_fbb, const DeConv2DGradFilterT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct BNGradT : public flatbuffers::NativeTable {
  typedef BNGrad TableType;
  float eps = 0.0f;
  float momentum = 0.0f;
};

struct BNGrad FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef BNGradT NativeTableType;
  typedef BNGradBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return BNGradTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_EPS = 4,
    VT_MOMENTUM = 6
  };
  float eps() const {
    return GetField<float>(VT_EPS, 0.0f);
  }
  bool mutate_eps(float _eps) {
    return SetField<float>(VT_EPS, _eps, 0.0f);
  }
  float momentum() const {
    return GetField<float>(VT_MOMENTUM, 0.0f);
  }
  bool mutate_momentum(float _momentum) {
    return SetField<float>(VT_MOMENTUM, _momentum, 0.0f);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<float>(verifier, VT_EPS) &&
           VerifyField<float>(verifier, VT_MOMENTUM) &&
           verifier.EndTable();
  }
  BNGradT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(BNGradT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<BNGrad> Pack(flatbuffers::FlatBufferBuilder &_fbb, const BNGradT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct BNGradBuilder {
  typedef BNGrad Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_eps(float eps) {
    fbb_.AddElement<float>(BNGrad::VT_EPS, eps, 0.0f);
  }
  void add_momentum(float momentum) {
    fbb_.AddElement<float>(BNGrad::VT_MOMENTUM, momentum, 0.0f);
  }
  explicit BNGradBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<BNGrad> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<BNGrad>(end);
    return o;
  }
};

inline flatbuffers::Offset<BNGrad> CreateBNGrad(
    flatbuffers::FlatBufferBuilder &_fbb,
    float eps = 0.0f,
    float momentum = 0.0f) {
  BNGradBuilder builder_(_fbb);
  builder_.add_momentum(momentum);
  builder_.add_eps(eps);
  return builder_.Finish();
}

flatbuffers::Offset<BNGrad> CreateBNGrad(flatbuffers::FlatBufferBuilder &_fbb, const BNGradT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ScaleT : public flatbuffers::NativeTable {
  typedef Scale TableType;
  int32_t axis = 0;
  mindspore::schema::v0::ActivationType activationType = mindspore::schema::v0::ActivationType_NO_ACTIVATION;
};

struct Scale FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ScaleT NativeTableType;
  typedef ScaleBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return ScaleTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_AXIS = 4,
    VT_ACTIVATIONTYPE = 6
  };
  int32_t axis() const {
    return GetField<int32_t>(VT_AXIS, 0);
  }
  bool mutate_axis(int32_t _axis) {
    return SetField<int32_t>(VT_AXIS, _axis, 0);
  }
  mindspore::schema::v0::ActivationType activationType() const {
    return static_cast<mindspore::schema::v0::ActivationType>(GetField<int8_t>(VT_ACTIVATIONTYPE, 0));
  }
  bool mutate_activationType(mindspore::schema::v0::ActivationType _activationType) {
    return SetField<int8_t>(VT_ACTIVATIONTYPE, static_cast<int8_t>(_activationType), 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_AXIS) &&
           VerifyField<int8_t>(verifier, VT_ACTIVATIONTYPE) &&
           verifier.EndTable();
  }
  ScaleT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ScaleT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Scale> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ScaleT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ScaleBuilder {
  typedef Scale Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_axis(int32_t axis) {
    fbb_.AddElement<int32_t>(Scale::VT_AXIS, axis, 0);
  }
  void add_activationType(mindspore::schema::v0::ActivationType activationType) {
    fbb_.AddElement<int8_t>(Scale::VT_ACTIVATIONTYPE, static_cast<int8_t>(activationType), 0);
  }
  explicit ScaleBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Scale> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Scale>(end);
    return o;
  }
};

inline flatbuffers::Offset<Scale> CreateScale(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t axis = 0,
    mindspore::schema::v0::ActivationType activationType = mindspore::schema::v0::ActivationType_NO_ACTIVATION) {
  ScaleBuilder builder_(_fbb);
  builder_.add_axis(axis);
  builder_.add_activationType(activationType);
  return builder_.Finish();
}

flatbuffers::Offset<Scale> CreateScale(flatbuffers::FlatBufferBuilder &_fbb, const ScaleT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct EltwiseT : public flatbuffers::NativeTable {
  typedef Eltwise TableType;
  mindspore::schema::v0::EltwiseMode mode = mindspore::schema::v0::EltwiseMode_PROD;
};

struct Eltwise FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef EltwiseT NativeTableType;
  typedef EltwiseBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return EltwiseTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_MODE = 4
  };
  mindspore::schema::v0::EltwiseMode mode() const {
    return static_cast<mindspore::schema::v0::EltwiseMode>(GetField<int8_t>(VT_MODE, 0));
  }
  bool mutate_mode(mindspore::schema::v0::EltwiseMode _mode) {
    return SetField<int8_t>(VT_MODE, static_cast<int8_t>(_mode), 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_MODE) &&
           verifier.EndTable();
  }
  EltwiseT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(EltwiseT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Eltwise> Pack(flatbuffers::FlatBufferBuilder &_fbb, const EltwiseT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct EltwiseBuilder {
  typedef Eltwise Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_mode(mindspore::schema::v0::EltwiseMode mode) {
    fbb_.AddElement<int8_t>(Eltwise::VT_MODE, static_cast<int8_t>(mode), 0);
  }
  explicit EltwiseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Eltwise> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Eltwise>(end);
    return o;
  }
};

inline flatbuffers::Offset<Eltwise> CreateEltwise(
    flatbuffers::FlatBufferBuilder &_fbb,
    mindspore::schema::v0::EltwiseMode mode = mindspore::schema::v0::EltwiseMode_PROD) {
  EltwiseBuilder builder_(_fbb);
  builder_.add_mode(mode);
  return builder_.Finish();
}

flatbuffers::Offset<Eltwise> CreateEltwise(flatbuffers::FlatBufferBuilder &_fbb, const EltwiseT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct AddT : public flatbuffers::NativeTable {
  typedef Add TableType;
  mindspore::schema::v0::ActivationType activationType = mindspore::schema::v0::ActivationType_NO_ACTIVATION;
};

struct Add FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef AddT NativeTableType;
  typedef AddBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return AddTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ACTIVATIONTYPE = 4
  };
  mindspore::schema::v0::ActivationType activationType() const {
    return static_cast<mindspore::schema::v0::ActivationType>(GetField<int8_t>(VT_ACTIVATIONTYPE, 0));
  }
  bool mutate_activationType(mindspore::schema::v0::ActivationType _activationType) {
    return SetField<int8_t>(VT_ACTIVATIONTYPE, static_cast<int8_t>(_activationType), 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_ACTIVATIONTYPE) &&
           verifier.EndTable();
  }
  AddT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(AddT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Add> Pack(flatbuffers::FlatBufferBuilder &_fbb, const AddT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct AddBuilder {
  typedef Add Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_activationType(mindspore::schema::v0::ActivationType activationType) {
    fbb_.AddElement<int8_t>(Add::VT_ACTIVATIONTYPE, static_cast<int8_t>(activationType), 0);
  }
  explicit AddBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Add> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Add>(end);
    return o;
  }
};

inline flatbuffers::Offset<Add> CreateAdd(
    flatbuffers::FlatBufferBuilder &_fbb,
    mindspore::schema::v0::ActivationType activationType = mindspore::schema::v0::ActivationType_NO_ACTIVATION) {
  AddBuilder builder_(_fbb);
  builder_.add_activationType(activationType);
  return builder_.Finish();
}

flatbuffers::Offset<Add> CreateAdd(flatbuffers::FlatBufferBuilder &_fbb, const AddT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct SubT : public flatbuffers::NativeTable {
  typedef Sub TableType;
  mindspore::schema::v0::ActivationType activationType = mindspore::schema::v0::ActivationType_NO_ACTIVATION;
};

struct Sub FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef SubT NativeTableType;
  typedef SubBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return SubTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ACTIVATIONTYPE = 4
  };
  mindspore::schema::v0::ActivationType activationType() const {
    return static_cast<mindspore::schema::v0::ActivationType>(GetField<int8_t>(VT_ACTIVATIONTYPE, 0));
  }
  bool mutate_activationType(mindspore::schema::v0::ActivationType _activationType) {
    return SetField<int8_t>(VT_ACTIVATIONTYPE, static_cast<int8_t>(_activationType), 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_ACTIVATIONTYPE) &&
           verifier.EndTable();
  }
  SubT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(SubT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Sub> Pack(flatbuffers::FlatBufferBuilder &_fbb, const SubT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct SubBuilder {
  typedef Sub Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_activationType(mindspore::schema::v0::ActivationType activationType) {
    fbb_.AddElement<int8_t>(Sub::VT_ACTIVATIONTYPE, static_cast<int8_t>(activationType), 0);
  }
  explicit SubBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Sub> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Sub>(end);
    return o;
  }
};

inline flatbuffers::Offset<Sub> CreateSub(
    flatbuffers::FlatBufferBuilder &_fbb,
    mindspore::schema::v0::ActivationType activationType = mindspore::schema::v0::ActivationType_NO_ACTIVATION) {
  SubBuilder builder_(_fbb);
  builder_.add_activationType(activationType);
  return builder_.Finish();
}

flatbuffers::Offset<Sub> CreateSub(flatbuffers::FlatBufferBuilder &_fbb, const SubT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct MulT : public flatbuffers::NativeTable {
  typedef Mul TableType;
  mindspore::schema::v0::ActivationType activationType = mindspore::schema::v0::ActivationType_NO_ACTIVATION;
};

struct Mul FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef MulT NativeTableType;
  typedef MulBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return MulTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ACTIVATIONTYPE = 4
  };
  mindspore::schema::v0::ActivationType activationType() const {
    return static_cast<mindspore::schema::v0::ActivationType>(GetField<int8_t>(VT_ACTIVATIONTYPE, 0));
  }
  bool mutate_activationType(mindspore::schema::v0::ActivationType _activationType) {
    return SetField<int8_t>(VT_ACTIVATIONTYPE, static_cast<int8_t>(_activationType), 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_ACTIVATIONTYPE) &&
           verifier.EndTable();
  }
  MulT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(MulT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Mul> Pack(flatbuffers::FlatBufferBuilder &_fbb, const MulT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct MulBuilder {
  typedef Mul Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_activationType(mindspore::schema::v0::ActivationType activationType) {
    fbb_.AddElement<int8_t>(Mul::VT_ACTIVATIONTYPE, static_cast<int8_t>(activationType), 0);
  }
  explicit MulBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Mul> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Mul>(end);
    return o;
  }
};

inline flatbuffers::Offset<Mul> CreateMul(
    flatbuffers::FlatBufferBuilder &_fbb,
    mindspore::schema::v0::ActivationType activationType = mindspore::schema::v0::ActivationType_NO_ACTIVATION) {
  MulBuilder builder_(_fbb);
  builder_.add_activationType(activationType);
  return builder_.Finish();
}

flatbuffers::Offset<Mul> CreateMul(flatbuffers::FlatBufferBuilder &_fbb, const MulT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct DivT : public flatbuffers::NativeTable {
  typedef Div TableType;
  mindspore::schema::v0::ActivationType activationType = mindspore::schema::v0::ActivationType_NO_ACTIVATION;
};

struct Div FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef DivT NativeTableType;
  typedef DivBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return DivTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ACTIVATIONTYPE = 4
  };
  mindspore::schema::v0::ActivationType activationType() const {
    return static_cast<mindspore::schema::v0::ActivationType>(GetField<int8_t>(VT_ACTIVATIONTYPE, 0));
  }
  bool mutate_activationType(mindspore::schema::v0::ActivationType _activationType) {
    return SetField<int8_t>(VT_ACTIVATIONTYPE, static_cast<int8_t>(_activationType), 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_ACTIVATIONTYPE) &&
           verifier.EndTable();
  }
  DivT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(DivT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Div> Pack(flatbuffers::FlatBufferBuilder &_fbb, const DivT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct DivBuilder {
  typedef Div Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_activationType(mindspore::schema::v0::ActivationType activationType) {
    fbb_.AddElement<int8_t>(Div::VT_ACTIVATIONTYPE, static_cast<int8_t>(activationType), 0);
  }
  explicit DivBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Div> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Div>(end);
    return o;
  }
};

inline flatbuffers::Offset<Div> CreateDiv(
    flatbuffers::FlatBufferBuilder &_fbb,
    mindspore::schema::v0::ActivationType activationType = mindspore::schema::v0::ActivationType_NO_ACTIVATION) {
  DivBuilder builder_(_fbb);
  builder_.add_activationType(activationType);
  return builder_.Finish();
}

flatbuffers::Offset<Div> CreateDiv(flatbuffers::FlatBufferBuilder &_fbb, const DivT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct AddGradT : public flatbuffers::NativeTable {
  typedef AddGrad TableType;
};

struct AddGrad FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef AddGradT NativeTableType;
  typedef AddGradBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return AddGradTypeTable();
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  AddGradT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(AddGradT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<AddGrad> Pack(flatbuffers::FlatBufferBuilder &_fbb, const AddGradT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct AddGradBuilder {
  typedef AddGrad Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit AddGradBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<AddGrad> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<AddGrad>(end);
    return o;
  }
};

inline flatbuffers::Offset<AddGrad> CreateAddGrad(
    flatbuffers::FlatBufferBuilder &_fbb) {
  AddGradBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<AddGrad> CreateAddGrad(flatbuffers::FlatBufferBuilder &_fbb, const AddGradT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct SubGradT : public flatbuffers::NativeTable {
  typedef SubGrad TableType;
};

struct SubGrad FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef SubGradT NativeTableType;
  typedef SubGradBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return SubGradTypeTable();
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  SubGradT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(SubGradT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<SubGrad> Pack(flatbuffers::FlatBufferBuilder &_fbb, const SubGradT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct SubGradBuilder {
  typedef SubGrad Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit SubGradBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<SubGrad> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SubGrad>(end);
    return o;
  }
};

inline flatbuffers::Offset<SubGrad> CreateSubGrad(
    flatbuffers::FlatBufferBuilder &_fbb) {
  SubGradBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<SubGrad> CreateSubGrad(flatbuffers::FlatBufferBuilder &_fbb, const SubGradT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct MulGradT : public flatbuffers::NativeTable {
  typedef MulGrad TableType;
};

struct MulGrad FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef MulGradT NativeTableType;
  typedef MulGradBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return MulGradTypeTable();
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  MulGradT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(MulGradT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<MulGrad> Pack(flatbuffers::FlatBufferBuilder &_fbb, const MulGradT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct MulGradBuilder {
  typedef MulGrad Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit MulGradBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<MulGrad> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<MulGrad>(end);
    return o;
  }
};

inline flatbuffers::Offset<MulGrad> CreateMulGrad(
    flatbuffers::FlatBufferBuilder &_fbb) {
  MulGradBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<MulGrad> CreateMulGrad(flatbuffers::FlatBufferBuilder &_fbb, const MulGradT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct DivGradT : public flatbuffers::NativeTable {
  typedef DivGrad TableType;
};

struct DivGrad FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef DivGradT NativeTableType;
  typedef DivGradBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return DivGradTypeTable();
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  DivGradT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(DivGradT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<DivGrad> Pack(flatbuffers::FlatBufferBuilder &_fbb, const DivGradT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct DivGradBuilder {
  typedef DivGrad Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit DivGradBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<DivGrad> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<DivGrad>(end);
    return o;
  }
};

inline flatbuffers::Offset<DivGrad> CreateDivGrad(
    flatbuffers::FlatBufferBuilder &_fbb) {
  DivGradBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<DivGrad> CreateDivGrad(flatbuffers::FlatBufferBuilder &_fbb, const DivGradT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct RealDivT : public flatbuffers::NativeTable {
  typedef RealDiv TableType;
};

struct RealDiv FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef RealDivT NativeTableType;
  typedef RealDivBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return RealDivTypeTable();
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  RealDivT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(RealDivT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<RealDiv> Pack(flatbuffers::FlatBufferBuilder &_fbb, const RealDivT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct RealDivBuilder {
  typedef RealDiv Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit RealDivBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<RealDiv> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<RealDiv>(end);
    return o;
  }
};

inline flatbuffers::Offset<RealDiv> CreateRealDiv(
    flatbuffers::FlatBufferBuilder &_fbb) {
  RealDivBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<RealDiv> CreateRealDiv(flatbuffers::FlatBufferBuilder &_fbb, const RealDivT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct RsqrtT : public flatbuffers::NativeTable {
  typedef Rsqrt TableType;
};

struct Rsqrt FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef RsqrtT NativeTableType;
  typedef RsqrtBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return RsqrtTypeTable();
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  RsqrtT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(RsqrtT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Rsqrt> Pack(flatbuffers::FlatBufferBuilder &_fbb, const RsqrtT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct RsqrtBuilder {
  typedef Rsqrt Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit RsqrtBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Rsqrt> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Rsqrt>(end);
    return o;
  }
};

inline flatbuffers::Offset<Rsqrt> CreateRsqrt(
    flatbuffers::FlatBufferBuilder &_fbb) {
  RsqrtBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<Rsqrt> CreateRsqrt(flatbuffers::FlatBufferBuilder &_fbb, const RsqrtT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct EqualT : public flatbuffers::NativeTable {
  typedef Equal TableType;
};

struct Equal FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef EqualT NativeTableType;
  typedef EqualBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return EqualTypeTable();
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  EqualT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(EqualT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Equal> Pack(flatbuffers::FlatBufferBuilder &_fbb, const EqualT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct EqualBuilder {
  typedef Equal Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit EqualBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Equal> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Equal>(end);
    return o;
  }
};

inline flatbuffers::Offset<Equal> CreateEqual(
    flatbuffers::FlatBufferBuilder &_fbb) {
  EqualBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<Equal> CreateEqual(flatbuffers::FlatBufferBuilder &_fbb, const EqualT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct LessT : public flatbuffers::NativeTable {
  typedef Less TableType;
};

struct Less FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef LessT NativeTableType;
  typedef LessBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return LessTypeTable();
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  LessT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(LessT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Less> Pack(flatbuffers::FlatBufferBuilder &_fbb, const LessT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct LessBuilder {
  typedef Less Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit LessBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Less> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Less>(end);
    return o;
  }
};

inline flatbuffers::Offset<Less> CreateLess(
    flatbuffers::FlatBufferBuilder &_fbb) {
  LessBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<Less> CreateLess(flatbuffers::FlatBufferBuilder &_fbb, const LessT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct GreaterT : public flatbuffers::NativeTable {
  typedef Greater TableType;
};

struct Greater FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef GreaterT NativeTableType;
  typedef GreaterBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return GreaterTypeTable();
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  GreaterT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(GreaterT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Greater> Pack(flatbuffers::FlatBufferBuilder &_fbb, const GreaterT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct GreaterBuilder {
  typedef Greater Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit GreaterBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Greater> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Greater>(end);
    return o;
  }
};

inline flatbuffers::Offset<Greater> CreateGreater(
    flatbuffers::FlatBufferBuilder &_fbb) {
  GreaterBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<Greater> CreateGreater(flatbuffers::FlatBufferBuilder &_fbb, const GreaterT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct NotEqualT : public flatbuffers::NativeTable {
  typedef NotEqual TableType;
};

struct NotEqual FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef NotEqualT NativeTableType;
  typedef NotEqualBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return NotEqualTypeTable();
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  NotEqualT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(NotEqualT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<NotEqual> Pack(flatbuffers::FlatBufferBuilder &_fbb, const NotEqualT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct NotEqualBuilder {
  typedef NotEqual Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit NotEqualBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<NotEqual> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<NotEqual>(end);
    return o;
  }
};

inline flatbuffers::Offset<NotEqual> CreateNotEqual(
    flatbuffers::FlatBufferBuilder &_fbb) {
  NotEqualBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<NotEqual> CreateNotEqual(flatbuffers::FlatBufferBuilder &_fbb, const NotEqualT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct LessEqualT : public flatbuffers::NativeTable {
  typedef LessEqual TableType;
};

struct LessEqual FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef LessEqualT NativeTableType;
  typedef LessEqualBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return LessEqualTypeTable();
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  LessEqualT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(LessEqualT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<LessEqual> Pack(flatbuffers::FlatBufferBuilder &_fbb, const LessEqualT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct LessEqualBuilder {
  typedef LessEqual Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit LessEqualBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<LessEqual> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<LessEqual>(end);
    return o;
  }
};

inline flatbuffers::Offset<LessEqual> CreateLessEqual(
    flatbuffers::FlatBufferBuilder &_fbb) {
  LessEqualBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<LessEqual> CreateLessEqual(flatbuffers::FlatBufferBuilder &_fbb, const LessEqualT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct GreaterEqualT : public flatbuffers::NativeTable {
  typedef GreaterEqual TableType;
};

struct GreaterEqual FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef GreaterEqualT NativeTableType;
  typedef GreaterEqualBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return GreaterEqualTypeTable();
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  GreaterEqualT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(GreaterEqualT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<GreaterEqual> Pack(flatbuffers::FlatBufferBuilder &_fbb, const GreaterEqualT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct GreaterEqualBuilder {
  typedef GreaterEqual Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit GreaterEqualBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<GreaterEqual> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<GreaterEqual>(end);
    return o;
  }
};

inline flatbuffers::Offset<GreaterEqual> CreateGreaterEqual(
    flatbuffers::FlatBufferBuilder &_fbb) {
  GreaterEqualBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<GreaterEqual> CreateGreaterEqual(flatbuffers::FlatBufferBuilder &_fbb, const GreaterEqualT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct MinT : public flatbuffers::NativeTable {
  typedef Min TableType;
};

struct Min FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef MinT NativeTableType;
  typedef MinBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return MinTypeTable();
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  MinT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(MinT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Min> Pack(flatbuffers::FlatBufferBuilder &_fbb, const MinT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct MinBuilder {
  typedef Min Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit MinBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Min> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Min>(end);
    return o;
  }
};

inline flatbuffers::Offset<Min> CreateMin(
    flatbuffers::FlatBufferBuilder &_fbb) {
  MinBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<Min> CreateMin(flatbuffers::FlatBufferBuilder &_fbb, const MinT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct SliceT : public flatbuffers::NativeTable {
  typedef Slice TableType;
  mindspore::schema::v0::Format format = mindspore::schema::v0::Format_NCHW;
  std::vector<int32_t> axes{};
  std::vector<int32_t> begin{};
  std::vector<int32_t> size{};
};

struct Slice FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef SliceT NativeTableType;
  typedef SliceBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return SliceTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_FORMAT = 4,
    VT_AXES = 6,
    VT_BEGIN = 8,
    VT_SIZE = 10
  };
  mindspore::schema::v0::Format format() const {
    return static_cast<mindspore::schema::v0::Format>(GetField<int32_t>(VT_FORMAT, 0));
  }
  bool mutate_format(mindspore::schema::v0::Format _format) {
    return SetField<int32_t>(VT_FORMAT, static_cast<int32_t>(_format), 0);
  }
  const flatbuffers::Vector<int32_t> *axes() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_AXES);
  }
  flatbuffers::Vector<int32_t> *mutable_axes() {
    return GetPointer<flatbuffers::Vector<int32_t> *>(VT_AXES);
  }
  const flatbuffers::Vector<int32_t> *begin() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_BEGIN);
  }
  flatbuffers::Vector<int32_t> *mutable_begin() {
    return GetPointer<flatbuffers::Vector<int32_t> *>(VT_BEGIN);
  }
  const flatbuffers::Vector<int32_t> *size() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_SIZE);
  }
  flatbuffers::Vector<int32_t> *mutable_size() {
    return GetPointer<flatbuffers::Vector<int32_t> *>(VT_SIZE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_FORMAT) &&
           VerifyOffset(verifier, VT_AXES) &&
           verifier.VerifyVector(axes()) &&
           VerifyOffset(verifier, VT_BEGIN) &&
           verifier.VerifyVector(begin()) &&
           VerifyOffset(verifier, VT_SIZE) &&
           verifier.VerifyVector(size()) &&
           verifier.EndTable();
  }
  SliceT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(SliceT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Slice> Pack(flatbuffers::FlatBufferBuilder &_fbb, const SliceT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct SliceBuilder {
  typedef Slice Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_format(mindspore::schema::v0::Format format) {
    fbb_.AddElement<int32_t>(Slice::VT_FORMAT, static_cast<int32_t>(format), 0);
  }
  void add_axes(flatbuffers::Offset<flatbuffers::Vector<int32_t>> axes) {
    fbb_.AddOffset(Slice::VT_AXES, axes);
  }
  void add_begin(flatbuffers::Offset<flatbuffers::Vector<int32_t>> begin) {
    fbb_.AddOffset(Slice::VT_BEGIN, begin);
  }
  void add_size(flatbuffers::Offset<flatbuffers::Vector<int32_t>> size) {
    fbb_.AddOffset(Slice::VT_SIZE, size);
  }
  explicit SliceBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Slice> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Slice>(end);
    return o;
  }
};

inline flatbuffers::Offset<Slice> CreateSlice(
    flatbuffers::FlatBufferBuilder &_fbb,
    mindspore::schema::v0::Format format = mindspore::schema::v0::Format_NCHW,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> axes = 0,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> begin = 0,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> size = 0) {
  SliceBuilder builder_(_fbb);
  builder_.add_size(size);
  builder_.add_begin(begin);
  builder_.add_axes(axes);
  builder_.add_format(format);
  return builder_.Finish();
}

inline flatbuffers::Offset<Slice> CreateSliceDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    mindspore::schema::v0::Format format = mindspore::schema::v0::Format_NCHW,
    const std::vector<int32_t> *axes = nullptr,
    const std::vector<int32_t> *begin = nullptr,
    const std::vector<int32_t> *size = nullptr) {
  auto axes__ = axes ? _fbb.CreateVector<int32_t>(*axes) : 0;
  auto begin__ = begin ? _fbb.CreateVector<int32_t>(*begin) : 0;
  auto size__ = size ? _fbb.CreateVector<int32_t>(*size) : 0;
  return mindspore::schema::v0::CreateSlice(
      _fbb,
      format,
      axes__,
      begin__,
      size__);
}

flatbuffers::Offset<Slice> CreateSlice(flatbuffers::FlatBufferBuilder &_fbb, const SliceT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct FloorT : public flatbuffers::NativeTable {
  typedef Floor TableType;
};

struct Floor FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef FloorT NativeTableType;
  typedef FloorBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return FloorTypeTable();
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  FloorT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(FloorT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Floor> Pack(flatbuffers::FlatBufferBuilder &_fbb, const FloorT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct FloorBuilder {
  typedef Floor Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit FloorBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Floor> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Floor>(end);
    return o;
  }
};

inline flatbuffers::Offset<Floor> CreateFloor(
    flatbuffers::FlatBufferBuilder &_fbb) {
  FloorBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<Floor> CreateFloor(flatbuffers::FlatBufferBuilder &_fbb, const FloorT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct AbsT : public flatbuffers::NativeTable {
  typedef Abs TableType;
};

struct Abs FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef AbsT NativeTableType;
  typedef AbsBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return AbsTypeTable();
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  AbsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(AbsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Abs> Pack(flatbuffers::FlatBufferBuilder &_fbb, const AbsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct AbsBuilder {
  typedef Abs Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit AbsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Abs> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Abs>(end);
    return o;
  }
};

inline flatbuffers::Offset<Abs> CreateAbs(
    flatbuffers::FlatBufferBuilder &_fbb) {
  AbsBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<Abs> CreateAbs(flatbuffers::FlatBufferBuilder &_fbb, const AbsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct NegT : public flatbuffers::NativeTable {
  typedef Neg TableType;
};

struct Neg FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef NegT NativeTableType;
  typedef NegBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return NegTypeTable();
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  NegT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(NegT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Neg> Pack(flatbuffers::FlatBufferBuilder &_fbb, const NegT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct NegBuilder {
  typedef Neg Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit NegBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Neg> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Neg>(end);
    return o;
  }
};

inline flatbuffers::Offset<Neg> CreateNeg(
    flatbuffers::FlatBufferBuilder &_fbb) {
  NegBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<Neg> CreateNeg(flatbuffers::FlatBufferBuilder &_fbb, const NegT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct NegGradT : public flatbuffers::NativeTable {
  typedef NegGrad TableType;
};

struct NegGrad FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef NegGradT NativeTableType;
  typedef NegGradBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return NegGradTypeTable();
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  NegGradT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(NegGradT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<NegGrad> Pack(flatbuffers::FlatBufferBuilder &_fbb, const NegGradT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct NegGradBuilder {
  typedef NegGrad Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit NegGradBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<NegGrad> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<NegGrad>(end);
    return o;
  }
};

inline flatbuffers::Offset<NegGrad> CreateNegGrad(
    flatbuffers::FlatBufferBuilder &_fbb) {
  NegGradBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<NegGrad> CreateNegGrad(flatbuffers::FlatBufferBuilder &_fbb, const NegGradT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ExpT : public flatbuffers::NativeTable {
  typedef Exp TableType;
  float base = -1.0f;
  float scale = 1.0f;
  float shift = 0.0f;
};

struct Exp FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ExpT NativeTableType;
  typedef ExpBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return ExpTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_BASE = 4,
    VT_SCALE = 6,
    VT_SHIFT = 8
  };
  float base() const {
    return GetField<float>(VT_BASE, -1.0f);
  }
  bool mutate_base(float _base) {
    return SetField<float>(VT_BASE, _base, -1.0f);
  }
  float scale() const {
    return GetField<float>(VT_SCALE, 1.0f);
  }
  bool mutate_scale(float _scale) {
    return SetField<float>(VT_SCALE, _scale, 1.0f);
  }
  float shift() const {
    return GetField<float>(VT_SHIFT, 0.0f);
  }
  bool mutate_shift(float _shift) {
    return SetField<float>(VT_SHIFT, _shift, 0.0f);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<float>(verifier, VT_BASE) &&
           VerifyField<float>(verifier, VT_SCALE) &&
           VerifyField<float>(verifier, VT_SHIFT) &&
           verifier.EndTable();
  }
  ExpT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ExpT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Exp> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ExpT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ExpBuilder {
  typedef Exp Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_base(float base) {
    fbb_.AddElement<float>(Exp::VT_BASE, base, -1.0f);
  }
  void add_scale(float scale) {
    fbb_.AddElement<float>(Exp::VT_SCALE, scale, 1.0f);
  }
  void add_shift(float shift) {
    fbb_.AddElement<float>(Exp::VT_SHIFT, shift, 0.0f);
  }
  explicit ExpBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Exp> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Exp>(end);
    return o;
  }
};

inline flatbuffers::Offset<Exp> CreateExp(
    flatbuffers::FlatBufferBuilder &_fbb,
    float base = -1.0f,
    float scale = 1.0f,
    float shift = 0.0f) {
  ExpBuilder builder_(_fbb);
  builder_.add_shift(shift);
  builder_.add_scale(scale);
  builder_.add_base(base);
  return builder_.Finish();
}

flatbuffers::Offset<Exp> CreateExp(flatbuffers::FlatBufferBuilder &_fbb, const ExpT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct CosT : public flatbuffers::NativeTable {
  typedef Cos TableType;
};

struct Cos FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef CosT NativeTableType;
  typedef CosBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return CosTypeTable();
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  CosT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(CosT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Cos> Pack(flatbuffers::FlatBufferBuilder &_fbb, const CosT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct CosBuilder {
  typedef Cos Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit CosBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Cos> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Cos>(end);
    return o;
  }
};

inline flatbuffers::Offset<Cos> CreateCos(
    flatbuffers::FlatBufferBuilder &_fbb) {
  CosBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<Cos> CreateCos(flatbuffers::FlatBufferBuilder &_fbb, const CosT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct SinT : public flatbuffers::NativeTable {
  typedef Sin TableType;
};

struct Sin FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef SinT NativeTableType;
  typedef SinBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return SinTypeTable();
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  SinT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(SinT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Sin> Pack(flatbuffers::FlatBufferBuilder &_fbb, const SinT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct SinBuilder {
  typedef Sin Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit SinBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Sin> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Sin>(end);
    return o;
  }
};

inline flatbuffers::Offset<Sin> CreateSin(
    flatbuffers::FlatBufferBuilder &_fbb) {
  SinBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<Sin> CreateSin(flatbuffers::FlatBufferBuilder &_fbb, const SinT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct SqrtT : public flatbuffers::NativeTable {
  typedef Sqrt TableType;
};

struct Sqrt FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef SqrtT NativeTableType;
  typedef SqrtBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return SqrtTypeTable();
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  SqrtT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(SqrtT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Sqrt> Pack(flatbuffers::FlatBufferBuilder &_fbb, const SqrtT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct SqrtBuilder {
  typedef Sqrt Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit SqrtBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Sqrt> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Sqrt>(end);
    return o;
  }
};

inline flatbuffers::Offset<Sqrt> CreateSqrt(
    flatbuffers::FlatBufferBuilder &_fbb) {
  SqrtBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<Sqrt> CreateSqrt(flatbuffers::FlatBufferBuilder &_fbb, const SqrtT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct SquareT : public flatbuffers::NativeTable {
  typedef Square TableType;
};

struct Square FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef SquareT NativeTableType;
  typedef SquareBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return SquareTypeTable();
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  SquareT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(SquareT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Square> Pack(flatbuffers::FlatBufferBuilder &_fbb, const SquareT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct SquareBuilder {
  typedef Square Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit SquareBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Square> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Square>(end);
    return o;
  }
};

inline flatbuffers::Offset<Square> CreateSquare(
    flatbuffers::FlatBufferBuilder &_fbb) {
  SquareBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<Square> CreateSquare(flatbuffers::FlatBufferBuilder &_fbb, const SquareT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct CeilT : public flatbuffers::NativeTable {
  typedef Ceil TableType;
};

struct Ceil FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef CeilT NativeTableType;
  typedef CeilBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return CeilTypeTable();
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  CeilT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(CeilT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Ceil> Pack(flatbuffers::FlatBufferBuilder &_fbb, const CeilT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct CeilBuilder {
  typedef Ceil Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit CeilBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Ceil> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Ceil>(end);
    return o;
  }
};

inline flatbuffers::Offset<Ceil> CreateCeil(
    flatbuffers::FlatBufferBuilder &_fbb) {
  CeilBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<Ceil> CreateCeil(flatbuffers::FlatBufferBuilder &_fbb, const CeilT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct LogT : public flatbuffers::NativeTable {
  typedef Log TableType;
};

struct Log FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef LogT NativeTableType;
  typedef LogBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return LogTypeTable();
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  LogT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(LogT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Log> Pack(flatbuffers::FlatBufferBuilder &_fbb, const LogT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct LogBuilder {
  typedef Log Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit LogBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Log> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Log>(end);
    return o;
  }
};

inline flatbuffers::Offset<Log> CreateLog(
    flatbuffers::FlatBufferBuilder &_fbb) {
  LogBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<Log> CreateLog(flatbuffers::FlatBufferBuilder &_fbb, const LogT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct LogGradT : public flatbuffers::NativeTable {
  typedef LogGrad TableType;
};

struct LogGrad FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef LogGradT NativeTableType;
  typedef LogGradBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return LogGradTypeTable();
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  LogGradT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(LogGradT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<LogGrad> Pack(flatbuffers::FlatBufferBuilder &_fbb, const LogGradT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct LogGradBuilder {
  typedef LogGrad Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit LogGradBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<LogGrad> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<LogGrad>(end);
    return o;
  }
};

inline flatbuffers::Offset<LogGrad> CreateLogGrad(
    flatbuffers::FlatBufferBuilder &_fbb) {
  LogGradBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<LogGrad> CreateLogGrad(flatbuffers::FlatBufferBuilder &_fbb, const LogGradT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct TanT : public flatbuffers::NativeTable {
  typedef Tan TableType;
};

struct Tan FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef TanT NativeTableType;
  typedef TanBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return TanTypeTable();
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  TanT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(TanT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Tan> Pack(flatbuffers::FlatBufferBuilder &_fbb, const TanT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct TanBuilder {
  typedef Tan Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit TanBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Tan> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Tan>(end);
    return o;
  }
};

inline flatbuffers::Offset<Tan> CreateTan(
    flatbuffers::FlatBufferBuilder &_fbb) {
  TanBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<Tan> CreateTan(flatbuffers::FlatBufferBuilder &_fbb, const TanT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct AtanT : public flatbuffers::NativeTable {
  typedef Atan TableType;
};

struct Atan FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef AtanT NativeTableType;
  typedef AtanBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return AtanTypeTable();
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  AtanT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(AtanT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Atan> Pack(flatbuffers::FlatBufferBuilder &_fbb, const AtanT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct AtanBuilder {
  typedef Atan Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit AtanBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Atan> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Atan>(end);
    return o;
  }
};

inline flatbuffers::Offset<Atan> CreateAtan(
    flatbuffers::FlatBufferBuilder &_fbb) {
  AtanBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<Atan> CreateAtan(flatbuffers::FlatBufferBuilder &_fbb, const AtanT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct AsinT : public flatbuffers::NativeTable {
  typedef Asin TableType;
};

struct Asin FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef AsinT NativeTableType;
  typedef AsinBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return AsinTypeTable();
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  AsinT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(AsinT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Asin> Pack(flatbuffers::FlatBufferBuilder &_fbb, const AsinT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct AsinBuilder {
  typedef Asin Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit AsinBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Asin> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Asin>(end);
    return o;
  }
};

inline flatbuffers::Offset<Asin> CreateAsin(
    flatbuffers::FlatBufferBuilder &_fbb) {
  AsinBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<Asin> CreateAsin(flatbuffers::FlatBufferBuilder &_fbb, const AsinT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ReshapeT : public flatbuffers::NativeTable {
  typedef Reshape TableType;
  mindspore::schema::v0::Format format = mindspore::schema::v0::Format_NCHW;
  std::vector<int64_t> shape{};
};

struct Reshape FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ReshapeT NativeTableType;
  typedef ReshapeBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return ReshapeTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_FORMAT = 4,
    VT_SHAPE = 6
  };
  mindspore::schema::v0::Format format() const {
    return static_cast<mindspore::schema::v0::Format>(GetField<int32_t>(VT_FORMAT, 0));
  }
  bool mutate_format(mindspore::schema::v0::Format _format) {
    return SetField<int32_t>(VT_FORMAT, static_cast<int32_t>(_format), 0);
  }
  const flatbuffers::Vector<int64_t> *shape() const {
    return GetPointer<const flatbuffers::Vector<int64_t> *>(VT_SHAPE);
  }
  flatbuffers::Vector<int64_t> *mutable_shape() {
    return GetPointer<flatbuffers::Vector<int64_t> *>(VT_SHAPE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_FORMAT) &&
           VerifyOffset(verifier, VT_SHAPE) &&
           verifier.VerifyVector(shape()) &&
           verifier.EndTable();
  }
  ReshapeT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ReshapeT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Reshape> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ReshapeT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ReshapeBuilder {
  typedef Reshape Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_format(mindspore::schema::v0::Format format) {
    fbb_.AddElement<int32_t>(Reshape::VT_FORMAT, static_cast<int32_t>(format), 0);
  }
  void add_shape(flatbuffers::Offset<flatbuffers::Vector<int64_t>> shape) {
    fbb_.AddOffset(Reshape::VT_SHAPE, shape);
  }
  explicit ReshapeBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Reshape> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Reshape>(end);
    return o;
  }
};

inline flatbuffers::Offset<Reshape> CreateReshape(
    flatbuffers::FlatBufferBuilder &_fbb,
    mindspore::schema::v0::Format format = mindspore::schema::v0::Format_NCHW,
    flatbuffers::Offset<flatbuffers::Vector<int64_t>> shape = 0) {
  ReshapeBuilder builder_(_fbb);
  builder_.add_shape(shape);
  builder_.add_format(format);
  return builder_.Finish();
}

inline flatbuffers::Offset<Reshape> CreateReshapeDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    mindspore::schema::v0::Format format = mindspore::schema::v0::Format_NCHW,
    const std::vector<int64_t> *shape = nullptr) {
  auto shape__ = shape ? _fbb.CreateVector<int64_t>(*shape) : 0;
  return mindspore::schema::v0::CreateReshape(
      _fbb,
      format,
      shape__);
}

flatbuffers::Offset<Reshape> CreateReshape(flatbuffers::FlatBufferBuilder &_fbb, const ReshapeT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct PowerT : public flatbuffers::NativeTable {
  typedef Power TableType;
  float power = 0.0f;
  float scale = 0.0f;
  float shift = 0.0f;
};

struct Power FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef PowerT NativeTableType;
  typedef PowerBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return PowerTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_POWER = 4,
    VT_SCALE = 6,
    VT_SHIFT = 8
  };
  float power() const {
    return GetField<float>(VT_POWER, 0.0f);
  }
  bool mutate_power(float _power) {
    return SetField<float>(VT_POWER, _power, 0.0f);
  }
  float scale() const {
    return GetField<float>(VT_SCALE, 0.0f);
  }
  bool mutate_scale(float _scale) {
    return SetField<float>(VT_SCALE, _scale, 0.0f);
  }
  float shift() const {
    return GetField<float>(VT_SHIFT, 0.0f);
  }
  bool mutate_shift(float _shift) {
    return SetField<float>(VT_SHIFT, _shift, 0.0f);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<float>(verifier, VT_POWER) &&
           VerifyField<float>(verifier, VT_SCALE) &&
           VerifyField<float>(verifier, VT_SHIFT) &&
           verifier.EndTable();
  }
  PowerT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(PowerT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Power> Pack(flatbuffers::FlatBufferBuilder &_fbb, const PowerT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct PowerBuilder {
  typedef Power Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_power(float power) {
    fbb_.AddElement<float>(Power::VT_POWER, power, 0.0f);
  }
  void add_scale(float scale) {
    fbb_.AddElement<float>(Power::VT_SCALE, scale, 0.0f);
  }
  void add_shift(float shift) {
    fbb_.AddElement<float>(Power::VT_SHIFT, shift, 0.0f);
  }
  explicit PowerBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Power> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Power>(end);
    return o;
  }
};

inline flatbuffers::Offset<Power> CreatePower(
    flatbuffers::FlatBufferBuilder &_fbb,
    float power = 0.0f,
    float scale = 0.0f,
    float shift = 0.0f) {
  PowerBuilder builder_(_fbb);
  builder_.add_shift(shift);
  builder_.add_scale(scale);
  builder_.add_power(power);
  return builder_.Finish();
}

flatbuffers::Offset<Power> CreatePower(flatbuffers::FlatBufferBuilder &_fbb, const PowerT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct PowerGradT : public flatbuffers::NativeTable {
  typedef PowerGrad TableType;
  float power = 0.0f;
  float scale = 0.0f;
  float shift = 0.0f;
};

struct PowerGrad FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef PowerGradT NativeTableType;
  typedef PowerGradBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return PowerGradTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_POWER = 4,
    VT_SCALE = 6,
    VT_SHIFT = 8
  };
  float power() const {
    return GetField<float>(VT_POWER, 0.0f);
  }
  bool mutate_power(float _power) {
    return SetField<float>(VT_POWER, _power, 0.0f);
  }
  float scale() const {
    return GetField<float>(VT_SCALE, 0.0f);
  }
  bool mutate_scale(float _scale) {
    return SetField<float>(VT_SCALE, _scale, 0.0f);
  }
  float shift() const {
    return GetField<float>(VT_SHIFT, 0.0f);
  }
  bool mutate_shift(float _shift) {
    return SetField<float>(VT_SHIFT, _shift, 0.0f);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<float>(verifier, VT_POWER) &&
           VerifyField<float>(verifier, VT_SCALE) &&
           VerifyField<float>(verifier, VT_SHIFT) &&
           verifier.EndTable();
  }
  PowerGradT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(PowerGradT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<PowerGrad> Pack(flatbuffers::FlatBufferBuilder &_fbb, const PowerGradT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct PowerGradBuilder {
  typedef PowerGrad Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_power(float power) {
    fbb_.AddElement<float>(PowerGrad::VT_POWER, power, 0.0f);
  }
  void add_scale(float scale) {
    fbb_.AddElement<float>(PowerGrad::VT_SCALE, scale, 0.0f);
  }
  void add_shift(float shift) {
    fbb_.AddElement<float>(PowerGrad::VT_SHIFT, shift, 0.0f);
  }
  explicit PowerGradBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<PowerGrad> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<PowerGrad>(end);
    return o;
  }
};

inline flatbuffers::Offset<PowerGrad> CreatePowerGrad(
    flatbuffers::FlatBufferBuilder &_fbb,
    float power = 0.0f,
    float scale = 0.0f,
    float shift = 0.0f) {
  PowerGradBuilder builder_(_fbb);
  builder_.add_shift(shift);
  builder_.add_scale(scale);
  builder_.add_power(power);
  return builder_.Finish();
}

flatbuffers::Offset<PowerGrad> CreatePowerGrad(flatbuffers::FlatBufferBuilder &_fbb, const PowerGradT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ArgMaxT : public flatbuffers::NativeTable {
  typedef ArgMax TableType;
  int32_t axis = 0;
  bool outMaxValue = false;
  int32_t topK = 1;
  bool keepDims = false;
  int32_t axisType = 0;
};

struct ArgMax FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ArgMaxT NativeTableType;
  typedef ArgMaxBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return ArgMaxTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_AXIS = 4,
    VT_OUTMAXVALUE = 6,
    VT_TOPK = 8,
    VT_KEEPDIMS = 10,
    VT_AXISTYPE = 12
  };
  int32_t axis() const {
    return GetField<int32_t>(VT_AXIS, 0);
  }
  bool mutate_axis(int32_t _axis) {
    return SetField<int32_t>(VT_AXIS, _axis, 0);
  }
  bool outMaxValue() const {
    return GetField<uint8_t>(VT_OUTMAXVALUE, 0) != 0;
  }
  bool mutate_outMaxValue(bool _outMaxValue) {
    return SetField<uint8_t>(VT_OUTMAXVALUE, static_cast<uint8_t>(_outMaxValue), 0);
  }
  int32_t topK() const {
    return GetField<int32_t>(VT_TOPK, 1);
  }
  bool mutate_topK(int32_t _topK) {
    return SetField<int32_t>(VT_TOPK, _topK, 1);
  }
  bool keepDims() const {
    return GetField<uint8_t>(VT_KEEPDIMS, 0) != 0;
  }
  bool mutate_keepDims(bool _keepDims) {
    return SetField<uint8_t>(VT_KEEPDIMS, static_cast<uint8_t>(_keepDims), 0);
  }
  int32_t axisType() const {
    return GetField<int32_t>(VT_AXISTYPE, 0);
  }
  bool mutate_axisType(int32_t _axisType) {
    return SetField<int32_t>(VT_AXISTYPE, _axisType, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_AXIS) &&
           VerifyField<uint8_t>(verifier, VT_OUTMAXVALUE) &&
           VerifyField<int32_t>(verifier, VT_TOPK) &&
           VerifyField<uint8_t>(verifier, VT_KEEPDIMS) &&
           VerifyField<int32_t>(verifier, VT_AXISTYPE) &&
           verifier.EndTable();
  }
  ArgMaxT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ArgMaxT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<ArgMax> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ArgMaxT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ArgMaxBuilder {
  typedef ArgMax Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_axis(int32_t axis) {
    fbb_.AddElement<int32_t>(ArgMax::VT_AXIS, axis, 0);
  }
  void add_outMaxValue(bool outMaxValue) {
    fbb_.AddElement<uint8_t>(ArgMax::VT_OUTMAXVALUE, static_cast<uint8_t>(outMaxValue), 0);
  }
  void add_topK(int32_t topK) {
    fbb_.AddElement<int32_t>(ArgMax::VT_TOPK, topK, 1);
  }
  void add_keepDims(bool keepDims) {
    fbb_.AddElement<uint8_t>(ArgMax::VT_KEEPDIMS, static_cast<uint8_t>(keepDims), 0);
  }
  void add_axisType(int32_t axisType) {
    fbb_.AddElement<int32_t>(ArgMax::VT_AXISTYPE, axisType, 0);
  }
  explicit ArgMaxBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<ArgMax> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ArgMax>(end);
    return o;
  }
};

inline flatbuffers::Offset<ArgMax> CreateArgMax(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t axis = 0,
    bool outMaxValue = false,
    int32_t topK = 1,
    bool keepDims = false,
    int32_t axisType = 0) {
  ArgMaxBuilder builder_(_fbb);
  builder_.add_axisType(axisType);
  builder_.add_topK(topK);
  builder_.add_axis(axis);
  builder_.add_keepDims(keepDims);
  builder_.add_outMaxValue(outMaxValue);
  return builder_.Finish();
}

flatbuffers::Offset<ArgMax> CreateArgMax(flatbuffers::FlatBufferBuilder &_fbb, const ArgMaxT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ArgMinT : public flatbuffers::NativeTable {
  typedef ArgMin TableType;
  int32_t axis = 0;
  bool outMaxValue = false;
  int32_t topK = 1;
  bool keepDims = false;
  int32_t axisType = 0;
};

struct ArgMin FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ArgMinT NativeTableType;
  typedef ArgMinBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return ArgMinTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_AXIS = 4,
    VT_OUTMAXVALUE = 6,
    VT_TOPK = 8,
    VT_KEEPDIMS = 10,
    VT_AXISTYPE = 12
  };
  int32_t axis() const {
    return GetField<int32_t>(VT_AXIS, 0);
  }
  bool mutate_axis(int32_t _axis) {
    return SetField<int32_t>(VT_AXIS, _axis, 0);
  }
  bool outMaxValue() const {
    return GetField<uint8_t>(VT_OUTMAXVALUE, 0) != 0;
  }
  bool mutate_outMaxValue(bool _outMaxValue) {
    return SetField<uint8_t>(VT_OUTMAXVALUE, static_cast<uint8_t>(_outMaxValue), 0);
  }
  int32_t topK() const {
    return GetField<int32_t>(VT_TOPK, 1);
  }
  bool mutate_topK(int32_t _topK) {
    return SetField<int32_t>(VT_TOPK, _topK, 1);
  }
  bool keepDims() const {
    return GetField<uint8_t>(VT_KEEPDIMS, 0) != 0;
  }
  bool mutate_keepDims(bool _keepDims) {
    return SetField<uint8_t>(VT_KEEPDIMS, static_cast<uint8_t>(_keepDims), 0);
  }
  int32_t axisType() const {
    return GetField<int32_t>(VT_AXISTYPE, 0);
  }
  bool mutate_axisType(int32_t _axisType) {
    return SetField<int32_t>(VT_AXISTYPE, _axisType, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_AXIS) &&
           VerifyField<uint8_t>(verifier, VT_OUTMAXVALUE) &&
           VerifyField<int32_t>(verifier, VT_TOPK) &&
           VerifyField<uint8_t>(verifier, VT_KEEPDIMS) &&
           VerifyField<int32_t>(verifier, VT_AXISTYPE) &&
           verifier.EndTable();
  }
  ArgMinT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ArgMinT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<ArgMin> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ArgMinT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ArgMinBuilder {
  typedef ArgMin Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_axis(int32_t axis) {
    fbb_.AddElement<int32_t>(ArgMin::VT_AXIS, axis, 0);
  }
  void add_outMaxValue(bool outMaxValue) {
    fbb_.AddElement<uint8_t>(ArgMin::VT_OUTMAXVALUE, static_cast<uint8_t>(outMaxValue), 0);
  }
  void add_topK(int32_t topK) {
    fbb_.AddElement<int32_t>(ArgMin::VT_TOPK, topK, 1);
  }
  void add_keepDims(bool keepDims) {
    fbb_.AddElement<uint8_t>(ArgMin::VT_KEEPDIMS, static_cast<uint8_t>(keepDims), 0);
  }
  void add_axisType(int32_t axisType) {
    fbb_.AddElement<int32_t>(ArgMin::VT_AXISTYPE, axisType, 0);
  }
  explicit ArgMinBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<ArgMin> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ArgMin>(end);
    return o;
  }
};

inline flatbuffers::Offset<ArgMin> CreateArgMin(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t axis = 0,
    bool outMaxValue = false,
    int32_t topK = 1,
    bool keepDims = false,
    int32_t axisType = 0) {
  ArgMinBuilder builder_(_fbb);
  builder_.add_axisType(axisType);
  builder_.add_topK(topK);
  builder_.add_axis(axis);
  builder_.add_keepDims(keepDims);
  builder_.add_outMaxValue(outMaxValue);
  return builder_.Finish();
}

flatbuffers::Offset<ArgMin> CreateArgMin(flatbuffers::FlatBufferBuilder &_fbb, const ArgMinT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct NetOutputT : public flatbuffers::NativeTable {
  typedef NetOutput TableType;
};

struct NetOutput FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef NetOutputT NativeTableType;
  typedef NetOutputBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return NetOutputTypeTable();
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  NetOutputT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(NetOutputT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<NetOutput> Pack(flatbuffers::FlatBufferBuilder &_fbb, const NetOutputT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct NetOutputBuilder {
  typedef NetOutput Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit NetOutputBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<NetOutput> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<NetOutput>(end);
    return o;
  }
};

inline flatbuffers::Offset<NetOutput> CreateNetOutput(
    flatbuffers::FlatBufferBuilder &_fbb) {
  NetOutputBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<NetOutput> CreateNetOutput(flatbuffers::FlatBufferBuilder &_fbb, const NetOutputT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct MatMulT : public flatbuffers::NativeTable {
  typedef MatMul TableType;
  bool broadcast = false;
  bool transposeA = false;
  bool transposeB = false;
};

struct MatMul FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef MatMulT NativeTableType;
  typedef MatMulBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return MatMulTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_BROADCAST = 4,
    VT_TRANSPOSEA = 6,
    VT_TRANSPOSEB = 8
  };
  bool broadcast() const {
    return GetField<uint8_t>(VT_BROADCAST, 0) != 0;
  }
  bool mutate_broadcast(bool _broadcast) {
    return SetField<uint8_t>(VT_BROADCAST, static_cast<uint8_t>(_broadcast), 0);
  }
  bool transposeA() const {
    return GetField<uint8_t>(VT_TRANSPOSEA, 0) != 0;
  }
  bool mutate_transposeA(bool _transposeA) {
    return SetField<uint8_t>(VT_TRANSPOSEA, static_cast<uint8_t>(_transposeA), 0);
  }
  bool transposeB() const {
    return GetField<uint8_t>(VT_TRANSPOSEB, 0) != 0;
  }
  bool mutate_transposeB(bool _transposeB) {
    return SetField<uint8_t>(VT_TRANSPOSEB, static_cast<uint8_t>(_transposeB), 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_BROADCAST) &&
           VerifyField<uint8_t>(verifier, VT_TRANSPOSEA) &&
           VerifyField<uint8_t>(verifier, VT_TRANSPOSEB) &&
           verifier.EndTable();
  }
  MatMulT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(MatMulT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<MatMul> Pack(flatbuffers::FlatBufferBuilder &_fbb, const MatMulT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct MatMulBuilder {
  typedef MatMul Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_broadcast(bool broadcast) {
    fbb_.AddElement<uint8_t>(MatMul::VT_BROADCAST, static_cast<uint8_t>(broadcast), 0);
  }
  void add_transposeA(bool transposeA) {
    fbb_.AddElement<uint8_t>(MatMul::VT_TRANSPOSEA, static_cast<uint8_t>(transposeA), 0);
  }
  void add_transposeB(bool transposeB) {
    fbb_.AddElement<uint8_t>(MatMul::VT_TRANSPOSEB, static_cast<uint8_t>(transposeB), 0);
  }
  explicit MatMulBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<MatMul> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<MatMul>(end);
    return o;
  }
};

inline flatbuffers::Offset<MatMul> CreateMatMul(
    flatbuffers::FlatBufferBuilder &_fbb,
    bool broadcast = false,
    bool transposeA = false,
    bool transposeB = false) {
  MatMulBuilder builder_(_fbb);
  builder_.add_transposeB(transposeB);
  builder_.add_transposeA(transposeA);
  builder_.add_broadcast(broadcast);
  return builder_.Finish();
}

flatbuffers::Offset<MatMul> CreateMatMul(flatbuffers::FlatBufferBuilder &_fbb, const MatMulT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct PReLUT : public flatbuffers::NativeTable {
  typedef PReLU TableType;
  bool channelShared = false;
  std::vector<float> slope{};
};

struct PReLU FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef PReLUT NativeTableType;
  typedef PReLUBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return PReLUTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_CHANNELSHARED = 4,
    VT_SLOPE = 6
  };
  bool channelShared() const {
    return GetField<uint8_t>(VT_CHANNELSHARED, 0) != 0;
  }
  bool mutate_channelShared(bool _channelShared) {
    return SetField<uint8_t>(VT_CHANNELSHARED, static_cast<uint8_t>(_channelShared), 0);
  }
  const flatbuffers::Vector<float> *slope() const {
    return GetPointer<const flatbuffers::Vector<float> *>(VT_SLOPE);
  }
  flatbuffers::Vector<float> *mutable_slope() {
    return GetPointer<flatbuffers::Vector<float> *>(VT_SLOPE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_CHANNELSHARED) &&
           VerifyOffset(verifier, VT_SLOPE) &&
           verifier.VerifyVector(slope()) &&
           verifier.EndTable();
  }
  PReLUT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(PReLUT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<PReLU> Pack(flatbuffers::FlatBufferBuilder &_fbb, const PReLUT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct PReLUBuilder {
  typedef PReLU Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_channelShared(bool channelShared) {
    fbb_.AddElement<uint8_t>(PReLU::VT_CHANNELSHARED, static_cast<uint8_t>(channelShared), 0);
  }
  void add_slope(flatbuffers::Offset<flatbuffers::Vector<float>> slope) {
    fbb_.AddOffset(PReLU::VT_SLOPE, slope);
  }
  explicit PReLUBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<PReLU> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<PReLU>(end);
    return o;
  }
};

inline flatbuffers::Offset<PReLU> CreatePReLU(
    flatbuffers::FlatBufferBuilder &_fbb,
    bool channelShared = false,
    flatbuffers::Offset<flatbuffers::Vector<float>> slope = 0) {
  PReLUBuilder builder_(_fbb);
  builder_.add_slope(slope);
  builder_.add_channelShared(channelShared);
  return builder_.Finish();
}

inline flatbuffers::Offset<PReLU> CreatePReLUDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    bool channelShared = false,
    const std::vector<float> *slope = nullptr) {
  auto slope__ = slope ? _fbb.CreateVector<float>(*slope) : 0;
  return mindspore::schema::v0::CreatePReLU(
      _fbb,
      channelShared,
      slope__);
}

flatbuffers::Offset<PReLU> CreatePReLU(flatbuffers::FlatBufferBuilder &_fbb, const PReLUT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct LeakyReLUT : public flatbuffers::NativeTable {
  typedef LeakyReLU TableType;
  float negativeSlope = 0.0f;
};

struct LeakyReLU FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef LeakyReLUT NativeTableType;
  typedef LeakyReLUBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return LeakyReLUTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NEGATIVESLOPE = 4
  };
  float negativeSlope() const {
    return GetField<float>(VT_NEGATIVESLOPE, 0.0f);
  }
  bool mutate_negativeSlope(float _negativeSlope) {
    return SetField<float>(VT_NEGATIVESLOPE, _negativeSlope, 0.0f);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<float>(verifier, VT_NEGATIVESLOPE) &&
           verifier.EndTable();
  }
  LeakyReLUT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(LeakyReLUT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<LeakyReLU> Pack(flatbuffers::FlatBufferBuilder &_fbb, const LeakyReLUT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct LeakyReLUBuilder {
  typedef LeakyReLU Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_negativeSlope(float negativeSlope) {
    fbb_.AddElement<float>(LeakyReLU::VT_NEGATIVESLOPE, negativeSlope, 0.0f);
  }
  explicit LeakyReLUBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<LeakyReLU> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<LeakyReLU>(end);
    return o;
  }
};

inline flatbuffers::Offset<LeakyReLU> CreateLeakyReLU(
    flatbuffers::FlatBufferBuilder &_fbb,
    float negativeSlope = 0.0f) {
  LeakyReLUBuilder builder_(_fbb);
  builder_.add_negativeSlope(negativeSlope);
  return builder_.Finish();
}

flatbuffers::Offset<LeakyReLU> CreateLeakyReLU(flatbuffers::FlatBufferBuilder &_fbb, const LeakyReLUT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct StridedSliceT : public flatbuffers::NativeTable {
  typedef StridedSlice TableType;
  int32_t beginMask = 0;
  int32_t endMask = 0;
  int32_t ellipsisMask = 0;
  int32_t newAxisMask = 0;
  int32_t shrinkAxisMask = 0;
  std::vector<int32_t> begin{};
  std::vector<int32_t> end{};
  std::vector<int32_t> stride{};
  std::vector<int32_t> isScale{};
};

struct StridedSlice FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef StridedSliceT NativeTableType;
  typedef StridedSliceBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return StridedSliceTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_BEGINMASK = 4,
    VT_ENDMASK = 6,
    VT_ELLIPSISMASK = 8,
    VT_NEWAXISMASK = 10,
    VT_SHRINKAXISMASK = 12,
    VT_BEGIN = 14,
    VT_END = 16,
    VT_STRIDE = 18,
    VT_ISSCALE = 20
  };
  int32_t beginMask() const {
    return GetField<int32_t>(VT_BEGINMASK, 0);
  }
  bool mutate_beginMask(int32_t _beginMask) {
    return SetField<int32_t>(VT_BEGINMASK, _beginMask, 0);
  }
  int32_t endMask() const {
    return GetField<int32_t>(VT_ENDMASK, 0);
  }
  bool mutate_endMask(int32_t _endMask) {
    return SetField<int32_t>(VT_ENDMASK, _endMask, 0);
  }
  int32_t ellipsisMask() const {
    return GetField<int32_t>(VT_ELLIPSISMASK, 0);
  }
  bool mutate_ellipsisMask(int32_t _ellipsisMask) {
    return SetField<int32_t>(VT_ELLIPSISMASK, _ellipsisMask, 0);
  }
  int32_t newAxisMask() const {
    return GetField<int32_t>(VT_NEWAXISMASK, 0);
  }
  bool mutate_newAxisMask(int32_t _newAxisMask) {
    return SetField<int32_t>(VT_NEWAXISMASK, _newAxisMask, 0);
  }
  int32_t shrinkAxisMask() const {
    return GetField<int32_t>(VT_SHRINKAXISMASK, 0);
  }
  bool mutate_shrinkAxisMask(int32_t _shrinkAxisMask) {
    return SetField<int32_t>(VT_SHRINKAXISMASK, _shrinkAxisMask, 0);
  }
  const flatbuffers::Vector<int32_t> *begin() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_BEGIN);
  }
  flatbuffers::Vector<int32_t> *mutable_begin() {
    return GetPointer<flatbuffers::Vector<int32_t> *>(VT_BEGIN);
  }
  const flatbuffers::Vector<int32_t> *end() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_END);
  }
  flatbuffers::Vector<int32_t> *mutable_end() {
    return GetPointer<flatbuffers::Vector<int32_t> *>(VT_END);
  }
  const flatbuffers::Vector<int32_t> *stride() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_STRIDE);
  }
  flatbuffers::Vector<int32_t> *mutable_stride() {
    return GetPointer<flatbuffers::Vector<int32_t> *>(VT_STRIDE);
  }
  const flatbuffers::Vector<int32_t> *isScale() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_ISSCALE);
  }
  flatbuffers::Vector<int32_t> *mutable_isScale() {
    return GetPointer<flatbuffers::Vector<int32_t> *>(VT_ISSCALE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_BEGINMASK) &&
           VerifyField<int32_t>(verifier, VT_ENDMASK) &&
           VerifyField<int32_t>(verifier, VT_ELLIPSISMASK) &&
           VerifyField<int32_t>(verifier, VT_NEWAXISMASK) &&
           VerifyField<int32_t>(verifier, VT_SHRINKAXISMASK) &&
           VerifyOffset(verifier, VT_BEGIN) &&
           verifier.VerifyVector(begin()) &&
           VerifyOffset(verifier, VT_END) &&
           verifier.VerifyVector(end()) &&
           VerifyOffset(verifier, VT_STRIDE) &&
           verifier.VerifyVector(stride()) &&
           VerifyOffset(verifier, VT_ISSCALE) &&
           verifier.VerifyVector(isScale()) &&
           verifier.EndTable();
  }
  StridedSliceT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(StridedSliceT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<StridedSlice> Pack(flatbuffers::FlatBufferBuilder &_fbb, const StridedSliceT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct StridedSliceBuilder {
  typedef StridedSlice Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_beginMask(int32_t beginMask) {
    fbb_.AddElement<int32_t>(StridedSlice::VT_BEGINMASK, beginMask, 0);
  }
  void add_endMask(int32_t endMask) {
    fbb_.AddElement<int32_t>(StridedSlice::VT_ENDMASK, endMask, 0);
  }
  void add_ellipsisMask(int32_t ellipsisMask) {
    fbb_.AddElement<int32_t>(StridedSlice::VT_ELLIPSISMASK, ellipsisMask, 0);
  }
  void add_newAxisMask(int32_t newAxisMask) {
    fbb_.AddElement<int32_t>(StridedSlice::VT_NEWAXISMASK, newAxisMask, 0);
  }
  void add_shrinkAxisMask(int32_t shrinkAxisMask) {
    fbb_.AddElement<int32_t>(StridedSlice::VT_SHRINKAXISMASK, shrinkAxisMask, 0);
  }
  void add_begin(flatbuffers::Offset<flatbuffers::Vector<int32_t>> begin) {
    fbb_.AddOffset(StridedSlice::VT_BEGIN, begin);
  }
  void add_end(flatbuffers::Offset<flatbuffers::Vector<int32_t>> end) {
    fbb_.AddOffset(StridedSlice::VT_END, end);
  }
  void add_stride(flatbuffers::Offset<flatbuffers::Vector<int32_t>> stride) {
    fbb_.AddOffset(StridedSlice::VT_STRIDE, stride);
  }
  void add_isScale(flatbuffers::Offset<flatbuffers::Vector<int32_t>> isScale) {
    fbb_.AddOffset(StridedSlice::VT_ISSCALE, isScale);
  }
  explicit StridedSliceBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<StridedSlice> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<StridedSlice>(end);
    return o;
  }
};

inline flatbuffers::Offset<StridedSlice> CreateStridedSlice(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t beginMask = 0,
    int32_t endMask = 0,
    int32_t ellipsisMask = 0,
    int32_t newAxisMask = 0,
    int32_t shrinkAxisMask = 0,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> begin = 0,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> end = 0,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> stride = 0,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> isScale = 0) {
  StridedSliceBuilder builder_(_fbb);
  builder_.add_isScale(isScale);
  builder_.add_stride(stride);
  builder_.add_end(end);
  builder_.add_begin(begin);
  builder_.add_shrinkAxisMask(shrinkAxisMask);
  builder_.add_newAxisMask(newAxisMask);
  builder_.add_ellipsisMask(ellipsisMask);
  builder_.add_endMask(endMask);
  builder_.add_beginMask(beginMask);
  return builder_.Finish();
}

inline flatbuffers::Offset<StridedSlice> CreateStridedSliceDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t beginMask = 0,
    int32_t endMask = 0,
    int32_t ellipsisMask = 0,
    int32_t newAxisMask = 0,
    int32_t shrinkAxisMask = 0,
    const std::vector<int32_t> *begin = nullptr,
    const std::vector<int32_t> *end = nullptr,
    const std::vector<int32_t> *stride = nullptr,
    const std::vector<int32_t> *isScale = nullptr) {
  auto begin__ = begin ? _fbb.CreateVector<int32_t>(*begin) : 0;
  auto end__ = end ? _fbb.CreateVector<int32_t>(*end) : 0;
  auto stride__ = stride ? _fbb.CreateVector<int32_t>(*stride) : 0;
  auto isScale__ = isScale ? _fbb.CreateVector<int32_t>(*isScale) : 0;
  return mindspore::schema::v0::CreateStridedSlice(
      _fbb,
      beginMask,
      endMask,
      ellipsisMask,
      newAxisMask,
      shrinkAxisMask,
      begin__,
      end__,
      stride__,
      isScale__);
}

flatbuffers::Offset<StridedSlice> CreateStridedSlice(flatbuffers::FlatBufferBuilder &_fbb, const StridedSliceT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct StackT : public flatbuffers::NativeTable {
  typedef Stack TableType;
  int32_t axis = 0;
  int32_t n = 0;
  std::vector<int32_t> isScale{};
};

struct Stack FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef StackT NativeTableType;
  typedef StackBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return StackTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_AXIS = 4,
    VT_N = 6,
    VT_ISSCALE = 8
  };
  int32_t axis() const {
    return GetField<int32_t>(VT_AXIS, 0);
  }
  bool mutate_axis(int32_t _axis) {
    return SetField<int32_t>(VT_AXIS, _axis, 0);
  }
  int32_t n() const {
    return GetField<int32_t>(VT_N, 0);
  }
  bool mutate_n(int32_t _n) {
    return SetField<int32_t>(VT_N, _n, 0);
  }
  const flatbuffers::Vector<int32_t> *isScale() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_ISSCALE);
  }
  flatbuffers::Vector<int32_t> *mutable_isScale() {
    return GetPointer<flatbuffers::Vector<int32_t> *>(VT_ISSCALE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_AXIS) &&
           VerifyField<int32_t>(verifier, VT_N) &&
           VerifyOffset(verifier, VT_ISSCALE) &&
           verifier.VerifyVector(isScale()) &&
           verifier.EndTable();
  }
  StackT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(StackT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Stack> Pack(flatbuffers::FlatBufferBuilder &_fbb, const StackT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct StackBuilder {
  typedef Stack Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_axis(int32_t axis) {
    fbb_.AddElement<int32_t>(Stack::VT_AXIS, axis, 0);
  }
  void add_n(int32_t n) {
    fbb_.AddElement<int32_t>(Stack::VT_N, n, 0);
  }
  void add_isScale(flatbuffers::Offset<flatbuffers::Vector<int32_t>> isScale) {
    fbb_.AddOffset(Stack::VT_ISSCALE, isScale);
  }
  explicit StackBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Stack> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Stack>(end);
    return o;
  }
};

inline flatbuffers::Offset<Stack> CreateStack(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t axis = 0,
    int32_t n = 0,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> isScale = 0) {
  StackBuilder builder_(_fbb);
  builder_.add_isScale(isScale);
  builder_.add_n(n);
  builder_.add_axis(axis);
  return builder_.Finish();
}

inline flatbuffers::Offset<Stack> CreateStackDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t axis = 0,
    int32_t n = 0,
    const std::vector<int32_t> *isScale = nullptr) {
  auto isScale__ = isScale ? _fbb.CreateVector<int32_t>(*isScale) : 0;
  return mindspore::schema::v0::CreateStack(
      _fbb,
      axis,
      n,
      isScale__);
}

flatbuffers::Offset<Stack> CreateStack(flatbuffers::FlatBufferBuilder &_fbb, const StackT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct RangeT : public flatbuffers::NativeTable {
  typedef Range TableType;
  int32_t dType = 0;
  int32_t start = 0;
  int32_t limit = 0;
  int32_t delta = 1;
};

struct Range FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef RangeT NativeTableType;
  typedef RangeBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return RangeTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_DTYPE = 4,
    VT_START = 6,
    VT_LIMIT = 8,
    VT_DELTA = 10
  };
  int32_t dType() const {
    return GetField<int32_t>(VT_DTYPE, 0);
  }
  bool mutate_dType(int32_t _dType) {
    return SetField<int32_t>(VT_DTYPE, _dType, 0);
  }
  int32_t start() const {
    return GetField<int32_t>(VT_START, 0);
  }
  bool mutate_start(int32_t _start) {
    return SetField<int32_t>(VT_START, _start, 0);
  }
  int32_t limit() const {
    return GetField<int32_t>(VT_LIMIT, 0);
  }
  bool mutate_limit(int32_t _limit) {
    return SetField<int32_t>(VT_LIMIT, _limit, 0);
  }
  int32_t delta() const {
    return GetField<int32_t>(VT_DELTA, 1);
  }
  bool mutate_delta(int32_t _delta) {
    return SetField<int32_t>(VT_DELTA, _delta, 1);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_DTYPE) &&
           VerifyField<int32_t>(verifier, VT_START) &&
           VerifyField<int32_t>(verifier, VT_LIMIT) &&
           VerifyField<int32_t>(verifier, VT_DELTA) &&
           verifier.EndTable();
  }
  RangeT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(RangeT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Range> Pack(flatbuffers::FlatBufferBuilder &_fbb, const RangeT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct RangeBuilder {
  typedef Range Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_dType(int32_t dType) {
    fbb_.AddElement<int32_t>(Range::VT_DTYPE, dType, 0);
  }
  void add_start(int32_t start) {
    fbb_.AddElement<int32_t>(Range::VT_START, start, 0);
  }
  void add_limit(int32_t limit) {
    fbb_.AddElement<int32_t>(Range::VT_LIMIT, limit, 0);
  }
  void add_delta(int32_t delta) {
    fbb_.AddElement<int32_t>(Range::VT_DELTA, delta, 1);
  }
  explicit RangeBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Range> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Range>(end);
    return o;
  }
};

inline flatbuffers::Offset<Range> CreateRange(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t dType = 0,
    int32_t start = 0,
    int32_t limit = 0,
    int32_t delta = 1) {
  RangeBuilder builder_(_fbb);
  builder_.add_delta(delta);
  builder_.add_limit(limit);
  builder_.add_start(start);
  builder_.add_dType(dType);
  return builder_.Finish();
}

flatbuffers::Offset<Range> CreateRange(flatbuffers::FlatBufferBuilder &_fbb, const RangeT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ExpandDimsT : public flatbuffers::NativeTable {
  typedef ExpandDims TableType;
  int32_t dim = 0;
};

struct ExpandDims FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ExpandDimsT NativeTableType;
  typedef ExpandDimsBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return ExpandDimsTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_DIM = 4
  };
  int32_t dim() const {
    return GetField<int32_t>(VT_DIM, 0);
  }
  bool mutate_dim(int32_t _dim) {
    return SetField<int32_t>(VT_DIM, _dim, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_DIM) &&
           verifier.EndTable();
  }
  ExpandDimsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ExpandDimsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<ExpandDims> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ExpandDimsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ExpandDimsBuilder {
  typedef ExpandDims Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_dim(int32_t dim) {
    fbb_.AddElement<int32_t>(ExpandDims::VT_DIM, dim, 0);
  }
  explicit ExpandDimsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<ExpandDims> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ExpandDims>(end);
    return o;
  }
};

inline flatbuffers::Offset<ExpandDims> CreateExpandDims(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t dim = 0) {
  ExpandDimsBuilder builder_(_fbb);
  builder_.add_dim(dim);
  return builder_.Finish();
}

flatbuffers::Offset<ExpandDims> CreateExpandDims(flatbuffers::FlatBufferBuilder &_fbb, const ExpandDimsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct TileT : public flatbuffers::NativeTable {
  typedef Tile TableType;
  std::vector<int32_t> multiples{};
  std::vector<int32_t> dims{};
};

struct Tile FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef TileT NativeTableType;
  typedef TileBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return TileTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_MULTIPLES = 4,
    VT_DIMS = 6
  };
  const flatbuffers::Vector<int32_t> *multiples() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_MULTIPLES);
  }
  flatbuffers::Vector<int32_t> *mutable_multiples() {
    return GetPointer<flatbuffers::Vector<int32_t> *>(VT_MULTIPLES);
  }
  const flatbuffers::Vector<int32_t> *dims() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_DIMS);
  }
  flatbuffers::Vector<int32_t> *mutable_dims() {
    return GetPointer<flatbuffers::Vector<int32_t> *>(VT_DIMS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_MULTIPLES) &&
           verifier.VerifyVector(multiples()) &&
           VerifyOffset(verifier, VT_DIMS) &&
           verifier.VerifyVector(dims()) &&
           verifier.EndTable();
  }
  TileT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(TileT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Tile> Pack(flatbuffers::FlatBufferBuilder &_fbb, const TileT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct TileBuilder {
  typedef Tile Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_multiples(flatbuffers::Offset<flatbuffers::Vector<int32_t>> multiples) {
    fbb_.AddOffset(Tile::VT_MULTIPLES, multiples);
  }
  void add_dims(flatbuffers::Offset<flatbuffers::Vector<int32_t>> dims) {
    fbb_.AddOffset(Tile::VT_DIMS, dims);
  }
  explicit TileBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Tile> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Tile>(end);
    return o;
  }
};

inline flatbuffers::Offset<Tile> CreateTile(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> multiples = 0,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> dims = 0) {
  TileBuilder builder_(_fbb);
  builder_.add_dims(dims);
  builder_.add_multiples(multiples);
  return builder_.Finish();
}

inline flatbuffers::Offset<Tile> CreateTileDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<int32_t> *multiples = nullptr,
    const std::vector<int32_t> *dims = nullptr) {
  auto multiples__ = multiples ? _fbb.CreateVector<int32_t>(*multiples) : 0;
  auto dims__ = dims ? _fbb.CreateVector<int32_t>(*dims) : 0;
  return mindspore::schema::v0::CreateTile(
      _fbb,
      multiples__,
      dims__);
}

flatbuffers::Offset<Tile> CreateTile(flatbuffers::FlatBufferBuilder &_fbb, const TileT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct CastT : public flatbuffers::NativeTable {
  typedef Cast TableType;
  int32_t srcT = 0;
  int32_t dstT = 0;
};

struct Cast FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef CastT NativeTableType;
  typedef CastBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return CastTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SRCT = 4,
    VT_DSTT = 6
  };
  int32_t srcT() const {
    return GetField<int32_t>(VT_SRCT, 0);
  }
  bool mutate_srcT(int32_t _srcT) {
    return SetField<int32_t>(VT_SRCT, _srcT, 0);
  }
  int32_t dstT() const {
    return GetField<int32_t>(VT_DSTT, 0);
  }
  bool mutate_dstT(int32_t _dstT) {
    return SetField<int32_t>(VT_DSTT, _dstT, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_SRCT) &&
           VerifyField<int32_t>(verifier, VT_DSTT) &&
           verifier.EndTable();
  }
  CastT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(CastT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Cast> Pack(flatbuffers::FlatBufferBuilder &_fbb, const CastT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct CastBuilder {
  typedef Cast Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_srcT(int32_t srcT) {
    fbb_.AddElement<int32_t>(Cast::VT_SRCT, srcT, 0);
  }
  void add_dstT(int32_t dstT) {
    fbb_.AddElement<int32_t>(Cast::VT_DSTT, dstT, 0);
  }
  explicit CastBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Cast> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Cast>(end);
    return o;
  }
};

inline flatbuffers::Offset<Cast> CreateCast(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t srcT = 0,
    int32_t dstT = 0) {
  CastBuilder builder_(_fbb);
  builder_.add_dstT(dstT);
  builder_.add_srcT(srcT);
  return builder_.Finish();
}

flatbuffers::Offset<Cast> CreateCast(flatbuffers::FlatBufferBuilder &_fbb, const CastT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct QuantDTypeCastT : public flatbuffers::NativeTable {
  typedef QuantDTypeCast TableType;
  int32_t srcT = 0;
  int32_t dstT = 0;
};

struct QuantDTypeCast FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef QuantDTypeCastT NativeTableType;
  typedef QuantDTypeCastBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return QuantDTypeCastTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SRCT = 4,
    VT_DSTT = 6
  };
  int32_t srcT() const {
    return GetField<int32_t>(VT_SRCT, 0);
  }
  bool mutate_srcT(int32_t _srcT) {
    return SetField<int32_t>(VT_SRCT, _srcT, 0);
  }
  int32_t dstT() const {
    return GetField<int32_t>(VT_DSTT, 0);
  }
  bool mutate_dstT(int32_t _dstT) {
    return SetField<int32_t>(VT_DSTT, _dstT, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_SRCT) &&
           VerifyField<int32_t>(verifier, VT_DSTT) &&
           verifier.EndTable();
  }
  QuantDTypeCastT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(QuantDTypeCastT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<QuantDTypeCast> Pack(flatbuffers::FlatBufferBuilder &_fbb, const QuantDTypeCastT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct QuantDTypeCastBuilder {
  typedef QuantDTypeCast Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_srcT(int32_t srcT) {
    fbb_.AddElement<int32_t>(QuantDTypeCast::VT_SRCT, srcT, 0);
  }
  void add_dstT(int32_t dstT) {
    fbb_.AddElement<int32_t>(QuantDTypeCast::VT_DSTT, dstT, 0);
  }
  explicit QuantDTypeCastBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<QuantDTypeCast> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<QuantDTypeCast>(end);
    return o;
  }
};

inline flatbuffers::Offset<QuantDTypeCast> CreateQuantDTypeCast(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t srcT = 0,
    int32_t dstT = 0) {
  QuantDTypeCastBuilder builder_(_fbb);
  builder_.add_dstT(dstT);
  builder_.add_srcT(srcT);
  return builder_.Finish();
}

flatbuffers::Offset<QuantDTypeCast> CreateQuantDTypeCast(flatbuffers::FlatBufferBuilder &_fbb, const QuantDTypeCastT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct SplitT : public flatbuffers::NativeTable {
  typedef Split TableType;
  int32_t numberSplit = 0;
  std::vector<int32_t> sizeSplits{};
  int32_t splitDim = 0;
};

struct Split FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef SplitT NativeTableType;
  typedef SplitBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return SplitTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NUMBERSPLIT = 4,
    VT_SIZESPLITS = 6,
    VT_SPLITDIM = 8
  };
  int32_t numberSplit() const {
    return GetField<int32_t>(VT_NUMBERSPLIT, 0);
  }
  bool mutate_numberSplit(int32_t _numberSplit) {
    return SetField<int32_t>(VT_NUMBERSPLIT, _numberSplit, 0);
  }
  const flatbuffers::Vector<int32_t> *sizeSplits() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_SIZESPLITS);
  }
  flatbuffers::Vector<int32_t> *mutable_sizeSplits() {
    return GetPointer<flatbuffers::Vector<int32_t> *>(VT_SIZESPLITS);
  }
  int32_t splitDim() const {
    return GetField<int32_t>(VT_SPLITDIM, 0);
  }
  bool mutate_splitDim(int32_t _splitDim) {
    return SetField<int32_t>(VT_SPLITDIM, _splitDim, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_NUMBERSPLIT) &&
           VerifyOffset(verifier, VT_SIZESPLITS) &&
           verifier.VerifyVector(sizeSplits()) &&
           VerifyField<int32_t>(verifier, VT_SPLITDIM) &&
           verifier.EndTable();
  }
  SplitT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(SplitT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Split> Pack(flatbuffers::FlatBufferBuilder &_fbb, const SplitT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct SplitBuilder {
  typedef Split Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_numberSplit(int32_t numberSplit) {
    fbb_.AddElement<int32_t>(Split::VT_NUMBERSPLIT, numberSplit, 0);
  }
  void add_sizeSplits(flatbuffers::Offset<flatbuffers::Vector<int32_t>> sizeSplits) {
    fbb_.AddOffset(Split::VT_SIZESPLITS, sizeSplits);
  }
  void add_splitDim(int32_t splitDim) {
    fbb_.AddElement<int32_t>(Split::VT_SPLITDIM, splitDim, 0);
  }
  explicit SplitBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Split> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Split>(end);
    return o;
  }
};

inline flatbuffers::Offset<Split> CreateSplit(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t numberSplit = 0,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> sizeSplits = 0,
    int32_t splitDim = 0) {
  SplitBuilder builder_(_fbb);
  builder_.add_splitDim(splitDim);
  builder_.add_sizeSplits(sizeSplits);
  builder_.add_numberSplit(numberSplit);
  return builder_.Finish();
}

inline flatbuffers::Offset<Split> CreateSplitDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t numberSplit = 0,
    const std::vector<int32_t> *sizeSplits = nullptr,
    int32_t splitDim = 0) {
  auto sizeSplits__ = sizeSplits ? _fbb.CreateVector<int32_t>(*sizeSplits) : 0;
  return mindspore::schema::v0::CreateSplit(
      _fbb,
      numberSplit,
      sizeSplits__,
      splitDim);
}

flatbuffers::Offset<Split> CreateSplit(flatbuffers::FlatBufferBuilder &_fbb, const SplitT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct CropT : public flatbuffers::NativeTable {
  typedef Crop TableType;
  int64_t axis = 0;
  std::vector<int64_t> offsets{};
};

struct Crop FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef CropT NativeTableType;
  typedef CropBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return CropTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_AXIS = 4,
    VT_OFFSETS = 6
  };
  int64_t axis() const {
    return GetField<int64_t>(VT_AXIS, 0);
  }
  bool mutate_axis(int64_t _axis) {
    return SetField<int64_t>(VT_AXIS, _axis, 0);
  }
  const flatbuffers::Vector<int64_t> *offsets() const {
    return GetPointer<const flatbuffers::Vector<int64_t> *>(VT_OFFSETS);
  }
  flatbuffers::Vector<int64_t> *mutable_offsets() {
    return GetPointer<flatbuffers::Vector<int64_t> *>(VT_OFFSETS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_AXIS) &&
           VerifyOffset(verifier, VT_OFFSETS) &&
           verifier.VerifyVector(offsets()) &&
           verifier.EndTable();
  }
  CropT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(CropT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Crop> Pack(flatbuffers::FlatBufferBuilder &_fbb, const CropT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct CropBuilder {
  typedef Crop Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_axis(int64_t axis) {
    fbb_.AddElement<int64_t>(Crop::VT_AXIS, axis, 0);
  }
  void add_offsets(flatbuffers::Offset<flatbuffers::Vector<int64_t>> offsets) {
    fbb_.AddOffset(Crop::VT_OFFSETS, offsets);
  }
  explicit CropBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Crop> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Crop>(end);
    return o;
  }
};

inline flatbuffers::Offset<Crop> CreateCrop(
    flatbuffers::FlatBufferBuilder &_fbb,
    int64_t axis = 0,
    flatbuffers::Offset<flatbuffers::Vector<int64_t>> offsets = 0) {
  CropBuilder builder_(_fbb);
  builder_.add_axis(axis);
  builder_.add_offsets(offsets);
  return builder_.Finish();
}

inline flatbuffers::Offset<Crop> CreateCropDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int64_t axis = 0,
    const std::vector<int64_t> *offsets = nullptr) {
  auto offsets__ = offsets ? _fbb.CreateVector<int64_t>(*offsets) : 0;
  return mindspore::schema::v0::CreateCrop(
      _fbb,
      axis,
      offsets__);
}

flatbuffers::Offset<Crop> CreateCrop(flatbuffers::FlatBufferBuilder &_fbb, const CropT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct PermuteT : public flatbuffers::NativeTable {
  typedef Permute TableType;
  std::vector<int64_t> order{};
};

struct Permute FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef PermuteT NativeTableType;
  typedef PermuteBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return PermuteTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ORDER = 4
  };
  const flatbuffers::Vector<int64_t> *order() const {
    return GetPointer<const flatbuffers::Vector<int64_t> *>(VT_ORDER);
  }
  flatbuffers::Vector<int64_t> *mutable_order() {
    return GetPointer<flatbuffers::Vector<int64_t> *>(VT_ORDER);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ORDER) &&
           verifier.VerifyVector(order()) &&
           verifier.EndTable();
  }
  PermuteT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(PermuteT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Permute> Pack(flatbuffers::FlatBufferBuilder &_fbb, const PermuteT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct PermuteBuilder {
  typedef Permute Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_order(flatbuffers::Offset<flatbuffers::Vector<int64_t>> order) {
    fbb_.AddOffset(Permute::VT_ORDER, order);
  }
  explicit PermuteBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Permute> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Permute>(end);
    return o;
  }
};

inline flatbuffers::Offset<Permute> CreatePermute(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<int64_t>> order = 0) {
  PermuteBuilder builder_(_fbb);
  builder_.add_order(order);
  return builder_.Finish();
}

inline flatbuffers::Offset<Permute> CreatePermuteDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<int64_t> *order = nullptr) {
  auto order__ = order ? _fbb.CreateVector<int64_t>(*order) : 0;
  return mindspore::schema::v0::CreatePermute(
      _fbb,
      order__);
}

flatbuffers::Offset<Permute> CreatePermute(flatbuffers::FlatBufferBuilder &_fbb, const PermuteT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ClipT : public flatbuffers::NativeTable {
  typedef Clip TableType;
  float max = 0.0f;
  float min = 0.0f;
};

struct Clip FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ClipT NativeTableType;
  typedef ClipBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return ClipTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_MAX = 4,
    VT_MIN = 6
  };
  float max() const {
    return GetField<float>(VT_MAX, 0.0f);
  }
  bool mutate_max(float _max) {
    return SetField<float>(VT_MAX, _max, 0.0f);
  }
  float min() const {
    return GetField<float>(VT_MIN, 0.0f);
  }
  bool mutate_min(float _min) {
    return SetField<float>(VT_MIN, _min, 0.0f);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<float>(verifier, VT_MAX) &&
           VerifyField<float>(verifier, VT_MIN) &&
           verifier.EndTable();
  }
  ClipT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ClipT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Clip> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ClipT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ClipBuilder {
  typedef Clip Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_max(float max) {
    fbb_.AddElement<float>(Clip::VT_MAX, max, 0.0f);
  }
  void add_min(float min) {
    fbb_.AddElement<float>(Clip::VT_MIN, min, 0.0f);
  }
  explicit ClipBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Clip> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Clip>(end);
    return o;
  }
};

inline flatbuffers::Offset<Clip> CreateClip(
    flatbuffers::FlatBufferBuilder &_fbb,
    float max = 0.0f,
    float min = 0.0f) {
  ClipBuilder builder_(_fbb);
  builder_.add_min(min);
  builder_.add_max(max);
  return builder_.Finish();
}

flatbuffers::Offset<Clip> CreateClip(flatbuffers::FlatBufferBuilder &_fbb, const ClipT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ConstantT : public flatbuffers::NativeTable {
  typedef Constant TableType;
};

struct Constant FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ConstantT NativeTableType;
  typedef ConstantBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return ConstantTypeTable();
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  ConstantT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ConstantT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Constant> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ConstantT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ConstantBuilder {
  typedef Constant Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit ConstantBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Constant> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Constant>(end);
    return o;
  }
};

inline flatbuffers::Offset<Constant> CreateConstant(
    flatbuffers::FlatBufferBuilder &_fbb) {
  ConstantBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<Constant> CreateConstant(flatbuffers::FlatBufferBuilder &_fbb, const ConstantT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct EluT : public flatbuffers::NativeTable {
  typedef Elu TableType;
  float alpha = 1.0f;
};

struct Elu FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef EluT NativeTableType;
  typedef EluBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return EluTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ALPHA = 4
  };
  float alpha() const {
    return GetField<float>(VT_ALPHA, 1.0f);
  }
  bool mutate_alpha(float _alpha) {
    return SetField<float>(VT_ALPHA, _alpha, 1.0f);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<float>(verifier, VT_ALPHA) &&
           verifier.EndTable();
  }
  EluT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(EluT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Elu> Pack(flatbuffers::FlatBufferBuilder &_fbb, const EluT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct EluBuilder {
  typedef Elu Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_alpha(float alpha) {
    fbb_.AddElement<float>(Elu::VT_ALPHA, alpha, 1.0f);
  }
  explicit EluBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Elu> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Elu>(end);
    return o;
  }
};

inline flatbuffers::Offset<Elu> CreateElu(
    flatbuffers::FlatBufferBuilder &_fbb,
    float alpha = 1.0f) {
  EluBuilder builder_(_fbb);
  builder_.add_alpha(alpha);
  return builder_.Finish();
}

flatbuffers::Offset<Elu> CreateElu(flatbuffers::FlatBufferBuilder &_fbb, const EluT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct BroadcastT : public flatbuffers::NativeTable {
  typedef Broadcast TableType;
};

struct Broadcast FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef BroadcastT NativeTableType;
  typedef BroadcastBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return BroadcastTypeTable();
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  BroadcastT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(BroadcastT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Broadcast> Pack(flatbuffers::FlatBufferBuilder &_fbb, const BroadcastT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct BroadcastBuilder {
  typedef Broadcast Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit BroadcastBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Broadcast> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Broadcast>(end);
    return o;
  }
};

inline flatbuffers::Offset<Broadcast> CreateBroadcast(
    flatbuffers::FlatBufferBuilder &_fbb) {
  BroadcastBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<Broadcast> CreateBroadcast(flatbuffers::FlatBufferBuilder &_fbb, const BroadcastT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct BroadcastToT : public flatbuffers::NativeTable {
  typedef BroadcastTo TableType;
  std::vector<int32_t> dst_shape{};
};

struct BroadcastTo FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef BroadcastToT NativeTableType;
  typedef BroadcastToBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return BroadcastToTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_DST_SHAPE = 4
  };
  const flatbuffers::Vector<int32_t> *dst_shape() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_DST_SHAPE);
  }
  flatbuffers::Vector<int32_t> *mutable_dst_shape() {
    return GetPointer<flatbuffers::Vector<int32_t> *>(VT_DST_SHAPE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_DST_SHAPE) &&
           verifier.VerifyVector(dst_shape()) &&
           verifier.EndTable();
  }
  BroadcastToT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(BroadcastToT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<BroadcastTo> Pack(flatbuffers::FlatBufferBuilder &_fbb, const BroadcastToT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct BroadcastToBuilder {
  typedef BroadcastTo Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_dst_shape(flatbuffers::Offset<flatbuffers::Vector<int32_t>> dst_shape) {
    fbb_.AddOffset(BroadcastTo::VT_DST_SHAPE, dst_shape);
  }
  explicit BroadcastToBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<BroadcastTo> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<BroadcastTo>(end);
    return o;
  }
};

inline flatbuffers::Offset<BroadcastTo> CreateBroadcastTo(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> dst_shape = 0) {
  BroadcastToBuilder builder_(_fbb);
  builder_.add_dst_shape(dst_shape);
  return builder_.Finish();
}

inline flatbuffers::Offset<BroadcastTo> CreateBroadcastToDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<int32_t> *dst_shape = nullptr) {
  auto dst_shape__ = dst_shape ? _fbb.CreateVector<int32_t>(*dst_shape) : 0;
  return mindspore::schema::v0::CreateBroadcastTo(
      _fbb,
      dst_shape__);
}

flatbuffers::Offset<BroadcastTo> CreateBroadcastTo(flatbuffers::FlatBufferBuilder &_fbb, const BroadcastToT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct LrnT : public flatbuffers::NativeTable {
  typedef Lrn TableType;
  float alpha = 0.0001f;
  float beta = 0.75f;
  float bias = 1.0f;
  int32_t size = 0;
};

struct Lrn FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef LrnT NativeTableType;
  typedef LrnBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return LrnTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ALPHA = 4,
    VT_BETA = 6,
    VT_BIAS = 8,
    VT_SIZE = 10
  };
  float alpha() const {
    return GetField<float>(VT_ALPHA, 0.0001f);
  }
  bool mutate_alpha(float _alpha) {
    return SetField<float>(VT_ALPHA, _alpha, 0.0001f);
  }
  float beta() const {
    return GetField<float>(VT_BETA, 0.75f);
  }
  bool mutate_beta(float _beta) {
    return SetField<float>(VT_BETA, _beta, 0.75f);
  }
  float bias() const {
    return GetField<float>(VT_BIAS, 1.0f);
  }
  bool mutate_bias(float _bias) {
    return SetField<float>(VT_BIAS, _bias, 1.0f);
  }
  int32_t size() const {
    return GetField<int32_t>(VT_SIZE, 0);
  }
  bool mutate_size(int32_t _size) {
    return SetField<int32_t>(VT_SIZE, _size, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<float>(verifier, VT_ALPHA) &&
           VerifyField<float>(verifier, VT_BETA) &&
           VerifyField<float>(verifier, VT_BIAS) &&
           VerifyField<int32_t>(verifier, VT_SIZE) &&
           verifier.EndTable();
  }
  LrnT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(LrnT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Lrn> Pack(flatbuffers::FlatBufferBuilder &_fbb, const LrnT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct LrnBuilder {
  typedef Lrn Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_alpha(float alpha) {
    fbb_.AddElement<float>(Lrn::VT_ALPHA, alpha, 0.0001f);
  }
  void add_beta(float beta) {
    fbb_.AddElement<float>(Lrn::VT_BETA, beta, 0.75f);
  }
  void add_bias(float bias) {
    fbb_.AddElement<float>(Lrn::VT_BIAS, bias, 1.0f);
  }
  void add_size(int32_t size) {
    fbb_.AddElement<int32_t>(Lrn::VT_SIZE, size, 0);
  }
  explicit LrnBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Lrn> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Lrn>(end);
    return o;
  }
};

inline flatbuffers::Offset<Lrn> CreateLrn(
    flatbuffers::FlatBufferBuilder &_fbb,
    float alpha = 0.0001f,
    float beta = 0.75f,
    float bias = 1.0f,
    int32_t size = 0) {
  LrnBuilder builder_(_fbb);
  builder_.add_size(size);
  builder_.add_bias(bias);
  builder_.add_beta(beta);
  builder_.add_alpha(alpha);
  return builder_.Finish();
}

flatbuffers::Offset<Lrn> CreateLrn(flatbuffers::FlatBufferBuilder &_fbb, const LrnT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ReduceT : public flatbuffers::NativeTable {
  typedef Reduce TableType;
  std::vector<int32_t> axes{};
  int32_t keepDims = 0;
  mindspore::schema::v0::ReduceMode mode = mindspore::schema::v0::ReduceMode_ReduceMean;
  bool reduceToEnd = false;
  float coeff = 1.0f;
};

struct Reduce FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ReduceT NativeTableType;
  typedef ReduceBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return ReduceTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_AXES = 4,
    VT_KEEPDIMS = 6,
    VT_MODE = 8,
    VT_REDUCETOEND = 10,
    VT_COEFF = 12
  };
  const flatbuffers::Vector<int32_t> *axes() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_AXES);
  }
  flatbuffers::Vector<int32_t> *mutable_axes() {
    return GetPointer<flatbuffers::Vector<int32_t> *>(VT_AXES);
  }
  int32_t keepDims() const {
    return GetField<int32_t>(VT_KEEPDIMS, 0);
  }
  bool mutate_keepDims(int32_t _keepDims) {
    return SetField<int32_t>(VT_KEEPDIMS, _keepDims, 0);
  }
  mindspore::schema::v0::ReduceMode mode() const {
    return static_cast<mindspore::schema::v0::ReduceMode>(GetField<int8_t>(VT_MODE, 0));
  }
  bool mutate_mode(mindspore::schema::v0::ReduceMode _mode) {
    return SetField<int8_t>(VT_MODE, static_cast<int8_t>(_mode), 0);
  }
  bool reduceToEnd() const {
    return GetField<uint8_t>(VT_REDUCETOEND, 0) != 0;
  }
  bool mutate_reduceToEnd(bool _reduceToEnd) {
    return SetField<uint8_t>(VT_REDUCETOEND, static_cast<uint8_t>(_reduceToEnd), 0);
  }
  float coeff() const {
    return GetField<float>(VT_COEFF, 1.0f);
  }
  bool mutate_coeff(float _coeff) {
    return SetField<float>(VT_COEFF, _coeff, 1.0f);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_AXES) &&
           verifier.VerifyVector(axes()) &&
           VerifyField<int32_t>(verifier, VT_KEEPDIMS) &&
           VerifyField<int8_t>(verifier, VT_MODE) &&
           VerifyField<uint8_t>(verifier, VT_REDUCETOEND) &&
           VerifyField<float>(verifier, VT_COEFF) &&
           verifier.EndTable();
  }
  ReduceT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ReduceT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Reduce> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ReduceT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ReduceBuilder {
  typedef Reduce Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_axes(flatbuffers::Offset<flatbuffers::Vector<int32_t>> axes) {
    fbb_.AddOffset(Reduce::VT_AXES, axes);
  }
  void add_keepDims(int32_t keepDims) {
    fbb_.AddElement<int32_t>(Reduce::VT_KEEPDIMS, keepDims, 0);
  }
  void add_mode(mindspore::schema::v0::ReduceMode mode) {
    fbb_.AddElement<int8_t>(Reduce::VT_MODE, static_cast<int8_t>(mode), 0);
  }
  void add_reduceToEnd(bool reduceToEnd) {
    fbb_.AddElement<uint8_t>(Reduce::VT_REDUCETOEND, static_cast<uint8_t>(reduceToEnd), 0);
  }
  void add_coeff(float coeff) {
    fbb_.AddElement<float>(Reduce::VT_COEFF, coeff, 1.0f);
  }
  explicit ReduceBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Reduce> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Reduce>(end);
    return o;
  }
};

inline flatbuffers::Offset<Reduce> CreateReduce(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> axes = 0,
    int32_t keepDims = 0,
    mindspore::schema::v0::ReduceMode mode = mindspore::schema::v0::ReduceMode_ReduceMean,
    bool reduceToEnd = false,
    float coeff = 1.0f) {
  ReduceBuilder builder_(_fbb);
  builder_.add_coeff(coeff);
  builder_.add_keepDims(keepDims);
  builder_.add_axes(axes);
  builder_.add_reduceToEnd(reduceToEnd);
  builder_.add_mode(mode);
  return builder_.Finish();
}

inline flatbuffers::Offset<Reduce> CreateReduceDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<int32_t> *axes = nullptr,
    int32_t keepDims = 0,
    mindspore::schema::v0::ReduceMode mode = mindspore::schema::v0::ReduceMode_ReduceMean,
    bool reduceToEnd = false,
    float coeff = 1.0f) {
  auto axes__ = axes ? _fbb.CreateVector<int32_t>(*axes) : 0;
  return mindspore::schema::v0::CreateReduce(
      _fbb,
      axes__,
      keepDims,
      mode,
      reduceToEnd,
      coeff);
}

flatbuffers::Offset<Reduce> CreateReduce(flatbuffers::FlatBufferBuilder &_fbb, const ReduceT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct TransposeT : public flatbuffers::NativeTable {
  typedef Transpose TableType;
  std::vector<int32_t> perm{};
  bool conjugate = false;
};

struct Transpose FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef TransposeT NativeTableType;
  typedef TransposeBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return TransposeTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_PERM = 4,
    VT_CONJUGATE = 6
  };
  const flatbuffers::Vector<int32_t> *perm() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_PERM);
  }
  flatbuffers::Vector<int32_t> *mutable_perm() {
    return GetPointer<flatbuffers::Vector<int32_t> *>(VT_PERM);
  }
  bool conjugate() const {
    return GetField<uint8_t>(VT_CONJUGATE, 0) != 0;
  }
  bool mutate_conjugate(bool _conjugate) {
    return SetField<uint8_t>(VT_CONJUGATE, static_cast<uint8_t>(_conjugate), 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_PERM) &&
           verifier.VerifyVector(perm()) &&
           VerifyField<uint8_t>(verifier, VT_CONJUGATE) &&
           verifier.EndTable();
  }
  TransposeT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(TransposeT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Transpose> Pack(flatbuffers::FlatBufferBuilder &_fbb, const TransposeT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct TransposeBuilder {
  typedef Transpose Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_perm(flatbuffers::Offset<flatbuffers::Vector<int32_t>> perm) {
    fbb_.AddOffset(Transpose::VT_PERM, perm);
  }
  void add_conjugate(bool conjugate) {
    fbb_.AddElement<uint8_t>(Transpose::VT_CONJUGATE, static_cast<uint8_t>(conjugate), 0);
  }
  explicit TransposeBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Transpose> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Transpose>(end);
    return o;
  }
};

inline flatbuffers::Offset<Transpose> CreateTranspose(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> perm = 0,
    bool conjugate = false) {
  TransposeBuilder builder_(_fbb);
  builder_.add_perm(perm);
  builder_.add_conjugate(conjugate);
  return builder_.Finish();
}

inline flatbuffers::Offset<Transpose> CreateTransposeDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<int32_t> *perm = nullptr,
    bool conjugate = false) {
  auto perm__ = perm ? _fbb.CreateVector<int32_t>(*perm) : 0;
  return mindspore::schema::v0::CreateTranspose(
      _fbb,
      perm__,
      conjugate);
}

flatbuffers::Offset<Transpose> CreateTranspose(flatbuffers::FlatBufferBuilder &_fbb, const TransposeT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct SqueezeT : public flatbuffers::NativeTable {
  typedef Squeeze TableType;
  std::vector<int32_t> axis{};
};

struct Squeeze FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef SqueezeT NativeTableType;
  typedef SqueezeBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return SqueezeTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_AXIS = 4
  };
  const flatbuffers::Vector<int32_t> *axis() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_AXIS);
  }
  flatbuffers::Vector<int32_t> *mutable_axis() {
    return GetPointer<flatbuffers::Vector<int32_t> *>(VT_AXIS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_AXIS) &&
           verifier.VerifyVector(axis()) &&
           verifier.EndTable();
  }
  SqueezeT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(SqueezeT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Squeeze> Pack(flatbuffers::FlatBufferBuilder &_fbb, const SqueezeT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct SqueezeBuilder {
  typedef Squeeze Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_axis(flatbuffers::Offset<flatbuffers::Vector<int32_t>> axis) {
    fbb_.AddOffset(Squeeze::VT_AXIS, axis);
  }
  explicit SqueezeBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Squeeze> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Squeeze>(end);
    return o;
  }
};

inline flatbuffers::Offset<Squeeze> CreateSqueeze(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> axis = 0) {
  SqueezeBuilder builder_(_fbb);
  builder_.add_axis(axis);
  return builder_.Finish();
}

inline flatbuffers::Offset<Squeeze> CreateSqueezeDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<int32_t> *axis = nullptr) {
  auto axis__ = axis ? _fbb.CreateVector<int32_t>(*axis) : 0;
  return mindspore::schema::v0::CreateSqueeze(
      _fbb,
      axis__);
}

flatbuffers::Offset<Squeeze> CreateSqueeze(flatbuffers::FlatBufferBuilder &_fbb, const SqueezeT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct UnsqueezeT : public flatbuffers::NativeTable {
  typedef Unsqueeze TableType;
  std::vector<int32_t> axis{};
};

struct Unsqueeze FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef UnsqueezeT NativeTableType;
  typedef UnsqueezeBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return UnsqueezeTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_AXIS = 4
  };
  const flatbuffers::Vector<int32_t> *axis() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_AXIS);
  }
  flatbuffers::Vector<int32_t> *mutable_axis() {
    return GetPointer<flatbuffers::Vector<int32_t> *>(VT_AXIS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_AXIS) &&
           verifier.VerifyVector(axis()) &&
           verifier.EndTable();
  }
  UnsqueezeT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(UnsqueezeT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Unsqueeze> Pack(flatbuffers::FlatBufferBuilder &_fbb, const UnsqueezeT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct UnsqueezeBuilder {
  typedef Unsqueeze Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_axis(flatbuffers::Offset<flatbuffers::Vector<int32_t>> axis) {
    fbb_.AddOffset(Unsqueeze::VT_AXIS, axis);
  }
  explicit UnsqueezeBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Unsqueeze> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Unsqueeze>(end);
    return o;
  }
};

inline flatbuffers::Offset<Unsqueeze> CreateUnsqueeze(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> axis = 0) {
  UnsqueezeBuilder builder_(_fbb);
  builder_.add_axis(axis);
  return builder_.Finish();
}

inline flatbuffers::Offset<Unsqueeze> CreateUnsqueezeDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<int32_t> *axis = nullptr) {
  auto axis__ = axis ? _fbb.CreateVector<int32_t>(*axis) : 0;
  return mindspore::schema::v0::CreateUnsqueeze(
      _fbb,
      axis__);
}

flatbuffers::Offset<Unsqueeze> CreateUnsqueeze(flatbuffers::FlatBufferBuilder &_fbb, const UnsqueezeT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct UpsampleT : public flatbuffers::NativeTable {
  typedef Upsample TableType;
  std::string mode{};
  std::vector<float> scales{};
};

struct Upsample FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef UpsampleT NativeTableType;
  typedef UpsampleBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return UpsampleTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_MODE = 4,
    VT_SCALES = 6
  };
  const flatbuffers::String *mode() const {
    return GetPointer<const flatbuffers::String *>(VT_MODE);
  }
  flatbuffers::String *mutable_mode() {
    return GetPointer<flatbuffers::String *>(VT_MODE);
  }
  const flatbuffers::Vector<float> *scales() const {
    return GetPointer<const flatbuffers::Vector<float> *>(VT_SCALES);
  }
  flatbuffers::Vector<float> *mutable_scales() {
    return GetPointer<flatbuffers::Vector<float> *>(VT_SCALES);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_MODE) &&
           verifier.VerifyString(mode()) &&
           VerifyOffset(verifier, VT_SCALES) &&
           verifier.VerifyVector(scales()) &&
           verifier.EndTable();
  }
  UpsampleT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(UpsampleT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Upsample> Pack(flatbuffers::FlatBufferBuilder &_fbb, const UpsampleT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct UpsampleBuilder {
  typedef Upsample Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_mode(flatbuffers::Offset<flatbuffers::String> mode) {
    fbb_.AddOffset(Upsample::VT_MODE, mode);
  }
  void add_scales(flatbuffers::Offset<flatbuffers::Vector<float>> scales) {
    fbb_.AddOffset(Upsample::VT_SCALES, scales);
  }
  explicit UpsampleBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Upsample> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Upsample>(end);
    return o;
  }
};

inline flatbuffers::Offset<Upsample> CreateUpsample(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> mode = 0,
    flatbuffers::Offset<flatbuffers::Vector<float>> scales = 0) {
  UpsampleBuilder builder_(_fbb);
  builder_.add_scales(scales);
  builder_.add_mode(mode);
  return builder_.Finish();
}

inline flatbuffers::Offset<Upsample> CreateUpsampleDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *mode = nullptr,
    const std::vector<float> *scales = nullptr) {
  auto mode__ = mode ? _fbb.CreateString(mode) : 0;
  auto scales__ = scales ? _fbb.CreateVector<float>(*scales) : 0;
  return mindspore::schema::v0::CreateUpsample(
      _fbb,
      mode__,
      scales__);
}

flatbuffers::Offset<Upsample> CreateUpsample(flatbuffers::FlatBufferBuilder &_fbb, const UpsampleT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct DropoutT : public flatbuffers::NativeTable {
  typedef Dropout TableType;
  float ratio = 0.5f;
};

struct Dropout FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef DropoutT NativeTableType;
  typedef DropoutBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return DropoutTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_RATIO = 4
  };
  float ratio() const {
    return GetField<float>(VT_RATIO, 0.5f);
  }
  bool mutate_ratio(float _ratio) {
    return SetField<float>(VT_RATIO, _ratio, 0.5f);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<float>(verifier, VT_RATIO) &&
           verifier.EndTable();
  }
  DropoutT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(DropoutT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Dropout> Pack(flatbuffers::FlatBufferBuilder &_fbb, const DropoutT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct DropoutBuilder {
  typedef Dropout Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_ratio(float ratio) {
    fbb_.AddElement<float>(Dropout::VT_RATIO, ratio, 0.5f);
  }
  explicit DropoutBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Dropout> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Dropout>(end);
    return o;
  }
};

inline flatbuffers::Offset<Dropout> CreateDropout(
    flatbuffers::FlatBufferBuilder &_fbb,
    float ratio = 0.5f) {
  DropoutBuilder builder_(_fbb);
  builder_.add_ratio(ratio);
  return builder_.Finish();
}

flatbuffers::Offset<Dropout> CreateDropout(flatbuffers::FlatBufferBuilder &_fbb, const DropoutT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct LocalResponseNormalizationT : public flatbuffers::NativeTable {
  typedef LocalResponseNormalization TableType;
  int32_t depth_radius = 0;
  float bias = 0.0f;
  float alpha = 0.0f;
  float beta = 0.0f;
};

struct LocalResponseNormalization FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef LocalResponseNormalizationT NativeTableType;
  typedef LocalResponseNormalizationBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return LocalResponseNormalizationTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_DEPTH_RADIUS = 4,
    VT_BIAS = 6,
    VT_ALPHA = 8,
    VT_BETA = 10
  };
  int32_t depth_radius() const {
    return GetField<int32_t>(VT_DEPTH_RADIUS, 0);
  }
  bool mutate_depth_radius(int32_t _depth_radius) {
    return SetField<int32_t>(VT_DEPTH_RADIUS, _depth_radius, 0);
  }
  float bias() const {
    return GetField<float>(VT_BIAS, 0.0f);
  }
  bool mutate_bias(float _bias) {
    return SetField<float>(VT_BIAS, _bias, 0.0f);
  }
  float alpha() const {
    return GetField<float>(VT_ALPHA, 0.0f);
  }
  bool mutate_alpha(float _alpha) {
    return SetField<float>(VT_ALPHA, _alpha, 0.0f);
  }
  float beta() const {
    return GetField<float>(VT_BETA, 0.0f);
  }
  bool mutate_beta(float _beta) {
    return SetField<float>(VT_BETA, _beta, 0.0f);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_DEPTH_RADIUS) &&
           VerifyField<float>(verifier, VT_BIAS) &&
           VerifyField<float>(verifier, VT_ALPHA) &&
           VerifyField<float>(verifier, VT_BETA) &&
           verifier.EndTable();
  }
  LocalResponseNormalizationT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(LocalResponseNormalizationT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<LocalResponseNormalization> Pack(flatbuffers::FlatBufferBuilder &_fbb, const LocalResponseNormalizationT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct LocalResponseNormalizationBuilder {
  typedef LocalResponseNormalization Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_depth_radius(int32_t depth_radius) {
    fbb_.AddElement<int32_t>(LocalResponseNormalization::VT_DEPTH_RADIUS, depth_radius, 0);
  }
  void add_bias(float bias) {
    fbb_.AddElement<float>(LocalResponseNormalization::VT_BIAS, bias, 0.0f);
  }
  void add_alpha(float alpha) {
    fbb_.AddElement<float>(LocalResponseNormalization::VT_ALPHA, alpha, 0.0f);
  }
  void add_beta(float beta) {
    fbb_.AddElement<float>(LocalResponseNormalization::VT_BETA, beta, 0.0f);
  }
  explicit LocalResponseNormalizationBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<LocalResponseNormalization> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<LocalResponseNormalization>(end);
    return o;
  }
};

inline flatbuffers::Offset<LocalResponseNormalization> CreateLocalResponseNormalization(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t depth_radius = 0,
    float bias = 0.0f,
    float alpha = 0.0f,
    float beta = 0.0f) {
  LocalResponseNormalizationBuilder builder_(_fbb);
  builder_.add_beta(beta);
  builder_.add_alpha(alpha);
  builder_.add_bias(bias);
  builder_.add_depth_radius(depth_radius);
  return builder_.Finish();
}

flatbuffers::Offset<LocalResponseNormalization> CreateLocalResponseNormalization(flatbuffers::FlatBufferBuilder &_fbb, const LocalResponseNormalizationT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ZerosLikeT : public flatbuffers::NativeTable {
  typedef ZerosLike TableType;
};

struct ZerosLike FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ZerosLikeT NativeTableType;
  typedef ZerosLikeBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return ZerosLikeTypeTable();
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  ZerosLikeT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ZerosLikeT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<ZerosLike> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ZerosLikeT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ZerosLikeBuilder {
  typedef ZerosLike Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit ZerosLikeBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<ZerosLike> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ZerosLike>(end);
    return o;
  }
};

inline flatbuffers::Offset<ZerosLike> CreateZerosLike(
    flatbuffers::FlatBufferBuilder &_fbb) {
  ZerosLikeBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<ZerosLike> CreateZerosLike(flatbuffers::FlatBufferBuilder &_fbb, const ZerosLikeT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct TopKT : public flatbuffers::NativeTable {
  typedef TopK TableType;
  int32_t k = 0;
  bool sorted = true;
};

struct TopK FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef TopKT NativeTableType;
  typedef TopKBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return TopKTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_K = 4,
    VT_SORTED = 6
  };
  int32_t k() const {
    return GetField<int32_t>(VT_K, 0);
  }
  bool mutate_k(int32_t _k) {
    return SetField<int32_t>(VT_K, _k, 0);
  }
  bool sorted() const {
    return GetField<uint8_t>(VT_SORTED, 1) != 0;
  }
  bool mutate_sorted(bool _sorted) {
    return SetField<uint8_t>(VT_SORTED, static_cast<uint8_t>(_sorted), 1);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_K) &&
           VerifyField<uint8_t>(verifier, VT_SORTED) &&
           verifier.EndTable();
  }
  TopKT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(TopKT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<TopK> Pack(flatbuffers::FlatBufferBuilder &_fbb, const TopKT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct TopKBuilder {
  typedef TopK Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_k(int32_t k) {
    fbb_.AddElement<int32_t>(TopK::VT_K, k, 0);
  }
  void add_sorted(bool sorted) {
    fbb_.AddElement<uint8_t>(TopK::VT_SORTED, static_cast<uint8_t>(sorted), 1);
  }
  explicit TopKBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<TopK> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<TopK>(end);
    return o;
  }
};

inline flatbuffers::Offset<TopK> CreateTopK(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t k = 0,
    bool sorted = true) {
  TopKBuilder builder_(_fbb);
  builder_.add_k(k);
  builder_.add_sorted(sorted);
  return builder_.Finish();
}

flatbuffers::Offset<TopK> CreateTopK(flatbuffers::FlatBufferBuilder &_fbb, const TopKT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct SpaceToDepthT : public flatbuffers::NativeTable {
  typedef SpaceToDepth TableType;
  int32_t blockSize = 0;
  mindspore::schema::v0::Format format = mindspore::schema::v0::Format_NCHW;
};

struct SpaceToDepth FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef SpaceToDepthT NativeTableType;
  typedef SpaceToDepthBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return SpaceToDepthTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_BLOCKSIZE = 4,
    VT_FORMAT = 6
  };
  int32_t blockSize() const {
    return GetField<int32_t>(VT_BLOCKSIZE, 0);
  }
  bool mutate_blockSize(int32_t _blockSize) {
    return SetField<int32_t>(VT_BLOCKSIZE, _blockSize, 0);
  }
  mindspore::schema::v0::Format format() const {
    return static_cast<mindspore::schema::v0::Format>(GetField<int32_t>(VT_FORMAT, 0));
  }
  bool mutate_format(mindspore::schema::v0::Format _format) {
    return SetField<int32_t>(VT_FORMAT, static_cast<int32_t>(_format), 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_BLOCKSIZE) &&
           VerifyField<int32_t>(verifier, VT_FORMAT) &&
           verifier.EndTable();
  }
  SpaceToDepthT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(SpaceToDepthT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<SpaceToDepth> Pack(flatbuffers::FlatBufferBuilder &_fbb, const SpaceToDepthT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct SpaceToDepthBuilder {
  typedef SpaceToDepth Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_blockSize(int32_t blockSize) {
    fbb_.AddElement<int32_t>(SpaceToDepth::VT_BLOCKSIZE, blockSize, 0);
  }
  void add_format(mindspore::schema::v0::Format format) {
    fbb_.AddElement<int32_t>(SpaceToDepth::VT_FORMAT, static_cast<int32_t>(format), 0);
  }
  explicit SpaceToDepthBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<SpaceToDepth> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SpaceToDepth>(end);
    return o;
  }
};

inline flatbuffers::Offset<SpaceToDepth> CreateSpaceToDepth(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t blockSize = 0,
    mindspore::schema::v0::Format format = mindspore::schema::v0::Format_NCHW) {
  SpaceToDepthBuilder builder_(_fbb);
  builder_.add_format(format);
  builder_.add_blockSize(blockSize);
  return builder_.Finish();
}

flatbuffers::Offset<SpaceToDepth> CreateSpaceToDepth(flatbuffers::FlatBufferBuilder &_fbb, const SpaceToDepthT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct SpaceToBatchT : public flatbuffers::NativeTable {
  typedef SpaceToBatch TableType;
  std::vector<int32_t> blockShape{};
  std::vector<int32_t> paddings{};
};

struct SpaceToBatch FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef SpaceToBatchT NativeTableType;
  typedef SpaceToBatchBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return SpaceToBatchTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_BLOCKSHAPE = 4,
    VT_PADDINGS = 6
  };
  const flatbuffers::Vector<int32_t> *blockShape() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_BLOCKSHAPE);
  }
  flatbuffers::Vector<int32_t> *mutable_blockShape() {
    return GetPointer<flatbuffers::Vector<int32_t> *>(VT_BLOCKSHAPE);
  }
  const flatbuffers::Vector<int32_t> *paddings() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_PADDINGS);
  }
  flatbuffers::Vector<int32_t> *mutable_paddings() {
    return GetPointer<flatbuffers::Vector<int32_t> *>(VT_PADDINGS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_BLOCKSHAPE) &&
           verifier.VerifyVector(blockShape()) &&
           VerifyOffset(verifier, VT_PADDINGS) &&
           verifier.VerifyVector(paddings()) &&
           verifier.EndTable();
  }
  SpaceToBatchT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(SpaceToBatchT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<SpaceToBatch> Pack(flatbuffers::FlatBufferBuilder &_fbb, const SpaceToBatchT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct SpaceToBatchBuilder {
  typedef SpaceToBatch Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_blockShape(flatbuffers::Offset<flatbuffers::Vector<int32_t>> blockShape) {
    fbb_.AddOffset(SpaceToBatch::VT_BLOCKSHAPE, blockShape);
  }
  void add_paddings(flatbuffers::Offset<flatbuffers::Vector<int32_t>> paddings) {
    fbb_.AddOffset(SpaceToBatch::VT_PADDINGS, paddings);
  }
  explicit SpaceToBatchBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<SpaceToBatch> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SpaceToBatch>(end);
    return o;
  }
};

inline flatbuffers::Offset<SpaceToBatch> CreateSpaceToBatch(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> blockShape = 0,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> paddings = 0) {
  SpaceToBatchBuilder builder_(_fbb);
  builder_.add_paddings(paddings);
  builder_.add_blockShape(blockShape);
  return builder_.Finish();
}

inline flatbuffers::Offset<SpaceToBatch> CreateSpaceToBatchDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<int32_t> *blockShape = nullptr,
    const std::vector<int32_t> *paddings = nullptr) {
  auto blockShape__ = blockShape ? _fbb.CreateVector<int32_t>(*blockShape) : 0;
  auto paddings__ = paddings ? _fbb.CreateVector<int32_t>(*paddings) : 0;
  return mindspore::schema::v0::CreateSpaceToBatch(
      _fbb,
      blockShape__,
      paddings__);
}

flatbuffers::Offset<SpaceToBatch> CreateSpaceToBatch(flatbuffers::FlatBufferBuilder &_fbb, const SpaceToBatchT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct SparseToDenseT : public flatbuffers::NativeTable {
  typedef SparseToDense TableType;
  bool validateIndices = false;
};

struct SparseToDense FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef SparseToDenseT NativeTableType;
  typedef SparseToDenseBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return SparseToDenseTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VALIDATEINDICES = 4
  };
  bool validateIndices() const {
    return GetField<uint8_t>(VT_VALIDATEINDICES, 0) != 0;
  }
  bool mutate_validateIndices(bool _validateIndices) {
    return SetField<uint8_t>(VT_VALIDATEINDICES, static_cast<uint8_t>(_validateIndices), 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_VALIDATEINDICES) &&
           verifier.EndTable();
  }
  SparseToDenseT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(SparseToDenseT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<SparseToDense> Pack(flatbuffers::FlatBufferBuilder &_fbb, const SparseToDenseT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct SparseToDenseBuilder {
  typedef SparseToDense Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_validateIndices(bool validateIndices) {
    fbb_.AddElement<uint8_t>(SparseToDense::VT_VALIDATEINDICES, static_cast<uint8_t>(validateIndices), 0);
  }
  explicit SparseToDenseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<SparseToDense> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SparseToDense>(end);
    return o;
  }
};

inline flatbuffers::Offset<SparseToDense> CreateSparseToDense(
    flatbuffers::FlatBufferBuilder &_fbb,
    bool validateIndices = false) {
  SparseToDenseBuilder builder_(_fbb);
  builder_.add_validateIndices(validateIndices);
  return builder_.Finish();
}

flatbuffers::Offset<SparseToDense> CreateSparseToDense(flatbuffers::FlatBufferBuilder &_fbb, const SparseToDenseT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ReverseSequenceT : public flatbuffers::NativeTable {
  typedef ReverseSequence TableType;
  int32_t seqAxis = 0;
  int32_t batchAxis = 0;
};

struct ReverseSequence FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ReverseSequenceT NativeTableType;
  typedef ReverseSequenceBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return ReverseSequenceTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SEQAXIS = 4,
    VT_BATCHAXIS = 6
  };
  int32_t seqAxis() const {
    return GetField<int32_t>(VT_SEQAXIS, 0);
  }
  bool mutate_seqAxis(int32_t _seqAxis) {
    return SetField<int32_t>(VT_SEQAXIS, _seqAxis, 0);
  }
  int32_t batchAxis() const {
    return GetField<int32_t>(VT_BATCHAXIS, 0);
  }
  bool mutate_batchAxis(int32_t _batchAxis) {
    return SetField<int32_t>(VT_BATCHAXIS, _batchAxis, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_SEQAXIS) &&
           VerifyField<int32_t>(verifier, VT_BATCHAXIS) &&
           verifier.EndTable();
  }
  ReverseSequenceT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ReverseSequenceT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<ReverseSequence> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ReverseSequenceT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ReverseSequenceBuilder {
  typedef ReverseSequence Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_seqAxis(int32_t seqAxis) {
    fbb_.AddElement<int32_t>(ReverseSequence::VT_SEQAXIS, seqAxis, 0);
  }
  void add_batchAxis(int32_t batchAxis) {
    fbb_.AddElement<int32_t>(ReverseSequence::VT_BATCHAXIS, batchAxis, 0);
  }
  explicit ReverseSequenceBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<ReverseSequence> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ReverseSequence>(end);
    return o;
  }
};

inline flatbuffers::Offset<ReverseSequence> CreateReverseSequence(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t seqAxis = 0,
    int32_t batchAxis = 0) {
  ReverseSequenceBuilder builder_(_fbb);
  builder_.add_batchAxis(batchAxis);
  builder_.add_seqAxis(seqAxis);
  return builder_.Finish();
}

flatbuffers::Offset<ReverseSequence> CreateReverseSequence(flatbuffers::FlatBufferBuilder &_fbb, const ReverseSequenceT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct RankT : public flatbuffers::NativeTable {
  typedef Rank TableType;
};

struct Rank FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef RankT NativeTableType;
  typedef RankBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return RankTypeTable();
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  RankT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(RankT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Rank> Pack(flatbuffers::FlatBufferBuilder &_fbb, const RankT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct RankBuilder {
  typedef Rank Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit RankBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Rank> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Rank>(end);
    return o;
  }
};

inline flatbuffers::Offset<Rank> CreateRank(
    flatbuffers::FlatBufferBuilder &_fbb) {
  RankBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<Rank> CreateRank(flatbuffers::FlatBufferBuilder &_fbb, const RankT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct GatherT : public flatbuffers::NativeTable {
  typedef Gather TableType;
  int32_t axis = 0;
  int32_t batchDims = 0;
};

struct Gather FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef GatherT NativeTableType;
  typedef GatherBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return GatherTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_AXIS = 4,
    VT_BATCHDIMS = 6
  };
  int32_t axis() const {
    return GetField<int32_t>(VT_AXIS, 0);
  }
  bool mutate_axis(int32_t _axis) {
    return SetField<int32_t>(VT_AXIS, _axis, 0);
  }
  int32_t batchDims() const {
    return GetField<int32_t>(VT_BATCHDIMS, 0);
  }
  bool mutate_batchDims(int32_t _batchDims) {
    return SetField<int32_t>(VT_BATCHDIMS, _batchDims, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_AXIS) &&
           VerifyField<int32_t>(verifier, VT_BATCHDIMS) &&
           verifier.EndTable();
  }
  GatherT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(GatherT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Gather> Pack(flatbuffers::FlatBufferBuilder &_fbb, const GatherT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct GatherBuilder {
  typedef Gather Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_axis(int32_t axis) {
    fbb_.AddElement<int32_t>(Gather::VT_AXIS, axis, 0);
  }
  void add_batchDims(int32_t batchDims) {
    fbb_.AddElement<int32_t>(Gather::VT_BATCHDIMS, batchDims, 0);
  }
  explicit GatherBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Gather> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Gather>(end);
    return o;
  }
};

inline flatbuffers::Offset<Gather> CreateGather(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t axis = 0,
    int32_t batchDims = 0) {
  GatherBuilder builder_(_fbb);
  builder_.add_batchDims(batchDims);
  builder_.add_axis(axis);
  return builder_.Finish();
}

flatbuffers::Offset<Gather> CreateGather(flatbuffers::FlatBufferBuilder &_fbb, const GatherT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct GatherNdT : public flatbuffers::NativeTable {
  typedef GatherNd TableType;
  int32_t batchDims = 0;
};

struct GatherNd FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef GatherNdT NativeTableType;
  typedef GatherNdBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return GatherNdTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_BATCHDIMS = 4
  };
  int32_t batchDims() const {
    return GetField<int32_t>(VT_BATCHDIMS, 0);
  }
  bool mutate_batchDims(int32_t _batchDims) {
    return SetField<int32_t>(VT_BATCHDIMS, _batchDims, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_BATCHDIMS) &&
           verifier.EndTable();
  }
  GatherNdT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(GatherNdT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<GatherNd> Pack(flatbuffers::FlatBufferBuilder &_fbb, const GatherNdT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct GatherNdBuilder {
  typedef GatherNd Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_batchDims(int32_t batchDims) {
    fbb_.AddElement<int32_t>(GatherNd::VT_BATCHDIMS, batchDims, 0);
  }
  explicit GatherNdBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<GatherNd> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<GatherNd>(end);
    return o;
  }
};

inline flatbuffers::Offset<GatherNd> CreateGatherNd(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t batchDims = 0) {
  GatherNdBuilder builder_(_fbb);
  builder_.add_batchDims(batchDims);
  return builder_.Finish();
}

flatbuffers::Offset<GatherNd> CreateGatherNd(flatbuffers::FlatBufferBuilder &_fbb, const GatherNdT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct FillT : public flatbuffers::NativeTable {
  typedef Fill TableType;
  std::vector<int32_t> dims{};
};

struct Fill FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef FillT NativeTableType;
  typedef FillBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return FillTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_DIMS = 4
  };
  const flatbuffers::Vector<int32_t> *dims() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_DIMS);
  }
  flatbuffers::Vector<int32_t> *mutable_dims() {
    return GetPointer<flatbuffers::Vector<int32_t> *>(VT_DIMS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_DIMS) &&
           verifier.VerifyVector(dims()) &&
           verifier.EndTable();
  }
  FillT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(FillT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Fill> Pack(flatbuffers::FlatBufferBuilder &_fbb, const FillT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct FillBuilder {
  typedef Fill Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_dims(flatbuffers::Offset<flatbuffers::Vector<int32_t>> dims) {
    fbb_.AddOffset(Fill::VT_DIMS, dims);
  }
  explicit FillBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Fill> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Fill>(end);
    return o;
  }
};

inline flatbuffers::Offset<Fill> CreateFill(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> dims = 0) {
  FillBuilder builder_(_fbb);
  builder_.add_dims(dims);
  return builder_.Finish();
}

inline flatbuffers::Offset<Fill> CreateFillDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<int32_t> *dims = nullptr) {
  auto dims__ = dims ? _fbb.CreateVector<int32_t>(*dims) : 0;
  return mindspore::schema::v0::CreateFill(
      _fbb,
      dims__);
}

flatbuffers::Offset<Fill> CreateFill(flatbuffers::FlatBufferBuilder &_fbb, const FillT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct DepthToSpaceT : public flatbuffers::NativeTable {
  typedef DepthToSpace TableType;
  int32_t blockSize = 0;
  mindspore::schema::v0::Format format = mindspore::schema::v0::Format_NCHW;
};

struct DepthToSpace FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef DepthToSpaceT NativeTableType;
  typedef DepthToSpaceBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return DepthToSpaceTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_BLOCKSIZE = 4,
    VT_FORMAT = 6
  };
  int32_t blockSize() const {
    return GetField<int32_t>(VT_BLOCKSIZE, 0);
  }
  bool mutate_blockSize(int32_t _blockSize) {
    return SetField<int32_t>(VT_BLOCKSIZE, _blockSize, 0);
  }
  mindspore::schema::v0::Format format() const {
    return static_cast<mindspore::schema::v0::Format>(GetField<int32_t>(VT_FORMAT, 0));
  }
  bool mutate_format(mindspore::schema::v0::Format _format) {
    return SetField<int32_t>(VT_FORMAT, static_cast<int32_t>(_format), 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_BLOCKSIZE) &&
           VerifyField<int32_t>(verifier, VT_FORMAT) &&
           verifier.EndTable();
  }
  DepthToSpaceT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(DepthToSpaceT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<DepthToSpace> Pack(flatbuffers::FlatBufferBuilder &_fbb, const DepthToSpaceT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct DepthToSpaceBuilder {
  typedef DepthToSpace Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_blockSize(int32_t blockSize) {
    fbb_.AddElement<int32_t>(DepthToSpace::VT_BLOCKSIZE, blockSize, 0);
  }
  void add_format(mindspore::schema::v0::Format format) {
    fbb_.AddElement<int32_t>(DepthToSpace::VT_FORMAT, static_cast<int32_t>(format), 0);
  }
  explicit DepthToSpaceBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<DepthToSpace> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<DepthToSpace>(end);
    return o;
  }
};

inline flatbuffers::Offset<DepthToSpace> CreateDepthToSpace(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t blockSize = 0,
    mindspore::schema::v0::Format format = mindspore::schema::v0::Format_NCHW) {
  DepthToSpaceBuilder builder_(_fbb);
  builder_.add_format(format);
  builder_.add_blockSize(blockSize);
  return builder_.Finish();
}

flatbuffers::Offset<DepthToSpace> CreateDepthToSpace(flatbuffers::FlatBufferBuilder &_fbb, const DepthToSpaceT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct BatchToSpaceT : public flatbuffers::NativeTable {
  typedef BatchToSpace TableType;
  std::vector<int32_t> blockShape{};
  std::vector<int32_t> crops{};
};

struct BatchToSpace FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef BatchToSpaceT NativeTableType;
  typedef BatchToSpaceBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return BatchToSpaceTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_BLOCKSHAPE = 4,
    VT_CROPS = 6
  };
  const flatbuffers::Vector<int32_t> *blockShape() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_BLOCKSHAPE);
  }
  flatbuffers::Vector<int32_t> *mutable_blockShape() {
    return GetPointer<flatbuffers::Vector<int32_t> *>(VT_BLOCKSHAPE);
  }
  const flatbuffers::Vector<int32_t> *crops() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_CROPS);
  }
  flatbuffers::Vector<int32_t> *mutable_crops() {
    return GetPointer<flatbuffers::Vector<int32_t> *>(VT_CROPS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_BLOCKSHAPE) &&
           verifier.VerifyVector(blockShape()) &&
           VerifyOffset(verifier, VT_CROPS) &&
           verifier.VerifyVector(crops()) &&
           verifier.EndTable();
  }
  BatchToSpaceT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(BatchToSpaceT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<BatchToSpace> Pack(flatbuffers::FlatBufferBuilder &_fbb, const BatchToSpaceT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct BatchToSpaceBuilder {
  typedef BatchToSpace Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_blockShape(flatbuffers::Offset<flatbuffers::Vector<int32_t>> blockShape) {
    fbb_.AddOffset(BatchToSpace::VT_BLOCKSHAPE, blockShape);
  }
  void add_crops(flatbuffers::Offset<flatbuffers::Vector<int32_t>> crops) {
    fbb_.AddOffset(BatchToSpace::VT_CROPS, crops);
  }
  explicit BatchToSpaceBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<BatchToSpace> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<BatchToSpace>(end);
    return o;
  }
};

inline flatbuffers::Offset<BatchToSpace> CreateBatchToSpace(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> blockShape = 0,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> crops = 0) {
  BatchToSpaceBuilder builder_(_fbb);
  builder_.add_crops(crops);
  builder_.add_blockShape(blockShape);
  return builder_.Finish();
}

inline flatbuffers::Offset<BatchToSpace> CreateBatchToSpaceDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<int32_t> *blockShape = nullptr,
    const std::vector<int32_t> *crops = nullptr) {
  auto blockShape__ = blockShape ? _fbb.CreateVector<int32_t>(*blockShape) : 0;
  auto crops__ = crops ? _fbb.CreateVector<int32_t>(*crops) : 0;
  return mindspore::schema::v0::CreateBatchToSpace(
      _fbb,
      blockShape__,
      crops__);
}

flatbuffers::Offset<BatchToSpace> CreateBatchToSpace(flatbuffers::FlatBufferBuilder &_fbb, const BatchToSpaceT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct BatchToSpaceNDT : public flatbuffers::NativeTable {
  typedef BatchToSpaceND TableType;
  std::vector<int32_t> blockShape{};
  std::vector<int32_t> crops{};
};

struct BatchToSpaceND FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef BatchToSpaceNDT NativeTableType;
  typedef BatchToSpaceNDBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return BatchToSpaceNDTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_BLOCKSHAPE = 4,
    VT_CROPS = 6
  };
  const flatbuffers::Vector<int32_t> *blockShape() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_BLOCKSHAPE);
  }
  flatbuffers::Vector<int32_t> *mutable_blockShape() {
    return GetPointer<flatbuffers::Vector<int32_t> *>(VT_BLOCKSHAPE);
  }
  const flatbuffers::Vector<int32_t> *crops() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_CROPS);
  }
  flatbuffers::Vector<int32_t> *mutable_crops() {
    return GetPointer<flatbuffers::Vector<int32_t> *>(VT_CROPS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_BLOCKSHAPE) &&
           verifier.VerifyVector(blockShape()) &&
           VerifyOffset(verifier, VT_CROPS) &&
           verifier.VerifyVector(crops()) &&
           verifier.EndTable();
  }
  BatchToSpaceNDT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(BatchToSpaceNDT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<BatchToSpaceND> Pack(flatbuffers::FlatBufferBuilder &_fbb, const BatchToSpaceNDT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct BatchToSpaceNDBuilder {
  typedef BatchToSpaceND Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_blockShape(flatbuffers::Offset<flatbuffers::Vector<int32_t>> blockShape) {
    fbb_.AddOffset(BatchToSpaceND::VT_BLOCKSHAPE, blockShape);
  }
  void add_crops(flatbuffers::Offset<flatbuffers::Vector<int32_t>> crops) {
    fbb_.AddOffset(BatchToSpaceND::VT_CROPS, crops);
  }
  explicit BatchToSpaceNDBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<BatchToSpaceND> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<BatchToSpaceND>(end);
    return o;
  }
};

inline flatbuffers::Offset<BatchToSpaceND> CreateBatchToSpaceND(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> blockShape = 0,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> crops = 0) {
  BatchToSpaceNDBuilder builder_(_fbb);
  builder_.add_crops(crops);
  builder_.add_blockShape(blockShape);
  return builder_.Finish();
}

inline flatbuffers::Offset<BatchToSpaceND> CreateBatchToSpaceNDDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<int32_t> *blockShape = nullptr,
    const std::vector<int32_t> *crops = nullptr) {
  auto blockShape__ = blockShape ? _fbb.CreateVector<int32_t>(*blockShape) : 0;
  auto crops__ = crops ? _fbb.CreateVector<int32_t>(*crops) : 0;
  return mindspore::schema::v0::CreateBatchToSpaceND(
      _fbb,
      blockShape__,
      crops__);
}

flatbuffers::Offset<BatchToSpaceND> CreateBatchToSpaceND(flatbuffers::FlatBufferBuilder &_fbb, const BatchToSpaceNDT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct AddNT : public flatbuffers::NativeTable {
  typedef AddN TableType;
  int32_t N = 0;
};

struct AddN FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef AddNT NativeTableType;
  typedef AddNBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return AddNTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_N = 4
  };
  int32_t N() const {
    return GetField<int32_t>(VT_N, 0);
  }
  bool mutate_N(int32_t _N) {
    return SetField<int32_t>(VT_N, _N, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_N) &&
           verifier.EndTable();
  }
  AddNT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(AddNT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<AddN> Pack(flatbuffers::FlatBufferBuilder &_fbb, const AddNT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct AddNBuilder {
  typedef AddN Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_N(int32_t N) {
    fbb_.AddElement<int32_t>(AddN::VT_N, N, 0);
  }
  explicit AddNBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<AddN> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<AddN>(end);
    return o;
  }
};

inline flatbuffers::Offset<AddN> CreateAddN(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t N = 0) {
  AddNBuilder builder_(_fbb);
  builder_.add_N(N);
  return builder_.Finish();
}

flatbuffers::Offset<AddN> CreateAddN(flatbuffers::FlatBufferBuilder &_fbb, const AddNT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct EmbeddingLookupT : public flatbuffers::NativeTable {
  typedef EmbeddingLookup TableType;
  float maxNorm = 0.0f;
};

struct EmbeddingLookup FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef EmbeddingLookupT NativeTableType;
  typedef EmbeddingLookupBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return EmbeddingLookupTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_MAXNORM = 4
  };
  float maxNorm() const {
    return GetField<float>(VT_MAXNORM, 0.0f);
  }
  bool mutate_maxNorm(float _maxNorm) {
    return SetField<float>(VT_MAXNORM, _maxNorm, 0.0f);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<float>(verifier, VT_MAXNORM) &&
           verifier.EndTable();
  }
  EmbeddingLookupT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(EmbeddingLookupT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<EmbeddingLookup> Pack(flatbuffers::FlatBufferBuilder &_fbb, const EmbeddingLookupT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct EmbeddingLookupBuilder {
  typedef EmbeddingLookup Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_maxNorm(float maxNorm) {
    fbb_.AddElement<float>(EmbeddingLookup::VT_MAXNORM, maxNorm, 0.0f);
  }
  explicit EmbeddingLookupBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<EmbeddingLookup> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<EmbeddingLookup>(end);
    return o;
  }
};

inline flatbuffers::Offset<EmbeddingLookup> CreateEmbeddingLookup(
    flatbuffers::FlatBufferBuilder &_fbb,
    float maxNorm = 0.0f) {
  EmbeddingLookupBuilder builder_(_fbb);
  builder_.add_maxNorm(maxNorm);
  return builder_.Finish();
}

flatbuffers::Offset<EmbeddingLookup> CreateEmbeddingLookup(flatbuffers::FlatBufferBuilder &_fbb, const EmbeddingLookupT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct EmbeddingLookupSparseT : public flatbuffers::NativeTable {
  typedef EmbeddingLookupSparse TableType;
  std::vector<int32_t> spIds{};
  std::vector<float> spWeights{};
  float maxNortm = 0.0f;
};

struct EmbeddingLookupSparse FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef EmbeddingLookupSparseT NativeTableType;
  typedef EmbeddingLookupSparseBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return EmbeddingLookupSparseTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SPIDS = 4,
    VT_SPWEIGHTS = 6,
    VT_MAXNORTM = 8
  };
  const flatbuffers::Vector<int32_t> *spIds() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_SPIDS);
  }
  flatbuffers::Vector<int32_t> *mutable_spIds() {
    return GetPointer<flatbuffers::Vector<int32_t> *>(VT_SPIDS);
  }
  const flatbuffers::Vector<float> *spWeights() const {
    return GetPointer<const flatbuffers::Vector<float> *>(VT_SPWEIGHTS);
  }
  flatbuffers::Vector<float> *mutable_spWeights() {
    return GetPointer<flatbuffers::Vector<float> *>(VT_SPWEIGHTS);
  }
  float maxNortm() const {
    return GetField<float>(VT_MAXNORTM, 0.0f);
  }
  bool mutate_maxNortm(float _maxNortm) {
    return SetField<float>(VT_MAXNORTM, _maxNortm, 0.0f);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_SPIDS) &&
           verifier.VerifyVector(spIds()) &&
           VerifyOffset(verifier, VT_SPWEIGHTS) &&
           verifier.VerifyVector(spWeights()) &&
           VerifyField<float>(verifier, VT_MAXNORTM) &&
           verifier.EndTable();
  }
  EmbeddingLookupSparseT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(EmbeddingLookupSparseT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<EmbeddingLookupSparse> Pack(flatbuffers::FlatBufferBuilder &_fbb, const EmbeddingLookupSparseT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct EmbeddingLookupSparseBuilder {
  typedef EmbeddingLookupSparse Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_spIds(flatbuffers::Offset<flatbuffers::Vector<int32_t>> spIds) {
    fbb_.AddOffset(EmbeddingLookupSparse::VT_SPIDS, spIds);
  }
  void add_spWeights(flatbuffers::Offset<flatbuffers::Vector<float>> spWeights) {
    fbb_.AddOffset(EmbeddingLookupSparse::VT_SPWEIGHTS, spWeights);
  }
  void add_maxNortm(float maxNortm) {
    fbb_.AddElement<float>(EmbeddingLookupSparse::VT_MAXNORTM, maxNortm, 0.0f);
  }
  explicit EmbeddingLookupSparseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<EmbeddingLookupSparse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<EmbeddingLookupSparse>(end);
    return o;
  }
};

inline flatbuffers::Offset<EmbeddingLookupSparse> CreateEmbeddingLookupSparse(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> spIds = 0,
    flatbuffers::Offset<flatbuffers::Vector<float>> spWeights = 0,
    float maxNortm = 0.0f) {
  EmbeddingLookupSparseBuilder builder_(_fbb);
  builder_.add_maxNortm(maxNortm);
  builder_.add_spWeights(spWeights);
  builder_.add_spIds(spIds);
  return builder_.Finish();
}

inline flatbuffers::Offset<EmbeddingLookupSparse> CreateEmbeddingLookupSparseDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<int32_t> *spIds = nullptr,
    const std::vector<float> *spWeights = nullptr,
    float maxNortm = 0.0f) {
  auto spIds__ = spIds ? _fbb.CreateVector<int32_t>(*spIds) : 0;
  auto spWeights__ = spWeights ? _fbb.CreateVector<float>(*spWeights) : 0;
  return mindspore::schema::v0::CreateEmbeddingLookupSparse(
      _fbb,
      spIds__,
      spWeights__,
      maxNortm);
}

flatbuffers::Offset<EmbeddingLookupSparse> CreateEmbeddingLookupSparse(flatbuffers::FlatBufferBuilder &_fbb, const EmbeddingLookupSparseT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct FloorDivT : public flatbuffers::NativeTable {
  typedef FloorDiv TableType;
};

struct FloorDiv FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef FloorDivT NativeTableType;
  typedef FloorDivBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return FloorDivTypeTable();
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  FloorDivT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(FloorDivT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<FloorDiv> Pack(flatbuffers::FlatBufferBuilder &_fbb, const FloorDivT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct FloorDivBuilder {
  typedef FloorDiv Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit FloorDivBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<FloorDiv> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<FloorDiv>(end);
    return o;
  }
};

inline flatbuffers::Offset<FloorDiv> CreateFloorDiv(
    flatbuffers::FlatBufferBuilder &_fbb) {
  FloorDivBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<FloorDiv> CreateFloorDiv(flatbuffers::FlatBufferBuilder &_fbb, const FloorDivT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct FloorModT : public flatbuffers::NativeTable {
  typedef FloorMod TableType;
};

struct FloorMod FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef FloorModT NativeTableType;
  typedef FloorModBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return FloorModTypeTable();
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  FloorModT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(FloorModT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<FloorMod> Pack(flatbuffers::FlatBufferBuilder &_fbb, const FloorModT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct FloorModBuilder {
  typedef FloorMod Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit FloorModBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<FloorMod> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<FloorMod>(end);
    return o;
  }
};

inline flatbuffers::Offset<FloorMod> CreateFloorMod(
    flatbuffers::FlatBufferBuilder &_fbb) {
  FloorModBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<FloorMod> CreateFloorMod(flatbuffers::FlatBufferBuilder &_fbb, const FloorModT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ModT : public flatbuffers::NativeTable {
  typedef Mod TableType;
};

struct Mod FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ModT NativeTableType;
  typedef ModBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return ModTypeTable();
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  ModT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ModT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Mod> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ModT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ModBuilder {
  typedef Mod Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit ModBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Mod> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Mod>(end);
    return o;
  }
};

inline flatbuffers::Offset<Mod> CreateMod(
    flatbuffers::FlatBufferBuilder &_fbb) {
  ModBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<Mod> CreateMod(flatbuffers::FlatBufferBuilder &_fbb, const ModT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct L2NormT : public flatbuffers::NativeTable {
  typedef L2Norm TableType;
  std::vector<int32_t> axis{};
  float epsilon = 0.0f;
  mindspore::schema::v0::ActivationType activationType = mindspore::schema::v0::ActivationType_NO_ACTIVATION;
};

struct L2Norm FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef L2NormT NativeTableType;
  typedef L2NormBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return L2NormTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_AXIS = 4,
    VT_EPSILON = 6,
    VT_ACTIVATIONTYPE = 8
  };
  const flatbuffers::Vector<int32_t> *axis() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_AXIS);
  }
  flatbuffers::Vector<int32_t> *mutable_axis() {
    return GetPointer<flatbuffers::Vector<int32_t> *>(VT_AXIS);
  }
  float epsilon() const {
    return GetField<float>(VT_EPSILON, 0.0f);
  }
  bool mutate_epsilon(float _epsilon) {
    return SetField<float>(VT_EPSILON, _epsilon, 0.0f);
  }
  mindspore::schema::v0::ActivationType activationType() const {
    return static_cast<mindspore::schema::v0::ActivationType>(GetField<int8_t>(VT_ACTIVATIONTYPE, 0));
  }
  bool mutate_activationType(mindspore::schema::v0::ActivationType _activationType) {
    return SetField<int8_t>(VT_ACTIVATIONTYPE, static_cast<int8_t>(_activationType), 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_AXIS) &&
           verifier.VerifyVector(axis()) &&
           VerifyField<float>(verifier, VT_EPSILON) &&
           VerifyField<int8_t>(verifier, VT_ACTIVATIONTYPE) &&
           verifier.EndTable();
  }
  L2NormT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(L2NormT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<L2Norm> Pack(flatbuffers::FlatBufferBuilder &_fbb, const L2NormT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct L2NormBuilder {
  typedef L2Norm Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_axis(flatbuffers::Offset<flatbuffers::Vector<int32_t>> axis) {
    fbb_.AddOffset(L2Norm::VT_AXIS, axis);
  }
  void add_epsilon(float epsilon) {
    fbb_.AddElement<float>(L2Norm::VT_EPSILON, epsilon, 0.0f);
  }
  void add_activationType(mindspore::schema::v0::ActivationType activationType) {
    fbb_.AddElement<int8_t>(L2Norm::VT_ACTIVATIONTYPE, static_cast<int8_t>(activationType), 0);
  }
  explicit L2NormBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<L2Norm> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<L2Norm>(end);
    return o;
  }
};

inline flatbuffers::Offset<L2Norm> CreateL2Norm(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> axis = 0,
    float epsilon = 0.0f,
    mindspore::schema::v0::ActivationType activationType = mindspore::schema::v0::ActivationType_NO_ACTIVATION) {
  L2NormBuilder builder_(_fbb);
  builder_.add_epsilon(epsilon);
  builder_.add_axis(axis);
  builder_.add_activationType(activationType);
  return builder_.Finish();
}

inline flatbuffers::Offset<L2Norm> CreateL2NormDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<int32_t> *axis = nullptr,
    float epsilon = 0.0f,
    mindspore::schema::v0::ActivationType activationType = mindspore::schema::v0::ActivationType_NO_ACTIVATION) {
  auto axis__ = axis ? _fbb.CreateVector<int32_t>(*axis) : 0;
  return mindspore::schema::v0::CreateL2Norm(
      _fbb,
      axis__,
      epsilon,
      activationType);
}

flatbuffers::Offset<L2Norm> CreateL2Norm(flatbuffers::FlatBufferBuilder &_fbb, const L2NormT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct LogicalAndT : public flatbuffers::NativeTable {
  typedef LogicalAnd TableType;
};

struct LogicalAnd FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef LogicalAndT NativeTableType;
  typedef LogicalAndBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return LogicalAndTypeTable();
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  LogicalAndT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(LogicalAndT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<LogicalAnd> Pack(flatbuffers::FlatBufferBuilder &_fbb, const LogicalAndT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct LogicalAndBuilder {
  typedef LogicalAnd Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit LogicalAndBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<LogicalAnd> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<LogicalAnd>(end);
    return o;
  }
};

inline flatbuffers::Offset<LogicalAnd> CreateLogicalAnd(
    flatbuffers::FlatBufferBuilder &_fbb) {
  LogicalAndBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<LogicalAnd> CreateLogicalAnd(flatbuffers::FlatBufferBuilder &_fbb, const LogicalAndT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct LogicalOrT : public flatbuffers::NativeTable {
  typedef LogicalOr TableType;
};

struct LogicalOr FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef LogicalOrT NativeTableType;
  typedef LogicalOrBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return LogicalOrTypeTable();
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  LogicalOrT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(LogicalOrT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<LogicalOr> Pack(flatbuffers::FlatBufferBuilder &_fbb, const LogicalOrT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct LogicalOrBuilder {
  typedef LogicalOr Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit LogicalOrBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<LogicalOr> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<LogicalOr>(end);
    return o;
  }
};

inline flatbuffers::Offset<LogicalOr> CreateLogicalOr(
    flatbuffers::FlatBufferBuilder &_fbb) {
  LogicalOrBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<LogicalOr> CreateLogicalOr(flatbuffers::FlatBufferBuilder &_fbb, const LogicalOrT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct LogicalXorT : public flatbuffers::NativeTable {
  typedef LogicalXor TableType;
};

struct LogicalXor FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef LogicalXorT NativeTableType;
  typedef LogicalXorBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return LogicalXorTypeTable();
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  LogicalXorT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(LogicalXorT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<LogicalXor> Pack(flatbuffers::FlatBufferBuilder &_fbb, const LogicalXorT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct LogicalXorBuilder {
  typedef LogicalXor Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit LogicalXorBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<LogicalXor> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<LogicalXor>(end);
    return o;
  }
};

inline flatbuffers::Offset<LogicalXor> CreateLogicalXor(
    flatbuffers::FlatBufferBuilder &_fbb) {
  LogicalXorBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<LogicalXor> CreateLogicalXor(flatbuffers::FlatBufferBuilder &_fbb, const LogicalXorT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct LogicalNotT : public flatbuffers::NativeTable {
  typedef LogicalNot TableType;
};

struct LogicalNot FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef LogicalNotT NativeTableType;
  typedef LogicalNotBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return LogicalNotTypeTable();
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  LogicalNotT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(LogicalNotT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<LogicalNot> Pack(flatbuffers::FlatBufferBuilder &_fbb, const LogicalNotT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct LogicalNotBuilder {
  typedef LogicalNot Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit LogicalNotBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<LogicalNot> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<LogicalNot>(end);
    return o;
  }
};

inline flatbuffers::Offset<LogicalNot> CreateLogicalNot(
    flatbuffers::FlatBufferBuilder &_fbb) {
  LogicalNotBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<LogicalNot> CreateLogicalNot(flatbuffers::FlatBufferBuilder &_fbb, const LogicalNotT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct MatrixDiagT : public flatbuffers::NativeTable {
  typedef MatrixDiag TableType;
  int32_t k = 0;
  int32_t numRows = 0;
  int32_t numCols = 0;
  float paddingValue = 0.0f;
};

struct MatrixDiag FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef MatrixDiagT NativeTableType;
  typedef MatrixDiagBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return MatrixDiagTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_K = 4,
    VT_NUMROWS = 6,
    VT_NUMCOLS = 8,
    VT_PADDINGVALUE = 10
  };
  int32_t k() const {
    return GetField<int32_t>(VT_K, 0);
  }
  bool mutate_k(int32_t _k) {
    return SetField<int32_t>(VT_K, _k, 0);
  }
  int32_t numRows() const {
    return GetField<int32_t>(VT_NUMROWS, 0);
  }
  bool mutate_numRows(int32_t _numRows) {
    return SetField<int32_t>(VT_NUMROWS, _numRows, 0);
  }
  int32_t numCols() const {
    return GetField<int32_t>(VT_NUMCOLS, 0);
  }
  bool mutate_numCols(int32_t _numCols) {
    return SetField<int32_t>(VT_NUMCOLS, _numCols, 0);
  }
  float paddingValue() const {
    return GetField<float>(VT_PADDINGVALUE, 0.0f);
  }
  bool mutate_paddingValue(float _paddingValue) {
    return SetField<float>(VT_PADDINGVALUE, _paddingValue, 0.0f);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_K) &&
           VerifyField<int32_t>(verifier, VT_NUMROWS) &&
           VerifyField<int32_t>(verifier, VT_NUMCOLS) &&
           VerifyField<float>(verifier, VT_PADDINGVALUE) &&
           verifier.EndTable();
  }
  MatrixDiagT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(MatrixDiagT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<MatrixDiag> Pack(flatbuffers::FlatBufferBuilder &_fbb, const MatrixDiagT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct MatrixDiagBuilder {
  typedef MatrixDiag Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_k(int32_t k) {
    fbb_.AddElement<int32_t>(MatrixDiag::VT_K, k, 0);
  }
  void add_numRows(int32_t numRows) {
    fbb_.AddElement<int32_t>(MatrixDiag::VT_NUMROWS, numRows, 0);
  }
  void add_numCols(int32_t numCols) {
    fbb_.AddElement<int32_t>(MatrixDiag::VT_NUMCOLS, numCols, 0);
  }
  void add_paddingValue(float paddingValue) {
    fbb_.AddElement<float>(MatrixDiag::VT_PADDINGVALUE, paddingValue, 0.0f);
  }
  explicit MatrixDiagBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<MatrixDiag> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<MatrixDiag>(end);
    return o;
  }
};

inline flatbuffers::Offset<MatrixDiag> CreateMatrixDiag(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t k = 0,
    int32_t numRows = 0,
    int32_t numCols = 0,
    float paddingValue = 0.0f) {
  MatrixDiagBuilder builder_(_fbb);
  builder_.add_paddingValue(paddingValue);
  builder_.add_numCols(numCols);
  builder_.add_numRows(numRows);
  builder_.add_k(k);
  return builder_.Finish();
}

flatbuffers::Offset<MatrixDiag> CreateMatrixDiag(flatbuffers::FlatBufferBuilder &_fbb, const MatrixDiagT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct SelectT : public flatbuffers::NativeTable {
  typedef Select TableType;
};

struct Select FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef SelectT NativeTableType;
  typedef SelectBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return SelectTypeTable();
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  SelectT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(SelectT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Select> Pack(flatbuffers::FlatBufferBuilder &_fbb, const SelectT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct SelectBuilder {
  typedef Select Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit SelectBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Select> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Select>(end);
    return o;
  }
};

inline flatbuffers::Offset<Select> CreateSelect(
    flatbuffers::FlatBufferBuilder &_fbb) {
  SelectBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<Select> CreateSelect(flatbuffers::FlatBufferBuilder &_fbb, const SelectT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct TfReduceT : public flatbuffers::NativeTable {
  typedef TfReduce TableType;
  mindspore::schema::v0::ReduceType type = mindspore::schema::v0::ReduceType_UNKNOWN;
};

struct TfReduce FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef TfReduceT NativeTableType;
  typedef TfReduceBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return TfReduceTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TYPE = 4
  };
  mindspore::schema::v0::ReduceType type() const {
    return static_cast<mindspore::schema::v0::ReduceType>(GetField<int8_t>(VT_TYPE, 7));
  }
  bool mutate_type(mindspore::schema::v0::ReduceType _type) {
    return SetField<int8_t>(VT_TYPE, static_cast<int8_t>(_type), 7);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_TYPE) &&
           verifier.EndTable();
  }
  TfReduceT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(TfReduceT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<TfReduce> Pack(flatbuffers::FlatBufferBuilder &_fbb, const TfReduceT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct TfReduceBuilder {
  typedef TfReduce Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_type(mindspore::schema::v0::ReduceType type) {
    fbb_.AddElement<int8_t>(TfReduce::VT_TYPE, static_cast<int8_t>(type), 7);
  }
  explicit TfReduceBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<TfReduce> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<TfReduce>(end);
    return o;
  }
};

inline flatbuffers::Offset<TfReduce> CreateTfReduce(
    flatbuffers::FlatBufferBuilder &_fbb,
    mindspore::schema::v0::ReduceType type = mindspore::schema::v0::ReduceType_UNKNOWN) {
  TfReduceBuilder builder_(_fbb);
  builder_.add_type(type);
  return builder_.Finish();
}

flatbuffers::Offset<TfReduce> CreateTfReduce(flatbuffers::FlatBufferBuilder &_fbb, const TfReduceT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ReverseT : public flatbuffers::NativeTable {
  typedef Reverse TableType;
  std::vector<int32_t> axis{};
};

struct Reverse FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ReverseT NativeTableType;
  typedef ReverseBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return ReverseTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_AXIS = 4
  };
  const flatbuffers::Vector<int32_t> *axis() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_AXIS);
  }
  flatbuffers::Vector<int32_t> *mutable_axis() {
    return GetPointer<flatbuffers::Vector<int32_t> *>(VT_AXIS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_AXIS) &&
           verifier.VerifyVector(axis()) &&
           verifier.EndTable();
  }
  ReverseT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ReverseT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Reverse> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ReverseT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ReverseBuilder {
  typedef Reverse Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_axis(flatbuffers::Offset<flatbuffers::Vector<int32_t>> axis) {
    fbb_.AddOffset(Reverse::VT_AXIS, axis);
  }
  explicit ReverseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Reverse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Reverse>(end);
    return o;
  }
};

inline flatbuffers::Offset<Reverse> CreateReverse(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> axis = 0) {
  ReverseBuilder builder_(_fbb);
  builder_.add_axis(axis);
  return builder_.Finish();
}

inline flatbuffers::Offset<Reverse> CreateReverseDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<int32_t> *axis = nullptr) {
  auto axis__ = axis ? _fbb.CreateVector<int32_t>(*axis) : 0;
  return mindspore::schema::v0::CreateReverse(
      _fbb,
      axis__);
}

flatbuffers::Offset<Reverse> CreateReverse(flatbuffers::FlatBufferBuilder &_fbb, const ReverseT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct RoundT : public flatbuffers::NativeTable {
  typedef Round TableType;
};

struct Round FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef RoundT NativeTableType;
  typedef RoundBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return RoundTypeTable();
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  RoundT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(RoundT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Round> Pack(flatbuffers::FlatBufferBuilder &_fbb, const RoundT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct RoundBuilder {
  typedef Round Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit RoundBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Round> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Round>(end);
    return o;
  }
};

inline flatbuffers::Offset<Round> CreateRound(
    flatbuffers::FlatBufferBuilder &_fbb) {
  RoundBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<Round> CreateRound(flatbuffers::FlatBufferBuilder &_fbb, const RoundT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ScatterT : public flatbuffers::NativeTable {
  typedef Scatter TableType;
};

struct Scatter FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ScatterT NativeTableType;
  typedef ScatterBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return ScatterTypeTable();
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  ScatterT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ScatterT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Scatter> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ScatterT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ScatterBuilder {
  typedef Scatter Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit ScatterBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Scatter> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Scatter>(end);
    return o;
  }
};

inline flatbuffers::Offset<Scatter> CreateScatter(
    flatbuffers::FlatBufferBuilder &_fbb) {
  ScatterBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<Scatter> CreateScatter(flatbuffers::FlatBufferBuilder &_fbb, const ScatterT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ScatterNDT : public flatbuffers::NativeTable {
  typedef ScatterND TableType;
};

struct ScatterND FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ScatterNDT NativeTableType;
  typedef ScatterNDBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return ScatterNDTypeTable();
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  ScatterNDT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ScatterNDT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<ScatterND> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ScatterNDT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ScatterNDBuilder {
  typedef ScatterND Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit ScatterNDBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<ScatterND> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ScatterND>(end);
    return o;
  }
};

inline flatbuffers::Offset<ScatterND> CreateScatterND(
    flatbuffers::FlatBufferBuilder &_fbb) {
  ScatterNDBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<ScatterND> CreateScatterND(flatbuffers::FlatBufferBuilder &_fbb, const ScatterNDT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct UniqueT : public flatbuffers::NativeTable {
  typedef Unique TableType;
  int32_t outType = 0;
};

struct Unique FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef UniqueT NativeTableType;
  typedef UniqueBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return UniqueTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_OUTTYPE = 4
  };
  int32_t outType() const {
    return GetField<int32_t>(VT_OUTTYPE, 0);
  }
  bool mutate_outType(int32_t _outType) {
    return SetField<int32_t>(VT_OUTTYPE, _outType, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_OUTTYPE) &&
           verifier.EndTable();
  }
  UniqueT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(UniqueT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Unique> Pack(flatbuffers::FlatBufferBuilder &_fbb, const UniqueT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct UniqueBuilder {
  typedef Unique Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_outType(int32_t outType) {
    fbb_.AddElement<int32_t>(Unique::VT_OUTTYPE, outType, 0);
  }
  explicit UniqueBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Unique> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Unique>(end);
    return o;
  }
};

inline flatbuffers::Offset<Unique> CreateUnique(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t outType = 0) {
  UniqueBuilder builder_(_fbb);
  builder_.add_outType(outType);
  return builder_.Finish();
}

flatbuffers::Offset<Unique> CreateUnique(flatbuffers::FlatBufferBuilder &_fbb, const UniqueT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct UnstackT : public flatbuffers::NativeTable {
  typedef Unstack TableType;
  int32_t num = 0;
  int32_t axis = 0;
};

struct Unstack FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef UnstackT NativeTableType;
  typedef UnstackBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return UnstackTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NUM = 4,
    VT_AXIS = 6
  };
  int32_t num() const {
    return GetField<int32_t>(VT_NUM, 0);
  }
  bool mutate_num(int32_t _num) {
    return SetField<int32_t>(VT_NUM, _num, 0);
  }
  int32_t axis() const {
    return GetField<int32_t>(VT_AXIS, 0);
  }
  bool mutate_axis(int32_t _axis) {
    return SetField<int32_t>(VT_AXIS, _axis, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_NUM) &&
           VerifyField<int32_t>(verifier, VT_AXIS) &&
           verifier.EndTable();
  }
  UnstackT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(UnstackT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Unstack> Pack(flatbuffers::FlatBufferBuilder &_fbb, const UnstackT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct UnstackBuilder {
  typedef Unstack Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_num(int32_t num) {
    fbb_.AddElement<int32_t>(Unstack::VT_NUM, num, 0);
  }
  void add_axis(int32_t axis) {
    fbb_.AddElement<int32_t>(Unstack::VT_AXIS, axis, 0);
  }
  explicit UnstackBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Unstack> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Unstack>(end);
    return o;
  }
};

inline flatbuffers::Offset<Unstack> CreateUnstack(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t num = 0,
    int32_t axis = 0) {
  UnstackBuilder builder_(_fbb);
  builder_.add_axis(axis);
  builder_.add_num(num);
  return builder_.Finish();
}

flatbuffers::Offset<Unstack> CreateUnstack(flatbuffers::FlatBufferBuilder &_fbb, const UnstackT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct OnnxInt8QuantizeT : public flatbuffers::NativeTable {
  typedef OnnxInt8Quantize TableType;
};

struct OnnxInt8Quantize FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef OnnxInt8QuantizeT NativeTableType;
  typedef OnnxInt8QuantizeBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return OnnxInt8QuantizeTypeTable();
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  OnnxInt8QuantizeT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(OnnxInt8QuantizeT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<OnnxInt8Quantize> Pack(flatbuffers::FlatBufferBuilder &_fbb, const OnnxInt8QuantizeT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct OnnxInt8QuantizeBuilder {
  typedef OnnxInt8Quantize Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit OnnxInt8QuantizeBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<OnnxInt8Quantize> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<OnnxInt8Quantize>(end);
    return o;
  }
};

inline flatbuffers::Offset<OnnxInt8Quantize> CreateOnnxInt8Quantize(
    flatbuffers::FlatBufferBuilder &_fbb) {
  OnnxInt8QuantizeBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<OnnxInt8Quantize> CreateOnnxInt8Quantize(flatbuffers::FlatBufferBuilder &_fbb, const OnnxInt8QuantizeT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct OnnxInt8DequantizeT : public flatbuffers::NativeTable {
  typedef OnnxInt8Dequantize TableType;
};

struct OnnxInt8Dequantize FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef OnnxInt8DequantizeT NativeTableType;
  typedef OnnxInt8DequantizeBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return OnnxInt8DequantizeTypeTable();
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  OnnxInt8DequantizeT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(OnnxInt8DequantizeT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<OnnxInt8Dequantize> Pack(flatbuffers::FlatBufferBuilder &_fbb, const OnnxInt8DequantizeT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct OnnxInt8DequantizeBuilder {
  typedef OnnxInt8Dequantize Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit OnnxInt8DequantizeBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<OnnxInt8Dequantize> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<OnnxInt8Dequantize>(end);
    return o;
  }
};

inline flatbuffers::Offset<OnnxInt8Dequantize> CreateOnnxInt8Dequantize(
    flatbuffers::FlatBufferBuilder &_fbb) {
  OnnxInt8DequantizeBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<OnnxInt8Dequantize> CreateOnnxInt8Dequantize(flatbuffers::FlatBufferBuilder &_fbb, const OnnxInt8DequantizeT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct FakeQuantWithMinMaxT : public flatbuffers::NativeTable {
  typedef FakeQuantWithMinMax TableType;
};

struct FakeQuantWithMinMax FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef FakeQuantWithMinMaxT NativeTableType;
  typedef FakeQuantWithMinMaxBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return FakeQuantWithMinMaxTypeTable();
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  FakeQuantWithMinMaxT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(FakeQuantWithMinMaxT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<FakeQuantWithMinMax> Pack(flatbuffers::FlatBufferBuilder &_fbb, const FakeQuantWithMinMaxT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct FakeQuantWithMinMaxBuilder {
  typedef FakeQuantWithMinMax Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit FakeQuantWithMinMaxBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<FakeQuantWithMinMax> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<FakeQuantWithMinMax>(end);
    return o;
  }
};

inline flatbuffers::Offset<FakeQuantWithMinMax> CreateFakeQuantWithMinMax(
    flatbuffers::FlatBufferBuilder &_fbb) {
  FakeQuantWithMinMaxBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<FakeQuantWithMinMax> CreateFakeQuantWithMinMax(flatbuffers::FlatBufferBuilder &_fbb, const FakeQuantWithMinMaxT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct FakeQuantWithMinMaxPerChannelT : public flatbuffers::NativeTable {
  typedef FakeQuantWithMinMaxPerChannel TableType;
};

struct FakeQuantWithMinMaxPerChannel FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef FakeQuantWithMinMaxPerChannelT NativeTableType;
  typedef FakeQuantWithMinMaxPerChannelBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return FakeQuantWithMinMaxPerChannelTypeTable();
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  FakeQuantWithMinMaxPerChannelT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(FakeQuantWithMinMaxPerChannelT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<FakeQuantWithMinMaxPerChannel> Pack(flatbuffers::FlatBufferBuilder &_fbb, const FakeQuantWithMinMaxPerChannelT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct FakeQuantWithMinMaxPerChannelBuilder {
  typedef FakeQuantWithMinMaxPerChannel Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit FakeQuantWithMinMaxPerChannelBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<FakeQuantWithMinMaxPerChannel> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<FakeQuantWithMinMaxPerChannel>(end);
    return o;
  }
};

inline flatbuffers::Offset<FakeQuantWithMinMaxPerChannel> CreateFakeQuantWithMinMaxPerChannel(
    flatbuffers::FlatBufferBuilder &_fbb) {
  FakeQuantWithMinMaxPerChannelBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<FakeQuantWithMinMaxPerChannel> CreateFakeQuantWithMinMaxPerChannel(flatbuffers::FlatBufferBuilder &_fbb, const FakeQuantWithMinMaxPerChannelT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct BatchNormFoldT : public flatbuffers::NativeTable {
  typedef BatchNormFold TableType;
};

struct BatchNormFold FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef BatchNormFoldT NativeTableType;
  typedef BatchNormFoldBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return BatchNormFoldTypeTable();
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  BatchNormFoldT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(BatchNormFoldT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<BatchNormFold> Pack(flatbuffers::FlatBufferBuilder &_fbb, const BatchNormFoldT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct BatchNormFoldBuilder {
  typedef BatchNormFold Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit BatchNormFoldBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<BatchNormFold> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<BatchNormFold>(end);
    return o;
  }
};

inline flatbuffers::Offset<BatchNormFold> CreateBatchNormFold(
    flatbuffers::FlatBufferBuilder &_fbb) {
  BatchNormFoldBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<BatchNormFold> CreateBatchNormFold(flatbuffers::FlatBufferBuilder &_fbb, const BatchNormFoldT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct MulFoldT : public flatbuffers::NativeTable {
  typedef MulFold TableType;
};

struct MulFold FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef MulFoldT NativeTableType;
  typedef MulFoldBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return MulFoldTypeTable();
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  MulFoldT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(MulFoldT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<MulFold> Pack(flatbuffers::FlatBufferBuilder &_fbb, const MulFoldT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct MulFoldBuilder {
  typedef MulFold Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit MulFoldBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<MulFold> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<MulFold>(end);
    return o;
  }
};

inline flatbuffers::Offset<MulFold> CreateMulFold(
    flatbuffers::FlatBufferBuilder &_fbb) {
  MulFoldBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<MulFold> CreateMulFold(flatbuffers::FlatBufferBuilder &_fbb, const MulFoldT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct AddFoldT : public flatbuffers::NativeTable {
  typedef AddFold TableType;
};

struct AddFold FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef AddFoldT NativeTableType;
  typedef AddFoldBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return AddFoldTypeTable();
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  AddFoldT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(AddFoldT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<AddFold> Pack(flatbuffers::FlatBufferBuilder &_fbb, const AddFoldT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct AddFoldBuilder {
  typedef AddFold Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit AddFoldBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<AddFold> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<AddFold>(end);
    return o;
  }
};

inline flatbuffers::Offset<AddFold> CreateAddFold(
    flatbuffers::FlatBufferBuilder &_fbb) {
  AddFoldBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<AddFold> CreateAddFold(flatbuffers::FlatBufferBuilder &_fbb, const AddFoldT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct SquaredDifferenceT : public flatbuffers::NativeTable {
  typedef SquaredDifference TableType;
};

struct SquaredDifference FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef SquaredDifferenceT NativeTableType;
  typedef SquaredDifferenceBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return SquaredDifferenceTypeTable();
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  SquaredDifferenceT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(SquaredDifferenceT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<SquaredDifference> Pack(flatbuffers::FlatBufferBuilder &_fbb, const SquaredDifferenceT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct SquaredDifferenceBuilder {
  typedef SquaredDifference Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit SquaredDifferenceBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<SquaredDifference> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SquaredDifference>(end);
    return o;
  }
};

inline flatbuffers::Offset<SquaredDifference> CreateSquaredDifference(
    flatbuffers::FlatBufferBuilder &_fbb) {
  SquaredDifferenceBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<SquaredDifference> CreateSquaredDifference(flatbuffers::FlatBufferBuilder &_fbb, const SquaredDifferenceT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct TupleGetItemT : public flatbuffers::NativeTable {
  typedef TupleGetItem TableType;
};

struct TupleGetItem FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef TupleGetItemT NativeTableType;
  typedef TupleGetItemBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return TupleGetItemTypeTable();
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  TupleGetItemT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(TupleGetItemT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<TupleGetItem> Pack(flatbuffers::FlatBufferBuilder &_fbb, const TupleGetItemT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct TupleGetItemBuilder {
  typedef TupleGetItem Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit TupleGetItemBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<TupleGetItem> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<TupleGetItem>(end);
    return o;
  }
};

inline flatbuffers::Offset<TupleGetItem> CreateTupleGetItem(
    flatbuffers::FlatBufferBuilder &_fbb) {
  TupleGetItemBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<TupleGetItem> CreateTupleGetItem(flatbuffers::FlatBufferBuilder &_fbb, const TupleGetItemT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ApplyMomentumT : public flatbuffers::NativeTable {
  typedef ApplyMomentum TableType;
  float gradientScale = 0.0f;
  bool useNesterov = false;
};

struct ApplyMomentum FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ApplyMomentumT NativeTableType;
  typedef ApplyMomentumBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return ApplyMomentumTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_GRADIENTSCALE = 4,
    VT_USENESTEROV = 6
  };
  float gradientScale() const {
    return GetField<float>(VT_GRADIENTSCALE, 0.0f);
  }
  bool mutate_gradientScale(float _gradientScale) {
    return SetField<float>(VT_GRADIENTSCALE, _gradientScale, 0.0f);
  }
  bool useNesterov() const {
    return GetField<uint8_t>(VT_USENESTEROV, 0) != 0;
  }
  bool mutate_useNesterov(bool _useNesterov) {
    return SetField<uint8_t>(VT_USENESTEROV, static_cast<uint8_t>(_useNesterov), 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<float>(verifier, VT_GRADIENTSCALE) &&
           VerifyField<uint8_t>(verifier, VT_USENESTEROV) &&
           verifier.EndTable();
  }
  ApplyMomentumT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ApplyMomentumT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<ApplyMomentum> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ApplyMomentumT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ApplyMomentumBuilder {
  typedef ApplyMomentum Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_gradientScale(float gradientScale) {
    fbb_.AddElement<float>(ApplyMomentum::VT_GRADIENTSCALE, gradientScale, 0.0f);
  }
  void add_useNesterov(bool useNesterov) {
    fbb_.AddElement<uint8_t>(ApplyMomentum::VT_USENESTEROV, static_cast<uint8_t>(useNesterov), 0);
  }
  explicit ApplyMomentumBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<ApplyMomentum> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ApplyMomentum>(end);
    return o;
  }
};

inline flatbuffers::Offset<ApplyMomentum> CreateApplyMomentum(
    flatbuffers::FlatBufferBuilder &_fbb,
    float gradientScale = 0.0f,
    bool useNesterov = false) {
  ApplyMomentumBuilder builder_(_fbb);
  builder_.add_gradientScale(gradientScale);
  builder_.add_useNesterov(useNesterov);
  return builder_.Finish();
}

flatbuffers::Offset<ApplyMomentum> CreateApplyMomentum(flatbuffers::FlatBufferBuilder &_fbb, const ApplyMomentumT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct SgdT : public flatbuffers::NativeTable {
  typedef Sgd TableType;
  float weightDecay = 0.0f;
  float dampening = 0.0f;
  bool useNesterov = false;
};

struct Sgd FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef SgdT NativeTableType;
  typedef SgdBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return SgdTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_WEIGHTDECAY = 4,
    VT_DAMPENING = 6,
    VT_USENESTEROV = 8
  };
  float weightDecay() const {
    return GetField<float>(VT_WEIGHTDECAY, 0.0f);
  }
  bool mutate_weightDecay(float _weightDecay) {
    return SetField<float>(VT_WEIGHTDECAY, _weightDecay, 0.0f);
  }
  float dampening() const {
    return GetField<float>(VT_DAMPENING, 0.0f);
  }
  bool mutate_dampening(float _dampening) {
    return SetField<float>(VT_DAMPENING, _dampening, 0.0f);
  }
  bool useNesterov() const {
    return GetField<uint8_t>(VT_USENESTEROV, 0) != 0;
  }
  bool mutate_useNesterov(bool _useNesterov) {
    return SetField<uint8_t>(VT_USENESTEROV, static_cast<uint8_t>(_useNesterov), 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<float>(verifier, VT_WEIGHTDECAY) &&
           VerifyField<float>(verifier, VT_DAMPENING) &&
           VerifyField<uint8_t>(verifier, VT_USENESTEROV) &&
           verifier.EndTable();
  }
  SgdT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(SgdT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Sgd> Pack(flatbuffers::FlatBufferBuilder &_fbb, const SgdT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct SgdBuilder {
  typedef Sgd Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_weightDecay(float weightDecay) {
    fbb_.AddElement<float>(Sgd::VT_WEIGHTDECAY, weightDecay, 0.0f);
  }
  void add_dampening(float dampening) {
    fbb_.AddElement<float>(Sgd::VT_DAMPENING, dampening, 0.0f);
  }
  void add_useNesterov(bool useNesterov) {
    fbb_.AddElement<uint8_t>(Sgd::VT_USENESTEROV, static_cast<uint8_t>(useNesterov), 0);
  }
  explicit SgdBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Sgd> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Sgd>(end);
    return o;
  }
};

inline flatbuffers::Offset<Sgd> CreateSgd(
    flatbuffers::FlatBufferBuilder &_fbb,
    float weightDecay = 0.0f,
    float dampening = 0.0f,
    bool useNesterov = false) {
  SgdBuilder builder_(_fbb);
  builder_.add_dampening(dampening);
  builder_.add_weightDecay(weightDecay);
  builder_.add_useNesterov(useNesterov);
  return builder_.Finish();
}

flatbuffers::Offset<Sgd> CreateSgd(flatbuffers::FlatBufferBuilder &_fbb, const SgdT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct AdamT : public flatbuffers::NativeTable {
  typedef Adam TableType;
  bool useNesterov = false;
};

struct Adam FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef AdamT NativeTableType;
  typedef AdamBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return AdamTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_USENESTEROV = 4
  };
  bool useNesterov() const {
    return GetField<uint8_t>(VT_USENESTEROV, 0) != 0;
  }
  bool mutate_useNesterov(bool _useNesterov) {
    return SetField<uint8_t>(VT_USENESTEROV, static_cast<uint8_t>(_useNesterov), 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_USENESTEROV) &&
           verifier.EndTable();
  }
  AdamT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(AdamT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Adam> Pack(flatbuffers::FlatBufferBuilder &_fbb, const AdamT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct AdamBuilder {
  typedef Adam Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_useNesterov(bool useNesterov) {
    fbb_.AddElement<uint8_t>(Adam::VT_USENESTEROV, static_cast<uint8_t>(useNesterov), 0);
  }
  explicit AdamBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Adam> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Adam>(end);
    return o;
  }
};

inline flatbuffers::Offset<Adam> CreateAdam(
    flatbuffers::FlatBufferBuilder &_fbb,
    bool useNesterov = false) {
  AdamBuilder builder_(_fbb);
  builder_.add_useNesterov(useNesterov);
  return builder_.Finish();
}

flatbuffers::Offset<Adam> CreateAdam(flatbuffers::FlatBufferBuilder &_fbb, const AdamT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct AssignT : public flatbuffers::NativeTable {
  typedef Assign TableType;
};

struct Assign FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef AssignT NativeTableType;
  typedef AssignBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return AssignTypeTable();
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  AssignT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(AssignT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Assign> Pack(flatbuffers::FlatBufferBuilder &_fbb, const AssignT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct AssignBuilder {
  typedef Assign Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit AssignBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Assign> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Assign>(end);
    return o;
  }
};

inline flatbuffers::Offset<Assign> CreateAssign(
    flatbuffers::FlatBufferBuilder &_fbb) {
  AssignBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<Assign> CreateAssign(flatbuffers::FlatBufferBuilder &_fbb, const AssignT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct AssignAddT : public flatbuffers::NativeTable {
  typedef AssignAdd TableType;
};

struct AssignAdd FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef AssignAddT NativeTableType;
  typedef AssignAddBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return AssignAddTypeTable();
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  AssignAddT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(AssignAddT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<AssignAdd> Pack(flatbuffers::FlatBufferBuilder &_fbb, const AssignAddT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct AssignAddBuilder {
  typedef AssignAdd Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit AssignAddBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<AssignAdd> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<AssignAdd>(end);
    return o;
  }
};

inline flatbuffers::Offset<AssignAdd> CreateAssignAdd(
    flatbuffers::FlatBufferBuilder &_fbb) {
  AssignAddBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<AssignAdd> CreateAssignAdd(flatbuffers::FlatBufferBuilder &_fbb, const AssignAddT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct WhereT : public flatbuffers::NativeTable {
  typedef Where TableType;
  std::vector<bool> condition{};
};

struct Where FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef WhereT NativeTableType;
  typedef WhereBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return WhereTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_CONDITION = 4
  };
  const flatbuffers::Vector<uint8_t> *condition() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_CONDITION);
  }
  flatbuffers::Vector<uint8_t> *mutable_condition() {
    return GetPointer<flatbuffers::Vector<uint8_t> *>(VT_CONDITION);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_CONDITION) &&
           verifier.VerifyVector(condition()) &&
           verifier.EndTable();
  }
  WhereT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(WhereT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Where> Pack(flatbuffers::FlatBufferBuilder &_fbb, const WhereT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct WhereBuilder {
  typedef Where Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_condition(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> condition) {
    fbb_.AddOffset(Where::VT_CONDITION, condition);
  }
  explicit WhereBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Where> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Where>(end);
    return o;
  }
};

inline flatbuffers::Offset<Where> CreateWhere(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> condition = 0) {
  WhereBuilder builder_(_fbb);
  builder_.add_condition(condition);
  return builder_.Finish();
}

inline flatbuffers::Offset<Where> CreateWhereDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<uint8_t> *condition = nullptr) {
  auto condition__ = condition ? _fbb.CreateVector<uint8_t>(*condition) : 0;
  return mindspore::schema::v0::CreateWhere(
      _fbb,
      condition__);
}

flatbuffers::Offset<Where> CreateWhere(flatbuffers::FlatBufferBuilder &_fbb, const WhereT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct OneHotT : public flatbuffers::NativeTable {
  typedef OneHot TableType;
  int32_t axis = 0;
};

struct OneHot FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef OneHotT NativeTableType;
  typedef OneHotBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return OneHotTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_AXIS = 4
  };
  int32_t axis() const {
    return GetField<int32_t>(VT_AXIS, 0);
  }
  bool mutate_axis(int32_t _axis) {
    return SetField<int32_t>(VT_AXIS, _axis, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_AXIS) &&
           verifier.EndTable();
  }
  OneHotT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(OneHotT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<OneHot> Pack(flatbuffers::FlatBufferBuilder &_fbb, const OneHotT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct OneHotBuilder {
  typedef OneHot Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_axis(int32_t axis) {
    fbb_.AddElement<int32_t>(OneHot::VT_AXIS, axis, 0);
  }
  explicit OneHotBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<OneHot> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<OneHot>(end);
    return o;
  }
};

inline flatbuffers::Offset<OneHot> CreateOneHot(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t axis = 0) {
  OneHotBuilder builder_(_fbb);
  builder_.add_axis(axis);
  return builder_.Finish();
}

flatbuffers::Offset<OneHot> CreateOneHot(flatbuffers::FlatBufferBuilder &_fbb, const OneHotT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct LstmT : public flatbuffers::NativeTable {
  typedef Lstm TableType;
  bool bidirection = false;
};

struct Lstm FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef LstmT NativeTableType;
  typedef LstmBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return LstmTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_BIDIRECTION = 4
  };
  bool bidirection() const {
    return GetField<uint8_t>(VT_BIDIRECTION, 0) != 0;
  }
  bool mutate_bidirection(bool _bidirection) {
    return SetField<uint8_t>(VT_BIDIRECTION, static_cast<uint8_t>(_bidirection), 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_BIDIRECTION) &&
           verifier.EndTable();
  }
  LstmT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(LstmT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Lstm> Pack(flatbuffers::FlatBufferBuilder &_fbb, const LstmT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct LstmBuilder {
  typedef Lstm Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_bidirection(bool bidirection) {
    fbb_.AddElement<uint8_t>(Lstm::VT_BIDIRECTION, static_cast<uint8_t>(bidirection), 0);
  }
  explicit LstmBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Lstm> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Lstm>(end);
    return o;
  }
};

inline flatbuffers::Offset<Lstm> CreateLstm(
    flatbuffers::FlatBufferBuilder &_fbb,
    bool bidirection = false) {
  LstmBuilder builder_(_fbb);
  builder_.add_bidirection(bidirection);
  return builder_.Finish();
}

flatbuffers::Offset<Lstm> CreateLstm(flatbuffers::FlatBufferBuilder &_fbb, const LstmT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct PriorBoxT : public flatbuffers::NativeTable {
  typedef PriorBox TableType;
  std::vector<int32_t> min_sizes{};
  std::vector<int32_t> max_sizes{};
  std::vector<float> aspect_ratios{};
  std::vector<float> variances{};
  int32_t image_size_w = 0;
  int32_t image_size_h = 0;
  float step_w = 0.0f;
  float step_h = 0.0f;
  bool clip = true;
  bool flip = true;
  float offset = 0.0f;
};

struct PriorBox FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef PriorBoxT NativeTableType;
  typedef PriorBoxBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return PriorBoxTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_MIN_SIZES = 4,
    VT_MAX_SIZES = 6,
    VT_ASPECT_RATIOS = 8,
    VT_VARIANCES = 10,
    VT_IMAGE_SIZE_W = 12,
    VT_IMAGE_SIZE_H = 14,
    VT_STEP_W = 16,
    VT_STEP_H = 18,
    VT_CLIP = 20,
    VT_FLIP = 22,
    VT_OFFSET = 24
  };
  const flatbuffers::Vector<int32_t> *min_sizes() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_MIN_SIZES);
  }
  flatbuffers::Vector<int32_t> *mutable_min_sizes() {
    return GetPointer<flatbuffers::Vector<int32_t> *>(VT_MIN_SIZES);
  }
  const flatbuffers::Vector<int32_t> *max_sizes() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_MAX_SIZES);
  }
  flatbuffers::Vector<int32_t> *mutable_max_sizes() {
    return GetPointer<flatbuffers::Vector<int32_t> *>(VT_MAX_SIZES);
  }
  const flatbuffers::Vector<float> *aspect_ratios() const {
    return GetPointer<const flatbuffers::Vector<float> *>(VT_ASPECT_RATIOS);
  }
  flatbuffers::Vector<float> *mutable_aspect_ratios() {
    return GetPointer<flatbuffers::Vector<float> *>(VT_ASPECT_RATIOS);
  }
  const flatbuffers::Vector<float> *variances() const {
    return GetPointer<const flatbuffers::Vector<float> *>(VT_VARIANCES);
  }
  flatbuffers::Vector<float> *mutable_variances() {
    return GetPointer<flatbuffers::Vector<float> *>(VT_VARIANCES);
  }
  int32_t image_size_w() const {
    return GetField<int32_t>(VT_IMAGE_SIZE_W, 0);
  }
  bool mutate_image_size_w(int32_t _image_size_w) {
    return SetField<int32_t>(VT_IMAGE_SIZE_W, _image_size_w, 0);
  }
  int32_t image_size_h() const {
    return GetField<int32_t>(VT_IMAGE_SIZE_H, 0);
  }
  bool mutate_image_size_h(int32_t _image_size_h) {
    return SetField<int32_t>(VT_IMAGE_SIZE_H, _image_size_h, 0);
  }
  float step_w() const {
    return GetField<float>(VT_STEP_W, 0.0f);
  }
  bool mutate_step_w(float _step_w) {
    return SetField<float>(VT_STEP_W, _step_w, 0.0f);
  }
  float step_h() const {
    return GetField<float>(VT_STEP_H, 0.0f);
  }
  bool mutate_step_h(float _step_h) {
    return SetField<float>(VT_STEP_H, _step_h, 0.0f);
  }
  bool clip() const {
    return GetField<uint8_t>(VT_CLIP, 1) != 0;
  }
  bool mutate_clip(bool _clip) {
    return SetField<uint8_t>(VT_CLIP, static_cast<uint8_t>(_clip), 1);
  }
  bool flip() const {
    return GetField<uint8_t>(VT_FLIP, 1) != 0;
  }
  bool mutate_flip(bool _flip) {
    return SetField<uint8_t>(VT_FLIP, static_cast<uint8_t>(_flip), 1);
  }
  float offset() const {
    return GetField<float>(VT_OFFSET, 0.0f);
  }
  bool mutate_offset(float _offset) {
    return SetField<float>(VT_OFFSET, _offset, 0.0f);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_MIN_SIZES) &&
           verifier.VerifyVector(min_sizes()) &&
           VerifyOffset(verifier, VT_MAX_SIZES) &&
           verifier.VerifyVector(max_sizes()) &&
           VerifyOffset(verifier, VT_ASPECT_RATIOS) &&
           verifier.VerifyVector(aspect_ratios()) &&
           VerifyOffset(verifier, VT_VARIANCES) &&
           verifier.VerifyVector(variances()) &&
           VerifyField<int32_t>(verifier, VT_IMAGE_SIZE_W) &&
           VerifyField<int32_t>(verifier, VT_IMAGE_SIZE_H) &&
           VerifyField<float>(verifier, VT_STEP_W) &&
           VerifyField<float>(verifier, VT_STEP_H) &&
           VerifyField<uint8_t>(verifier, VT_CLIP) &&
           VerifyField<uint8_t>(verifier, VT_FLIP) &&
           VerifyField<float>(verifier, VT_OFFSET) &&
           verifier.EndTable();
  }
  PriorBoxT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(PriorBoxT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<PriorBox> Pack(flatbuffers::FlatBufferBuilder &_fbb, const PriorBoxT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct PriorBoxBuilder {
  typedef PriorBox Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_min_sizes(flatbuffers::Offset<flatbuffers::Vector<int32_t>> min_sizes) {
    fbb_.AddOffset(PriorBox::VT_MIN_SIZES, min_sizes);
  }
  void add_max_sizes(flatbuffers::Offset<flatbuffers::Vector<int32_t>> max_sizes) {
    fbb_.AddOffset(PriorBox::VT_MAX_SIZES, max_sizes);
  }
  void add_aspect_ratios(flatbuffers::Offset<flatbuffers::Vector<float>> aspect_ratios) {
    fbb_.AddOffset(PriorBox::VT_ASPECT_RATIOS, aspect_ratios);
  }
  void add_variances(flatbuffers::Offset<flatbuffers::Vector<float>> variances) {
    fbb_.AddOffset(PriorBox::VT_VARIANCES, variances);
  }
  void add_image_size_w(int32_t image_size_w) {
    fbb_.AddElement<int32_t>(PriorBox::VT_IMAGE_SIZE_W, image_size_w, 0);
  }
  void add_image_size_h(int32_t image_size_h) {
    fbb_.AddElement<int32_t>(PriorBox::VT_IMAGE_SIZE_H, image_size_h, 0);
  }
  void add_step_w(float step_w) {
    fbb_.AddElement<float>(PriorBox::VT_STEP_W, step_w, 0.0f);
  }
  void add_step_h(float step_h) {
    fbb_.AddElement<float>(PriorBox::VT_STEP_H, step_h, 0.0f);
  }
  void add_clip(bool clip) {
    fbb_.AddElement<uint8_t>(PriorBox::VT_CLIP, static_cast<uint8_t>(clip), 1);
  }
  void add_flip(bool flip) {
    fbb_.AddElement<uint8_t>(PriorBox::VT_FLIP, static_cast<uint8_t>(flip), 1);
  }
  void add_offset(float offset) {
    fbb_.AddElement<float>(PriorBox::VT_OFFSET, offset, 0.0f);
  }
  explicit PriorBoxBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<PriorBox> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<PriorBox>(end);
    return o;
  }
};

inline flatbuffers::Offset<PriorBox> CreatePriorBox(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> min_sizes = 0,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> max_sizes = 0,
    flatbuffers::Offset<flatbuffers::Vector<float>> aspect_ratios = 0,
    flatbuffers::Offset<flatbuffers::Vector<float>> variances = 0,
    int32_t image_size_w = 0,
    int32_t image_size_h = 0,
    float step_w = 0.0f,
    float step_h = 0.0f,
    bool clip = true,
    bool flip = true,
    float offset = 0.0f) {
  PriorBoxBuilder builder_(_fbb);
  builder_.add_offset(offset);
  builder_.add_step_h(step_h);
  builder_.add_step_w(step_w);
  builder_.add_image_size_h(image_size_h);
  builder_.add_image_size_w(image_size_w);
  builder_.add_variances(variances);
  builder_.add_aspect_ratios(aspect_ratios);
  builder_.add_max_sizes(max_sizes);
  builder_.add_min_sizes(min_sizes);
  builder_.add_flip(flip);
  builder_.add_clip(clip);
  return builder_.Finish();
}

inline flatbuffers::Offset<PriorBox> CreatePriorBoxDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<int32_t> *min_sizes = nullptr,
    const std::vector<int32_t> *max_sizes = nullptr,
    const std::vector<float> *aspect_ratios = nullptr,
    const std::vector<float> *variances = nullptr,
    int32_t image_size_w = 0,
    int32_t image_size_h = 0,
    float step_w = 0.0f,
    float step_h = 0.0f,
    bool clip = true,
    bool flip = true,
    float offset = 0.0f) {
  auto min_sizes__ = min_sizes ? _fbb.CreateVector<int32_t>(*min_sizes) : 0;
  auto max_sizes__ = max_sizes ? _fbb.CreateVector<int32_t>(*max_sizes) : 0;
  auto aspect_ratios__ = aspect_ratios ? _fbb.CreateVector<float>(*aspect_ratios) : 0;
  auto variances__ = variances ? _fbb.CreateVector<float>(*variances) : 0;
  return mindspore::schema::v0::CreatePriorBox(
      _fbb,
      min_sizes__,
      max_sizes__,
      aspect_ratios__,
      variances__,
      image_size_w,
      image_size_h,
      step_w,
      step_h,
      clip,
      flip,
      offset);
}

flatbuffers::Offset<PriorBox> CreatePriorBox(flatbuffers::FlatBufferBuilder &_fbb, const PriorBoxT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct SpaceToBatchNDT : public flatbuffers::NativeTable {
  typedef SpaceToBatchND TableType;
  std::vector<int32_t> blockShape{};
  std::vector<int32_t> paddings{};
};

struct SpaceToBatchND FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef SpaceToBatchNDT NativeTableType;
  typedef SpaceToBatchNDBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return SpaceToBatchNDTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_BLOCKSHAPE = 4,
    VT_PADDINGS = 6
  };
  const flatbuffers::Vector<int32_t> *blockShape() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_BLOCKSHAPE);
  }
  flatbuffers::Vector<int32_t> *mutable_blockShape() {
    return GetPointer<flatbuffers::Vector<int32_t> *>(VT_BLOCKSHAPE);
  }
  const flatbuffers::Vector<int32_t> *paddings() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_PADDINGS);
  }
  flatbuffers::Vector<int32_t> *mutable_paddings() {
    return GetPointer<flatbuffers::Vector<int32_t> *>(VT_PADDINGS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_BLOCKSHAPE) &&
           verifier.VerifyVector(blockShape()) &&
           VerifyOffset(verifier, VT_PADDINGS) &&
           verifier.VerifyVector(paddings()) &&
           verifier.EndTable();
  }
  SpaceToBatchNDT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(SpaceToBatchNDT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<SpaceToBatchND> Pack(flatbuffers::FlatBufferBuilder &_fbb, const SpaceToBatchNDT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct SpaceToBatchNDBuilder {
  typedef SpaceToBatchND Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_blockShape(flatbuffers::Offset<flatbuffers::Vector<int32_t>> blockShape) {
    fbb_.AddOffset(SpaceToBatchND::VT_BLOCKSHAPE, blockShape);
  }
  void add_paddings(flatbuffers::Offset<flatbuffers::Vector<int32_t>> paddings) {
    fbb_.AddOffset(SpaceToBatchND::VT_PADDINGS, paddings);
  }
  explicit SpaceToBatchNDBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<SpaceToBatchND> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SpaceToBatchND>(end);
    return o;
  }
};

inline flatbuffers::Offset<SpaceToBatchND> CreateSpaceToBatchND(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> blockShape = 0,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> paddings = 0) {
  SpaceToBatchNDBuilder builder_(_fbb);
  builder_.add_paddings(paddings);
  builder_.add_blockShape(blockShape);
  return builder_.Finish();
}

inline flatbuffers::Offset<SpaceToBatchND> CreateSpaceToBatchNDDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<int32_t> *blockShape = nullptr,
    const std::vector<int32_t> *paddings = nullptr) {
  auto blockShape__ = blockShape ? _fbb.CreateVector<int32_t>(*blockShape) : 0;
  auto paddings__ = paddings ? _fbb.CreateVector<int32_t>(*paddings) : 0;
  return mindspore::schema::v0::CreateSpaceToBatchND(
      _fbb,
      blockShape__,
      paddings__);
}

flatbuffers::Offset<SpaceToBatchND> CreateSpaceToBatchND(flatbuffers::FlatBufferBuilder &_fbb, const SpaceToBatchNDT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct MakeTupleT : public flatbuffers::NativeTable {
  typedef MakeTuple TableType;
};

struct MakeTuple FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef MakeTupleT NativeTableType;
  typedef MakeTupleBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return MakeTupleTypeTable();
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  MakeTupleT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(MakeTupleT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<MakeTuple> Pack(flatbuffers::FlatBufferBuilder &_fbb, const MakeTupleT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct MakeTupleBuilder {
  typedef MakeTuple Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit MakeTupleBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<MakeTuple> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<MakeTuple>(end);
    return o;
  }
};

inline flatbuffers::Offset<MakeTuple> CreateMakeTuple(
    flatbuffers::FlatBufferBuilder &_fbb) {
  MakeTupleBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<MakeTuple> CreateMakeTuple(flatbuffers::FlatBufferBuilder &_fbb, const MakeTupleT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ToFormatT : public flatbuffers::NativeTable {
  typedef ToFormat TableType;
  int32_t srcT = 0;
  int32_t dstT = 0;
};

struct ToFormat FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ToFormatT NativeTableType;
  typedef ToFormatBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return ToFormatTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SRCT = 4,
    VT_DSTT = 6
  };
  int32_t srcT() const {
    return GetField<int32_t>(VT_SRCT, 0);
  }
  bool mutate_srcT(int32_t _srcT) {
    return SetField<int32_t>(VT_SRCT, _srcT, 0);
  }
  int32_t dstT() const {
    return GetField<int32_t>(VT_DSTT, 0);
  }
  bool mutate_dstT(int32_t _dstT) {
    return SetField<int32_t>(VT_DSTT, _dstT, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_SRCT) &&
           VerifyField<int32_t>(verifier, VT_DSTT) &&
           verifier.EndTable();
  }
  ToFormatT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ToFormatT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<ToFormat> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ToFormatT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ToFormatBuilder {
  typedef ToFormat Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_srcT(int32_t srcT) {
    fbb_.AddElement<int32_t>(ToFormat::VT_SRCT, srcT, 0);
  }
  void add_dstT(int32_t dstT) {
    fbb_.AddElement<int32_t>(ToFormat::VT_DSTT, dstT, 0);
  }
  explicit ToFormatBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<ToFormat> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ToFormat>(end);
    return o;
  }
};

inline flatbuffers::Offset<ToFormat> CreateToFormat(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t srcT = 0,
    int32_t dstT = 0) {
  ToFormatBuilder builder_(_fbb);
  builder_.add_dstT(dstT);
  builder_.add_srcT(srcT);
  return builder_.Finish();
}

flatbuffers::Offset<ToFormat> CreateToFormat(flatbuffers::FlatBufferBuilder &_fbb, const ToFormatT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct DependT : public flatbuffers::NativeTable {
  typedef Depend TableType;
};

struct Depend FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef DependT NativeTableType;
  typedef DependBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return DependTypeTable();
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  DependT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(DependT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Depend> Pack(flatbuffers::FlatBufferBuilder &_fbb, const DependT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct DependBuilder {
  typedef Depend Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit DependBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Depend> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Depend>(end);
    return o;
  }
};

inline flatbuffers::Offset<Depend> CreateDepend(
    flatbuffers::FlatBufferBuilder &_fbb) {
  DependBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<Depend> CreateDepend(flatbuffers::FlatBufferBuilder &_fbb, const DependT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ControlDependT : public flatbuffers::NativeTable {
  typedef ControlDepend TableType;
};

struct ControlDepend FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ControlDependT NativeTableType;
  typedef ControlDependBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return ControlDependTypeTable();
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  ControlDependT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ControlDependT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<ControlDepend> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ControlDependT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ControlDependBuilder {
  typedef ControlDepend Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit ControlDependBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<ControlDepend> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ControlDepend>(end);
    return o;
  }
};

inline flatbuffers::Offset<ControlDepend> CreateControlDepend(
    flatbuffers::FlatBufferBuilder &_fbb) {
  ControlDependBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<ControlDepend> CreateControlDepend(flatbuffers::FlatBufferBuilder &_fbb, const ControlDependT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ReturnT : public flatbuffers::NativeTable {
  typedef Return TableType;
};

struct Return FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ReturnT NativeTableType;
  typedef ReturnBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return ReturnTypeTable();
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  ReturnT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ReturnT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Return> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ReturnT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ReturnBuilder {
  typedef Return Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit ReturnBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Return> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Return>(end);
    return o;
  }
};

inline flatbuffers::Offset<Return> CreateReturn(
    flatbuffers::FlatBufferBuilder &_fbb) {
  ReturnBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<Return> CreateReturn(flatbuffers::FlatBufferBuilder &_fbb, const ReturnT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ProposalT : public flatbuffers::NativeTable {
  typedef Proposal TableType;
  float feat_stride = 0.0f;
  float base_size = 0.0f;
  float min_size = 0.0f;
  std::vector<float> ratio{};
  std::vector<float> scale{};
  int32_t pre_nms_topn = 0;
  int32_t post_nms_topn = 0;
  float nms_thresh = 0.0f;
};

struct Proposal FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ProposalT NativeTableType;
  typedef ProposalBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return ProposalTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_FEAT_STRIDE = 4,
    VT_BASE_SIZE = 6,
    VT_MIN_SIZE = 8,
    VT_RATIO = 10,
    VT_SCALE = 12,
    VT_PRE_NMS_TOPN = 14,
    VT_POST_NMS_TOPN = 16,
    VT_NMS_THRESH = 18
  };
  float feat_stride() const {
    return GetField<float>(VT_FEAT_STRIDE, 0.0f);
  }
  bool mutate_feat_stride(float _feat_stride) {
    return SetField<float>(VT_FEAT_STRIDE, _feat_stride, 0.0f);
  }
  float base_size() const {
    return GetField<float>(VT_BASE_SIZE, 0.0f);
  }
  bool mutate_base_size(float _base_size) {
    return SetField<float>(VT_BASE_SIZE, _base_size, 0.0f);
  }
  float min_size() const {
    return GetField<float>(VT_MIN_SIZE, 0.0f);
  }
  bool mutate_min_size(float _min_size) {
    return SetField<float>(VT_MIN_SIZE, _min_size, 0.0f);
  }
  const flatbuffers::Vector<float> *ratio() const {
    return GetPointer<const flatbuffers::Vector<float> *>(VT_RATIO);
  }
  flatbuffers::Vector<float> *mutable_ratio() {
    return GetPointer<flatbuffers::Vector<float> *>(VT_RATIO);
  }
  const flatbuffers::Vector<float> *scale() const {
    return GetPointer<const flatbuffers::Vector<float> *>(VT_SCALE);
  }
  flatbuffers::Vector<float> *mutable_scale() {
    return GetPointer<flatbuffers::Vector<float> *>(VT_SCALE);
  }
  int32_t pre_nms_topn() const {
    return GetField<int32_t>(VT_PRE_NMS_TOPN, 0);
  }
  bool mutate_pre_nms_topn(int32_t _pre_nms_topn) {
    return SetField<int32_t>(VT_PRE_NMS_TOPN, _pre_nms_topn, 0);
  }
  int32_t post_nms_topn() const {
    return GetField<int32_t>(VT_POST_NMS_TOPN, 0);
  }
  bool mutate_post_nms_topn(int32_t _post_nms_topn) {
    return SetField<int32_t>(VT_POST_NMS_TOPN, _post_nms_topn, 0);
  }
  float nms_thresh() const {
    return GetField<float>(VT_NMS_THRESH, 0.0f);
  }
  bool mutate_nms_thresh(float _nms_thresh) {
    return SetField<float>(VT_NMS_THRESH, _nms_thresh, 0.0f);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<float>(verifier, VT_FEAT_STRIDE) &&
           VerifyField<float>(verifier, VT_BASE_SIZE) &&
           VerifyField<float>(verifier, VT_MIN_SIZE) &&
           VerifyOffset(verifier, VT_RATIO) &&
           verifier.VerifyVector(ratio()) &&
           VerifyOffset(verifier, VT_SCALE) &&
           verifier.VerifyVector(scale()) &&
           VerifyField<int32_t>(verifier, VT_PRE_NMS_TOPN) &&
           VerifyField<int32_t>(verifier, VT_POST_NMS_TOPN) &&
           VerifyField<float>(verifier, VT_NMS_THRESH) &&
           verifier.EndTable();
  }
  ProposalT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ProposalT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Proposal> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ProposalT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ProposalBuilder {
  typedef Proposal Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_feat_stride(float feat_stride) {
    fbb_.AddElement<float>(Proposal::VT_FEAT_STRIDE, feat_stride, 0.0f);
  }
  void add_base_size(float base_size) {
    fbb_.AddElement<float>(Proposal::VT_BASE_SIZE, base_size, 0.0f);
  }
  void add_min_size(float min_size) {
    fbb_.AddElement<float>(Proposal::VT_MIN_SIZE, min_size, 0.0f);
  }
  void add_ratio(flatbuffers::Offset<flatbuffers::Vector<float>> ratio) {
    fbb_.AddOffset(Proposal::VT_RATIO, ratio);
  }
  void add_scale(flatbuffers::Offset<flatbuffers::Vector<float>> scale) {
    fbb_.AddOffset(Proposal::VT_SCALE, scale);
  }
  void add_pre_nms_topn(int32_t pre_nms_topn) {
    fbb_.AddElement<int32_t>(Proposal::VT_PRE_NMS_TOPN, pre_nms_topn, 0);
  }
  void add_post_nms_topn(int32_t post_nms_topn) {
    fbb_.AddElement<int32_t>(Proposal::VT_POST_NMS_TOPN, post_nms_topn, 0);
  }
  void add_nms_thresh(float nms_thresh) {
    fbb_.AddElement<float>(Proposal::VT_NMS_THRESH, nms_thresh, 0.0f);
  }
  explicit ProposalBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Proposal> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Proposal>(end);
    return o;
  }
};

inline flatbuffers::Offset<Proposal> CreateProposal(
    flatbuffers::FlatBufferBuilder &_fbb,
    float feat_stride = 0.0f,
    float base_size = 0.0f,
    float min_size = 0.0f,
    flatbuffers::Offset<flatbuffers::Vector<float>> ratio = 0,
    flatbuffers::Offset<flatbuffers::Vector<float>> scale = 0,
    int32_t pre_nms_topn = 0,
    int32_t post_nms_topn = 0,
    float nms_thresh = 0.0f) {
  ProposalBuilder builder_(_fbb);
  builder_.add_nms_thresh(nms_thresh);
  builder_.add_post_nms_topn(post_nms_topn);
  builder_.add_pre_nms_topn(pre_nms_topn);
  builder_.add_scale(scale);
  builder_.add_ratio(ratio);
  builder_.add_min_size(min_size);
  builder_.add_base_size(base_size);
  builder_.add_feat_stride(feat_stride);
  return builder_.Finish();
}

inline flatbuffers::Offset<Proposal> CreateProposalDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    float feat_stride = 0.0f,
    float base_size = 0.0f,
    float min_size = 0.0f,
    const std::vector<float> *ratio = nullptr,
    const std::vector<float> *scale = nullptr,
    int32_t pre_nms_topn = 0,
    int32_t post_nms_topn = 0,
    float nms_thresh = 0.0f) {
  auto ratio__ = ratio ? _fbb.CreateVector<float>(*ratio) : 0;
  auto scale__ = scale ? _fbb.CreateVector<float>(*scale) : 0;
  return mindspore::schema::v0::CreateProposal(
      _fbb,
      feat_stride,
      base_size,
      min_size,
      ratio__,
      scale__,
      pre_nms_topn,
      post_nms_topn,
      nms_thresh);
}

flatbuffers::Offset<Proposal> CreateProposal(flatbuffers::FlatBufferBuilder &_fbb, const ProposalT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct CustomT : public flatbuffers::NativeTable {
  typedef Custom TableType;
  std::vector<uint8_t> custom{};
};

struct Custom FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef CustomT NativeTableType;
  typedef CustomBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return CustomTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_CUSTOM = 4
  };
  const flatbuffers::Vector<uint8_t> *custom() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_CUSTOM);
  }
  flatbuffers::Vector<uint8_t> *mutable_custom() {
    return GetPointer<flatbuffers::Vector<uint8_t> *>(VT_CUSTOM);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_CUSTOM) &&
           verifier.VerifyVector(custom()) &&
           verifier.EndTable();
  }
  CustomT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(CustomT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Custom> Pack(flatbuffers::FlatBufferBuilder &_fbb, const CustomT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct CustomBuilder {
  typedef Custom Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_custom(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> custom) {
    fbb_.AddOffset(Custom::VT_CUSTOM, custom);
  }
  explicit CustomBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Custom> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Custom>(end);
    return o;
  }
};

inline flatbuffers::Offset<Custom> CreateCustom(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> custom = 0) {
  CustomBuilder builder_(_fbb);
  builder_.add_custom(custom);
  return builder_.Finish();
}

inline flatbuffers::Offset<Custom> CreateCustomDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<uint8_t> *custom = nullptr) {
  auto custom__ = custom ? _fbb.CreateVector<uint8_t>(*custom) : 0;
  return mindspore::schema::v0::CreateCustom(
      _fbb,
      custom__);
}

flatbuffers::Offset<Custom> CreateCustom(flatbuffers::FlatBufferBuilder &_fbb, const CustomT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct BlackBoxT : public flatbuffers::NativeTable {
  typedef BlackBox TableType;
  std::string id{};
  int32_t size = 0;
  std::vector<uint8_t> address{};
};

struct BlackBox FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef BlackBoxT NativeTableType;
  typedef BlackBoxBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return BlackBoxTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID = 4,
    VT_SIZE = 6,
    VT_ADDRESS = 8
  };
  const flatbuffers::String *id() const {
    return GetPointer<const flatbuffers::String *>(VT_ID);
  }
  flatbuffers::String *mutable_id() {
    return GetPointer<flatbuffers::String *>(VT_ID);
  }
  int32_t size() const {
    return GetField<int32_t>(VT_SIZE, 0);
  }
  bool mutate_size(int32_t _size) {
    return SetField<int32_t>(VT_SIZE, _size, 0);
  }
  const flatbuffers::Vector<uint8_t> *address() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_ADDRESS);
  }
  flatbuffers::Vector<uint8_t> *mutable_address() {
    return GetPointer<flatbuffers::Vector<uint8_t> *>(VT_ADDRESS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ID) &&
           verifier.VerifyString(id()) &&
           VerifyField<int32_t>(verifier, VT_SIZE) &&
           VerifyOffset(verifier, VT_ADDRESS) &&
           verifier.VerifyVector(address()) &&
           verifier.EndTable();
  }
  BlackBoxT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(BlackBoxT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<BlackBox> Pack(flatbuffers::FlatBufferBuilder &_fbb, const BlackBoxT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct BlackBoxBuilder {
  typedef BlackBox Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_id(flatbuffers::Offset<flatbuffers::String> id) {
    fbb_.AddOffset(BlackBox::VT_ID, id);
  }
  void add_size(int32_t size) {
    fbb_.AddElement<int32_t>(BlackBox::VT_SIZE, size, 0);
  }
  void add_address(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> address) {
    fbb_.AddOffset(BlackBox::VT_ADDRESS, address);
  }
  explicit BlackBoxBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<BlackBox> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<BlackBox>(end);
    return o;
  }
};

inline flatbuffers::Offset<BlackBox> CreateBlackBox(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> id = 0,
    int32_t size = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> address = 0) {
  BlackBoxBuilder builder_(_fbb);
  builder_.add_address(address);
  builder_.add_size(size);
  builder_.add_id(id);
  return builder_.Finish();
}

inline flatbuffers::Offset<BlackBox> CreateBlackBoxDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *id = nullptr,
    int32_t size = 0,
    const std::vector<uint8_t> *address = nullptr) {
  auto id__ = id ? _fbb.CreateString(id) : 0;
  auto address__ = address ? _fbb.CreateVector<uint8_t>(*address) : 0;
  return mindspore::schema::v0::CreateBlackBox(
      _fbb,
      id__,
      size,
      address__);
}

flatbuffers::Offset<BlackBox> CreateBlackBox(flatbuffers::FlatBufferBuilder &_fbb, const BlackBoxT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct LshProjectionT : public flatbuffers::NativeTable {
  typedef LshProjection TableType;
  mindspore::schema::v0::LshProjectionType type = mindspore::schema::v0::LshProjectionType_UNKNOWN;
};

struct LshProjection FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef LshProjectionT NativeTableType;
  typedef LshProjectionBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return LshProjectionTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TYPE = 4
  };
  mindspore::schema::v0::LshProjectionType type() const {
    return static_cast<mindspore::schema::v0::LshProjectionType>(GetField<int8_t>(VT_TYPE, 0));
  }
  bool mutate_type(mindspore::schema::v0::LshProjectionType _type) {
    return SetField<int8_t>(VT_TYPE, static_cast<int8_t>(_type), 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_TYPE) &&
           verifier.EndTable();
  }
  LshProjectionT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(LshProjectionT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<LshProjection> Pack(flatbuffers::FlatBufferBuilder &_fbb, const LshProjectionT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct LshProjectionBuilder {
  typedef LshProjection Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_type(mindspore::schema::v0::LshProjectionType type) {
    fbb_.AddElement<int8_t>(LshProjection::VT_TYPE, static_cast<int8_t>(type), 0);
  }
  explicit LshProjectionBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<LshProjection> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<LshProjection>(end);
    return o;
  }
};

inline flatbuffers::Offset<LshProjection> CreateLshProjection(
    flatbuffers::FlatBufferBuilder &_fbb,
    mindspore::schema::v0::LshProjectionType type = mindspore::schema::v0::LshProjectionType_UNKNOWN) {
  LshProjectionBuilder builder_(_fbb);
  builder_.add_type(type);
  return builder_.Finish();
}

flatbuffers::Offset<LshProjection> CreateLshProjection(flatbuffers::FlatBufferBuilder &_fbb, const LshProjectionT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct HashtableLookupT : public flatbuffers::NativeTable {
  typedef HashtableLookup TableType;
};

struct HashtableLookup FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef HashtableLookupT NativeTableType;
  typedef HashtableLookupBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return HashtableLookupTypeTable();
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  HashtableLookupT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(HashtableLookupT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<HashtableLookup> Pack(flatbuffers::FlatBufferBuilder &_fbb, const HashtableLookupT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct HashtableLookupBuilder {
  typedef HashtableLookup Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit HashtableLookupBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<HashtableLookup> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<HashtableLookup>(end);
    return o;
  }
};

inline flatbuffers::Offset<HashtableLookup> CreateHashtableLookup(
    flatbuffers::FlatBufferBuilder &_fbb) {
  HashtableLookupBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<HashtableLookup> CreateHashtableLookup(flatbuffers::FlatBufferBuilder &_fbb, const HashtableLookupT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct SkipGramT : public flatbuffers::NativeTable {
  typedef SkipGram TableType;
  bool includeAllGrams = false;
  int32_t maxSkipSize = 0;
  int32_t ngramSize = 0;
};

struct SkipGram FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef SkipGramT NativeTableType;
  typedef SkipGramBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return SkipGramTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_INCLUDEALLGRAMS = 4,
    VT_MAXSKIPSIZE = 6,
    VT_NGRAMSIZE = 8
  };
  bool includeAllGrams() const {
    return GetField<uint8_t>(VT_INCLUDEALLGRAMS, 0) != 0;
  }
  bool mutate_includeAllGrams(bool _includeAllGrams) {
    return SetField<uint8_t>(VT_INCLUDEALLGRAMS, static_cast<uint8_t>(_includeAllGrams), 0);
  }
  int32_t maxSkipSize() const {
    return GetField<int32_t>(VT_MAXSKIPSIZE, 0);
  }
  bool mutate_maxSkipSize(int32_t _maxSkipSize) {
    return SetField<int32_t>(VT_MAXSKIPSIZE, _maxSkipSize, 0);
  }
  int32_t ngramSize() const {
    return GetField<int32_t>(VT_NGRAMSIZE, 0);
  }
  bool mutate_ngramSize(int32_t _ngramSize) {
    return SetField<int32_t>(VT_NGRAMSIZE, _ngramSize, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_INCLUDEALLGRAMS) &&
           VerifyField<int32_t>(verifier, VT_MAXSKIPSIZE) &&
           VerifyField<int32_t>(verifier, VT_NGRAMSIZE) &&
           verifier.EndTable();
  }
  SkipGramT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(SkipGramT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<SkipGram> Pack(flatbuffers::FlatBufferBuilder &_fbb, const SkipGramT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct SkipGramBuilder {
  typedef SkipGram Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_includeAllGrams(bool includeAllGrams) {
    fbb_.AddElement<uint8_t>(SkipGram::VT_INCLUDEALLGRAMS, static_cast<uint8_t>(includeAllGrams), 0);
  }
  void add_maxSkipSize(int32_t maxSkipSize) {
    fbb_.AddElement<int32_t>(SkipGram::VT_MAXSKIPSIZE, maxSkipSize, 0);
  }
  void add_ngramSize(int32_t ngramSize) {
    fbb_.AddElement<int32_t>(SkipGram::VT_NGRAMSIZE, ngramSize, 0);
  }
  explicit SkipGramBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<SkipGram> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SkipGram>(end);
    return o;
  }
};

inline flatbuffers::Offset<SkipGram> CreateSkipGram(
    flatbuffers::FlatBufferBuilder &_fbb,
    bool includeAllGrams = false,
    int32_t maxSkipSize = 0,
    int32_t ngramSize = 0) {
  SkipGramBuilder builder_(_fbb);
  builder_.add_ngramSize(ngramSize);
  builder_.add_maxSkipSize(maxSkipSize);
  builder_.add_includeAllGrams(includeAllGrams);
  return builder_.Finish();
}

flatbuffers::Offset<SkipGram> CreateSkipGram(flatbuffers::FlatBufferBuilder &_fbb, const SkipGramT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct CustomPredictT : public flatbuffers::NativeTable {
  typedef CustomPredict TableType;
  int32_t outputNum = 0;
  float weightThreshold = 0.0f;
};

struct CustomPredict FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef CustomPredictT NativeTableType;
  typedef CustomPredictBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return CustomPredictTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_OUTPUTNUM = 4,
    VT_WEIGHTTHRESHOLD = 6
  };
  int32_t outputNum() const {
    return GetField<int32_t>(VT_OUTPUTNUM, 0);
  }
  bool mutate_outputNum(int32_t _outputNum) {
    return SetField<int32_t>(VT_OUTPUTNUM, _outputNum, 0);
  }
  float weightThreshold() const {
    return GetField<float>(VT_WEIGHTTHRESHOLD, 0.0f);
  }
  bool mutate_weightThreshold(float _weightThreshold) {
    return SetField<float>(VT_WEIGHTTHRESHOLD, _weightThreshold, 0.0f);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_OUTPUTNUM) &&
           VerifyField<float>(verifier, VT_WEIGHTTHRESHOLD) &&
           verifier.EndTable();
  }
  CustomPredictT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(CustomPredictT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<CustomPredict> Pack(flatbuffers::FlatBufferBuilder &_fbb, const CustomPredictT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct CustomPredictBuilder {
  typedef CustomPredict Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_outputNum(int32_t outputNum) {
    fbb_.AddElement<int32_t>(CustomPredict::VT_OUTPUTNUM, outputNum, 0);
  }
  void add_weightThreshold(float weightThreshold) {
    fbb_.AddElement<float>(CustomPredict::VT_WEIGHTTHRESHOLD, weightThreshold, 0.0f);
  }
  explicit CustomPredictBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<CustomPredict> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<CustomPredict>(end);
    return o;
  }
};

inline flatbuffers::Offset<CustomPredict> CreateCustomPredict(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t outputNum = 0,
    float weightThreshold = 0.0f) {
  CustomPredictBuilder builder_(_fbb);
  builder_.add_weightThreshold(weightThreshold);
  builder_.add_outputNum(outputNum);
  return builder_.Finish();
}

flatbuffers::Offset<CustomPredict> CreateCustomPredict(flatbuffers::FlatBufferBuilder &_fbb, const CustomPredictT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct CustomNormalizeT : public flatbuffers::NativeTable {
  typedef CustomNormalize TableType;
};

struct CustomNormalize FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef CustomNormalizeT NativeTableType;
  typedef CustomNormalizeBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return CustomNormalizeTypeTable();
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  CustomNormalizeT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(CustomNormalizeT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<CustomNormalize> Pack(flatbuffers::FlatBufferBuilder &_fbb, const CustomNormalizeT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct CustomNormalizeBuilder {
  typedef CustomNormalize Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit CustomNormalizeBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<CustomNormalize> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<CustomNormalize>(end);
    return o;
  }
};

inline flatbuffers::Offset<CustomNormalize> CreateCustomNormalize(
    flatbuffers::FlatBufferBuilder &_fbb) {
  CustomNormalizeBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<CustomNormalize> CreateCustomNormalize(flatbuffers::FlatBufferBuilder &_fbb, const CustomNormalizeT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct CustomExtractFeaturesT : public flatbuffers::NativeTable {
  typedef CustomExtractFeatures TableType;
};

struct CustomExtractFeatures FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef CustomExtractFeaturesT NativeTableType;
  typedef CustomExtractFeaturesBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return CustomExtractFeaturesTypeTable();
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  CustomExtractFeaturesT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(CustomExtractFeaturesT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<CustomExtractFeatures> Pack(flatbuffers::FlatBufferBuilder &_fbb, const CustomExtractFeaturesT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct CustomExtractFeaturesBuilder {
  typedef CustomExtractFeatures Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit CustomExtractFeaturesBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<CustomExtractFeatures> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<CustomExtractFeatures>(end);
    return o;
  }
};

inline flatbuffers::Offset<CustomExtractFeatures> CreateCustomExtractFeatures(
    flatbuffers::FlatBufferBuilder &_fbb) {
  CustomExtractFeaturesBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<CustomExtractFeatures> CreateCustomExtractFeatures(flatbuffers::FlatBufferBuilder &_fbb, const CustomExtractFeaturesT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct AudioSpectrogramT : public flatbuffers::NativeTable {
  typedef AudioSpectrogram TableType;
  int32_t windowSize = 0;
  int32_t stride = 0;
  bool magSquare = false;
};

struct AudioSpectrogram FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef AudioSpectrogramT NativeTableType;
  typedef AudioSpectrogramBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return AudioSpectrogramTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_WINDOWSIZE = 4,
    VT_STRIDE = 6,
    VT_MAGSQUARE = 8
  };
  int32_t windowSize() const {
    return GetField<int32_t>(VT_WINDOWSIZE, 0);
  }
  bool mutate_windowSize(int32_t _windowSize) {
    return SetField<int32_t>(VT_WINDOWSIZE, _windowSize, 0);
  }
  int32_t stride() const {
    return GetField<int32_t>(VT_STRIDE, 0);
  }
  bool mutate_stride(int32_t _stride) {
    return SetField<int32_t>(VT_STRIDE, _stride, 0);
  }
  bool magSquare() const {
    return GetField<uint8_t>(VT_MAGSQUARE, 0) != 0;
  }
  bool mutate_magSquare(bool _magSquare) {
    return SetField<uint8_t>(VT_MAGSQUARE, static_cast<uint8_t>(_magSquare), 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_WINDOWSIZE) &&
           VerifyField<int32_t>(verifier, VT_STRIDE) &&
           VerifyField<uint8_t>(verifier, VT_MAGSQUARE) &&
           verifier.EndTable();
  }
  AudioSpectrogramT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(AudioSpectrogramT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<AudioSpectrogram> Pack(flatbuffers::FlatBufferBuilder &_fbb, const AudioSpectrogramT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct AudioSpectrogramBuilder {
  typedef AudioSpectrogram Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_windowSize(int32_t windowSize) {
    fbb_.AddElement<int32_t>(AudioSpectrogram::VT_WINDOWSIZE, windowSize, 0);
  }
  void add_stride(int32_t stride) {
    fbb_.AddElement<int32_t>(AudioSpectrogram::VT_STRIDE, stride, 0);
  }
  void add_magSquare(bool magSquare) {
    fbb_.AddElement<uint8_t>(AudioSpectrogram::VT_MAGSQUARE, static_cast<uint8_t>(magSquare), 0);
  }
  explicit AudioSpectrogramBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<AudioSpectrogram> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<AudioSpectrogram>(end);
    return o;
  }
};

inline flatbuffers::Offset<AudioSpectrogram> CreateAudioSpectrogram(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t windowSize = 0,
    int32_t stride = 0,
    bool magSquare = false) {
  AudioSpectrogramBuilder builder_(_fbb);
  builder_.add_stride(stride);
  builder_.add_windowSize(windowSize);
  builder_.add_magSquare(magSquare);
  return builder_.Finish();
}

flatbuffers::Offset<AudioSpectrogram> CreateAudioSpectrogram(flatbuffers::FlatBufferBuilder &_fbb, const AudioSpectrogramT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct MfccT : public flatbuffers::NativeTable {
  typedef Mfcc TableType;
  float freqUpperLimit = 0.0f;
  float freqLowerLimit = 0.0f;
  int32_t filterBankChannelNum = 0;
  int32_t dctCoeffNum = 0;
};

struct Mfcc FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef MfccT NativeTableType;
  typedef MfccBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return MfccTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_FREQUPPERLIMIT = 4,
    VT_FREQLOWERLIMIT = 6,
    VT_FILTERBANKCHANNELNUM = 8,
    VT_DCTCOEFFNUM = 10
  };
  float freqUpperLimit() const {
    return GetField<float>(VT_FREQUPPERLIMIT, 0.0f);
  }
  bool mutate_freqUpperLimit(float _freqUpperLimit) {
    return SetField<float>(VT_FREQUPPERLIMIT, _freqUpperLimit, 0.0f);
  }
  float freqLowerLimit() const {
    return GetField<float>(VT_FREQLOWERLIMIT, 0.0f);
  }
  bool mutate_freqLowerLimit(float _freqLowerLimit) {
    return SetField<float>(VT_FREQLOWERLIMIT, _freqLowerLimit, 0.0f);
  }
  int32_t filterBankChannelNum() const {
    return GetField<int32_t>(VT_FILTERBANKCHANNELNUM, 0);
  }
  bool mutate_filterBankChannelNum(int32_t _filterBankChannelNum) {
    return SetField<int32_t>(VT_FILTERBANKCHANNELNUM, _filterBankChannelNum, 0);
  }
  int32_t dctCoeffNum() const {
    return GetField<int32_t>(VT_DCTCOEFFNUM, 0);
  }
  bool mutate_dctCoeffNum(int32_t _dctCoeffNum) {
    return SetField<int32_t>(VT_DCTCOEFFNUM, _dctCoeffNum, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<float>(verifier, VT_FREQUPPERLIMIT) &&
           VerifyField<float>(verifier, VT_FREQLOWERLIMIT) &&
           VerifyField<int32_t>(verifier, VT_FILTERBANKCHANNELNUM) &&
           VerifyField<int32_t>(verifier, VT_DCTCOEFFNUM) &&
           verifier.EndTable();
  }
  MfccT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(MfccT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Mfcc> Pack(flatbuffers::FlatBufferBuilder &_fbb, const MfccT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct MfccBuilder {
  typedef Mfcc Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_freqUpperLimit(float freqUpperLimit) {
    fbb_.AddElement<float>(Mfcc::VT_FREQUPPERLIMIT, freqUpperLimit, 0.0f);
  }
  void add_freqLowerLimit(float freqLowerLimit) {
    fbb_.AddElement<float>(Mfcc::VT_FREQLOWERLIMIT, freqLowerLimit, 0.0f);
  }
  void add_filterBankChannelNum(int32_t filterBankChannelNum) {
    fbb_.AddElement<int32_t>(Mfcc::VT_FILTERBANKCHANNELNUM, filterBankChannelNum, 0);
  }
  void add_dctCoeffNum(int32_t dctCoeffNum) {
    fbb_.AddElement<int32_t>(Mfcc::VT_DCTCOEFFNUM, dctCoeffNum, 0);
  }
  explicit MfccBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Mfcc> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Mfcc>(end);
    return o;
  }
};

inline flatbuffers::Offset<Mfcc> CreateMfcc(
    flatbuffers::FlatBufferBuilder &_fbb,
    float freqUpperLimit = 0.0f,
    float freqLowerLimit = 0.0f,
    int32_t filterBankChannelNum = 0,
    int32_t dctCoeffNum = 0) {
  MfccBuilder builder_(_fbb);
  builder_.add_dctCoeffNum(dctCoeffNum);
  builder_.add_filterBankChannelNum(filterBankChannelNum);
  builder_.add_freqLowerLimit(freqLowerLimit);
  builder_.add_freqUpperLimit(freqUpperLimit);
  return builder_.Finish();
}

flatbuffers::Offset<Mfcc> CreateMfcc(flatbuffers::FlatBufferBuilder &_fbb, const MfccT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct RfftT : public flatbuffers::NativeTable {
  typedef Rfft TableType;
  int32_t fftLength = 0;
};

struct Rfft FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef RfftT NativeTableType;
  typedef RfftBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return RfftTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_FFTLENGTH = 4
  };
  int32_t fftLength() const {
    return GetField<int32_t>(VT_FFTLENGTH, 0);
  }
  bool mutate_fftLength(int32_t _fftLength) {
    return SetField<int32_t>(VT_FFTLENGTH, _fftLength, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_FFTLENGTH) &&
           verifier.EndTable();
  }
  RfftT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(RfftT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Rfft> Pack(flatbuffers::FlatBufferBuilder &_fbb, const RfftT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct RfftBuilder {
  typedef Rfft Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_fftLength(int32_t fftLength) {
    fbb_.AddElement<int32_t>(Rfft::VT_FFTLENGTH, fftLength, 0);
  }
  explicit RfftBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Rfft> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Rfft>(end);
    return o;
  }
};

inline flatbuffers::Offset<Rfft> CreateRfft(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t fftLength = 0) {
  RfftBuilder builder_(_fbb);
  builder_.add_fftLength(fftLength);
  return builder_.Finish();
}

flatbuffers::Offset<Rfft> CreateRfft(flatbuffers::FlatBufferBuilder &_fbb, const RfftT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct FftRealT : public flatbuffers::NativeTable {
  typedef FftReal TableType;
};

struct FftReal FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef FftRealT NativeTableType;
  typedef FftRealBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return FftRealTypeTable();
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  FftRealT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(FftRealT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<FftReal> Pack(flatbuffers::FlatBufferBuilder &_fbb, const FftRealT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct FftRealBuilder {
  typedef FftReal Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit FftRealBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<FftReal> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<FftReal>(end);
    return o;
  }
};

inline flatbuffers::Offset<FftReal> CreateFftReal(
    flatbuffers::FlatBufferBuilder &_fbb) {
  FftRealBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<FftReal> CreateFftReal(flatbuffers::FlatBufferBuilder &_fbb, const FftRealT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct FftImagT : public flatbuffers::NativeTable {
  typedef FftImag TableType;
};

struct FftImag FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef FftImagT NativeTableType;
  typedef FftImagBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return FftImagTypeTable();
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  FftImagT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(FftImagT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<FftImag> Pack(flatbuffers::FlatBufferBuilder &_fbb, const FftImagT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct FftImagBuilder {
  typedef FftImag Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit FftImagBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<FftImag> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<FftImag>(end);
    return o;
  }
};

inline flatbuffers::Offset<FftImag> CreateFftImag(
    flatbuffers::FlatBufferBuilder &_fbb) {
  FftImagBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<FftImag> CreateFftImag(flatbuffers::FlatBufferBuilder &_fbb, const FftImagT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct DropoutGradT : public flatbuffers::NativeTable {
  typedef DropoutGrad TableType;
  float ratio = 0.5f;
};

struct DropoutGrad FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef DropoutGradT NativeTableType;
  typedef DropoutGradBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return DropoutGradTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_RATIO = 4
  };
  float ratio() const {
    return GetField<float>(VT_RATIO, 0.5f);
  }
  bool mutate_ratio(float _ratio) {
    return SetField<float>(VT_RATIO, _ratio, 0.5f);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<float>(verifier, VT_RATIO) &&
           verifier.EndTable();
  }
  DropoutGradT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(DropoutGradT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<DropoutGrad> Pack(flatbuffers::FlatBufferBuilder &_fbb, const DropoutGradT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct DropoutGradBuilder {
  typedef DropoutGrad Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_ratio(float ratio) {
    fbb_.AddElement<float>(DropoutGrad::VT_RATIO, ratio, 0.5f);
  }
  explicit DropoutGradBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<DropoutGrad> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<DropoutGrad>(end);
    return o;
  }
};

inline flatbuffers::Offset<DropoutGrad> CreateDropoutGrad(
    flatbuffers::FlatBufferBuilder &_fbb,
    float ratio = 0.5f) {
  DropoutGradBuilder builder_(_fbb);
  builder_.add_ratio(ratio);
  return builder_.Finish();
}

flatbuffers::Offset<DropoutGrad> CreateDropoutGrad(flatbuffers::FlatBufferBuilder &_fbb, const DropoutGradT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct MaximumGradT : public flatbuffers::NativeTable {
  typedef MaximumGrad TableType;
};

struct MaximumGrad FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef MaximumGradT NativeTableType;
  typedef MaximumGradBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return MaximumGradTypeTable();
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  MaximumGradT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(MaximumGradT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<MaximumGrad> Pack(flatbuffers::FlatBufferBuilder &_fbb, const MaximumGradT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct MaximumGradBuilder {
  typedef MaximumGrad Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit MaximumGradBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<MaximumGrad> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<MaximumGrad>(end);
    return o;
  }
};

inline flatbuffers::Offset<MaximumGrad> CreateMaximumGrad(
    flatbuffers::FlatBufferBuilder &_fbb) {
  MaximumGradBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<MaximumGrad> CreateMaximumGrad(flatbuffers::FlatBufferBuilder &_fbb, const MaximumGradT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct MinimumGradT : public flatbuffers::NativeTable {
  typedef MinimumGrad TableType;
};

struct MinimumGrad FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef MinimumGradT NativeTableType;
  typedef MinimumGradBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return MinimumGradTypeTable();
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  MinimumGradT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(MinimumGradT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<MinimumGrad> Pack(flatbuffers::FlatBufferBuilder &_fbb, const MinimumGradT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct MinimumGradBuilder {
  typedef MinimumGrad Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit MinimumGradBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<MinimumGrad> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<MinimumGrad>(end);
    return o;
  }
};

inline flatbuffers::Offset<MinimumGrad> CreateMinimumGrad(
    flatbuffers::FlatBufferBuilder &_fbb) {
  MinimumGradBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<MinimumGrad> CreateMinimumGrad(flatbuffers::FlatBufferBuilder &_fbb, const MinimumGradT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct NonMaxSuppressionT : public flatbuffers::NativeTable {
  typedef NonMaxSuppression TableType;
  int32_t centerPointBox = 0;
};

struct NonMaxSuppression FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef NonMaxSuppressionT NativeTableType;
  typedef NonMaxSuppressionBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return NonMaxSuppressionTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_CENTERPOINTBOX = 4
  };
  int32_t centerPointBox() const {
    return GetField<int32_t>(VT_CENTERPOINTBOX, 0);
  }
  bool mutate_centerPointBox(int32_t _centerPointBox) {
    return SetField<int32_t>(VT_CENTERPOINTBOX, _centerPointBox, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_CENTERPOINTBOX) &&
           verifier.EndTable();
  }
  NonMaxSuppressionT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(NonMaxSuppressionT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<NonMaxSuppression> Pack(flatbuffers::FlatBufferBuilder &_fbb, const NonMaxSuppressionT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct NonMaxSuppressionBuilder {
  typedef NonMaxSuppression Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_centerPointBox(int32_t centerPointBox) {
    fbb_.AddElement<int32_t>(NonMaxSuppression::VT_CENTERPOINTBOX, centerPointBox, 0);
  }
  explicit NonMaxSuppressionBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<NonMaxSuppression> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<NonMaxSuppression>(end);
    return o;
  }
};

inline flatbuffers::Offset<NonMaxSuppression> CreateNonMaxSuppression(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t centerPointBox = 0) {
  NonMaxSuppressionBuilder builder_(_fbb);
  builder_.add_centerPointBox(centerPointBox);
  return builder_.Finish();
}

flatbuffers::Offset<NonMaxSuppression> CreateNonMaxSuppression(flatbuffers::FlatBufferBuilder &_fbb, const NonMaxSuppressionT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct InstanceNormT : public flatbuffers::NativeTable {
  typedef InstanceNorm TableType;
  float epsilon = 0.00001f;
};

struct InstanceNorm FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef InstanceNormT NativeTableType;
  typedef InstanceNormBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return InstanceNormTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_EPSILON = 4
  };
  float epsilon() const {
    return GetField<float>(VT_EPSILON, 0.00001f);
  }
  bool mutate_epsilon(float _epsilon) {
    return SetField<float>(VT_EPSILON, _epsilon, 0.00001f);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<float>(verifier, VT_EPSILON) &&
           verifier.EndTable();
  }
  InstanceNormT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(InstanceNormT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<InstanceNorm> Pack(flatbuffers::FlatBufferBuilder &_fbb, const InstanceNormT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct InstanceNormBuilder {
  typedef InstanceNorm Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_epsilon(float epsilon) {
    fbb_.AddElement<float>(InstanceNorm::VT_EPSILON, epsilon, 0.00001f);
  }
  explicit InstanceNormBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<InstanceNorm> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<InstanceNorm>(end);
    return o;
  }
};

inline flatbuffers::Offset<InstanceNorm> CreateInstanceNorm(
    flatbuffers::FlatBufferBuilder &_fbb,
    float epsilon = 0.00001f) {
  InstanceNormBuilder builder_(_fbb);
  builder_.add_epsilon(epsilon);
  return builder_.Finish();
}

flatbuffers::Offset<InstanceNorm> CreateInstanceNorm(flatbuffers::FlatBufferBuilder &_fbb, const InstanceNormT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct LoopT : public flatbuffers::NativeTable {
  typedef Loop TableType;
  int32_t subGraphIndex = 0;
};

struct Loop FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef LoopT NativeTableType;
  typedef LoopBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return LoopTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SUBGRAPHINDEX = 4
  };
  int32_t subGraphIndex() const {
    return GetField<int32_t>(VT_SUBGRAPHINDEX, 0);
  }
  bool mutate_subGraphIndex(int32_t _subGraphIndex) {
    return SetField<int32_t>(VT_SUBGRAPHINDEX, _subGraphIndex, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_SUBGRAPHINDEX) &&
           verifier.EndTable();
  }
  LoopT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(LoopT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Loop> Pack(flatbuffers::FlatBufferBuilder &_fbb, const LoopT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct LoopBuilder {
  typedef Loop Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_subGraphIndex(int32_t subGraphIndex) {
    fbb_.AddElement<int32_t>(Loop::VT_SUBGRAPHINDEX, subGraphIndex, 0);
  }
  explicit LoopBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Loop> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Loop>(end);
    return o;
  }
};

inline flatbuffers::Offset<Loop> CreateLoop(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t subGraphIndex = 0) {
  LoopBuilder builder_(_fbb);
  builder_.add_subGraphIndex(subGraphIndex);
  return builder_.Finish();
}

flatbuffers::Offset<Loop> CreateLoop(flatbuffers::FlatBufferBuilder &_fbb, const LoopT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct IdentityT : public flatbuffers::NativeTable {
  typedef Identity TableType;
};

struct Identity FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef IdentityT NativeTableType;
  typedef IdentityBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return IdentityTypeTable();
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  IdentityT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(IdentityT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Identity> Pack(flatbuffers::FlatBufferBuilder &_fbb, const IdentityT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct IdentityBuilder {
  typedef Identity Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit IdentityBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Identity> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Identity>(end);
    return o;
  }
};

inline flatbuffers::Offset<Identity> CreateIdentity(
    flatbuffers::FlatBufferBuilder &_fbb) {
  IdentityBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<Identity> CreateIdentity(flatbuffers::FlatBufferBuilder &_fbb, const IdentityT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct LayerNormT : public flatbuffers::NativeTable {
  typedef LayerNorm TableType;
  std::vector<int32_t> normalizedShape{};
  float epsilon = 0.00001f;
  bool elementwiseAffine = false;
};

struct LayerNorm FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef LayerNormT NativeTableType;
  typedef LayerNormBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return LayerNormTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NORMALIZEDSHAPE = 4,
    VT_EPSILON = 6,
    VT_ELEMENTWISEAFFINE = 8
  };
  const flatbuffers::Vector<int32_t> *normalizedShape() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_NORMALIZEDSHAPE);
  }
  flatbuffers::Vector<int32_t> *mutable_normalizedShape() {
    return GetPointer<flatbuffers::Vector<int32_t> *>(VT_NORMALIZEDSHAPE);
  }
  float epsilon() const {
    return GetField<float>(VT_EPSILON, 0.00001f);
  }
  bool mutate_epsilon(float _epsilon) {
    return SetField<float>(VT_EPSILON, _epsilon, 0.00001f);
  }
  bool elementwiseAffine() const {
    return GetField<uint8_t>(VT_ELEMENTWISEAFFINE, 0) != 0;
  }
  bool mutate_elementwiseAffine(bool _elementwiseAffine) {
    return SetField<uint8_t>(VT_ELEMENTWISEAFFINE, static_cast<uint8_t>(_elementwiseAffine), 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NORMALIZEDSHAPE) &&
           verifier.VerifyVector(normalizedShape()) &&
           VerifyField<float>(verifier, VT_EPSILON) &&
           VerifyField<uint8_t>(verifier, VT_ELEMENTWISEAFFINE) &&
           verifier.EndTable();
  }
  LayerNormT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(LayerNormT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<LayerNorm> Pack(flatbuffers::FlatBufferBuilder &_fbb, const LayerNormT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct LayerNormBuilder {
  typedef LayerNorm Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_normalizedShape(flatbuffers::Offset<flatbuffers::Vector<int32_t>> normalizedShape) {
    fbb_.AddOffset(LayerNorm::VT_NORMALIZEDSHAPE, normalizedShape);
  }
  void add_epsilon(float epsilon) {
    fbb_.AddElement<float>(LayerNorm::VT_EPSILON, epsilon, 0.00001f);
  }
  void add_elementwiseAffine(bool elementwiseAffine) {
    fbb_.AddElement<uint8_t>(LayerNorm::VT_ELEMENTWISEAFFINE, static_cast<uint8_t>(elementwiseAffine), 0);
  }
  explicit LayerNormBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<LayerNorm> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<LayerNorm>(end);
    return o;
  }
};

inline flatbuffers::Offset<LayerNorm> CreateLayerNorm(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> normalizedShape = 0,
    float epsilon = 0.00001f,
    bool elementwiseAffine = false) {
  LayerNormBuilder builder_(_fbb);
  builder_.add_epsilon(epsilon);
  builder_.add_normalizedShape(normalizedShape);
  builder_.add_elementwiseAffine(elementwiseAffine);
  return builder_.Finish();
}

inline flatbuffers::Offset<LayerNorm> CreateLayerNormDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<int32_t> *normalizedShape = nullptr,
    float epsilon = 0.00001f,
    bool elementwiseAffine = false) {
  auto normalizedShape__ = normalizedShape ? _fbb.CreateVector<int32_t>(*normalizedShape) : 0;
  return mindspore::schema::v0::CreateLayerNorm(
      _fbb,
      normalizedShape__,
      epsilon,
      elementwiseAffine);
}

flatbuffers::Offset<LayerNorm> CreateLayerNorm(flatbuffers::FlatBufferBuilder &_fbb, const LayerNormT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct WhileT : public flatbuffers::NativeTable {
  typedef While TableType;
  int32_t condSubgraphIndex = 0;
  int32_t bodySubgraphIndex = 0;
};

struct While FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef WhileT NativeTableType;
  typedef WhileBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return WhileTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_CONDSUBGRAPHINDEX = 4,
    VT_BODYSUBGRAPHINDEX = 6
  };
  int32_t condSubgraphIndex() const {
    return GetField<int32_t>(VT_CONDSUBGRAPHINDEX, 0);
  }
  bool mutate_condSubgraphIndex(int32_t _condSubgraphIndex) {
    return SetField<int32_t>(VT_CONDSUBGRAPHINDEX, _condSubgraphIndex, 0);
  }
  int32_t bodySubgraphIndex() const {
    return GetField<int32_t>(VT_BODYSUBGRAPHINDEX, 0);
  }
  bool mutate_bodySubgraphIndex(int32_t _bodySubgraphIndex) {
    return SetField<int32_t>(VT_BODYSUBGRAPHINDEX, _bodySubgraphIndex, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_CONDSUBGRAPHINDEX) &&
           VerifyField<int32_t>(verifier, VT_BODYSUBGRAPHINDEX) &&
           verifier.EndTable();
  }
  WhileT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(WhileT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<While> Pack(flatbuffers::FlatBufferBuilder &_fbb, const WhileT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct WhileBuilder {
  typedef While Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_condSubgraphIndex(int32_t condSubgraphIndex) {
    fbb_.AddElement<int32_t>(While::VT_CONDSUBGRAPHINDEX, condSubgraphIndex, 0);
  }
  void add_bodySubgraphIndex(int32_t bodySubgraphIndex) {
    fbb_.AddElement<int32_t>(While::VT_BODYSUBGRAPHINDEX, bodySubgraphIndex, 0);
  }
  explicit WhileBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<While> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<While>(end);
    return o;
  }
};

inline flatbuffers::Offset<While> CreateWhile(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t condSubgraphIndex = 0,
    int32_t bodySubgraphIndex = 0) {
  WhileBuilder builder_(_fbb);
  builder_.add_bodySubgraphIndex(bodySubgraphIndex);
  builder_.add_condSubgraphIndex(condSubgraphIndex);
  return builder_.Finish();
}

flatbuffers::Offset<While> CreateWhile(flatbuffers::FlatBufferBuilder &_fbb, const WhileT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct UnsortedSegmentSumT : public flatbuffers::NativeTable {
  typedef UnsortedSegmentSum TableType;
  int32_t numSegments = 0;
};

struct UnsortedSegmentSum FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef UnsortedSegmentSumT NativeTableType;
  typedef UnsortedSegmentSumBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return UnsortedSegmentSumTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NUMSEGMENTS = 4
  };
  int32_t numSegments() const {
    return GetField<int32_t>(VT_NUMSEGMENTS, 0);
  }
  bool mutate_numSegments(int32_t _numSegments) {
    return SetField<int32_t>(VT_NUMSEGMENTS, _numSegments, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_NUMSEGMENTS) &&
           verifier.EndTable();
  }
  UnsortedSegmentSumT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(UnsortedSegmentSumT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<UnsortedSegmentSum> Pack(flatbuffers::FlatBufferBuilder &_fbb, const UnsortedSegmentSumT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct UnsortedSegmentSumBuilder {
  typedef UnsortedSegmentSum Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_numSegments(int32_t numSegments) {
    fbb_.AddElement<int32_t>(UnsortedSegmentSum::VT_NUMSEGMENTS, numSegments, 0);
  }
  explicit UnsortedSegmentSumBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<UnsortedSegmentSum> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<UnsortedSegmentSum>(end);
    return o;
  }
};

inline flatbuffers::Offset<UnsortedSegmentSum> CreateUnsortedSegmentSum(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t numSegments = 0) {
  UnsortedSegmentSumBuilder builder_(_fbb);
  builder_.add_numSegments(numSegments);
  return builder_.Finish();
}

flatbuffers::Offset<UnsortedSegmentSum> CreateUnsortedSegmentSum(flatbuffers::FlatBufferBuilder &_fbb, const UnsortedSegmentSumT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct OnesLikeT : public flatbuffers::NativeTable {
  typedef OnesLike TableType;
};

struct OnesLike FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef OnesLikeT NativeTableType;
  typedef OnesLikeBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return OnesLikeTypeTable();
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  OnesLikeT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(OnesLikeT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<OnesLike> Pack(flatbuffers::FlatBufferBuilder &_fbb, const OnesLikeT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct OnesLikeBuilder {
  typedef OnesLike Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit OnesLikeBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<OnesLike> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<OnesLike>(end);
    return o;
  }
};

inline flatbuffers::Offset<OnesLike> CreateOnesLike(
    flatbuffers::FlatBufferBuilder &_fbb) {
  OnesLikeBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<OnesLike> CreateOnesLike(flatbuffers::FlatBufferBuilder &_fbb, const OnesLikeT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct BinaryCrossEntropyT : public flatbuffers::NativeTable {
  typedef BinaryCrossEntropy TableType;
  int32_t reduction = 1;
};

struct BinaryCrossEntropy FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef BinaryCrossEntropyT NativeTableType;
  typedef BinaryCrossEntropyBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return BinaryCrossEntropyTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_REDUCTION = 4
  };
  int32_t reduction() const {
    return GetField<int32_t>(VT_REDUCTION, 1);
  }
  bool mutate_reduction(int32_t _reduction) {
    return SetField<int32_t>(VT_REDUCTION, _reduction, 1);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_REDUCTION) &&
           verifier.EndTable();
  }
  BinaryCrossEntropyT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(BinaryCrossEntropyT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<BinaryCrossEntropy> Pack(flatbuffers::FlatBufferBuilder &_fbb, const BinaryCrossEntropyT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct BinaryCrossEntropyBuilder {
  typedef BinaryCrossEntropy Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_reduction(int32_t reduction) {
    fbb_.AddElement<int32_t>(BinaryCrossEntropy::VT_REDUCTION, reduction, 1);
  }
  explicit BinaryCrossEntropyBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<BinaryCrossEntropy> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<BinaryCrossEntropy>(end);
    return o;
  }
};

inline flatbuffers::Offset<BinaryCrossEntropy> CreateBinaryCrossEntropy(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t reduction = 1) {
  BinaryCrossEntropyBuilder builder_(_fbb);
  builder_.add_reduction(reduction);
  return builder_.Finish();
}

flatbuffers::Offset<BinaryCrossEntropy> CreateBinaryCrossEntropy(flatbuffers::FlatBufferBuilder &_fbb, const BinaryCrossEntropyT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct BinaryCrossEntropyGradT : public flatbuffers::NativeTable {
  typedef BinaryCrossEntropyGrad TableType;
  int32_t reduction = 1;
};

struct BinaryCrossEntropyGrad FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef BinaryCrossEntropyGradT NativeTableType;
  typedef BinaryCrossEntropyGradBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return BinaryCrossEntropyGradTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_REDUCTION = 4
  };
  int32_t reduction() const {
    return GetField<int32_t>(VT_REDUCTION, 1);
  }
  bool mutate_reduction(int32_t _reduction) {
    return SetField<int32_t>(VT_REDUCTION, _reduction, 1);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_REDUCTION) &&
           verifier.EndTable();
  }
  BinaryCrossEntropyGradT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(BinaryCrossEntropyGradT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<BinaryCrossEntropyGrad> Pack(flatbuffers::FlatBufferBuilder &_fbb, const BinaryCrossEntropyGradT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct BinaryCrossEntropyGradBuilder {
  typedef BinaryCrossEntropyGrad Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_reduction(int32_t reduction) {
    fbb_.AddElement<int32_t>(BinaryCrossEntropyGrad::VT_REDUCTION, reduction, 1);
  }
  explicit BinaryCrossEntropyGradBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<BinaryCrossEntropyGrad> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<BinaryCrossEntropyGrad>(end);
    return o;
  }
};

inline flatbuffers::Offset<BinaryCrossEntropyGrad> CreateBinaryCrossEntropyGrad(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t reduction = 1) {
  BinaryCrossEntropyGradBuilder builder_(_fbb);
  builder_.add_reduction(reduction);
  return builder_.Finish();
}

flatbuffers::Offset<BinaryCrossEntropyGrad> CreateBinaryCrossEntropyGrad(flatbuffers::FlatBufferBuilder &_fbb, const BinaryCrossEntropyGradT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct LpNormalizationT : public flatbuffers::NativeTable {
  typedef LpNormalization TableType;
  int32_t axis = 0;
  int32_t p = 0;
};

struct LpNormalization FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef LpNormalizationT NativeTableType;
  typedef LpNormalizationBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return LpNormalizationTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_AXIS = 4,
    VT_P = 6
  };
  int32_t axis() const {
    return GetField<int32_t>(VT_AXIS, 0);
  }
  bool mutate_axis(int32_t _axis) {
    return SetField<int32_t>(VT_AXIS, _axis, 0);
  }
  int32_t p() const {
    return GetField<int32_t>(VT_P, 0);
  }
  bool mutate_p(int32_t _p) {
    return SetField<int32_t>(VT_P, _p, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_AXIS) &&
           VerifyField<int32_t>(verifier, VT_P) &&
           verifier.EndTable();
  }
  LpNormalizationT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(LpNormalizationT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<LpNormalization> Pack(flatbuffers::FlatBufferBuilder &_fbb, const LpNormalizationT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct LpNormalizationBuilder {
  typedef LpNormalization Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_axis(int32_t axis) {
    fbb_.AddElement<int32_t>(LpNormalization::VT_AXIS, axis, 0);
  }
  void add_p(int32_t p) {
    fbb_.AddElement<int32_t>(LpNormalization::VT_P, p, 0);
  }
  explicit LpNormalizationBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<LpNormalization> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<LpNormalization>(end);
    return o;
  }
};

inline flatbuffers::Offset<LpNormalization> CreateLpNormalization(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t axis = 0,
    int32_t p = 0) {
  LpNormalizationBuilder builder_(_fbb);
  builder_.add_p(p);
  builder_.add_axis(axis);
  return builder_.Finish();
}

flatbuffers::Offset<LpNormalization> CreateLpNormalization(flatbuffers::FlatBufferBuilder &_fbb, const LpNormalizationT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct SwitchT : public flatbuffers::NativeTable {
  typedef Switch TableType;
};

struct Switch FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef SwitchT NativeTableType;
  typedef SwitchBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return SwitchTypeTable();
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  SwitchT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(SwitchT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Switch> Pack(flatbuffers::FlatBufferBuilder &_fbb, const SwitchT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct SwitchBuilder {
  typedef Switch Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit SwitchBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Switch> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Switch>(end);
    return o;
  }
};

inline flatbuffers::Offset<Switch> CreateSwitch(
    flatbuffers::FlatBufferBuilder &_fbb) {
  SwitchBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<Switch> CreateSwitch(flatbuffers::FlatBufferBuilder &_fbb, const SwitchT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct PartialT : public flatbuffers::NativeTable {
  typedef Partial TableType;
  int32_t subGraphIndex = 0;
};

struct Partial FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef PartialT NativeTableType;
  typedef PartialBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return PartialTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SUBGRAPHINDEX = 4
  };
  int32_t subGraphIndex() const {
    return GetField<int32_t>(VT_SUBGRAPHINDEX, 0);
  }
  bool mutate_subGraphIndex(int32_t _subGraphIndex) {
    return SetField<int32_t>(VT_SUBGRAPHINDEX, _subGraphIndex, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_SUBGRAPHINDEX) &&
           verifier.EndTable();
  }
  PartialT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(PartialT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Partial> Pack(flatbuffers::FlatBufferBuilder &_fbb, const PartialT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct PartialBuilder {
  typedef Partial Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_subGraphIndex(int32_t subGraphIndex) {
    fbb_.AddElement<int32_t>(Partial::VT_SUBGRAPHINDEX, subGraphIndex, 0);
  }
  explicit PartialBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Partial> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Partial>(end);
    return o;
  }
};

inline flatbuffers::Offset<Partial> CreatePartial(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t subGraphIndex = 0) {
  PartialBuilder builder_(_fbb);
  builder_.add_subGraphIndex(subGraphIndex);
  return builder_.Finish();
}

flatbuffers::Offset<Partial> CreatePartial(flatbuffers::FlatBufferBuilder &_fbb, const PartialT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct TensorListFromTensorT : public flatbuffers::NativeTable {
  typedef TensorListFromTensor TableType;
  int32_t elementDType = 0;
  int32_t shapeType = 0;
};

struct TensorListFromTensor FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef TensorListFromTensorT NativeTableType;
  typedef TensorListFromTensorBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return TensorListFromTensorTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ELEMENTDTYPE = 4,
    VT_SHAPETYPE = 6
  };
  int32_t elementDType() const {
    return GetField<int32_t>(VT_ELEMENTDTYPE, 0);
  }
  bool mutate_elementDType(int32_t _elementDType) {
    return SetField<int32_t>(VT_ELEMENTDTYPE, _elementDType, 0);
  }
  int32_t shapeType() const {
    return GetField<int32_t>(VT_SHAPETYPE, 0);
  }
  bool mutate_shapeType(int32_t _shapeType) {
    return SetField<int32_t>(VT_SHAPETYPE, _shapeType, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_ELEMENTDTYPE) &&
           VerifyField<int32_t>(verifier, VT_SHAPETYPE) &&
           verifier.EndTable();
  }
  TensorListFromTensorT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(TensorListFromTensorT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<TensorListFromTensor> Pack(flatbuffers::FlatBufferBuilder &_fbb, const TensorListFromTensorT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct TensorListFromTensorBuilder {
  typedef TensorListFromTensor Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_elementDType(int32_t elementDType) {
    fbb_.AddElement<int32_t>(TensorListFromTensor::VT_ELEMENTDTYPE, elementDType, 0);
  }
  void add_shapeType(int32_t shapeType) {
    fbb_.AddElement<int32_t>(TensorListFromTensor::VT_SHAPETYPE, shapeType, 0);
  }
  explicit TensorListFromTensorBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<TensorListFromTensor> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<TensorListFromTensor>(end);
    return o;
  }
};

inline flatbuffers::Offset<TensorListFromTensor> CreateTensorListFromTensor(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t elementDType = 0,
    int32_t shapeType = 0) {
  TensorListFromTensorBuilder builder_(_fbb);
  builder_.add_shapeType(shapeType);
  builder_.add_elementDType(elementDType);
  return builder_.Finish();
}

flatbuffers::Offset<TensorListFromTensor> CreateTensorListFromTensor(flatbuffers::FlatBufferBuilder &_fbb, const TensorListFromTensorT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct TensorListStackT : public flatbuffers::NativeTable {
  typedef TensorListStack TableType;
  int32_t numElements = 0;
  int32_t elementDType = 0;
};

struct TensorListStack FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef TensorListStackT NativeTableType;
  typedef TensorListStackBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return TensorListStackTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NUMELEMENTS = 4,
    VT_ELEMENTDTYPE = 6
  };
  int32_t numElements() const {
    return GetField<int32_t>(VT_NUMELEMENTS, 0);
  }
  bool mutate_numElements(int32_t _numElements) {
    return SetField<int32_t>(VT_NUMELEMENTS, _numElements, 0);
  }
  int32_t elementDType() const {
    return GetField<int32_t>(VT_ELEMENTDTYPE, 0);
  }
  bool mutate_elementDType(int32_t _elementDType) {
    return SetField<int32_t>(VT_ELEMENTDTYPE, _elementDType, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_NUMELEMENTS) &&
           VerifyField<int32_t>(verifier, VT_ELEMENTDTYPE) &&
           verifier.EndTable();
  }
  TensorListStackT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(TensorListStackT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<TensorListStack> Pack(flatbuffers::FlatBufferBuilder &_fbb, const TensorListStackT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct TensorListStackBuilder {
  typedef TensorListStack Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_numElements(int32_t numElements) {
    fbb_.AddElement<int32_t>(TensorListStack::VT_NUMELEMENTS, numElements, 0);
  }
  void add_elementDType(int32_t elementDType) {
    fbb_.AddElement<int32_t>(TensorListStack::VT_ELEMENTDTYPE, elementDType, 0);
  }
  explicit TensorListStackBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<TensorListStack> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<TensorListStack>(end);
    return o;
  }
};

inline flatbuffers::Offset<TensorListStack> CreateTensorListStack(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t numElements = 0,
    int32_t elementDType = 0) {
  TensorListStackBuilder builder_(_fbb);
  builder_.add_elementDType(elementDType);
  builder_.add_numElements(numElements);
  return builder_.Finish();
}

flatbuffers::Offset<TensorListStack> CreateTensorListStack(flatbuffers::FlatBufferBuilder &_fbb, const TensorListStackT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct TensorListGetItemT : public flatbuffers::NativeTable {
  typedef TensorListGetItem TableType;
  int32_t elementDType = 0;
};

struct TensorListGetItem FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef TensorListGetItemT NativeTableType;
  typedef TensorListGetItemBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return TensorListGetItemTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ELEMENTDTYPE = 4
  };
  int32_t elementDType() const {
    return GetField<int32_t>(VT_ELEMENTDTYPE, 0);
  }
  bool mutate_elementDType(int32_t _elementDType) {
    return SetField<int32_t>(VT_ELEMENTDTYPE, _elementDType, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_ELEMENTDTYPE) &&
           verifier.EndTable();
  }
  TensorListGetItemT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(TensorListGetItemT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<TensorListGetItem> Pack(flatbuffers::FlatBufferBuilder &_fbb, const TensorListGetItemT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct TensorListGetItemBuilder {
  typedef TensorListGetItem Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_elementDType(int32_t elementDType) {
    fbb_.AddElement<int32_t>(TensorListGetItem::VT_ELEMENTDTYPE, elementDType, 0);
  }
  explicit TensorListGetItemBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<TensorListGetItem> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<TensorListGetItem>(end);
    return o;
  }
};

inline flatbuffers::Offset<TensorListGetItem> CreateTensorListGetItem(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t elementDType = 0) {
  TensorListGetItemBuilder builder_(_fbb);
  builder_.add_elementDType(elementDType);
  return builder_.Finish();
}

flatbuffers::Offset<TensorListGetItem> CreateTensorListGetItem(flatbuffers::FlatBufferBuilder &_fbb, const TensorListGetItemT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct TensorListSetItemT : public flatbuffers::NativeTable {
  typedef TensorListSetItem TableType;
  int32_t elementDType = 0;
};

struct TensorListSetItem FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef TensorListSetItemT NativeTableType;
  typedef TensorListSetItemBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return TensorListSetItemTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ELEMENTDTYPE = 4
  };
  int32_t elementDType() const {
    return GetField<int32_t>(VT_ELEMENTDTYPE, 0);
  }
  bool mutate_elementDType(int32_t _elementDType) {
    return SetField<int32_t>(VT_ELEMENTDTYPE, _elementDType, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_ELEMENTDTYPE) &&
           verifier.EndTable();
  }
  TensorListSetItemT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(TensorListSetItemT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<TensorListSetItem> Pack(flatbuffers::FlatBufferBuilder &_fbb, const TensorListSetItemT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct TensorListSetItemBuilder {
  typedef TensorListSetItem Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_elementDType(int32_t elementDType) {
    fbb_.AddElement<int32_t>(TensorListSetItem::VT_ELEMENTDTYPE, elementDType, 0);
  }
  explicit TensorListSetItemBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<TensorListSetItem> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<TensorListSetItem>(end);
    return o;
  }
};

inline flatbuffers::Offset<TensorListSetItem> CreateTensorListSetItem(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t elementDType = 0) {
  TensorListSetItemBuilder builder_(_fbb);
  builder_.add_elementDType(elementDType);
  return builder_.Finish();
}

flatbuffers::Offset<TensorListSetItem> CreateTensorListSetItem(flatbuffers::FlatBufferBuilder &_fbb, const TensorListSetItemT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct TensorListReserveT : public flatbuffers::NativeTable {
  typedef TensorListReserve TableType;
  int32_t elementDType = 0;
  int32_t shapeType = 0;
};

struct TensorListReserve FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef TensorListReserveT NativeTableType;
  typedef TensorListReserveBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return TensorListReserveTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ELEMENTDTYPE = 4,
    VT_SHAPETYPE = 6
  };
  int32_t elementDType() const {
    return GetField<int32_t>(VT_ELEMENTDTYPE, 0);
  }
  bool mutate_elementDType(int32_t _elementDType) {
    return SetField<int32_t>(VT_ELEMENTDTYPE, _elementDType, 0);
  }
  int32_t shapeType() const {
    return GetField<int32_t>(VT_SHAPETYPE, 0);
  }
  bool mutate_shapeType(int32_t _shapeType) {
    return SetField<int32_t>(VT_SHAPETYPE, _shapeType, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_ELEMENTDTYPE) &&
           VerifyField<int32_t>(verifier, VT_SHAPETYPE) &&
           verifier.EndTable();
  }
  TensorListReserveT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(TensorListReserveT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<TensorListReserve> Pack(flatbuffers::FlatBufferBuilder &_fbb, const TensorListReserveT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct TensorListReserveBuilder {
  typedef TensorListReserve Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_elementDType(int32_t elementDType) {
    fbb_.AddElement<int32_t>(TensorListReserve::VT_ELEMENTDTYPE, elementDType, 0);
  }
  void add_shapeType(int32_t shapeType) {
    fbb_.AddElement<int32_t>(TensorListReserve::VT_SHAPETYPE, shapeType, 0);
  }
  explicit TensorListReserveBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<TensorListReserve> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<TensorListReserve>(end);
    return o;
  }
};

inline flatbuffers::Offset<TensorListReserve> CreateTensorListReserve(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t elementDType = 0,
    int32_t shapeType = 0) {
  TensorListReserveBuilder builder_(_fbb);
  builder_.add_shapeType(shapeType);
  builder_.add_elementDType(elementDType);
  return builder_.Finish();
}

flatbuffers::Offset<TensorListReserve> CreateTensorListReserve(flatbuffers::FlatBufferBuilder &_fbb, const TensorListReserveT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct AllT : public flatbuffers::NativeTable {
  typedef All TableType;
  int32_t keepDims = 0;
};

struct All FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef AllT NativeTableType;
  typedef AllBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return AllTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_KEEPDIMS = 4
  };
  int32_t keepDims() const {
    return GetField<int32_t>(VT_KEEPDIMS, 0);
  }
  bool mutate_keepDims(int32_t _keepDims) {
    return SetField<int32_t>(VT_KEEPDIMS, _keepDims, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_KEEPDIMS) &&
           verifier.EndTable();
  }
  AllT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(AllT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<All> Pack(flatbuffers::FlatBufferBuilder &_fbb, const AllT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct AllBuilder {
  typedef All Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_keepDims(int32_t keepDims) {
    fbb_.AddElement<int32_t>(All::VT_KEEPDIMS, keepDims, 0);
  }
  explicit AllBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<All> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<All>(end);
    return o;
  }
};

inline flatbuffers::Offset<All> CreateAll(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t keepDims = 0) {
  AllBuilder builder_(_fbb);
  builder_.add_keepDims(keepDims);
  return builder_.Finish();
}

flatbuffers::Offset<All> CreateAll(flatbuffers::FlatBufferBuilder &_fbb, const AllT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct AssertT : public flatbuffers::NativeTable {
  typedef Assert TableType;
  int32_t summarize = 0;
};

struct Assert FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef AssertT NativeTableType;
  typedef AssertBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return AssertTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SUMMARIZE = 4
  };
  int32_t summarize() const {
    return GetField<int32_t>(VT_SUMMARIZE, 0);
  }
  bool mutate_summarize(int32_t _summarize) {
    return SetField<int32_t>(VT_SUMMARIZE, _summarize, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_SUMMARIZE) &&
           verifier.EndTable();
  }
  AssertT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(AssertT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Assert> Pack(flatbuffers::FlatBufferBuilder &_fbb, const AssertT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct AssertBuilder {
  typedef Assert Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_summarize(int32_t summarize) {
    fbb_.AddElement<int32_t>(Assert::VT_SUMMARIZE, summarize, 0);
  }
  explicit AssertBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Assert> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Assert>(end);
    return o;
  }
};

inline flatbuffers::Offset<Assert> CreateAssert(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t summarize = 0) {
  AssertBuilder builder_(_fbb);
  builder_.add_summarize(summarize);
  return builder_.Finish();
}

flatbuffers::Offset<Assert> CreateAssert(flatbuffers::FlatBufferBuilder &_fbb, const AssertT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct SmoothL1LossT : public flatbuffers::NativeTable {
  typedef SmoothL1Loss TableType;
  float beta = 0.0f;
};

struct SmoothL1Loss FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef SmoothL1LossT NativeTableType;
  typedef SmoothL1LossBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return SmoothL1LossTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_BETA = 4
  };
  float beta() const {
    return GetField<float>(VT_BETA, 0.0f);
  }
  bool mutate_beta(float _beta) {
    return SetField<float>(VT_BETA, _beta, 0.0f);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<float>(verifier, VT_BETA) &&
           verifier.EndTable();
  }
  SmoothL1LossT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(SmoothL1LossT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<SmoothL1Loss> Pack(flatbuffers::FlatBufferBuilder &_fbb, const SmoothL1LossT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct SmoothL1LossBuilder {
  typedef SmoothL1Loss Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_beta(float beta) {
    fbb_.AddElement<float>(SmoothL1Loss::VT_BETA, beta, 0.0f);
  }
  explicit SmoothL1LossBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<SmoothL1Loss> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SmoothL1Loss>(end);
    return o;
  }
};

inline flatbuffers::Offset<SmoothL1Loss> CreateSmoothL1Loss(
    flatbuffers::FlatBufferBuilder &_fbb,
    float beta = 0.0f) {
  SmoothL1LossBuilder builder_(_fbb);
  builder_.add_beta(beta);
  return builder_.Finish();
}

flatbuffers::Offset<SmoothL1Loss> CreateSmoothL1Loss(flatbuffers::FlatBufferBuilder &_fbb, const SmoothL1LossT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct SmoothL1LossGradT : public flatbuffers::NativeTable {
  typedef SmoothL1LossGrad TableType;
  float beta = 0.0f;
};

struct SmoothL1LossGrad FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef SmoothL1LossGradT NativeTableType;
  typedef SmoothL1LossGradBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return SmoothL1LossGradTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_BETA = 4
  };
  float beta() const {
    return GetField<float>(VT_BETA, 0.0f);
  }
  bool mutate_beta(float _beta) {
    return SetField<float>(VT_BETA, _beta, 0.0f);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<float>(verifier, VT_BETA) &&
           verifier.EndTable();
  }
  SmoothL1LossGradT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(SmoothL1LossGradT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<SmoothL1LossGrad> Pack(flatbuffers::FlatBufferBuilder &_fbb, const SmoothL1LossGradT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct SmoothL1LossGradBuilder {
  typedef SmoothL1LossGrad Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_beta(float beta) {
    fbb_.AddElement<float>(SmoothL1LossGrad::VT_BETA, beta, 0.0f);
  }
  explicit SmoothL1LossGradBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<SmoothL1LossGrad> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SmoothL1LossGrad>(end);
    return o;
  }
};

inline flatbuffers::Offset<SmoothL1LossGrad> CreateSmoothL1LossGrad(
    flatbuffers::FlatBufferBuilder &_fbb,
    float beta = 0.0f) {
  SmoothL1LossGradBuilder builder_(_fbb);
  builder_.add_beta(beta);
  return builder_.Finish();
}

flatbuffers::Offset<SmoothL1LossGrad> CreateSmoothL1LossGrad(flatbuffers::FlatBufferBuilder &_fbb, const SmoothL1LossGradT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct SigmoidCrossEntropyWithLogitsT : public flatbuffers::NativeTable {
  typedef SigmoidCrossEntropyWithLogits TableType;
  float beta = 0.0f;
};

struct SigmoidCrossEntropyWithLogits FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef SigmoidCrossEntropyWithLogitsT NativeTableType;
  typedef SigmoidCrossEntropyWithLogitsBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return SigmoidCrossEntropyWithLogitsTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_BETA = 4
  };
  float beta() const {
    return GetField<float>(VT_BETA, 0.0f);
  }
  bool mutate_beta(float _beta) {
    return SetField<float>(VT_BETA, _beta, 0.0f);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<float>(verifier, VT_BETA) &&
           verifier.EndTable();
  }
  SigmoidCrossEntropyWithLogitsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(SigmoidCrossEntropyWithLogitsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<SigmoidCrossEntropyWithLogits> Pack(flatbuffers::FlatBufferBuilder &_fbb, const SigmoidCrossEntropyWithLogitsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct SigmoidCrossEntropyWithLogitsBuilder {
  typedef SigmoidCrossEntropyWithLogits Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_beta(float beta) {
    fbb_.AddElement<float>(SigmoidCrossEntropyWithLogits::VT_BETA, beta, 0.0f);
  }
  explicit SigmoidCrossEntropyWithLogitsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<SigmoidCrossEntropyWithLogits> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SigmoidCrossEntropyWithLogits>(end);
    return o;
  }
};

inline flatbuffers::Offset<SigmoidCrossEntropyWithLogits> CreateSigmoidCrossEntropyWithLogits(
    flatbuffers::FlatBufferBuilder &_fbb,
    float beta = 0.0f) {
  SigmoidCrossEntropyWithLogitsBuilder builder_(_fbb);
  builder_.add_beta(beta);
  return builder_.Finish();
}

flatbuffers::Offset<SigmoidCrossEntropyWithLogits> CreateSigmoidCrossEntropyWithLogits(flatbuffers::FlatBufferBuilder &_fbb, const SigmoidCrossEntropyWithLogitsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct SigmoidCrossEntropyWithLogitsGradT : public flatbuffers::NativeTable {
  typedef SigmoidCrossEntropyWithLogitsGrad TableType;
  float beta = 0.0f;
};

struct SigmoidCrossEntropyWithLogitsGrad FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef SigmoidCrossEntropyWithLogitsGradT NativeTableType;
  typedef SigmoidCrossEntropyWithLogitsGradBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return SigmoidCrossEntropyWithLogitsGradTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_BETA = 4
  };
  float beta() const {
    return GetField<float>(VT_BETA, 0.0f);
  }
  bool mutate_beta(float _beta) {
    return SetField<float>(VT_BETA, _beta, 0.0f);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<float>(verifier, VT_BETA) &&
           verifier.EndTable();
  }
  SigmoidCrossEntropyWithLogitsGradT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(SigmoidCrossEntropyWithLogitsGradT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<SigmoidCrossEntropyWithLogitsGrad> Pack(flatbuffers::FlatBufferBuilder &_fbb, const SigmoidCrossEntropyWithLogitsGradT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct SigmoidCrossEntropyWithLogitsGradBuilder {
  typedef SigmoidCrossEntropyWithLogitsGrad Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_beta(float beta) {
    fbb_.AddElement<float>(SigmoidCrossEntropyWithLogitsGrad::VT_BETA, beta, 0.0f);
  }
  explicit SigmoidCrossEntropyWithLogitsGradBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<SigmoidCrossEntropyWithLogitsGrad> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SigmoidCrossEntropyWithLogitsGrad>(end);
    return o;
  }
};

inline flatbuffers::Offset<SigmoidCrossEntropyWithLogitsGrad> CreateSigmoidCrossEntropyWithLogitsGrad(
    flatbuffers::FlatBufferBuilder &_fbb,
    float beta = 0.0f) {
  SigmoidCrossEntropyWithLogitsGradBuilder builder_(_fbb);
  builder_.add_beta(beta);
  return builder_.Finish();
}

flatbuffers::Offset<SigmoidCrossEntropyWithLogitsGrad> CreateSigmoidCrossEntropyWithLogitsGrad(flatbuffers::FlatBufferBuilder &_fbb, const SigmoidCrossEntropyWithLogitsGradT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ReciprocalT : public flatbuffers::NativeTable {
  typedef Reciprocal TableType;
};

struct Reciprocal FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ReciprocalT NativeTableType;
  typedef ReciprocalBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return ReciprocalTypeTable();
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  ReciprocalT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ReciprocalT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Reciprocal> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ReciprocalT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ReciprocalBuilder {
  typedef Reciprocal Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit ReciprocalBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Reciprocal> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Reciprocal>(end);
    return o;
  }
};

inline flatbuffers::Offset<Reciprocal> CreateReciprocal(
    flatbuffers::FlatBufferBuilder &_fbb) {
  ReciprocalBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<Reciprocal> CreateReciprocal(flatbuffers::FlatBufferBuilder &_fbb, const ReciprocalT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct MergeT : public flatbuffers::NativeTable {
  typedef Merge TableType;
};

struct Merge FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef MergeT NativeTableType;
  typedef MergeBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return MergeTypeTable();
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  MergeT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(MergeT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Merge> Pack(flatbuffers::FlatBufferBuilder &_fbb, const MergeT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct MergeBuilder {
  typedef Merge Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit MergeBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Merge> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Merge>(end);
    return o;
  }
};

inline flatbuffers::Offset<Merge> CreateMerge(
    flatbuffers::FlatBufferBuilder &_fbb) {
  MergeBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<Merge> CreateMerge(flatbuffers::FlatBufferBuilder &_fbb, const MergeT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct GeLUT : public flatbuffers::NativeTable {
  typedef GeLU TableType;
  bool approximate = false;
};

struct GeLU FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef GeLUT NativeTableType;
  typedef GeLUBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return GeLUTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_APPROXIMATE = 4
  };
  bool approximate() const {
    return GetField<uint8_t>(VT_APPROXIMATE, 0) != 0;
  }
  bool mutate_approximate(bool _approximate) {
    return SetField<uint8_t>(VT_APPROXIMATE, static_cast<uint8_t>(_approximate), 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_APPROXIMATE) &&
           verifier.EndTable();
  }
  GeLUT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(GeLUT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<GeLU> Pack(flatbuffers::FlatBufferBuilder &_fbb, const GeLUT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct GeLUBuilder {
  typedef GeLU Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_approximate(bool approximate) {
    fbb_.AddElement<uint8_t>(GeLU::VT_APPROXIMATE, static_cast<uint8_t>(approximate), 0);
  }
  explicit GeLUBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<GeLU> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<GeLU>(end);
    return o;
  }
};

inline flatbuffers::Offset<GeLU> CreateGeLU(
    flatbuffers::FlatBufferBuilder &_fbb,
    bool approximate = false) {
  GeLUBuilder builder_(_fbb);
  builder_.add_approximate(approximate);
  return builder_.Finish();
}

flatbuffers::Offset<GeLU> CreateGeLU(flatbuffers::FlatBufferBuilder &_fbb, const GeLUT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

inline PadT *Pad::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<PadT>(new PadT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Pad::UnPackTo(PadT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = paddings(); if (_e) { _o->paddings.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->paddings[_i] = _e->Get(_i); } } }
  { auto _e = paddingMode(); _o->paddingMode = _e; }
  { auto _e = constantValue(); _o->constantValue = _e; }
}

inline flatbuffers::Offset<Pad> Pad::Pack(flatbuffers::FlatBufferBuilder &_fbb, const PadT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreatePad(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Pad> CreatePad(flatbuffers::FlatBufferBuilder &_fbb, const PadT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const PadT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _paddings = _o->paddings.size() ? _fbb.CreateVector(_o->paddings) : 0;
  auto _paddingMode = _o->paddingMode;
  auto _constantValue = _o->constantValue;
  return mindspore::schema::v0::CreatePad(
      _fbb,
      _paddings,
      _paddingMode,
      _constantValue);
}

inline MaximumT *Maximum::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<MaximumT>(new MaximumT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Maximum::UnPackTo(MaximumT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<Maximum> Maximum::Pack(flatbuffers::FlatBufferBuilder &_fbb, const MaximumT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateMaximum(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Maximum> CreateMaximum(flatbuffers::FlatBufferBuilder &_fbb, const MaximumT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const MaximumT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return mindspore::schema::v0::CreateMaximum(
      _fbb);
}

inline MinimumT *Minimum::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<MinimumT>(new MinimumT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Minimum::UnPackTo(MinimumT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<Minimum> Minimum::Pack(flatbuffers::FlatBufferBuilder &_fbb, const MinimumT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateMinimum(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Minimum> CreateMinimum(flatbuffers::FlatBufferBuilder &_fbb, const MinimumT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const MinimumT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return mindspore::schema::v0::CreateMinimum(
      _fbb);
}

inline FlattenT *Flatten::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<FlattenT>(new FlattenT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Flatten::UnPackTo(FlattenT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<Flatten> Flatten::Pack(flatbuffers::FlatBufferBuilder &_fbb, const FlattenT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateFlatten(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Flatten> CreateFlatten(flatbuffers::FlatBufferBuilder &_fbb, const FlattenT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const FlattenT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return mindspore::schema::v0::CreateFlatten(
      _fbb);
}

inline FlattenGradT *FlattenGrad::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<FlattenGradT>(new FlattenGradT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void FlattenGrad::UnPackTo(FlattenGradT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<FlattenGrad> FlattenGrad::Pack(flatbuffers::FlatBufferBuilder &_fbb, const FlattenGradT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateFlattenGrad(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<FlattenGrad> CreateFlattenGrad(flatbuffers::FlatBufferBuilder &_fbb, const FlattenGradT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const FlattenGradT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return mindspore::schema::v0::CreateFlattenGrad(
      _fbb);
}

inline ConcatT *Concat::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<ConcatT>(new ConcatT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Concat::UnPackTo(ConcatT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = axis(); _o->axis = _e; }
  { auto _e = n(); _o->n = _e; }
}

inline flatbuffers::Offset<Concat> Concat::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ConcatT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateConcat(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Concat> CreateConcat(flatbuffers::FlatBufferBuilder &_fbb, const ConcatT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ConcatT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _axis = _o->axis;
  auto _n = _o->n;
  return mindspore::schema::v0::CreateConcat(
      _fbb,
      _axis,
      _n);
}

inline SoftMaxT *SoftMax::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<SoftMaxT>(new SoftMaxT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void SoftMax::UnPackTo(SoftMaxT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = axis(); _o->axis = _e; }
}

inline flatbuffers::Offset<SoftMax> SoftMax::Pack(flatbuffers::FlatBufferBuilder &_fbb, const SoftMaxT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateSoftMax(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<SoftMax> CreateSoftMax(flatbuffers::FlatBufferBuilder &_fbb, const SoftMaxT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const SoftMaxT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _axis = _o->axis;
  return mindspore::schema::v0::CreateSoftMax(
      _fbb,
      _axis);
}

inline ActivationT *Activation::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<ActivationT>(new ActivationT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Activation::UnPackTo(ActivationT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = type(); _o->type = _e; }
  { auto _e = alpha(); _o->alpha = _e; }
  { auto _e = min_val(); _o->min_val = _e; }
  { auto _e = max_val(); _o->max_val = _e; }
}

inline flatbuffers::Offset<Activation> Activation::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ActivationT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateActivation(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Activation> CreateActivation(flatbuffers::FlatBufferBuilder &_fbb, const ActivationT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ActivationT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _type = _o->type;
  auto _alpha = _o->alpha;
  auto _min_val = _o->min_val;
  auto _max_val = _o->max_val;
  return mindspore::schema::v0::CreateActivation(
      _fbb,
      _type,
      _alpha,
      _min_val,
      _max_val);
}

inline ActivationGradT *ActivationGrad::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<ActivationGradT>(new ActivationGradT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void ActivationGrad::UnPackTo(ActivationGradT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = type(); _o->type = _e; }
  { auto _e = alpha(); _o->alpha = _e; }
}

inline flatbuffers::Offset<ActivationGrad> ActivationGrad::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ActivationGradT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateActivationGrad(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<ActivationGrad> CreateActivationGrad(flatbuffers::FlatBufferBuilder &_fbb, const ActivationGradT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ActivationGradT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _type = _o->type;
  auto _alpha = _o->alpha;
  return mindspore::schema::v0::CreateActivationGrad(
      _fbb,
      _type,
      _alpha);
}

inline Conv2DT *Conv2D::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<Conv2DT>(new Conv2DT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Conv2D::UnPackTo(Conv2DT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = format(); _o->format = _e; }
  { auto _e = group(); _o->group = _e; }
  { auto _e = channelIn(); _o->channelIn = _e; }
  { auto _e = channelOut(); _o->channelOut = _e; }
  { auto _e = kernelW(); _o->kernelW = _e; }
  { auto _e = kernelH(); _o->kernelH = _e; }
  { auto _e = strideW(); _o->strideW = _e; }
  { auto _e = strideH(); _o->strideH = _e; }
  { auto _e = padMode(); _o->padMode = _e; }
  { auto _e = padUp(); _o->padUp = _e; }
  { auto _e = padDown(); _o->padDown = _e; }
  { auto _e = padLeft(); _o->padLeft = _e; }
  { auto _e = padRight(); _o->padRight = _e; }
  { auto _e = dilateW(); _o->dilateW = _e; }
  { auto _e = dilateH(); _o->dilateH = _e; }
  { auto _e = hasBias(); _o->hasBias = _e; }
  { auto _e = activationType(); _o->activationType = _e; }
}

inline flatbuffers::Offset<Conv2D> Conv2D::Pack(flatbuffers::FlatBufferBuilder &_fbb, const Conv2DT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateConv2D(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Conv2D> CreateConv2D(flatbuffers::FlatBufferBuilder &_fbb, const Conv2DT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const Conv2DT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _format = _o->format;
  auto _group = _o->group;
  auto _channelIn = _o->channelIn;
  auto _channelOut = _o->channelOut;
  auto _kernelW = _o->kernelW;
  auto _kernelH = _o->kernelH;
  auto _strideW = _o->strideW;
  auto _strideH = _o->strideH;
  auto _padMode = _o->padMode;
  auto _padUp = _o->padUp;
  auto _padDown = _o->padDown;
  auto _padLeft = _o->padLeft;
  auto _padRight = _o->padRight;
  auto _dilateW = _o->dilateW;
  auto _dilateH = _o->dilateH;
  auto _hasBias = _o->hasBias;
  auto _activationType = _o->activationType;
  return mindspore::schema::v0::CreateConv2D(
      _fbb,
      _format,
      _group,
      _channelIn,
      _channelOut,
      _kernelW,
      _kernelH,
      _strideW,
      _strideH,
      _padMode,
      _padUp,
      _padDown,
      _padLeft,
      _padRight,
      _dilateW,
      _dilateH,
      _hasBias,
      _activationType);
}

inline AdderT *Adder::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<AdderT>(new AdderT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Adder::UnPackTo(AdderT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = format(); _o->format = _e; }
  { auto _e = group(); _o->group = _e; }
  { auto _e = channelIn(); _o->channelIn = _e; }
  { auto _e = channelOut(); _o->channelOut = _e; }
  { auto _e = kernelW(); _o->kernelW = _e; }
  { auto _e = kernelH(); _o->kernelH = _e; }
  { auto _e = strideW(); _o->strideW = _e; }
  { auto _e = strideH(); _o->strideH = _e; }
  { auto _e = padMode(); _o->padMode = _e; }
  { auto _e = padUp(); _o->padUp = _e; }
  { auto _e = padDown(); _o->padDown = _e; }
  { auto _e = padLeft(); _o->padLeft = _e; }
  { auto _e = padRight(); _o->padRight = _e; }
  { auto _e = dilateW(); _o->dilateW = _e; }
  { auto _e = dilateH(); _o->dilateH = _e; }
  { auto _e = hasBias(); _o->hasBias = _e; }
  { auto _e = activationType(); _o->activationType = _e; }
}

inline flatbuffers::Offset<Adder> Adder::Pack(flatbuffers::FlatBufferBuilder &_fbb, const AdderT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateAdder(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Adder> CreateAdder(flatbuffers::FlatBufferBuilder &_fbb, const AdderT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const AdderT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _format = _o->format;
  auto _group = _o->group;
  auto _channelIn = _o->channelIn;
  auto _channelOut = _o->channelOut;
  auto _kernelW = _o->kernelW;
  auto _kernelH = _o->kernelH;
  auto _strideW = _o->strideW;
  auto _strideH = _o->strideH;
  auto _padMode = _o->padMode;
  auto _padUp = _o->padUp;
  auto _padDown = _o->padDown;
  auto _padLeft = _o->padLeft;
  auto _padRight = _o->padRight;
  auto _dilateW = _o->dilateW;
  auto _dilateH = _o->dilateH;
  auto _hasBias = _o->hasBias;
  auto _activationType = _o->activationType;
  return mindspore::schema::v0::CreateAdder(
      _fbb,
      _format,
      _group,
      _channelIn,
      _channelOut,
      _kernelW,
      _kernelH,
      _strideW,
      _strideH,
      _padMode,
      _padUp,
      _padDown,
      _padLeft,
      _padRight,
      _dilateW,
      _dilateH,
      _hasBias,
      _activationType);
}

inline Conv2DGradFilterT *Conv2DGradFilter::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<Conv2DGradFilterT>(new Conv2DGradFilterT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Conv2DGradFilter::UnPackTo(Conv2DGradFilterT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = format(); _o->format = _e; }
  { auto _e = group(); _o->group = _e; }
  { auto _e = channelIn(); _o->channelIn = _e; }
  { auto _e = channelOut(); _o->channelOut = _e; }
  { auto _e = kernelW(); _o->kernelW = _e; }
  { auto _e = kernelH(); _o->kernelH = _e; }
  { auto _e = strideW(); _o->strideW = _e; }
  { auto _e = strideH(); _o->strideH = _e; }
  { auto _e = padMode(); _o->padMode = _e; }
  { auto _e = padUp(); _o->padUp = _e; }
  { auto _e = padDown(); _o->padDown = _e; }
  { auto _e = padLeft(); _o->padLeft = _e; }
  { auto _e = padRight(); _o->padRight = _e; }
  { auto _e = dilateW(); _o->dilateW = _e; }
  { auto _e = dilateH(); _o->dilateH = _e; }
  { auto _e = hasBias(); _o->hasBias = _e; }
  { auto _e = filter_shape(); if (_e) { _o->filter_shape.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->filter_shape[_i] = _e->Get(_i); } } }
  { auto _e = activationType(); _o->activationType = _e; }
}

inline flatbuffers::Offset<Conv2DGradFilter> Conv2DGradFilter::Pack(flatbuffers::FlatBufferBuilder &_fbb, const Conv2DGradFilterT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateConv2DGradFilter(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Conv2DGradFilter> CreateConv2DGradFilter(flatbuffers::FlatBufferBuilder &_fbb, const Conv2DGradFilterT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const Conv2DGradFilterT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _format = _o->format;
  auto _group = _o->group;
  auto _channelIn = _o->channelIn;
  auto _channelOut = _o->channelOut;
  auto _kernelW = _o->kernelW;
  auto _kernelH = _o->kernelH;
  auto _strideW = _o->strideW;
  auto _strideH = _o->strideH;
  auto _padMode = _o->padMode;
  auto _padUp = _o->padUp;
  auto _padDown = _o->padDown;
  auto _padLeft = _o->padLeft;
  auto _padRight = _o->padRight;
  auto _dilateW = _o->dilateW;
  auto _dilateH = _o->dilateH;
  auto _hasBias = _o->hasBias;
  auto _filter_shape = _o->filter_shape.size() ? _fbb.CreateVector(_o->filter_shape) : 0;
  auto _activationType = _o->activationType;
  return mindspore::schema::v0::CreateConv2DGradFilter(
      _fbb,
      _format,
      _group,
      _channelIn,
      _channelOut,
      _kernelW,
      _kernelH,
      _strideW,
      _strideH,
      _padMode,
      _padUp,
      _padDown,
      _padLeft,
      _padRight,
      _dilateW,
      _dilateH,
      _hasBias,
      _filter_shape,
      _activationType);
}

inline Conv2DGradInputT *Conv2DGradInput::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<Conv2DGradInputT>(new Conv2DGradInputT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Conv2DGradInput::UnPackTo(Conv2DGradInputT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = format(); _o->format = _e; }
  { auto _e = group(); _o->group = _e; }
  { auto _e = channelIn(); _o->channelIn = _e; }
  { auto _e = channelOut(); _o->channelOut = _e; }
  { auto _e = kernelW(); _o->kernelW = _e; }
  { auto _e = kernelH(); _o->kernelH = _e; }
  { auto _e = strideW(); _o->strideW = _e; }
  { auto _e = strideH(); _o->strideH = _e; }
  { auto _e = padMode(); _o->padMode = _e; }
  { auto _e = padUp(); _o->padUp = _e; }
  { auto _e = padDown(); _o->padDown = _e; }
  { auto _e = padLeft(); _o->padLeft = _e; }
  { auto _e = padRight(); _o->padRight = _e; }
  { auto _e = dilateW(); _o->dilateW = _e; }
  { auto _e = dilateH(); _o->dilateH = _e; }
  { auto _e = hasBias(); _o->hasBias = _e; }
  { auto _e = input_shape(); if (_e) { _o->input_shape.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->input_shape[_i] = _e->Get(_i); } } }
  { auto _e = activationType(); _o->activationType = _e; }
}

inline flatbuffers::Offset<Conv2DGradInput> Conv2DGradInput::Pack(flatbuffers::FlatBufferBuilder &_fbb, const Conv2DGradInputT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateConv2DGradInput(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Conv2DGradInput> CreateConv2DGradInput(flatbuffers::FlatBufferBuilder &_fbb, const Conv2DGradInputT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const Conv2DGradInputT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _format = _o->format;
  auto _group = _o->group;
  auto _channelIn = _o->channelIn;
  auto _channelOut = _o->channelOut;
  auto _kernelW = _o->kernelW;
  auto _kernelH = _o->kernelH;
  auto _strideW = _o->strideW;
  auto _strideH = _o->strideH;
  auto _padMode = _o->padMode;
  auto _padUp = _o->padUp;
  auto _padDown = _o->padDown;
  auto _padLeft = _o->padLeft;
  auto _padRight = _o->padRight;
  auto _dilateW = _o->dilateW;
  auto _dilateH = _o->dilateH;
  auto _hasBias = _o->hasBias;
  auto _input_shape = _o->input_shape.size() ? _fbb.CreateVector(_o->input_shape) : 0;
  auto _activationType = _o->activationType;
  return mindspore::schema::v0::CreateConv2DGradInput(
      _fbb,
      _format,
      _group,
      _channelIn,
      _channelOut,
      _kernelW,
      _kernelH,
      _strideW,
      _strideH,
      _padMode,
      _padUp,
      _padDown,
      _padLeft,
      _padRight,
      _dilateW,
      _dilateH,
      _hasBias,
      _input_shape,
      _activationType);
}

inline GroupConv2DGradInputT *GroupConv2DGradInput::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<GroupConv2DGradInputT>(new GroupConv2DGradInputT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void GroupConv2DGradInput::UnPackTo(GroupConv2DGradInputT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = format(); _o->format = _e; }
  { auto _e = group(); _o->group = _e; }
  { auto _e = channelIn(); _o->channelIn = _e; }
  { auto _e = channelOut(); _o->channelOut = _e; }
  { auto _e = kernelW(); _o->kernelW = _e; }
  { auto _e = kernelH(); _o->kernelH = _e; }
  { auto _e = strideW(); _o->strideW = _e; }
  { auto _e = strideH(); _o->strideH = _e; }
  { auto _e = padMode(); _o->padMode = _e; }
  { auto _e = padUp(); _o->padUp = _e; }
  { auto _e = padDown(); _o->padDown = _e; }
  { auto _e = padLeft(); _o->padLeft = _e; }
  { auto _e = padRight(); _o->padRight = _e; }
  { auto _e = dilateW(); _o->dilateW = _e; }
  { auto _e = dilateH(); _o->dilateH = _e; }
  { auto _e = hasBias(); _o->hasBias = _e; }
  { auto _e = input_shape(); if (_e) { _o->input_shape.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->input_shape[_i] = _e->Get(_i); } } }
  { auto _e = activationType(); _o->activationType = _e; }
}

inline flatbuffers::Offset<GroupConv2DGradInput> GroupConv2DGradInput::Pack(flatbuffers::FlatBufferBuilder &_fbb, const GroupConv2DGradInputT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateGroupConv2DGradInput(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<GroupConv2DGradInput> CreateGroupConv2DGradInput(flatbuffers::FlatBufferBuilder &_fbb, const GroupConv2DGradInputT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const GroupConv2DGradInputT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _format = _o->format;
  auto _group = _o->group;
  auto _channelIn = _o->channelIn;
  auto _channelOut = _o->channelOut;
  auto _kernelW = _o->kernelW;
  auto _kernelH = _o->kernelH;
  auto _strideW = _o->strideW;
  auto _strideH = _o->strideH;
  auto _padMode = _o->padMode;
  auto _padUp = _o->padUp;
  auto _padDown = _o->padDown;
  auto _padLeft = _o->padLeft;
  auto _padRight = _o->padRight;
  auto _dilateW = _o->dilateW;
  auto _dilateH = _o->dilateH;
  auto _hasBias = _o->hasBias;
  auto _input_shape = _o->input_shape.size() ? _fbb.CreateVector(_o->input_shape) : 0;
  auto _activationType = _o->activationType;
  return mindspore::schema::v0::CreateGroupConv2DGradInput(
      _fbb,
      _format,
      _group,
      _channelIn,
      _channelOut,
      _kernelW,
      _kernelH,
      _strideW,
      _strideH,
      _padMode,
      _padUp,
      _padDown,
      _padLeft,
      _padRight,
      _dilateW,
      _dilateH,
      _hasBias,
      _input_shape,
      _activationType);
}

inline FusedBatchNormT *FusedBatchNorm::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<FusedBatchNormT>(new FusedBatchNormT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void FusedBatchNorm::UnPackTo(FusedBatchNormT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = epsilon(); _o->epsilon = _e; }
  { auto _e = momentum(); _o->momentum = _e; }
  { auto _e = spatial(); _o->spatial = _e; }
}

inline flatbuffers::Offset<FusedBatchNorm> FusedBatchNorm::Pack(flatbuffers::FlatBufferBuilder &_fbb, const FusedBatchNormT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateFusedBatchNorm(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<FusedBatchNorm> CreateFusedBatchNorm(flatbuffers::FlatBufferBuilder &_fbb, const FusedBatchNormT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const FusedBatchNormT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _epsilon = _o->epsilon;
  auto _momentum = _o->momentum;
  auto _spatial = _o->spatial;
  return mindspore::schema::v0::CreateFusedBatchNorm(
      _fbb,
      _epsilon,
      _momentum,
      _spatial);
}

inline BatchNormT *BatchNorm::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<BatchNormT>(new BatchNormT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void BatchNorm::UnPackTo(BatchNormT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = epsilon(); _o->epsilon = _e; }
}

inline flatbuffers::Offset<BatchNorm> BatchNorm::Pack(flatbuffers::FlatBufferBuilder &_fbb, const BatchNormT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateBatchNorm(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<BatchNorm> CreateBatchNorm(flatbuffers::FlatBufferBuilder &_fbb, const BatchNormT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const BatchNormT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _epsilon = _o->epsilon;
  return mindspore::schema::v0::CreateBatchNorm(
      _fbb,
      _epsilon);
}

inline BiasGradT *BiasGrad::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<BiasGradT>(new BiasGradT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void BiasGrad::UnPackTo(BiasGradT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = axis(); if (_e) { _o->axis.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->axis[_i] = _e->Get(_i); } } }
}

inline flatbuffers::Offset<BiasGrad> BiasGrad::Pack(flatbuffers::FlatBufferBuilder &_fbb, const BiasGradT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateBiasGrad(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<BiasGrad> CreateBiasGrad(flatbuffers::FlatBufferBuilder &_fbb, const BiasGradT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const BiasGradT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _axis = _o->axis.size() ? _fbb.CreateVector(_o->axis) : 0;
  return mindspore::schema::v0::CreateBiasGrad(
      _fbb,
      _axis);
}

inline SoftmaxCrossEntropyT *SoftmaxCrossEntropy::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<SoftmaxCrossEntropyT>(new SoftmaxCrossEntropyT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void SoftmaxCrossEntropy::UnPackTo(SoftmaxCrossEntropyT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = axis(); if (_e) { _o->axis.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->axis[_i] = _e->Get(_i); } } }
}

inline flatbuffers::Offset<SoftmaxCrossEntropy> SoftmaxCrossEntropy::Pack(flatbuffers::FlatBufferBuilder &_fbb, const SoftmaxCrossEntropyT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateSoftmaxCrossEntropy(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<SoftmaxCrossEntropy> CreateSoftmaxCrossEntropy(flatbuffers::FlatBufferBuilder &_fbb, const SoftmaxCrossEntropyT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const SoftmaxCrossEntropyT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _axis = _o->axis.size() ? _fbb.CreateVector(_o->axis) : 0;
  return mindspore::schema::v0::CreateSoftmaxCrossEntropy(
      _fbb,
      _axis);
}

inline SparseSoftmaxCrossEntropyT *SparseSoftmaxCrossEntropy::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<SparseSoftmaxCrossEntropyT>(new SparseSoftmaxCrossEntropyT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void SparseSoftmaxCrossEntropy::UnPackTo(SparseSoftmaxCrossEntropyT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = isGrad(); _o->isGrad = _e; }
}

inline flatbuffers::Offset<SparseSoftmaxCrossEntropy> SparseSoftmaxCrossEntropy::Pack(flatbuffers::FlatBufferBuilder &_fbb, const SparseSoftmaxCrossEntropyT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateSparseSoftmaxCrossEntropy(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<SparseSoftmaxCrossEntropy> CreateSparseSoftmaxCrossEntropy(flatbuffers::FlatBufferBuilder &_fbb, const SparseSoftmaxCrossEntropyT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const SparseSoftmaxCrossEntropyT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _isGrad = _o->isGrad;
  return mindspore::schema::v0::CreateSparseSoftmaxCrossEntropy(
      _fbb,
      _isGrad);
}

inline make_tupleT *make_tuple::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<make_tupleT>(new make_tupleT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void make_tuple::UnPackTo(make_tupleT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<make_tuple> make_tuple::Pack(flatbuffers::FlatBufferBuilder &_fbb, const make_tupleT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return Createmake_tuple(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<make_tuple> Createmake_tuple(flatbuffers::FlatBufferBuilder &_fbb, const make_tupleT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const make_tupleT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return mindspore::schema::v0::Createmake_tuple(
      _fbb);
}

inline PoolingGradT *PoolingGrad::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<PoolingGradT>(new PoolingGradT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void PoolingGrad::UnPackTo(PoolingGradT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = format(); _o->format = _e; }
  { auto _e = poolingMode(); _o->poolingMode = _e; }
  { auto _e = global(); _o->global = _e; }
  { auto _e = windowW(); _o->windowW = _e; }
  { auto _e = windowH(); _o->windowH = _e; }
  { auto _e = strideW(); _o->strideW = _e; }
  { auto _e = strideH(); _o->strideH = _e; }
  { auto _e = padMode(); _o->padMode = _e; }
  { auto _e = padUp(); _o->padUp = _e; }
  { auto _e = padDown(); _o->padDown = _e; }
  { auto _e = padLeft(); _o->padLeft = _e; }
  { auto _e = padRight(); _o->padRight = _e; }
  { auto _e = roundMode(); _o->roundMode = _e; }
}

inline flatbuffers::Offset<PoolingGrad> PoolingGrad::Pack(flatbuffers::FlatBufferBuilder &_fbb, const PoolingGradT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreatePoolingGrad(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<PoolingGrad> CreatePoolingGrad(flatbuffers::FlatBufferBuilder &_fbb, const PoolingGradT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const PoolingGradT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _format = _o->format;
  auto _poolingMode = _o->poolingMode;
  auto _global = _o->global;
  auto _windowW = _o->windowW;
  auto _windowH = _o->windowH;
  auto _strideW = _o->strideW;
  auto _strideH = _o->strideH;
  auto _padMode = _o->padMode;
  auto _padUp = _o->padUp;
  auto _padDown = _o->padDown;
  auto _padLeft = _o->padLeft;
  auto _padRight = _o->padRight;
  auto _roundMode = _o->roundMode;
  return mindspore::schema::v0::CreatePoolingGrad(
      _fbb,
      _format,
      _poolingMode,
      _global,
      _windowW,
      _windowH,
      _strideW,
      _strideH,
      _padMode,
      _padUp,
      _padDown,
      _padLeft,
      _padRight,
      _roundMode);
}

inline ShapeT *Shape::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<ShapeT>(new ShapeT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Shape::UnPackTo(ShapeT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<Shape> Shape::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ShapeT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateShape(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Shape> CreateShape(flatbuffers::FlatBufferBuilder &_fbb, const ShapeT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ShapeT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return mindspore::schema::v0::CreateShape(
      _fbb);
}

inline ConstantOfShapeT *ConstantOfShape::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<ConstantOfShapeT>(new ConstantOfShapeT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void ConstantOfShape::UnPackTo(ConstantOfShapeT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = dataType(); _o->dataType = _e; }
  { auto _e = value(); if (_e) { _o->value.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->value[_i] = _e->Get(_i); } } }
}

inline flatbuffers::Offset<ConstantOfShape> ConstantOfShape::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ConstantOfShapeT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateConstantOfShape(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<ConstantOfShape> CreateConstantOfShape(flatbuffers::FlatBufferBuilder &_fbb, const ConstantOfShapeT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ConstantOfShapeT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _dataType = _o->dataType;
  auto _value = _o->value.size() ? _fbb.CreateVector(_o->value) : 0;
  return mindspore::schema::v0::CreateConstantOfShape(
      _fbb,
      _dataType,
      _value);
}

inline Nchw2NhwcT *Nchw2Nhwc::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<Nchw2NhwcT>(new Nchw2NhwcT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Nchw2Nhwc::UnPackTo(Nchw2NhwcT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<Nchw2Nhwc> Nchw2Nhwc::Pack(flatbuffers::FlatBufferBuilder &_fbb, const Nchw2NhwcT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateNchw2Nhwc(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Nchw2Nhwc> CreateNchw2Nhwc(flatbuffers::FlatBufferBuilder &_fbb, const Nchw2NhwcT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const Nchw2NhwcT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return mindspore::schema::v0::CreateNchw2Nhwc(
      _fbb);
}

inline Nhwc2NchwT *Nhwc2Nchw::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<Nhwc2NchwT>(new Nhwc2NchwT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Nhwc2Nchw::UnPackTo(Nhwc2NchwT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<Nhwc2Nchw> Nhwc2Nchw::Pack(flatbuffers::FlatBufferBuilder &_fbb, const Nhwc2NchwT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateNhwc2Nchw(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Nhwc2Nchw> CreateNhwc2Nchw(flatbuffers::FlatBufferBuilder &_fbb, const Nhwc2NchwT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const Nhwc2NchwT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return mindspore::schema::v0::CreateNhwc2Nchw(
      _fbb);
}

inline FakeQuantWithMinMaxVarsT *FakeQuantWithMinMaxVars::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<FakeQuantWithMinMaxVarsT>(new FakeQuantWithMinMaxVarsT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void FakeQuantWithMinMaxVars::UnPackTo(FakeQuantWithMinMaxVarsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = narrowRange(); _o->narrowRange = _e; }
  { auto _e = numBits(); _o->numBits = _e; }
}

inline flatbuffers::Offset<FakeQuantWithMinMaxVars> FakeQuantWithMinMaxVars::Pack(flatbuffers::FlatBufferBuilder &_fbb, const FakeQuantWithMinMaxVarsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateFakeQuantWithMinMaxVars(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<FakeQuantWithMinMaxVars> CreateFakeQuantWithMinMaxVars(flatbuffers::FlatBufferBuilder &_fbb, const FakeQuantWithMinMaxVarsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const FakeQuantWithMinMaxVarsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _narrowRange = _o->narrowRange;
  auto _numBits = _o->numBits;
  return mindspore::schema::v0::CreateFakeQuantWithMinMaxVars(
      _fbb,
      _narrowRange,
      _numBits);
}

inline BiasAddT *BiasAdd::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<BiasAddT>(new BiasAddT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void BiasAdd::UnPackTo(BiasAddT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = axis(); if (_e) { _o->axis.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->axis[_i] = _e->Get(_i); } } }
}

inline flatbuffers::Offset<BiasAdd> BiasAdd::Pack(flatbuffers::FlatBufferBuilder &_fbb, const BiasAddT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateBiasAdd(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<BiasAdd> CreateBiasAdd(flatbuffers::FlatBufferBuilder &_fbb, const BiasAddT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const BiasAddT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _axis = _o->axis.size() ? _fbb.CreateVector(_o->axis) : 0;
  return mindspore::schema::v0::CreateBiasAdd(
      _fbb,
      _axis);
}

inline ROIPoolingT *ROIPooling::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<ROIPoolingT>(new ROIPoolingT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void ROIPooling::UnPackTo(ROIPoolingT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = pooledH(); _o->pooledH = _e; }
  { auto _e = pooledW(); _o->pooledW = _e; }
  { auto _e = scale(); _o->scale = _e; }
}

inline flatbuffers::Offset<ROIPooling> ROIPooling::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ROIPoolingT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateROIPooling(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<ROIPooling> CreateROIPooling(flatbuffers::FlatBufferBuilder &_fbb, const ROIPoolingT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ROIPoolingT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _pooledH = _o->pooledH;
  auto _pooledW = _o->pooledW;
  auto _scale = _o->scale;
  return mindspore::schema::v0::CreateROIPooling(
      _fbb,
      _pooledH,
      _pooledW,
      _scale);
}

inline PoolingT *Pooling::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<PoolingT>(new PoolingT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Pooling::UnPackTo(PoolingT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = format(); _o->format = _e; }
  { auto _e = poolingMode(); _o->poolingMode = _e; }
  { auto _e = global(); _o->global = _e; }
  { auto _e = windowW(); _o->windowW = _e; }
  { auto _e = windowH(); _o->windowH = _e; }
  { auto _e = strideW(); _o->strideW = _e; }
  { auto _e = strideH(); _o->strideH = _e; }
  { auto _e = padMode(); _o->padMode = _e; }
  { auto _e = padUp(); _o->padUp = _e; }
  { auto _e = padDown(); _o->padDown = _e; }
  { auto _e = padLeft(); _o->padLeft = _e; }
  { auto _e = padRight(); _o->padRight = _e; }
  { auto _e = roundMode(); _o->roundMode = _e; }
  { auto _e = activationType(); _o->activationType = _e; }
  { auto _e = avgMode(); _o->avgMode = _e; }
}

inline flatbuffers::Offset<Pooling> Pooling::Pack(flatbuffers::FlatBufferBuilder &_fbb, const PoolingT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreatePooling(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Pooling> CreatePooling(flatbuffers::FlatBufferBuilder &_fbb, const PoolingT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const PoolingT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _format = _o->format;
  auto _poolingMode = _o->poolingMode;
  auto _global = _o->global;
  auto _windowW = _o->windowW;
  auto _windowH = _o->windowH;
  auto _strideW = _o->strideW;
  auto _strideH = _o->strideH;
  auto _padMode = _o->padMode;
  auto _padUp = _o->padUp;
  auto _padDown = _o->padDown;
  auto _padLeft = _o->padLeft;
  auto _padRight = _o->padRight;
  auto _roundMode = _o->roundMode;
  auto _activationType = _o->activationType;
  auto _avgMode = _o->avgMode;
  return mindspore::schema::v0::CreatePooling(
      _fbb,
      _format,
      _poolingMode,
      _global,
      _windowW,
      _windowH,
      _strideW,
      _strideH,
      _padMode,
      _padUp,
      _padDown,
      _padLeft,
      _padRight,
      _roundMode,
      _activationType,
      _avgMode);
}

inline DepthwiseConv2DT *DepthwiseConv2D::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<DepthwiseConv2DT>(new DepthwiseConv2DT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void DepthwiseConv2D::UnPackTo(DepthwiseConv2DT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = format(); _o->format = _e; }
  { auto _e = channelIn(); _o->channelIn = _e; }
  { auto _e = channelMultiplier(); _o->channelMultiplier = _e; }
  { auto _e = kernelW(); _o->kernelW = _e; }
  { auto _e = kernelH(); _o->kernelH = _e; }
  { auto _e = strideW(); _o->strideW = _e; }
  { auto _e = strideH(); _o->strideH = _e; }
  { auto _e = padMode(); _o->padMode = _e; }
  { auto _e = padUp(); _o->padUp = _e; }
  { auto _e = padDown(); _o->padDown = _e; }
  { auto _e = padLeft(); _o->padLeft = _e; }
  { auto _e = padRight(); _o->padRight = _e; }
  { auto _e = dilateW(); _o->dilateW = _e; }
  { auto _e = dilateH(); _o->dilateH = _e; }
  { auto _e = hasBias(); _o->hasBias = _e; }
  { auto _e = activationType(); _o->activationType = _e; }
}

inline flatbuffers::Offset<DepthwiseConv2D> DepthwiseConv2D::Pack(flatbuffers::FlatBufferBuilder &_fbb, const DepthwiseConv2DT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateDepthwiseConv2D(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<DepthwiseConv2D> CreateDepthwiseConv2D(flatbuffers::FlatBufferBuilder &_fbb, const DepthwiseConv2DT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const DepthwiseConv2DT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _format = _o->format;
  auto _channelIn = _o->channelIn;
  auto _channelMultiplier = _o->channelMultiplier;
  auto _kernelW = _o->kernelW;
  auto _kernelH = _o->kernelH;
  auto _strideW = _o->strideW;
  auto _strideH = _o->strideH;
  auto _padMode = _o->padMode;
  auto _padUp = _o->padUp;
  auto _padDown = _o->padDown;
  auto _padLeft = _o->padLeft;
  auto _padRight = _o->padRight;
  auto _dilateW = _o->dilateW;
  auto _dilateH = _o->dilateH;
  auto _hasBias = _o->hasBias;
  auto _activationType = _o->activationType;
  return mindspore::schema::v0::CreateDepthwiseConv2D(
      _fbb,
      _format,
      _channelIn,
      _channelMultiplier,
      _kernelW,
      _kernelH,
      _strideW,
      _strideH,
      _padMode,
      _padUp,
      _padDown,
      _padLeft,
      _padRight,
      _dilateW,
      _dilateH,
      _hasBias,
      _activationType);
}

inline DeDepthwiseConv2DT *DeDepthwiseConv2D::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<DeDepthwiseConv2DT>(new DeDepthwiseConv2DT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void DeDepthwiseConv2D::UnPackTo(DeDepthwiseConv2DT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = format(); _o->format = _e; }
  { auto _e = channelIn(); _o->channelIn = _e; }
  { auto _e = channelMultiplier(); _o->channelMultiplier = _e; }
  { auto _e = kernelW(); _o->kernelW = _e; }
  { auto _e = kernelH(); _o->kernelH = _e; }
  { auto _e = strideW(); _o->strideW = _e; }
  { auto _e = strideH(); _o->strideH = _e; }
  { auto _e = padMode(); _o->padMode = _e; }
  { auto _e = padUp(); _o->padUp = _e; }
  { auto _e = padDown(); _o->padDown = _e; }
  { auto _e = padLeft(); _o->padLeft = _e; }
  { auto _e = padRight(); _o->padRight = _e; }
  { auto _e = dilateW(); _o->dilateW = _e; }
  { auto _e = dilateH(); _o->dilateH = _e; }
  { auto _e = hasBias(); _o->hasBias = _e; }
  { auto _e = activationType(); _o->activationType = _e; }
}

inline flatbuffers::Offset<DeDepthwiseConv2D> DeDepthwiseConv2D::Pack(flatbuffers::FlatBufferBuilder &_fbb, const DeDepthwiseConv2DT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateDeDepthwiseConv2D(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<DeDepthwiseConv2D> CreateDeDepthwiseConv2D(flatbuffers::FlatBufferBuilder &_fbb, const DeDepthwiseConv2DT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const DeDepthwiseConv2DT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _format = _o->format;
  auto _channelIn = _o->channelIn;
  auto _channelMultiplier = _o->channelMultiplier;
  auto _kernelW = _o->kernelW;
  auto _kernelH = _o->kernelH;
  auto _strideW = _o->strideW;
  auto _strideH = _o->strideH;
  auto _padMode = _o->padMode;
  auto _padUp = _o->padUp;
  auto _padDown = _o->padDown;
  auto _padLeft = _o->padLeft;
  auto _padRight = _o->padRight;
  auto _dilateW = _o->dilateW;
  auto _dilateH = _o->dilateH;
  auto _hasBias = _o->hasBias;
  auto _activationType = _o->activationType;
  return mindspore::schema::v0::CreateDeDepthwiseConv2D(
      _fbb,
      _format,
      _channelIn,
      _channelMultiplier,
      _kernelW,
      _kernelH,
      _strideW,
      _strideH,
      _padMode,
      _padUp,
      _padDown,
      _padLeft,
      _padRight,
      _dilateW,
      _dilateH,
      _hasBias,
      _activationType);
}

inline ResizeT *Resize::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<ResizeT>(new ResizeT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Resize::UnPackTo(ResizeT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = format(); _o->format = _e; }
  { auto _e = method(); _o->method = _e; }
  { auto _e = newHeight(); _o->newHeight = _e; }
  { auto _e = newWidth(); _o->newWidth = _e; }
  { auto _e = alignCorners(); _o->alignCorners = _e; }
  { auto _e = preserveAspectRatio(); _o->preserveAspectRatio = _e; }
  { auto _e = coordinateTransformMode(); _o->coordinateTransformMode = _e; }
  { auto _e = cubicCoeff(); _o->cubicCoeff = _e; }
  { auto _e = excludeOutside(); _o->excludeOutside = _e; }
  { auto _e = extrapolationValue(); _o->extrapolationValue = _e; }
  { auto _e = nearestMode(); _o->nearestMode = _e; }
}

inline flatbuffers::Offset<Resize> Resize::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ResizeT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateResize(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Resize> CreateResize(flatbuffers::FlatBufferBuilder &_fbb, const ResizeT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ResizeT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _format = _o->format;
  auto _method = _o->method;
  auto _newHeight = _o->newHeight;
  auto _newWidth = _o->newWidth;
  auto _alignCorners = _o->alignCorners;
  auto _preserveAspectRatio = _o->preserveAspectRatio;
  auto _coordinateTransformMode = _o->coordinateTransformMode;
  auto _cubicCoeff = _o->cubicCoeff;
  auto _excludeOutside = _o->excludeOutside;
  auto _extrapolationValue = _o->extrapolationValue;
  auto _nearestMode = _o->nearestMode;
  return mindspore::schema::v0::CreateResize(
      _fbb,
      _format,
      _method,
      _newHeight,
      _newWidth,
      _alignCorners,
      _preserveAspectRatio,
      _coordinateTransformMode,
      _cubicCoeff,
      _excludeOutside,
      _extrapolationValue,
      _nearestMode);
}

inline DetectionPostProcessT *DetectionPostProcess::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<DetectionPostProcessT>(new DetectionPostProcessT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void DetectionPostProcess::UnPackTo(DetectionPostProcessT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = format(); _o->format = _e; }
  { auto _e = inputSize(); _o->inputSize = _e; }
  { auto _e = hScale(); _o->hScale = _e; }
  { auto _e = wScale(); _o->wScale = _e; }
  { auto _e = xScale(); _o->xScale = _e; }
  { auto _e = yScale(); _o->yScale = _e; }
  { auto _e = NmsIouThreshold(); _o->NmsIouThreshold = _e; }
  { auto _e = NmsScoreThreshold(); _o->NmsScoreThreshold = _e; }
  { auto _e = MaxDetections(); _o->MaxDetections = _e; }
  { auto _e = DetectionsPerClass(); _o->DetectionsPerClass = _e; }
  { auto _e = MaxClassesPerDetection(); _o->MaxClassesPerDetection = _e; }
  { auto _e = NumClasses(); _o->NumClasses = _e; }
  { auto _e = UseRegularNms(); _o->UseRegularNms = _e; }
  { auto _e = OutQuantized(); _o->OutQuantized = _e; }
}

inline flatbuffers::Offset<DetectionPostProcess> DetectionPostProcess::Pack(flatbuffers::FlatBufferBuilder &_fbb, const DetectionPostProcessT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateDetectionPostProcess(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<DetectionPostProcess> CreateDetectionPostProcess(flatbuffers::FlatBufferBuilder &_fbb, const DetectionPostProcessT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const DetectionPostProcessT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _format = _o->format;
  auto _inputSize = _o->inputSize;
  auto _hScale = _o->hScale;
  auto _wScale = _o->wScale;
  auto _xScale = _o->xScale;
  auto _yScale = _o->yScale;
  auto _NmsIouThreshold = _o->NmsIouThreshold;
  auto _NmsScoreThreshold = _o->NmsScoreThreshold;
  auto _MaxDetections = _o->MaxDetections;
  auto _DetectionsPerClass = _o->DetectionsPerClass;
  auto _MaxClassesPerDetection = _o->MaxClassesPerDetection;
  auto _NumClasses = _o->NumClasses;
  auto _UseRegularNms = _o->UseRegularNms;
  auto _OutQuantized = _o->OutQuantized;
  return mindspore::schema::v0::CreateDetectionPostProcess(
      _fbb,
      _format,
      _inputSize,
      _hScale,
      _wScale,
      _xScale,
      _yScale,
      _NmsIouThreshold,
      _NmsScoreThreshold,
      _MaxDetections,
      _DetectionsPerClass,
      _MaxClassesPerDetection,
      _NumClasses,
      _UseRegularNms,
      _OutQuantized);
}

inline FullConnectionT *FullConnection::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<FullConnectionT>(new FullConnectionT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void FullConnection::UnPackTo(FullConnectionT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = hasBias(); _o->hasBias = _e; }
  { auto _e = axis(); _o->axis = _e; }
  { auto _e = useAxis(); _o->useAxis = _e; }
  { auto _e = activationType(); _o->activationType = _e; }
}

inline flatbuffers::Offset<FullConnection> FullConnection::Pack(flatbuffers::FlatBufferBuilder &_fbb, const FullConnectionT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateFullConnection(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<FullConnection> CreateFullConnection(flatbuffers::FlatBufferBuilder &_fbb, const FullConnectionT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const FullConnectionT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _hasBias = _o->hasBias;
  auto _axis = _o->axis;
  auto _useAxis = _o->useAxis;
  auto _activationType = _o->activationType;
  return mindspore::schema::v0::CreateFullConnection(
      _fbb,
      _hasBias,
      _axis,
      _useAxis,
      _activationType);
}

inline MeanT *Mean::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<MeanT>(new MeanT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Mean::UnPackTo(MeanT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = axis(); if (_e) { _o->axis.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->axis[_i] = _e->Get(_i); } } }
  { auto _e = keepDims(); _o->keepDims = _e; }
}

inline flatbuffers::Offset<Mean> Mean::Pack(flatbuffers::FlatBufferBuilder &_fbb, const MeanT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateMean(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Mean> CreateMean(flatbuffers::FlatBufferBuilder &_fbb, const MeanT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const MeanT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _axis = _o->axis.size() ? _fbb.CreateVector(_o->axis) : 0;
  auto _keepDims = _o->keepDims;
  return mindspore::schema::v0::CreateMean(
      _fbb,
      _axis,
      _keepDims);
}

inline DeConv2DT *DeConv2D::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<DeConv2DT>(new DeConv2DT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void DeConv2D::UnPackTo(DeConv2DT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = format(); _o->format = _e; }
  { auto _e = group(); _o->group = _e; }
  { auto _e = channelIn(); _o->channelIn = _e; }
  { auto _e = channelOut(); _o->channelOut = _e; }
  { auto _e = kernelW(); _o->kernelW = _e; }
  { auto _e = kernelH(); _o->kernelH = _e; }
  { auto _e = strideW(); _o->strideW = _e; }
  { auto _e = strideH(); _o->strideH = _e; }
  { auto _e = padMode(); _o->padMode = _e; }
  { auto _e = padUp(); _o->padUp = _e; }
  { auto _e = padDown(); _o->padDown = _e; }
  { auto _e = padLeft(); _o->padLeft = _e; }
  { auto _e = padRight(); _o->padRight = _e; }
  { auto _e = dilateW(); _o->dilateW = _e; }
  { auto _e = dilateH(); _o->dilateH = _e; }
  { auto _e = hasBias(); _o->hasBias = _e; }
  { auto _e = activationType(); _o->activationType = _e; }
}

inline flatbuffers::Offset<DeConv2D> DeConv2D::Pack(flatbuffers::FlatBufferBuilder &_fbb, const DeConv2DT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateDeConv2D(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<DeConv2D> CreateDeConv2D(flatbuffers::FlatBufferBuilder &_fbb, const DeConv2DT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const DeConv2DT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _format = _o->format;
  auto _group = _o->group;
  auto _channelIn = _o->channelIn;
  auto _channelOut = _o->channelOut;
  auto _kernelW = _o->kernelW;
  auto _kernelH = _o->kernelH;
  auto _strideW = _o->strideW;
  auto _strideH = _o->strideH;
  auto _padMode = _o->padMode;
  auto _padUp = _o->padUp;
  auto _padDown = _o->padDown;
  auto _padLeft = _o->padLeft;
  auto _padRight = _o->padRight;
  auto _dilateW = _o->dilateW;
  auto _dilateH = _o->dilateH;
  auto _hasBias = _o->hasBias;
  auto _activationType = _o->activationType;
  return mindspore::schema::v0::CreateDeConv2D(
      _fbb,
      _format,
      _group,
      _channelIn,
      _channelOut,
      _kernelW,
      _kernelH,
      _strideW,
      _strideH,
      _padMode,
      _padUp,
      _padDown,
      _padLeft,
      _padRight,
      _dilateW,
      _dilateH,
      _hasBias,
      _activationType);
}

inline DeConv2DGradFilterT *DeConv2DGradFilter::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<DeConv2DGradFilterT>(new DeConv2DGradFilterT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void DeConv2DGradFilter::UnPackTo(DeConv2DGradFilterT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = format(); _o->format = _e; }
  { auto _e = group(); _o->group = _e; }
  { auto _e = channelIn(); _o->channelIn = _e; }
  { auto _e = channelOut(); _o->channelOut = _e; }
  { auto _e = kernelW(); _o->kernelW = _e; }
  { auto _e = kernelH(); _o->kernelH = _e; }
  { auto _e = strideW(); _o->strideW = _e; }
  { auto _e = strideH(); _o->strideH = _e; }
  { auto _e = padMode(); _o->padMode = _e; }
  { auto _e = padUp(); _o->padUp = _e; }
  { auto _e = padDown(); _o->padDown = _e; }
  { auto _e = padLeft(); _o->padLeft = _e; }
  { auto _e = padRight(); _o->padRight = _e; }
  { auto _e = dilateW(); _o->dilateW = _e; }
  { auto _e = dilateH(); _o->dilateH = _e; }
  { auto _e = hasBias(); _o->hasBias = _e; }
  { auto _e = activationType(); _o->activationType = _e; }
}

inline flatbuffers::Offset<DeConv2DGradFilter> DeConv2DGradFilter::Pack(flatbuffers::FlatBufferBuilder &_fbb, const DeConv2DGradFilterT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateDeConv2DGradFilter(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<DeConv2DGradFilter> CreateDeConv2DGradFilter(flatbuffers::FlatBufferBuilder &_fbb, const DeConv2DGradFilterT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const DeConv2DGradFilterT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _format = _o->format;
  auto _group = _o->group;
  auto _channelIn = _o->channelIn;
  auto _channelOut = _o->channelOut;
  auto _kernelW = _o->kernelW;
  auto _kernelH = _o->kernelH;
  auto _strideW = _o->strideW;
  auto _strideH = _o->strideH;
  auto _padMode = _o->padMode;
  auto _padUp = _o->padUp;
  auto _padDown = _o->padDown;
  auto _padLeft = _o->padLeft;
  auto _padRight = _o->padRight;
  auto _dilateW = _o->dilateW;
  auto _dilateH = _o->dilateH;
  auto _hasBias = _o->hasBias;
  auto _activationType = _o->activationType;
  return mindspore::schema::v0::CreateDeConv2DGradFilter(
      _fbb,
      _format,
      _group,
      _channelIn,
      _channelOut,
      _kernelW,
      _kernelH,
      _strideW,
      _strideH,
      _padMode,
      _padUp,
      _padDown,
      _padLeft,
      _padRight,
      _dilateW,
      _dilateH,
      _hasBias,
      _activationType);
}

inline BNGradT *BNGrad::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<BNGradT>(new BNGradT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void BNGrad::UnPackTo(BNGradT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = eps(); _o->eps = _e; }
  { auto _e = momentum(); _o->momentum = _e; }
}

inline flatbuffers::Offset<BNGrad> BNGrad::Pack(flatbuffers::FlatBufferBuilder &_fbb, const BNGradT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateBNGrad(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<BNGrad> CreateBNGrad(flatbuffers::FlatBufferBuilder &_fbb, const BNGradT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const BNGradT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _eps = _o->eps;
  auto _momentum = _o->momentum;
  return mindspore::schema::v0::CreateBNGrad(
      _fbb,
      _eps,
      _momentum);
}

inline ScaleT *Scale::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<ScaleT>(new ScaleT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Scale::UnPackTo(ScaleT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = axis(); _o->axis = _e; }
  { auto _e = activationType(); _o->activationType = _e; }
}

inline flatbuffers::Offset<Scale> Scale::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ScaleT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateScale(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Scale> CreateScale(flatbuffers::FlatBufferBuilder &_fbb, const ScaleT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ScaleT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _axis = _o->axis;
  auto _activationType = _o->activationType;
  return mindspore::schema::v0::CreateScale(
      _fbb,
      _axis,
      _activationType);
}

inline EltwiseT *Eltwise::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<EltwiseT>(new EltwiseT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Eltwise::UnPackTo(EltwiseT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = mode(); _o->mode = _e; }
}

inline flatbuffers::Offset<Eltwise> Eltwise::Pack(flatbuffers::FlatBufferBuilder &_fbb, const EltwiseT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateEltwise(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Eltwise> CreateEltwise(flatbuffers::FlatBufferBuilder &_fbb, const EltwiseT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const EltwiseT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _mode = _o->mode;
  return mindspore::schema::v0::CreateEltwise(
      _fbb,
      _mode);
}

inline AddT *Add::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<AddT>(new AddT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Add::UnPackTo(AddT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = activationType(); _o->activationType = _e; }
}

inline flatbuffers::Offset<Add> Add::Pack(flatbuffers::FlatBufferBuilder &_fbb, const AddT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateAdd(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Add> CreateAdd(flatbuffers::FlatBufferBuilder &_fbb, const AddT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const AddT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _activationType = _o->activationType;
  return mindspore::schema::v0::CreateAdd(
      _fbb,
      _activationType);
}

inline SubT *Sub::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<SubT>(new SubT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Sub::UnPackTo(SubT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = activationType(); _o->activationType = _e; }
}

inline flatbuffers::Offset<Sub> Sub::Pack(flatbuffers::FlatBufferBuilder &_fbb, const SubT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateSub(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Sub> CreateSub(flatbuffers::FlatBufferBuilder &_fbb, const SubT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const SubT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _activationType = _o->activationType;
  return mindspore::schema::v0::CreateSub(
      _fbb,
      _activationType);
}

inline MulT *Mul::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<MulT>(new MulT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Mul::UnPackTo(MulT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = activationType(); _o->activationType = _e; }
}

inline flatbuffers::Offset<Mul> Mul::Pack(flatbuffers::FlatBufferBuilder &_fbb, const MulT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateMul(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Mul> CreateMul(flatbuffers::FlatBufferBuilder &_fbb, const MulT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const MulT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _activationType = _o->activationType;
  return mindspore::schema::v0::CreateMul(
      _fbb,
      _activationType);
}

inline DivT *Div::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<DivT>(new DivT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Div::UnPackTo(DivT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = activationType(); _o->activationType = _e; }
}

inline flatbuffers::Offset<Div> Div::Pack(flatbuffers::FlatBufferBuilder &_fbb, const DivT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateDiv(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Div> CreateDiv(flatbuffers::FlatBufferBuilder &_fbb, const DivT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const DivT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _activationType = _o->activationType;
  return mindspore::schema::v0::CreateDiv(
      _fbb,
      _activationType);
}

inline AddGradT *AddGrad::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<AddGradT>(new AddGradT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void AddGrad::UnPackTo(AddGradT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<AddGrad> AddGrad::Pack(flatbuffers::FlatBufferBuilder &_fbb, const AddGradT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateAddGrad(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<AddGrad> CreateAddGrad(flatbuffers::FlatBufferBuilder &_fbb, const AddGradT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const AddGradT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return mindspore::schema::v0::CreateAddGrad(
      _fbb);
}

inline SubGradT *SubGrad::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<SubGradT>(new SubGradT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void SubGrad::UnPackTo(SubGradT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<SubGrad> SubGrad::Pack(flatbuffers::FlatBufferBuilder &_fbb, const SubGradT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateSubGrad(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<SubGrad> CreateSubGrad(flatbuffers::FlatBufferBuilder &_fbb, const SubGradT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const SubGradT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return mindspore::schema::v0::CreateSubGrad(
      _fbb);
}

inline MulGradT *MulGrad::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<MulGradT>(new MulGradT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void MulGrad::UnPackTo(MulGradT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<MulGrad> MulGrad::Pack(flatbuffers::FlatBufferBuilder &_fbb, const MulGradT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateMulGrad(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<MulGrad> CreateMulGrad(flatbuffers::FlatBufferBuilder &_fbb, const MulGradT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const MulGradT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return mindspore::schema::v0::CreateMulGrad(
      _fbb);
}

inline DivGradT *DivGrad::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<DivGradT>(new DivGradT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void DivGrad::UnPackTo(DivGradT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<DivGrad> DivGrad::Pack(flatbuffers::FlatBufferBuilder &_fbb, const DivGradT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateDivGrad(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<DivGrad> CreateDivGrad(flatbuffers::FlatBufferBuilder &_fbb, const DivGradT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const DivGradT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return mindspore::schema::v0::CreateDivGrad(
      _fbb);
}

inline RealDivT *RealDiv::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<RealDivT>(new RealDivT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void RealDiv::UnPackTo(RealDivT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<RealDiv> RealDiv::Pack(flatbuffers::FlatBufferBuilder &_fbb, const RealDivT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateRealDiv(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<RealDiv> CreateRealDiv(flatbuffers::FlatBufferBuilder &_fbb, const RealDivT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const RealDivT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return mindspore::schema::v0::CreateRealDiv(
      _fbb);
}

inline RsqrtT *Rsqrt::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<RsqrtT>(new RsqrtT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Rsqrt::UnPackTo(RsqrtT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<Rsqrt> Rsqrt::Pack(flatbuffers::FlatBufferBuilder &_fbb, const RsqrtT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateRsqrt(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Rsqrt> CreateRsqrt(flatbuffers::FlatBufferBuilder &_fbb, const RsqrtT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const RsqrtT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return mindspore::schema::v0::CreateRsqrt(
      _fbb);
}

inline EqualT *Equal::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<EqualT>(new EqualT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Equal::UnPackTo(EqualT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<Equal> Equal::Pack(flatbuffers::FlatBufferBuilder &_fbb, const EqualT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateEqual(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Equal> CreateEqual(flatbuffers::FlatBufferBuilder &_fbb, const EqualT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const EqualT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return mindspore::schema::v0::CreateEqual(
      _fbb);
}

inline LessT *Less::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<LessT>(new LessT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Less::UnPackTo(LessT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<Less> Less::Pack(flatbuffers::FlatBufferBuilder &_fbb, const LessT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateLess(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Less> CreateLess(flatbuffers::FlatBufferBuilder &_fbb, const LessT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const LessT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return mindspore::schema::v0::CreateLess(
      _fbb);
}

inline GreaterT *Greater::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<GreaterT>(new GreaterT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Greater::UnPackTo(GreaterT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<Greater> Greater::Pack(flatbuffers::FlatBufferBuilder &_fbb, const GreaterT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateGreater(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Greater> CreateGreater(flatbuffers::FlatBufferBuilder &_fbb, const GreaterT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const GreaterT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return mindspore::schema::v0::CreateGreater(
      _fbb);
}

inline NotEqualT *NotEqual::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<NotEqualT>(new NotEqualT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void NotEqual::UnPackTo(NotEqualT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<NotEqual> NotEqual::Pack(flatbuffers::FlatBufferBuilder &_fbb, const NotEqualT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateNotEqual(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<NotEqual> CreateNotEqual(flatbuffers::FlatBufferBuilder &_fbb, const NotEqualT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const NotEqualT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return mindspore::schema::v0::CreateNotEqual(
      _fbb);
}

inline LessEqualT *LessEqual::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<LessEqualT>(new LessEqualT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void LessEqual::UnPackTo(LessEqualT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<LessEqual> LessEqual::Pack(flatbuffers::FlatBufferBuilder &_fbb, const LessEqualT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateLessEqual(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<LessEqual> CreateLessEqual(flatbuffers::FlatBufferBuilder &_fbb, const LessEqualT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const LessEqualT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return mindspore::schema::v0::CreateLessEqual(
      _fbb);
}

inline GreaterEqualT *GreaterEqual::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<GreaterEqualT>(new GreaterEqualT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void GreaterEqual::UnPackTo(GreaterEqualT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<GreaterEqual> GreaterEqual::Pack(flatbuffers::FlatBufferBuilder &_fbb, const GreaterEqualT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateGreaterEqual(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<GreaterEqual> CreateGreaterEqual(flatbuffers::FlatBufferBuilder &_fbb, const GreaterEqualT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const GreaterEqualT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return mindspore::schema::v0::CreateGreaterEqual(
      _fbb);
}

inline MinT *Min::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<MinT>(new MinT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Min::UnPackTo(MinT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<Min> Min::Pack(flatbuffers::FlatBufferBuilder &_fbb, const MinT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateMin(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Min> CreateMin(flatbuffers::FlatBufferBuilder &_fbb, const MinT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const MinT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return mindspore::schema::v0::CreateMin(
      _fbb);
}

inline SliceT *Slice::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<SliceT>(new SliceT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Slice::UnPackTo(SliceT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = format(); _o->format = _e; }
  { auto _e = axes(); if (_e) { _o->axes.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->axes[_i] = _e->Get(_i); } } }
  { auto _e = begin(); if (_e) { _o->begin.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->begin[_i] = _e->Get(_i); } } }
  { auto _e = size(); if (_e) { _o->size.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->size[_i] = _e->Get(_i); } } }
}

inline flatbuffers::Offset<Slice> Slice::Pack(flatbuffers::FlatBufferBuilder &_fbb, const SliceT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateSlice(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Slice> CreateSlice(flatbuffers::FlatBufferBuilder &_fbb, const SliceT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const SliceT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _format = _o->format;
  auto _axes = _o->axes.size() ? _fbb.CreateVector(_o->axes) : 0;
  auto _begin = _o->begin.size() ? _fbb.CreateVector(_o->begin) : 0;
  auto _size = _o->size.size() ? _fbb.CreateVector(_o->size) : 0;
  return mindspore::schema::v0::CreateSlice(
      _fbb,
      _format,
      _axes,
      _begin,
      _size);
}

inline FloorT *Floor::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<FloorT>(new FloorT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Floor::UnPackTo(FloorT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<Floor> Floor::Pack(flatbuffers::FlatBufferBuilder &_fbb, const FloorT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateFloor(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Floor> CreateFloor(flatbuffers::FlatBufferBuilder &_fbb, const FloorT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const FloorT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return mindspore::schema::v0::CreateFloor(
      _fbb);
}

inline AbsT *Abs::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<AbsT>(new AbsT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Abs::UnPackTo(AbsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<Abs> Abs::Pack(flatbuffers::FlatBufferBuilder &_fbb, const AbsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateAbs(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Abs> CreateAbs(flatbuffers::FlatBufferBuilder &_fbb, const AbsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const AbsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return mindspore::schema::v0::CreateAbs(
      _fbb);
}

inline NegT *Neg::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<NegT>(new NegT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Neg::UnPackTo(NegT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<Neg> Neg::Pack(flatbuffers::FlatBufferBuilder &_fbb, const NegT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateNeg(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Neg> CreateNeg(flatbuffers::FlatBufferBuilder &_fbb, const NegT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const NegT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return mindspore::schema::v0::CreateNeg(
      _fbb);
}

inline NegGradT *NegGrad::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<NegGradT>(new NegGradT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void NegGrad::UnPackTo(NegGradT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<NegGrad> NegGrad::Pack(flatbuffers::FlatBufferBuilder &_fbb, const NegGradT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateNegGrad(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<NegGrad> CreateNegGrad(flatbuffers::FlatBufferBuilder &_fbb, const NegGradT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const NegGradT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return mindspore::schema::v0::CreateNegGrad(
      _fbb);
}

inline ExpT *Exp::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<ExpT>(new ExpT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Exp::UnPackTo(ExpT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = base(); _o->base = _e; }
  { auto _e = scale(); _o->scale = _e; }
  { auto _e = shift(); _o->shift = _e; }
}

inline flatbuffers::Offset<Exp> Exp::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ExpT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateExp(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Exp> CreateExp(flatbuffers::FlatBufferBuilder &_fbb, const ExpT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ExpT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _base = _o->base;
  auto _scale = _o->scale;
  auto _shift = _o->shift;
  return mindspore::schema::v0::CreateExp(
      _fbb,
      _base,
      _scale,
      _shift);
}

inline CosT *Cos::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<CosT>(new CosT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Cos::UnPackTo(CosT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<Cos> Cos::Pack(flatbuffers::FlatBufferBuilder &_fbb, const CosT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateCos(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Cos> CreateCos(flatbuffers::FlatBufferBuilder &_fbb, const CosT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const CosT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return mindspore::schema::v0::CreateCos(
      _fbb);
}

inline SinT *Sin::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<SinT>(new SinT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Sin::UnPackTo(SinT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<Sin> Sin::Pack(flatbuffers::FlatBufferBuilder &_fbb, const SinT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateSin(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Sin> CreateSin(flatbuffers::FlatBufferBuilder &_fbb, const SinT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const SinT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return mindspore::schema::v0::CreateSin(
      _fbb);
}

inline SqrtT *Sqrt::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<SqrtT>(new SqrtT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Sqrt::UnPackTo(SqrtT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<Sqrt> Sqrt::Pack(flatbuffers::FlatBufferBuilder &_fbb, const SqrtT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateSqrt(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Sqrt> CreateSqrt(flatbuffers::FlatBufferBuilder &_fbb, const SqrtT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const SqrtT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return mindspore::schema::v0::CreateSqrt(
      _fbb);
}

inline SquareT *Square::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<SquareT>(new SquareT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Square::UnPackTo(SquareT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<Square> Square::Pack(flatbuffers::FlatBufferBuilder &_fbb, const SquareT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateSquare(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Square> CreateSquare(flatbuffers::FlatBufferBuilder &_fbb, const SquareT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const SquareT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return mindspore::schema::v0::CreateSquare(
      _fbb);
}

inline CeilT *Ceil::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<CeilT>(new CeilT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Ceil::UnPackTo(CeilT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<Ceil> Ceil::Pack(flatbuffers::FlatBufferBuilder &_fbb, const CeilT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateCeil(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Ceil> CreateCeil(flatbuffers::FlatBufferBuilder &_fbb, const CeilT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const CeilT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return mindspore::schema::v0::CreateCeil(
      _fbb);
}

inline LogT *Log::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<LogT>(new LogT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Log::UnPackTo(LogT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<Log> Log::Pack(flatbuffers::FlatBufferBuilder &_fbb, const LogT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateLog(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Log> CreateLog(flatbuffers::FlatBufferBuilder &_fbb, const LogT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const LogT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return mindspore::schema::v0::CreateLog(
      _fbb);
}

inline LogGradT *LogGrad::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<LogGradT>(new LogGradT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void LogGrad::UnPackTo(LogGradT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<LogGrad> LogGrad::Pack(flatbuffers::FlatBufferBuilder &_fbb, const LogGradT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateLogGrad(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<LogGrad> CreateLogGrad(flatbuffers::FlatBufferBuilder &_fbb, const LogGradT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const LogGradT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return mindspore::schema::v0::CreateLogGrad(
      _fbb);
}

inline TanT *Tan::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<TanT>(new TanT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Tan::UnPackTo(TanT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<Tan> Tan::Pack(flatbuffers::FlatBufferBuilder &_fbb, const TanT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateTan(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Tan> CreateTan(flatbuffers::FlatBufferBuilder &_fbb, const TanT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const TanT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return mindspore::schema::v0::CreateTan(
      _fbb);
}

inline AtanT *Atan::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<AtanT>(new AtanT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Atan::UnPackTo(AtanT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<Atan> Atan::Pack(flatbuffers::FlatBufferBuilder &_fbb, const AtanT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateAtan(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Atan> CreateAtan(flatbuffers::FlatBufferBuilder &_fbb, const AtanT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const AtanT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return mindspore::schema::v0::CreateAtan(
      _fbb);
}

inline AsinT *Asin::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<AsinT>(new AsinT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Asin::UnPackTo(AsinT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<Asin> Asin::Pack(flatbuffers::FlatBufferBuilder &_fbb, const AsinT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateAsin(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Asin> CreateAsin(flatbuffers::FlatBufferBuilder &_fbb, const AsinT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const AsinT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return mindspore::schema::v0::CreateAsin(
      _fbb);
}

inline ReshapeT *Reshape::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<ReshapeT>(new ReshapeT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Reshape::UnPackTo(ReshapeT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = format(); _o->format = _e; }
  { auto _e = shape(); if (_e) { _o->shape.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->shape[_i] = _e->Get(_i); } } }
}

inline flatbuffers::Offset<Reshape> Reshape::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ReshapeT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateReshape(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Reshape> CreateReshape(flatbuffers::FlatBufferBuilder &_fbb, const ReshapeT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ReshapeT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _format = _o->format;
  auto _shape = _o->shape.size() ? _fbb.CreateVector(_o->shape) : 0;
  return mindspore::schema::v0::CreateReshape(
      _fbb,
      _format,
      _shape);
}

inline PowerT *Power::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<PowerT>(new PowerT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Power::UnPackTo(PowerT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = power(); _o->power = _e; }
  { auto _e = scale(); _o->scale = _e; }
  { auto _e = shift(); _o->shift = _e; }
}

inline flatbuffers::Offset<Power> Power::Pack(flatbuffers::FlatBufferBuilder &_fbb, const PowerT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreatePower(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Power> CreatePower(flatbuffers::FlatBufferBuilder &_fbb, const PowerT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const PowerT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _power = _o->power;
  auto _scale = _o->scale;
  auto _shift = _o->shift;
  return mindspore::schema::v0::CreatePower(
      _fbb,
      _power,
      _scale,
      _shift);
}

inline PowerGradT *PowerGrad::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<PowerGradT>(new PowerGradT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void PowerGrad::UnPackTo(PowerGradT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = power(); _o->power = _e; }
  { auto _e = scale(); _o->scale = _e; }
  { auto _e = shift(); _o->shift = _e; }
}

inline flatbuffers::Offset<PowerGrad> PowerGrad::Pack(flatbuffers::FlatBufferBuilder &_fbb, const PowerGradT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreatePowerGrad(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<PowerGrad> CreatePowerGrad(flatbuffers::FlatBufferBuilder &_fbb, const PowerGradT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const PowerGradT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _power = _o->power;
  auto _scale = _o->scale;
  auto _shift = _o->shift;
  return mindspore::schema::v0::CreatePowerGrad(
      _fbb,
      _power,
      _scale,
      _shift);
}

inline ArgMaxT *ArgMax::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<ArgMaxT>(new ArgMaxT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void ArgMax::UnPackTo(ArgMaxT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = axis(); _o->axis = _e; }
  { auto _e = outMaxValue(); _o->outMaxValue = _e; }
  { auto _e = topK(); _o->topK = _e; }
  { auto _e = keepDims(); _o->keepDims = _e; }
  { auto _e = axisType(); _o->axisType = _e; }
}

inline flatbuffers::Offset<ArgMax> ArgMax::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ArgMaxT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateArgMax(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<ArgMax> CreateArgMax(flatbuffers::FlatBufferBuilder &_fbb, const ArgMaxT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ArgMaxT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _axis = _o->axis;
  auto _outMaxValue = _o->outMaxValue;
  auto _topK = _o->topK;
  auto _keepDims = _o->keepDims;
  auto _axisType = _o->axisType;
  return mindspore::schema::v0::CreateArgMax(
      _fbb,
      _axis,
      _outMaxValue,
      _topK,
      _keepDims,
      _axisType);
}

inline ArgMinT *ArgMin::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<ArgMinT>(new ArgMinT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void ArgMin::UnPackTo(ArgMinT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = axis(); _o->axis = _e; }
  { auto _e = outMaxValue(); _o->outMaxValue = _e; }
  { auto _e = topK(); _o->topK = _e; }
  { auto _e = keepDims(); _o->keepDims = _e; }
  { auto _e = axisType(); _o->axisType = _e; }
}

inline flatbuffers::Offset<ArgMin> ArgMin::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ArgMinT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateArgMin(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<ArgMin> CreateArgMin(flatbuffers::FlatBufferBuilder &_fbb, const ArgMinT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ArgMinT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _axis = _o->axis;
  auto _outMaxValue = _o->outMaxValue;
  auto _topK = _o->topK;
  auto _keepDims = _o->keepDims;
  auto _axisType = _o->axisType;
  return mindspore::schema::v0::CreateArgMin(
      _fbb,
      _axis,
      _outMaxValue,
      _topK,
      _keepDims,
      _axisType);
}

inline NetOutputT *NetOutput::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<NetOutputT>(new NetOutputT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void NetOutput::UnPackTo(NetOutputT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<NetOutput> NetOutput::Pack(flatbuffers::FlatBufferBuilder &_fbb, const NetOutputT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateNetOutput(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<NetOutput> CreateNetOutput(flatbuffers::FlatBufferBuilder &_fbb, const NetOutputT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const NetOutputT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return mindspore::schema::v0::CreateNetOutput(
      _fbb);
}

inline MatMulT *MatMul::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<MatMulT>(new MatMulT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void MatMul::UnPackTo(MatMulT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = broadcast(); _o->broadcast = _e; }
  { auto _e = transposeA(); _o->transposeA = _e; }
  { auto _e = transposeB(); _o->transposeB = _e; }
}

inline flatbuffers::Offset<MatMul> MatMul::Pack(flatbuffers::FlatBufferBuilder &_fbb, const MatMulT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateMatMul(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<MatMul> CreateMatMul(flatbuffers::FlatBufferBuilder &_fbb, const MatMulT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const MatMulT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _broadcast = _o->broadcast;
  auto _transposeA = _o->transposeA;
  auto _transposeB = _o->transposeB;
  return mindspore::schema::v0::CreateMatMul(
      _fbb,
      _broadcast,
      _transposeA,
      _transposeB);
}

inline PReLUT *PReLU::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<PReLUT>(new PReLUT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void PReLU::UnPackTo(PReLUT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = channelShared(); _o->channelShared = _e; }
  { auto _e = slope(); if (_e) { _o->slope.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->slope[_i] = _e->Get(_i); } } }
}

inline flatbuffers::Offset<PReLU> PReLU::Pack(flatbuffers::FlatBufferBuilder &_fbb, const PReLUT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreatePReLU(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<PReLU> CreatePReLU(flatbuffers::FlatBufferBuilder &_fbb, const PReLUT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const PReLUT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _channelShared = _o->channelShared;
  auto _slope = _o->slope.size() ? _fbb.CreateVector(_o->slope) : 0;
  return mindspore::schema::v0::CreatePReLU(
      _fbb,
      _channelShared,
      _slope);
}

inline LeakyReLUT *LeakyReLU::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<LeakyReLUT>(new LeakyReLUT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void LeakyReLU::UnPackTo(LeakyReLUT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = negativeSlope(); _o->negativeSlope = _e; }
}

inline flatbuffers::Offset<LeakyReLU> LeakyReLU::Pack(flatbuffers::FlatBufferBuilder &_fbb, const LeakyReLUT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateLeakyReLU(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<LeakyReLU> CreateLeakyReLU(flatbuffers::FlatBufferBuilder &_fbb, const LeakyReLUT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const LeakyReLUT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _negativeSlope = _o->negativeSlope;
  return mindspore::schema::v0::CreateLeakyReLU(
      _fbb,
      _negativeSlope);
}

inline StridedSliceT *StridedSlice::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<StridedSliceT>(new StridedSliceT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void StridedSlice::UnPackTo(StridedSliceT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = beginMask(); _o->beginMask = _e; }
  { auto _e = endMask(); _o->endMask = _e; }
  { auto _e = ellipsisMask(); _o->ellipsisMask = _e; }
  { auto _e = newAxisMask(); _o->newAxisMask = _e; }
  { auto _e = shrinkAxisMask(); _o->shrinkAxisMask = _e; }
  { auto _e = begin(); if (_e) { _o->begin.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->begin[_i] = _e->Get(_i); } } }
  { auto _e = end(); if (_e) { _o->end.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->end[_i] = _e->Get(_i); } } }
  { auto _e = stride(); if (_e) { _o->stride.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->stride[_i] = _e->Get(_i); } } }
  { auto _e = isScale(); if (_e) { _o->isScale.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->isScale[_i] = _e->Get(_i); } } }
}

inline flatbuffers::Offset<StridedSlice> StridedSlice::Pack(flatbuffers::FlatBufferBuilder &_fbb, const StridedSliceT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateStridedSlice(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<StridedSlice> CreateStridedSlice(flatbuffers::FlatBufferBuilder &_fbb, const StridedSliceT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const StridedSliceT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _beginMask = _o->beginMask;
  auto _endMask = _o->endMask;
  auto _ellipsisMask = _o->ellipsisMask;
  auto _newAxisMask = _o->newAxisMask;
  auto _shrinkAxisMask = _o->shrinkAxisMask;
  auto _begin = _o->begin.size() ? _fbb.CreateVector(_o->begin) : 0;
  auto _end = _o->end.size() ? _fbb.CreateVector(_o->end) : 0;
  auto _stride = _o->stride.size() ? _fbb.CreateVector(_o->stride) : 0;
  auto _isScale = _o->isScale.size() ? _fbb.CreateVector(_o->isScale) : 0;
  return mindspore::schema::v0::CreateStridedSlice(
      _fbb,
      _beginMask,
      _endMask,
      _ellipsisMask,
      _newAxisMask,
      _shrinkAxisMask,
      _begin,
      _end,
      _stride,
      _isScale);
}

inline StackT *Stack::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<StackT>(new StackT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Stack::UnPackTo(StackT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = axis(); _o->axis = _e; }
  { auto _e = n(); _o->n = _e; }
  { auto _e = isScale(); if (_e) { _o->isScale.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->isScale[_i] = _e->Get(_i); } } }
}

inline flatbuffers::Offset<Stack> Stack::Pack(flatbuffers::FlatBufferBuilder &_fbb, const StackT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateStack(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Stack> CreateStack(flatbuffers::FlatBufferBuilder &_fbb, const StackT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const StackT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _axis = _o->axis;
  auto _n = _o->n;
  auto _isScale = _o->isScale.size() ? _fbb.CreateVector(_o->isScale) : 0;
  return mindspore::schema::v0::CreateStack(
      _fbb,
      _axis,
      _n,
      _isScale);
}

inline RangeT *Range::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<RangeT>(new RangeT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Range::UnPackTo(RangeT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = dType(); _o->dType = _e; }
  { auto _e = start(); _o->start = _e; }
  { auto _e = limit(); _o->limit = _e; }
  { auto _e = delta(); _o->delta = _e; }
}

inline flatbuffers::Offset<Range> Range::Pack(flatbuffers::FlatBufferBuilder &_fbb, const RangeT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateRange(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Range> CreateRange(flatbuffers::FlatBufferBuilder &_fbb, const RangeT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const RangeT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _dType = _o->dType;
  auto _start = _o->start;
  auto _limit = _o->limit;
  auto _delta = _o->delta;
  return mindspore::schema::v0::CreateRange(
      _fbb,
      _dType,
      _start,
      _limit,
      _delta);
}

inline ExpandDimsT *ExpandDims::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<ExpandDimsT>(new ExpandDimsT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void ExpandDims::UnPackTo(ExpandDimsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = dim(); _o->dim = _e; }
}

inline flatbuffers::Offset<ExpandDims> ExpandDims::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ExpandDimsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateExpandDims(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<ExpandDims> CreateExpandDims(flatbuffers::FlatBufferBuilder &_fbb, const ExpandDimsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ExpandDimsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _dim = _o->dim;
  return mindspore::schema::v0::CreateExpandDims(
      _fbb,
      _dim);
}

inline TileT *Tile::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<TileT>(new TileT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Tile::UnPackTo(TileT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = multiples(); if (_e) { _o->multiples.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->multiples[_i] = _e->Get(_i); } } }
  { auto _e = dims(); if (_e) { _o->dims.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->dims[_i] = _e->Get(_i); } } }
}

inline flatbuffers::Offset<Tile> Tile::Pack(flatbuffers::FlatBufferBuilder &_fbb, const TileT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateTile(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Tile> CreateTile(flatbuffers::FlatBufferBuilder &_fbb, const TileT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const TileT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _multiples = _o->multiples.size() ? _fbb.CreateVector(_o->multiples) : 0;
  auto _dims = _o->dims.size() ? _fbb.CreateVector(_o->dims) : 0;
  return mindspore::schema::v0::CreateTile(
      _fbb,
      _multiples,
      _dims);
}

inline CastT *Cast::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<CastT>(new CastT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Cast::UnPackTo(CastT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = srcT(); _o->srcT = _e; }
  { auto _e = dstT(); _o->dstT = _e; }
}

inline flatbuffers::Offset<Cast> Cast::Pack(flatbuffers::FlatBufferBuilder &_fbb, const CastT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateCast(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Cast> CreateCast(flatbuffers::FlatBufferBuilder &_fbb, const CastT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const CastT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _srcT = _o->srcT;
  auto _dstT = _o->dstT;
  return mindspore::schema::v0::CreateCast(
      _fbb,
      _srcT,
      _dstT);
}

inline QuantDTypeCastT *QuantDTypeCast::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<QuantDTypeCastT>(new QuantDTypeCastT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void QuantDTypeCast::UnPackTo(QuantDTypeCastT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = srcT(); _o->srcT = _e; }
  { auto _e = dstT(); _o->dstT = _e; }
}

inline flatbuffers::Offset<QuantDTypeCast> QuantDTypeCast::Pack(flatbuffers::FlatBufferBuilder &_fbb, const QuantDTypeCastT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateQuantDTypeCast(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<QuantDTypeCast> CreateQuantDTypeCast(flatbuffers::FlatBufferBuilder &_fbb, const QuantDTypeCastT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const QuantDTypeCastT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _srcT = _o->srcT;
  auto _dstT = _o->dstT;
  return mindspore::schema::v0::CreateQuantDTypeCast(
      _fbb,
      _srcT,
      _dstT);
}

inline SplitT *Split::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<SplitT>(new SplitT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Split::UnPackTo(SplitT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = numberSplit(); _o->numberSplit = _e; }
  { auto _e = sizeSplits(); if (_e) { _o->sizeSplits.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->sizeSplits[_i] = _e->Get(_i); } } }
  { auto _e = splitDim(); _o->splitDim = _e; }
}

inline flatbuffers::Offset<Split> Split::Pack(flatbuffers::FlatBufferBuilder &_fbb, const SplitT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateSplit(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Split> CreateSplit(flatbuffers::FlatBufferBuilder &_fbb, const SplitT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const SplitT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _numberSplit = _o->numberSplit;
  auto _sizeSplits = _o->sizeSplits.size() ? _fbb.CreateVector(_o->sizeSplits) : 0;
  auto _splitDim = _o->splitDim;
  return mindspore::schema::v0::CreateSplit(
      _fbb,
      _numberSplit,
      _sizeSplits,
      _splitDim);
}

inline CropT *Crop::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<CropT>(new CropT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Crop::UnPackTo(CropT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = axis(); _o->axis = _e; }
  { auto _e = offsets(); if (_e) { _o->offsets.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->offsets[_i] = _e->Get(_i); } } }
}

inline flatbuffers::Offset<Crop> Crop::Pack(flatbuffers::FlatBufferBuilder &_fbb, const CropT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateCrop(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Crop> CreateCrop(flatbuffers::FlatBufferBuilder &_fbb, const CropT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const CropT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _axis = _o->axis;
  auto _offsets = _o->offsets.size() ? _fbb.CreateVector(_o->offsets) : 0;
  return mindspore::schema::v0::CreateCrop(
      _fbb,
      _axis,
      _offsets);
}

inline PermuteT *Permute::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<PermuteT>(new PermuteT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Permute::UnPackTo(PermuteT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = order(); if (_e) { _o->order.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->order[_i] = _e->Get(_i); } } }
}

inline flatbuffers::Offset<Permute> Permute::Pack(flatbuffers::FlatBufferBuilder &_fbb, const PermuteT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreatePermute(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Permute> CreatePermute(flatbuffers::FlatBufferBuilder &_fbb, const PermuteT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const PermuteT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _order = _o->order.size() ? _fbb.CreateVector(_o->order) : 0;
  return mindspore::schema::v0::CreatePermute(
      _fbb,
      _order);
}

inline ClipT *Clip::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<ClipT>(new ClipT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Clip::UnPackTo(ClipT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = max(); _o->max = _e; }
  { auto _e = min(); _o->min = _e; }
}

inline flatbuffers::Offset<Clip> Clip::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ClipT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateClip(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Clip> CreateClip(flatbuffers::FlatBufferBuilder &_fbb, const ClipT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ClipT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _max = _o->max;
  auto _min = _o->min;
  return mindspore::schema::v0::CreateClip(
      _fbb,
      _max,
      _min);
}

inline ConstantT *Constant::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<ConstantT>(new ConstantT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Constant::UnPackTo(ConstantT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<Constant> Constant::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ConstantT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateConstant(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Constant> CreateConstant(flatbuffers::FlatBufferBuilder &_fbb, const ConstantT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ConstantT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return mindspore::schema::v0::CreateConstant(
      _fbb);
}

inline EluT *Elu::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<EluT>(new EluT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Elu::UnPackTo(EluT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = alpha(); _o->alpha = _e; }
}

inline flatbuffers::Offset<Elu> Elu::Pack(flatbuffers::FlatBufferBuilder &_fbb, const EluT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateElu(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Elu> CreateElu(flatbuffers::FlatBufferBuilder &_fbb, const EluT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const EluT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _alpha = _o->alpha;
  return mindspore::schema::v0::CreateElu(
      _fbb,
      _alpha);
}

inline BroadcastT *Broadcast::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<BroadcastT>(new BroadcastT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Broadcast::UnPackTo(BroadcastT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<Broadcast> Broadcast::Pack(flatbuffers::FlatBufferBuilder &_fbb, const BroadcastT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateBroadcast(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Broadcast> CreateBroadcast(flatbuffers::FlatBufferBuilder &_fbb, const BroadcastT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const BroadcastT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return mindspore::schema::v0::CreateBroadcast(
      _fbb);
}

inline BroadcastToT *BroadcastTo::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<BroadcastToT>(new BroadcastToT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void BroadcastTo::UnPackTo(BroadcastToT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = dst_shape(); if (_e) { _o->dst_shape.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->dst_shape[_i] = _e->Get(_i); } } }
}

inline flatbuffers::Offset<BroadcastTo> BroadcastTo::Pack(flatbuffers::FlatBufferBuilder &_fbb, const BroadcastToT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateBroadcastTo(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<BroadcastTo> CreateBroadcastTo(flatbuffers::FlatBufferBuilder &_fbb, const BroadcastToT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const BroadcastToT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _dst_shape = _o->dst_shape.size() ? _fbb.CreateVector(_o->dst_shape) : 0;
  return mindspore::schema::v0::CreateBroadcastTo(
      _fbb,
      _dst_shape);
}

inline LrnT *Lrn::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<LrnT>(new LrnT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Lrn::UnPackTo(LrnT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = alpha(); _o->alpha = _e; }
  { auto _e = beta(); _o->beta = _e; }
  { auto _e = bias(); _o->bias = _e; }
  { auto _e = size(); _o->size = _e; }
}

inline flatbuffers::Offset<Lrn> Lrn::Pack(flatbuffers::FlatBufferBuilder &_fbb, const LrnT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateLrn(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Lrn> CreateLrn(flatbuffers::FlatBufferBuilder &_fbb, const LrnT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const LrnT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _alpha = _o->alpha;
  auto _beta = _o->beta;
  auto _bias = _o->bias;
  auto _size = _o->size;
  return mindspore::schema::v0::CreateLrn(
      _fbb,
      _alpha,
      _beta,
      _bias,
      _size);
}

inline ReduceT *Reduce::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<ReduceT>(new ReduceT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Reduce::UnPackTo(ReduceT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = axes(); if (_e) { _o->axes.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->axes[_i] = _e->Get(_i); } } }
  { auto _e = keepDims(); _o->keepDims = _e; }
  { auto _e = mode(); _o->mode = _e; }
  { auto _e = reduceToEnd(); _o->reduceToEnd = _e; }
  { auto _e = coeff(); _o->coeff = _e; }
}

inline flatbuffers::Offset<Reduce> Reduce::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ReduceT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateReduce(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Reduce> CreateReduce(flatbuffers::FlatBufferBuilder &_fbb, const ReduceT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ReduceT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _axes = _o->axes.size() ? _fbb.CreateVector(_o->axes) : 0;
  auto _keepDims = _o->keepDims;
  auto _mode = _o->mode;
  auto _reduceToEnd = _o->reduceToEnd;
  auto _coeff = _o->coeff;
  return mindspore::schema::v0::CreateReduce(
      _fbb,
      _axes,
      _keepDims,
      _mode,
      _reduceToEnd,
      _coeff);
}

inline TransposeT *Transpose::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<TransposeT>(new TransposeT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Transpose::UnPackTo(TransposeT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = perm(); if (_e) { _o->perm.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->perm[_i] = _e->Get(_i); } } }
  { auto _e = conjugate(); _o->conjugate = _e; }
}

inline flatbuffers::Offset<Transpose> Transpose::Pack(flatbuffers::FlatBufferBuilder &_fbb, const TransposeT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateTranspose(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Transpose> CreateTranspose(flatbuffers::FlatBufferBuilder &_fbb, const TransposeT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const TransposeT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _perm = _o->perm.size() ? _fbb.CreateVector(_o->perm) : 0;
  auto _conjugate = _o->conjugate;
  return mindspore::schema::v0::CreateTranspose(
      _fbb,
      _perm,
      _conjugate);
}

inline SqueezeT *Squeeze::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<SqueezeT>(new SqueezeT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Squeeze::UnPackTo(SqueezeT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = axis(); if (_e) { _o->axis.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->axis[_i] = _e->Get(_i); } } }
}

inline flatbuffers::Offset<Squeeze> Squeeze::Pack(flatbuffers::FlatBufferBuilder &_fbb, const SqueezeT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateSqueeze(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Squeeze> CreateSqueeze(flatbuffers::FlatBufferBuilder &_fbb, const SqueezeT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const SqueezeT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _axis = _o->axis.size() ? _fbb.CreateVector(_o->axis) : 0;
  return mindspore::schema::v0::CreateSqueeze(
      _fbb,
      _axis);
}

inline UnsqueezeT *Unsqueeze::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<UnsqueezeT>(new UnsqueezeT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Unsqueeze::UnPackTo(UnsqueezeT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = axis(); if (_e) { _o->axis.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->axis[_i] = _e->Get(_i); } } }
}

inline flatbuffers::Offset<Unsqueeze> Unsqueeze::Pack(flatbuffers::FlatBufferBuilder &_fbb, const UnsqueezeT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateUnsqueeze(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Unsqueeze> CreateUnsqueeze(flatbuffers::FlatBufferBuilder &_fbb, const UnsqueezeT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const UnsqueezeT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _axis = _o->axis.size() ? _fbb.CreateVector(_o->axis) : 0;
  return mindspore::schema::v0::CreateUnsqueeze(
      _fbb,
      _axis);
}

inline UpsampleT *Upsample::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<UpsampleT>(new UpsampleT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Upsample::UnPackTo(UpsampleT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = mode(); if (_e) _o->mode = _e->str(); }
  { auto _e = scales(); if (_e) { _o->scales.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->scales[_i] = _e->Get(_i); } } }
}

inline flatbuffers::Offset<Upsample> Upsample::Pack(flatbuffers::FlatBufferBuilder &_fbb, const UpsampleT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateUpsample(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Upsample> CreateUpsample(flatbuffers::FlatBufferBuilder &_fbb, const UpsampleT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const UpsampleT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _mode = _o->mode.empty() ? 0 : _fbb.CreateString(_o->mode);
  auto _scales = _o->scales.size() ? _fbb.CreateVector(_o->scales) : 0;
  return mindspore::schema::v0::CreateUpsample(
      _fbb,
      _mode,
      _scales);
}

inline DropoutT *Dropout::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<DropoutT>(new DropoutT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Dropout::UnPackTo(DropoutT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = ratio(); _o->ratio = _e; }
}

inline flatbuffers::Offset<Dropout> Dropout::Pack(flatbuffers::FlatBufferBuilder &_fbb, const DropoutT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateDropout(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Dropout> CreateDropout(flatbuffers::FlatBufferBuilder &_fbb, const DropoutT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const DropoutT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _ratio = _o->ratio;
  return mindspore::schema::v0::CreateDropout(
      _fbb,
      _ratio);
}

inline LocalResponseNormalizationT *LocalResponseNormalization::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<LocalResponseNormalizationT>(new LocalResponseNormalizationT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void LocalResponseNormalization::UnPackTo(LocalResponseNormalizationT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = depth_radius(); _o->depth_radius = _e; }
  { auto _e = bias(); _o->bias = _e; }
  { auto _e = alpha(); _o->alpha = _e; }
  { auto _e = beta(); _o->beta = _e; }
}

inline flatbuffers::Offset<LocalResponseNormalization> LocalResponseNormalization::Pack(flatbuffers::FlatBufferBuilder &_fbb, const LocalResponseNormalizationT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateLocalResponseNormalization(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<LocalResponseNormalization> CreateLocalResponseNormalization(flatbuffers::FlatBufferBuilder &_fbb, const LocalResponseNormalizationT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const LocalResponseNormalizationT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _depth_radius = _o->depth_radius;
  auto _bias = _o->bias;
  auto _alpha = _o->alpha;
  auto _beta = _o->beta;
  return mindspore::schema::v0::CreateLocalResponseNormalization(
      _fbb,
      _depth_radius,
      _bias,
      _alpha,
      _beta);
}

inline ZerosLikeT *ZerosLike::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<ZerosLikeT>(new ZerosLikeT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void ZerosLike::UnPackTo(ZerosLikeT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<ZerosLike> ZerosLike::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ZerosLikeT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateZerosLike(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<ZerosLike> CreateZerosLike(flatbuffers::FlatBufferBuilder &_fbb, const ZerosLikeT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ZerosLikeT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return mindspore::schema::v0::CreateZerosLike(
      _fbb);
}

inline TopKT *TopK::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<TopKT>(new TopKT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void TopK::UnPackTo(TopKT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = k(); _o->k = _e; }
  { auto _e = sorted(); _o->sorted = _e; }
}

inline flatbuffers::Offset<TopK> TopK::Pack(flatbuffers::FlatBufferBuilder &_fbb, const TopKT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateTopK(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<TopK> CreateTopK(flatbuffers::FlatBufferBuilder &_fbb, const TopKT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const TopKT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _k = _o->k;
  auto _sorted = _o->sorted;
  return mindspore::schema::v0::CreateTopK(
      _fbb,
      _k,
      _sorted);
}

inline SpaceToDepthT *SpaceToDepth::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<SpaceToDepthT>(new SpaceToDepthT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void SpaceToDepth::UnPackTo(SpaceToDepthT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = blockSize(); _o->blockSize = _e; }
  { auto _e = format(); _o->format = _e; }
}

inline flatbuffers::Offset<SpaceToDepth> SpaceToDepth::Pack(flatbuffers::FlatBufferBuilder &_fbb, const SpaceToDepthT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateSpaceToDepth(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<SpaceToDepth> CreateSpaceToDepth(flatbuffers::FlatBufferBuilder &_fbb, const SpaceToDepthT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const SpaceToDepthT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _blockSize = _o->blockSize;
  auto _format = _o->format;
  return mindspore::schema::v0::CreateSpaceToDepth(
      _fbb,
      _blockSize,
      _format);
}

inline SpaceToBatchT *SpaceToBatch::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<SpaceToBatchT>(new SpaceToBatchT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void SpaceToBatch::UnPackTo(SpaceToBatchT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = blockShape(); if (_e) { _o->blockShape.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->blockShape[_i] = _e->Get(_i); } } }
  { auto _e = paddings(); if (_e) { _o->paddings.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->paddings[_i] = _e->Get(_i); } } }
}

inline flatbuffers::Offset<SpaceToBatch> SpaceToBatch::Pack(flatbuffers::FlatBufferBuilder &_fbb, const SpaceToBatchT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateSpaceToBatch(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<SpaceToBatch> CreateSpaceToBatch(flatbuffers::FlatBufferBuilder &_fbb, const SpaceToBatchT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const SpaceToBatchT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _blockShape = _o->blockShape.size() ? _fbb.CreateVector(_o->blockShape) : 0;
  auto _paddings = _o->paddings.size() ? _fbb.CreateVector(_o->paddings) : 0;
  return mindspore::schema::v0::CreateSpaceToBatch(
      _fbb,
      _blockShape,
      _paddings);
}

inline SparseToDenseT *SparseToDense::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<SparseToDenseT>(new SparseToDenseT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void SparseToDense::UnPackTo(SparseToDenseT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = validateIndices(); _o->validateIndices = _e; }
}

inline flatbuffers::Offset<SparseToDense> SparseToDense::Pack(flatbuffers::FlatBufferBuilder &_fbb, const SparseToDenseT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateSparseToDense(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<SparseToDense> CreateSparseToDense(flatbuffers::FlatBufferBuilder &_fbb, const SparseToDenseT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const SparseToDenseT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _validateIndices = _o->validateIndices;
  return mindspore::schema::v0::CreateSparseToDense(
      _fbb,
      _validateIndices);
}

inline ReverseSequenceT *ReverseSequence::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<ReverseSequenceT>(new ReverseSequenceT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void ReverseSequence::UnPackTo(ReverseSequenceT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = seqAxis(); _o->seqAxis = _e; }
  { auto _e = batchAxis(); _o->batchAxis = _e; }
}

inline flatbuffers::Offset<ReverseSequence> ReverseSequence::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ReverseSequenceT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateReverseSequence(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<ReverseSequence> CreateReverseSequence(flatbuffers::FlatBufferBuilder &_fbb, const ReverseSequenceT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ReverseSequenceT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _seqAxis = _o->seqAxis;
  auto _batchAxis = _o->batchAxis;
  return mindspore::schema::v0::CreateReverseSequence(
      _fbb,
      _seqAxis,
      _batchAxis);
}

inline RankT *Rank::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<RankT>(new RankT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Rank::UnPackTo(RankT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<Rank> Rank::Pack(flatbuffers::FlatBufferBuilder &_fbb, const RankT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateRank(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Rank> CreateRank(flatbuffers::FlatBufferBuilder &_fbb, const RankT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const RankT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return mindspore::schema::v0::CreateRank(
      _fbb);
}

inline GatherT *Gather::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<GatherT>(new GatherT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Gather::UnPackTo(GatherT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = axis(); _o->axis = _e; }
  { auto _e = batchDims(); _o->batchDims = _e; }
}

inline flatbuffers::Offset<Gather> Gather::Pack(flatbuffers::FlatBufferBuilder &_fbb, const GatherT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateGather(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Gather> CreateGather(flatbuffers::FlatBufferBuilder &_fbb, const GatherT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const GatherT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _axis = _o->axis;
  auto _batchDims = _o->batchDims;
  return mindspore::schema::v0::CreateGather(
      _fbb,
      _axis,
      _batchDims);
}

inline GatherNdT *GatherNd::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<GatherNdT>(new GatherNdT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void GatherNd::UnPackTo(GatherNdT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = batchDims(); _o->batchDims = _e; }
}

inline flatbuffers::Offset<GatherNd> GatherNd::Pack(flatbuffers::FlatBufferBuilder &_fbb, const GatherNdT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateGatherNd(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<GatherNd> CreateGatherNd(flatbuffers::FlatBufferBuilder &_fbb, const GatherNdT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const GatherNdT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _batchDims = _o->batchDims;
  return mindspore::schema::v0::CreateGatherNd(
      _fbb,
      _batchDims);
}

inline FillT *Fill::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<FillT>(new FillT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Fill::UnPackTo(FillT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = dims(); if (_e) { _o->dims.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->dims[_i] = _e->Get(_i); } } }
}

inline flatbuffers::Offset<Fill> Fill::Pack(flatbuffers::FlatBufferBuilder &_fbb, const FillT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateFill(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Fill> CreateFill(flatbuffers::FlatBufferBuilder &_fbb, const FillT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const FillT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _dims = _o->dims.size() ? _fbb.CreateVector(_o->dims) : 0;
  return mindspore::schema::v0::CreateFill(
      _fbb,
      _dims);
}

inline DepthToSpaceT *DepthToSpace::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<DepthToSpaceT>(new DepthToSpaceT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void DepthToSpace::UnPackTo(DepthToSpaceT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = blockSize(); _o->blockSize = _e; }
  { auto _e = format(); _o->format = _e; }
}

inline flatbuffers::Offset<DepthToSpace> DepthToSpace::Pack(flatbuffers::FlatBufferBuilder &_fbb, const DepthToSpaceT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateDepthToSpace(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<DepthToSpace> CreateDepthToSpace(flatbuffers::FlatBufferBuilder &_fbb, const DepthToSpaceT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const DepthToSpaceT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _blockSize = _o->blockSize;
  auto _format = _o->format;
  return mindspore::schema::v0::CreateDepthToSpace(
      _fbb,
      _blockSize,
      _format);
}

inline BatchToSpaceT *BatchToSpace::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<BatchToSpaceT>(new BatchToSpaceT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void BatchToSpace::UnPackTo(BatchToSpaceT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = blockShape(); if (_e) { _o->blockShape.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->blockShape[_i] = _e->Get(_i); } } }
  { auto _e = crops(); if (_e) { _o->crops.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->crops[_i] = _e->Get(_i); } } }
}

inline flatbuffers::Offset<BatchToSpace> BatchToSpace::Pack(flatbuffers::FlatBufferBuilder &_fbb, const BatchToSpaceT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateBatchToSpace(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<BatchToSpace> CreateBatchToSpace(flatbuffers::FlatBufferBuilder &_fbb, const BatchToSpaceT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const BatchToSpaceT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _blockShape = _o->blockShape.size() ? _fbb.CreateVector(_o->blockShape) : 0;
  auto _crops = _o->crops.size() ? _fbb.CreateVector(_o->crops) : 0;
  return mindspore::schema::v0::CreateBatchToSpace(
      _fbb,
      _blockShape,
      _crops);
}

inline BatchToSpaceNDT *BatchToSpaceND::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<BatchToSpaceNDT>(new BatchToSpaceNDT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void BatchToSpaceND::UnPackTo(BatchToSpaceNDT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = blockShape(); if (_e) { _o->blockShape.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->blockShape[_i] = _e->Get(_i); } } }
  { auto _e = crops(); if (_e) { _o->crops.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->crops[_i] = _e->Get(_i); } } }
}

inline flatbuffers::Offset<BatchToSpaceND> BatchToSpaceND::Pack(flatbuffers::FlatBufferBuilder &_fbb, const BatchToSpaceNDT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateBatchToSpaceND(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<BatchToSpaceND> CreateBatchToSpaceND(flatbuffers::FlatBufferBuilder &_fbb, const BatchToSpaceNDT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const BatchToSpaceNDT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _blockShape = _o->blockShape.size() ? _fbb.CreateVector(_o->blockShape) : 0;
  auto _crops = _o->crops.size() ? _fbb.CreateVector(_o->crops) : 0;
  return mindspore::schema::v0::CreateBatchToSpaceND(
      _fbb,
      _blockShape,
      _crops);
}

inline AddNT *AddN::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<AddNT>(new AddNT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void AddN::UnPackTo(AddNT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = N(); _o->N = _e; }
}

inline flatbuffers::Offset<AddN> AddN::Pack(flatbuffers::FlatBufferBuilder &_fbb, const AddNT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateAddN(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<AddN> CreateAddN(flatbuffers::FlatBufferBuilder &_fbb, const AddNT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const AddNT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _N = _o->N;
  return mindspore::schema::v0::CreateAddN(
      _fbb,
      _N);
}

inline EmbeddingLookupT *EmbeddingLookup::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<EmbeddingLookupT>(new EmbeddingLookupT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void EmbeddingLookup::UnPackTo(EmbeddingLookupT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = maxNorm(); _o->maxNorm = _e; }
}

inline flatbuffers::Offset<EmbeddingLookup> EmbeddingLookup::Pack(flatbuffers::FlatBufferBuilder &_fbb, const EmbeddingLookupT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateEmbeddingLookup(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<EmbeddingLookup> CreateEmbeddingLookup(flatbuffers::FlatBufferBuilder &_fbb, const EmbeddingLookupT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const EmbeddingLookupT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _maxNorm = _o->maxNorm;
  return mindspore::schema::v0::CreateEmbeddingLookup(
      _fbb,
      _maxNorm);
}

inline EmbeddingLookupSparseT *EmbeddingLookupSparse::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<EmbeddingLookupSparseT>(new EmbeddingLookupSparseT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void EmbeddingLookupSparse::UnPackTo(EmbeddingLookupSparseT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = spIds(); if (_e) { _o->spIds.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->spIds[_i] = _e->Get(_i); } } }
  { auto _e = spWeights(); if (_e) { _o->spWeights.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->spWeights[_i] = _e->Get(_i); } } }
  { auto _e = maxNortm(); _o->maxNortm = _e; }
}

inline flatbuffers::Offset<EmbeddingLookupSparse> EmbeddingLookupSparse::Pack(flatbuffers::FlatBufferBuilder &_fbb, const EmbeddingLookupSparseT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateEmbeddingLookupSparse(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<EmbeddingLookupSparse> CreateEmbeddingLookupSparse(flatbuffers::FlatBufferBuilder &_fbb, const EmbeddingLookupSparseT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const EmbeddingLookupSparseT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _spIds = _o->spIds.size() ? _fbb.CreateVector(_o->spIds) : 0;
  auto _spWeights = _o->spWeights.size() ? _fbb.CreateVector(_o->spWeights) : 0;
  auto _maxNortm = _o->maxNortm;
  return mindspore::schema::v0::CreateEmbeddingLookupSparse(
      _fbb,
      _spIds,
      _spWeights,
      _maxNortm);
}

inline FloorDivT *FloorDiv::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<FloorDivT>(new FloorDivT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void FloorDiv::UnPackTo(FloorDivT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<FloorDiv> FloorDiv::Pack(flatbuffers::FlatBufferBuilder &_fbb, const FloorDivT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateFloorDiv(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<FloorDiv> CreateFloorDiv(flatbuffers::FlatBufferBuilder &_fbb, const FloorDivT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const FloorDivT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return mindspore::schema::v0::CreateFloorDiv(
      _fbb);
}

inline FloorModT *FloorMod::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<FloorModT>(new FloorModT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void FloorMod::UnPackTo(FloorModT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<FloorMod> FloorMod::Pack(flatbuffers::FlatBufferBuilder &_fbb, const FloorModT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateFloorMod(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<FloorMod> CreateFloorMod(flatbuffers::FlatBufferBuilder &_fbb, const FloorModT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const FloorModT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return mindspore::schema::v0::CreateFloorMod(
      _fbb);
}

inline ModT *Mod::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<ModT>(new ModT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Mod::UnPackTo(ModT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<Mod> Mod::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ModT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateMod(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Mod> CreateMod(flatbuffers::FlatBufferBuilder &_fbb, const ModT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ModT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return mindspore::schema::v0::CreateMod(
      _fbb);
}

inline L2NormT *L2Norm::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<L2NormT>(new L2NormT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void L2Norm::UnPackTo(L2NormT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = axis(); if (_e) { _o->axis.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->axis[_i] = _e->Get(_i); } } }
  { auto _e = epsilon(); _o->epsilon = _e; }
  { auto _e = activationType(); _o->activationType = _e; }
}

inline flatbuffers::Offset<L2Norm> L2Norm::Pack(flatbuffers::FlatBufferBuilder &_fbb, const L2NormT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateL2Norm(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<L2Norm> CreateL2Norm(flatbuffers::FlatBufferBuilder &_fbb, const L2NormT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const L2NormT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _axis = _o->axis.size() ? _fbb.CreateVector(_o->axis) : 0;
  auto _epsilon = _o->epsilon;
  auto _activationType = _o->activationType;
  return mindspore::schema::v0::CreateL2Norm(
      _fbb,
      _axis,
      _epsilon,
      _activationType);
}

inline LogicalAndT *LogicalAnd::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<LogicalAndT>(new LogicalAndT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void LogicalAnd::UnPackTo(LogicalAndT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<LogicalAnd> LogicalAnd::Pack(flatbuffers::FlatBufferBuilder &_fbb, const LogicalAndT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateLogicalAnd(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<LogicalAnd> CreateLogicalAnd(flatbuffers::FlatBufferBuilder &_fbb, const LogicalAndT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const LogicalAndT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return mindspore::schema::v0::CreateLogicalAnd(
      _fbb);
}

inline LogicalOrT *LogicalOr::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<LogicalOrT>(new LogicalOrT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void LogicalOr::UnPackTo(LogicalOrT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<LogicalOr> LogicalOr::Pack(flatbuffers::FlatBufferBuilder &_fbb, const LogicalOrT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateLogicalOr(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<LogicalOr> CreateLogicalOr(flatbuffers::FlatBufferBuilder &_fbb, const LogicalOrT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const LogicalOrT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return mindspore::schema::v0::CreateLogicalOr(
      _fbb);
}

inline LogicalXorT *LogicalXor::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<LogicalXorT>(new LogicalXorT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void LogicalXor::UnPackTo(LogicalXorT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<LogicalXor> LogicalXor::Pack(flatbuffers::FlatBufferBuilder &_fbb, const LogicalXorT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateLogicalXor(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<LogicalXor> CreateLogicalXor(flatbuffers::FlatBufferBuilder &_fbb, const LogicalXorT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const LogicalXorT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return mindspore::schema::v0::CreateLogicalXor(
      _fbb);
}

inline LogicalNotT *LogicalNot::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<LogicalNotT>(new LogicalNotT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void LogicalNot::UnPackTo(LogicalNotT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<LogicalNot> LogicalNot::Pack(flatbuffers::FlatBufferBuilder &_fbb, const LogicalNotT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateLogicalNot(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<LogicalNot> CreateLogicalNot(flatbuffers::FlatBufferBuilder &_fbb, const LogicalNotT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const LogicalNotT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return mindspore::schema::v0::CreateLogicalNot(
      _fbb);
}

inline MatrixDiagT *MatrixDiag::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<MatrixDiagT>(new MatrixDiagT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void MatrixDiag::UnPackTo(MatrixDiagT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = k(); _o->k = _e; }
  { auto _e = numRows(); _o->numRows = _e; }
  { auto _e = numCols(); _o->numCols = _e; }
  { auto _e = paddingValue(); _o->paddingValue = _e; }
}

inline flatbuffers::Offset<MatrixDiag> MatrixDiag::Pack(flatbuffers::FlatBufferBuilder &_fbb, const MatrixDiagT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateMatrixDiag(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<MatrixDiag> CreateMatrixDiag(flatbuffers::FlatBufferBuilder &_fbb, const MatrixDiagT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const MatrixDiagT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _k = _o->k;
  auto _numRows = _o->numRows;
  auto _numCols = _o->numCols;
  auto _paddingValue = _o->paddingValue;
  return mindspore::schema::v0::CreateMatrixDiag(
      _fbb,
      _k,
      _numRows,
      _numCols,
      _paddingValue);
}

inline SelectT *Select::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<SelectT>(new SelectT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Select::UnPackTo(SelectT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<Select> Select::Pack(flatbuffers::FlatBufferBuilder &_fbb, const SelectT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateSelect(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Select> CreateSelect(flatbuffers::FlatBufferBuilder &_fbb, const SelectT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const SelectT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return mindspore::schema::v0::CreateSelect(
      _fbb);
}

inline TfReduceT *TfReduce::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<TfReduceT>(new TfReduceT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void TfReduce::UnPackTo(TfReduceT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = type(); _o->type = _e; }
}

inline flatbuffers::Offset<TfReduce> TfReduce::Pack(flatbuffers::FlatBufferBuilder &_fbb, const TfReduceT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateTfReduce(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<TfReduce> CreateTfReduce(flatbuffers::FlatBufferBuilder &_fbb, const TfReduceT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const TfReduceT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _type = _o->type;
  return mindspore::schema::v0::CreateTfReduce(
      _fbb,
      _type);
}

inline ReverseT *Reverse::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<ReverseT>(new ReverseT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Reverse::UnPackTo(ReverseT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = axis(); if (_e) { _o->axis.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->axis[_i] = _e->Get(_i); } } }
}

inline flatbuffers::Offset<Reverse> Reverse::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ReverseT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateReverse(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Reverse> CreateReverse(flatbuffers::FlatBufferBuilder &_fbb, const ReverseT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ReverseT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _axis = _o->axis.size() ? _fbb.CreateVector(_o->axis) : 0;
  return mindspore::schema::v0::CreateReverse(
      _fbb,
      _axis);
}

inline RoundT *Round::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<RoundT>(new RoundT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Round::UnPackTo(RoundT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<Round> Round::Pack(flatbuffers::FlatBufferBuilder &_fbb, const RoundT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateRound(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Round> CreateRound(flatbuffers::FlatBufferBuilder &_fbb, const RoundT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const RoundT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return mindspore::schema::v0::CreateRound(
      _fbb);
}

inline ScatterT *Scatter::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<ScatterT>(new ScatterT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Scatter::UnPackTo(ScatterT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<Scatter> Scatter::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ScatterT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateScatter(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Scatter> CreateScatter(flatbuffers::FlatBufferBuilder &_fbb, const ScatterT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ScatterT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return mindspore::schema::v0::CreateScatter(
      _fbb);
}

inline ScatterNDT *ScatterND::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<ScatterNDT>(new ScatterNDT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void ScatterND::UnPackTo(ScatterNDT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<ScatterND> ScatterND::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ScatterNDT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateScatterND(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<ScatterND> CreateScatterND(flatbuffers::FlatBufferBuilder &_fbb, const ScatterNDT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ScatterNDT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return mindspore::schema::v0::CreateScatterND(
      _fbb);
}

inline UniqueT *Unique::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<UniqueT>(new UniqueT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Unique::UnPackTo(UniqueT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = outType(); _o->outType = _e; }
}

inline flatbuffers::Offset<Unique> Unique::Pack(flatbuffers::FlatBufferBuilder &_fbb, const UniqueT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateUnique(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Unique> CreateUnique(flatbuffers::FlatBufferBuilder &_fbb, const UniqueT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const UniqueT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _outType = _o->outType;
  return mindspore::schema::v0::CreateUnique(
      _fbb,
      _outType);
}

inline UnstackT *Unstack::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<UnstackT>(new UnstackT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Unstack::UnPackTo(UnstackT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = num(); _o->num = _e; }
  { auto _e = axis(); _o->axis = _e; }
}

inline flatbuffers::Offset<Unstack> Unstack::Pack(flatbuffers::FlatBufferBuilder &_fbb, const UnstackT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateUnstack(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Unstack> CreateUnstack(flatbuffers::FlatBufferBuilder &_fbb, const UnstackT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const UnstackT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _num = _o->num;
  auto _axis = _o->axis;
  return mindspore::schema::v0::CreateUnstack(
      _fbb,
      _num,
      _axis);
}

inline OnnxInt8QuantizeT *OnnxInt8Quantize::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<OnnxInt8QuantizeT>(new OnnxInt8QuantizeT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void OnnxInt8Quantize::UnPackTo(OnnxInt8QuantizeT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<OnnxInt8Quantize> OnnxInt8Quantize::Pack(flatbuffers::FlatBufferBuilder &_fbb, const OnnxInt8QuantizeT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateOnnxInt8Quantize(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<OnnxInt8Quantize> CreateOnnxInt8Quantize(flatbuffers::FlatBufferBuilder &_fbb, const OnnxInt8QuantizeT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const OnnxInt8QuantizeT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return mindspore::schema::v0::CreateOnnxInt8Quantize(
      _fbb);
}

inline OnnxInt8DequantizeT *OnnxInt8Dequantize::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<OnnxInt8DequantizeT>(new OnnxInt8DequantizeT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void OnnxInt8Dequantize::UnPackTo(OnnxInt8DequantizeT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<OnnxInt8Dequantize> OnnxInt8Dequantize::Pack(flatbuffers::FlatBufferBuilder &_fbb, const OnnxInt8DequantizeT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateOnnxInt8Dequantize(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<OnnxInt8Dequantize> CreateOnnxInt8Dequantize(flatbuffers::FlatBufferBuilder &_fbb, const OnnxInt8DequantizeT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const OnnxInt8DequantizeT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return mindspore::schema::v0::CreateOnnxInt8Dequantize(
      _fbb);
}

inline FakeQuantWithMinMaxT *FakeQuantWithMinMax::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<FakeQuantWithMinMaxT>(new FakeQuantWithMinMaxT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void FakeQuantWithMinMax::UnPackTo(FakeQuantWithMinMaxT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<FakeQuantWithMinMax> FakeQuantWithMinMax::Pack(flatbuffers::FlatBufferBuilder &_fbb, const FakeQuantWithMinMaxT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateFakeQuantWithMinMax(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<FakeQuantWithMinMax> CreateFakeQuantWithMinMax(flatbuffers::FlatBufferBuilder &_fbb, const FakeQuantWithMinMaxT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const FakeQuantWithMinMaxT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return mindspore::schema::v0::CreateFakeQuantWithMinMax(
      _fbb);
}

inline FakeQuantWithMinMaxPerChannelT *FakeQuantWithMinMaxPerChannel::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<FakeQuantWithMinMaxPerChannelT>(new FakeQuantWithMinMaxPerChannelT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void FakeQuantWithMinMaxPerChannel::UnPackTo(FakeQuantWithMinMaxPerChannelT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<FakeQuantWithMinMaxPerChannel> FakeQuantWithMinMaxPerChannel::Pack(flatbuffers::FlatBufferBuilder &_fbb, const FakeQuantWithMinMaxPerChannelT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateFakeQuantWithMinMaxPerChannel(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<FakeQuantWithMinMaxPerChannel> CreateFakeQuantWithMinMaxPerChannel(flatbuffers::FlatBufferBuilder &_fbb, const FakeQuantWithMinMaxPerChannelT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const FakeQuantWithMinMaxPerChannelT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return mindspore::schema::v0::CreateFakeQuantWithMinMaxPerChannel(
      _fbb);
}

inline BatchNormFoldT *BatchNormFold::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<BatchNormFoldT>(new BatchNormFoldT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void BatchNormFold::UnPackTo(BatchNormFoldT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<BatchNormFold> BatchNormFold::Pack(flatbuffers::FlatBufferBuilder &_fbb, const BatchNormFoldT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateBatchNormFold(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<BatchNormFold> CreateBatchNormFold(flatbuffers::FlatBufferBuilder &_fbb, const BatchNormFoldT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const BatchNormFoldT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return mindspore::schema::v0::CreateBatchNormFold(
      _fbb);
}

inline MulFoldT *MulFold::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<MulFoldT>(new MulFoldT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void MulFold::UnPackTo(MulFoldT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<MulFold> MulFold::Pack(flatbuffers::FlatBufferBuilder &_fbb, const MulFoldT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateMulFold(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<MulFold> CreateMulFold(flatbuffers::FlatBufferBuilder &_fbb, const MulFoldT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const MulFoldT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return mindspore::schema::v0::CreateMulFold(
      _fbb);
}

inline AddFoldT *AddFold::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<AddFoldT>(new AddFoldT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void AddFold::UnPackTo(AddFoldT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<AddFold> AddFold::Pack(flatbuffers::FlatBufferBuilder &_fbb, const AddFoldT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateAddFold(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<AddFold> CreateAddFold(flatbuffers::FlatBufferBuilder &_fbb, const AddFoldT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const AddFoldT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return mindspore::schema::v0::CreateAddFold(
      _fbb);
}

inline SquaredDifferenceT *SquaredDifference::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<SquaredDifferenceT>(new SquaredDifferenceT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void SquaredDifference::UnPackTo(SquaredDifferenceT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<SquaredDifference> SquaredDifference::Pack(flatbuffers::FlatBufferBuilder &_fbb, const SquaredDifferenceT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateSquaredDifference(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<SquaredDifference> CreateSquaredDifference(flatbuffers::FlatBufferBuilder &_fbb, const SquaredDifferenceT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const SquaredDifferenceT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return mindspore::schema::v0::CreateSquaredDifference(
      _fbb);
}

inline TupleGetItemT *TupleGetItem::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<TupleGetItemT>(new TupleGetItemT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void TupleGetItem::UnPackTo(TupleGetItemT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<TupleGetItem> TupleGetItem::Pack(flatbuffers::FlatBufferBuilder &_fbb, const TupleGetItemT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateTupleGetItem(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<TupleGetItem> CreateTupleGetItem(flatbuffers::FlatBufferBuilder &_fbb, const TupleGetItemT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const TupleGetItemT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return mindspore::schema::v0::CreateTupleGetItem(
      _fbb);
}

inline ApplyMomentumT *ApplyMomentum::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<ApplyMomentumT>(new ApplyMomentumT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void ApplyMomentum::UnPackTo(ApplyMomentumT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = gradientScale(); _o->gradientScale = _e; }
  { auto _e = useNesterov(); _o->useNesterov = _e; }
}

inline flatbuffers::Offset<ApplyMomentum> ApplyMomentum::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ApplyMomentumT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateApplyMomentum(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<ApplyMomentum> CreateApplyMomentum(flatbuffers::FlatBufferBuilder &_fbb, const ApplyMomentumT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ApplyMomentumT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _gradientScale = _o->gradientScale;
  auto _useNesterov = _o->useNesterov;
  return mindspore::schema::v0::CreateApplyMomentum(
      _fbb,
      _gradientScale,
      _useNesterov);
}

inline SgdT *Sgd::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<SgdT>(new SgdT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Sgd::UnPackTo(SgdT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = weightDecay(); _o->weightDecay = _e; }
  { auto _e = dampening(); _o->dampening = _e; }
  { auto _e = useNesterov(); _o->useNesterov = _e; }
}

inline flatbuffers::Offset<Sgd> Sgd::Pack(flatbuffers::FlatBufferBuilder &_fbb, const SgdT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateSgd(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Sgd> CreateSgd(flatbuffers::FlatBufferBuilder &_fbb, const SgdT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const SgdT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _weightDecay = _o->weightDecay;
  auto _dampening = _o->dampening;
  auto _useNesterov = _o->useNesterov;
  return mindspore::schema::v0::CreateSgd(
      _fbb,
      _weightDecay,
      _dampening,
      _useNesterov);
}

inline AdamT *Adam::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<AdamT>(new AdamT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Adam::UnPackTo(AdamT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = useNesterov(); _o->useNesterov = _e; }
}

inline flatbuffers::Offset<Adam> Adam::Pack(flatbuffers::FlatBufferBuilder &_fbb, const AdamT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateAdam(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Adam> CreateAdam(flatbuffers::FlatBufferBuilder &_fbb, const AdamT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const AdamT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _useNesterov = _o->useNesterov;
  return mindspore::schema::v0::CreateAdam(
      _fbb,
      _useNesterov);
}

inline AssignT *Assign::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<AssignT>(new AssignT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Assign::UnPackTo(AssignT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<Assign> Assign::Pack(flatbuffers::FlatBufferBuilder &_fbb, const AssignT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateAssign(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Assign> CreateAssign(flatbuffers::FlatBufferBuilder &_fbb, const AssignT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const AssignT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return mindspore::schema::v0::CreateAssign(
      _fbb);
}

inline AssignAddT *AssignAdd::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<AssignAddT>(new AssignAddT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void AssignAdd::UnPackTo(AssignAddT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<AssignAdd> AssignAdd::Pack(flatbuffers::FlatBufferBuilder &_fbb, const AssignAddT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateAssignAdd(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<AssignAdd> CreateAssignAdd(flatbuffers::FlatBufferBuilder &_fbb, const AssignAddT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const AssignAddT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return mindspore::schema::v0::CreateAssignAdd(
      _fbb);
}

inline WhereT *Where::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<WhereT>(new WhereT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Where::UnPackTo(WhereT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = condition(); if (_e) { _o->condition.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->condition[_i] = _e->Get(_i) != 0; } } }
}

inline flatbuffers::Offset<Where> Where::Pack(flatbuffers::FlatBufferBuilder &_fbb, const WhereT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateWhere(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Where> CreateWhere(flatbuffers::FlatBufferBuilder &_fbb, const WhereT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const WhereT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _condition = _o->condition.size() ? _fbb.CreateVector(_o->condition) : 0;
  return mindspore::schema::v0::CreateWhere(
      _fbb,
      _condition);
}

inline OneHotT *OneHot::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<OneHotT>(new OneHotT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void OneHot::UnPackTo(OneHotT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = axis(); _o->axis = _e; }
}

inline flatbuffers::Offset<OneHot> OneHot::Pack(flatbuffers::FlatBufferBuilder &_fbb, const OneHotT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateOneHot(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<OneHot> CreateOneHot(flatbuffers::FlatBufferBuilder &_fbb, const OneHotT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const OneHotT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _axis = _o->axis;
  return mindspore::schema::v0::CreateOneHot(
      _fbb,
      _axis);
}

inline LstmT *Lstm::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<LstmT>(new LstmT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Lstm::UnPackTo(LstmT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = bidirection(); _o->bidirection = _e; }
}

inline flatbuffers::Offset<Lstm> Lstm::Pack(flatbuffers::FlatBufferBuilder &_fbb, const LstmT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateLstm(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Lstm> CreateLstm(flatbuffers::FlatBufferBuilder &_fbb, const LstmT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const LstmT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _bidirection = _o->bidirection;
  return mindspore::schema::v0::CreateLstm(
      _fbb,
      _bidirection);
}

inline PriorBoxT *PriorBox::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<PriorBoxT>(new PriorBoxT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void PriorBox::UnPackTo(PriorBoxT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = min_sizes(); if (_e) { _o->min_sizes.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->min_sizes[_i] = _e->Get(_i); } } }
  { auto _e = max_sizes(); if (_e) { _o->max_sizes.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->max_sizes[_i] = _e->Get(_i); } } }
  { auto _e = aspect_ratios(); if (_e) { _o->aspect_ratios.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->aspect_ratios[_i] = _e->Get(_i); } } }
  { auto _e = variances(); if (_e) { _o->variances.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->variances[_i] = _e->Get(_i); } } }
  { auto _e = image_size_w(); _o->image_size_w = _e; }
  { auto _e = image_size_h(); _o->image_size_h = _e; }
  { auto _e = step_w(); _o->step_w = _e; }
  { auto _e = step_h(); _o->step_h = _e; }
  { auto _e = clip(); _o->clip = _e; }
  { auto _e = flip(); _o->flip = _e; }
  { auto _e = offset(); _o->offset = _e; }
}

inline flatbuffers::Offset<PriorBox> PriorBox::Pack(flatbuffers::FlatBufferBuilder &_fbb, const PriorBoxT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreatePriorBox(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<PriorBox> CreatePriorBox(flatbuffers::FlatBufferBuilder &_fbb, const PriorBoxT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const PriorBoxT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _min_sizes = _o->min_sizes.size() ? _fbb.CreateVector(_o->min_sizes) : 0;
  auto _max_sizes = _o->max_sizes.size() ? _fbb.CreateVector(_o->max_sizes) : 0;
  auto _aspect_ratios = _o->aspect_ratios.size() ? _fbb.CreateVector(_o->aspect_ratios) : 0;
  auto _variances = _o->variances.size() ? _fbb.CreateVector(_o->variances) : 0;
  auto _image_size_w = _o->image_size_w;
  auto _image_size_h = _o->image_size_h;
  auto _step_w = _o->step_w;
  auto _step_h = _o->step_h;
  auto _clip = _o->clip;
  auto _flip = _o->flip;
  auto _offset = _o->offset;
  return mindspore::schema::v0::CreatePriorBox(
      _fbb,
      _min_sizes,
      _max_sizes,
      _aspect_ratios,
      _variances,
      _image_size_w,
      _image_size_h,
      _step_w,
      _step_h,
      _clip,
      _flip,
      _offset);
}

inline SpaceToBatchNDT *SpaceToBatchND::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<SpaceToBatchNDT>(new SpaceToBatchNDT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void SpaceToBatchND::UnPackTo(SpaceToBatchNDT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = blockShape(); if (_e) { _o->blockShape.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->blockShape[_i] = _e->Get(_i); } } }
  { auto _e = paddings(); if (_e) { _o->paddings.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->paddings[_i] = _e->Get(_i); } } }
}

inline flatbuffers::Offset<SpaceToBatchND> SpaceToBatchND::Pack(flatbuffers::FlatBufferBuilder &_fbb, const SpaceToBatchNDT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateSpaceToBatchND(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<SpaceToBatchND> CreateSpaceToBatchND(flatbuffers::FlatBufferBuilder &_fbb, const SpaceToBatchNDT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const SpaceToBatchNDT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _blockShape = _o->blockShape.size() ? _fbb.CreateVector(_o->blockShape) : 0;
  auto _paddings = _o->paddings.size() ? _fbb.CreateVector(_o->paddings) : 0;
  return mindspore::schema::v0::CreateSpaceToBatchND(
      _fbb,
      _blockShape,
      _paddings);
}

inline MakeTupleT *MakeTuple::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<MakeTupleT>(new MakeTupleT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void MakeTuple::UnPackTo(MakeTupleT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<MakeTuple> MakeTuple::Pack(flatbuffers::FlatBufferBuilder &_fbb, const MakeTupleT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateMakeTuple(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<MakeTuple> CreateMakeTuple(flatbuffers::FlatBufferBuilder &_fbb, const MakeTupleT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const MakeTupleT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return mindspore::schema::v0::CreateMakeTuple(
      _fbb);
}

inline ToFormatT *ToFormat::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<ToFormatT>(new ToFormatT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void ToFormat::UnPackTo(ToFormatT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = srcT(); _o->srcT = _e; }
  { auto _e = dstT(); _o->dstT = _e; }
}

inline flatbuffers::Offset<ToFormat> ToFormat::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ToFormatT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateToFormat(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<ToFormat> CreateToFormat(flatbuffers::FlatBufferBuilder &_fbb, const ToFormatT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ToFormatT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _srcT = _o->srcT;
  auto _dstT = _o->dstT;
  return mindspore::schema::v0::CreateToFormat(
      _fbb,
      _srcT,
      _dstT);
}

inline DependT *Depend::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<DependT>(new DependT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Depend::UnPackTo(DependT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<Depend> Depend::Pack(flatbuffers::FlatBufferBuilder &_fbb, const DependT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateDepend(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Depend> CreateDepend(flatbuffers::FlatBufferBuilder &_fbb, const DependT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const DependT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return mindspore::schema::v0::CreateDepend(
      _fbb);
}

inline ControlDependT *ControlDepend::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<ControlDependT>(new ControlDependT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void ControlDepend::UnPackTo(ControlDependT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<ControlDepend> ControlDepend::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ControlDependT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateControlDepend(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<ControlDepend> CreateControlDepend(flatbuffers::FlatBufferBuilder &_fbb, const ControlDependT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ControlDependT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return mindspore::schema::v0::CreateControlDepend(
      _fbb);
}

inline ReturnT *Return::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<ReturnT>(new ReturnT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Return::UnPackTo(ReturnT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<Return> Return::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ReturnT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateReturn(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Return> CreateReturn(flatbuffers::FlatBufferBuilder &_fbb, const ReturnT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ReturnT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return mindspore::schema::v0::CreateReturn(
      _fbb);
}

inline ProposalT *Proposal::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<ProposalT>(new ProposalT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Proposal::UnPackTo(ProposalT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = feat_stride(); _o->feat_stride = _e; }
  { auto _e = base_size(); _o->base_size = _e; }
  { auto _e = min_size(); _o->min_size = _e; }
  { auto _e = ratio(); if (_e) { _o->ratio.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->ratio[_i] = _e->Get(_i); } } }
  { auto _e = scale(); if (_e) { _o->scale.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->scale[_i] = _e->Get(_i); } } }
  { auto _e = pre_nms_topn(); _o->pre_nms_topn = _e; }
  { auto _e = post_nms_topn(); _o->post_nms_topn = _e; }
  { auto _e = nms_thresh(); _o->nms_thresh = _e; }
}

inline flatbuffers::Offset<Proposal> Proposal::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ProposalT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateProposal(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Proposal> CreateProposal(flatbuffers::FlatBufferBuilder &_fbb, const ProposalT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ProposalT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _feat_stride = _o->feat_stride;
  auto _base_size = _o->base_size;
  auto _min_size = _o->min_size;
  auto _ratio = _o->ratio.size() ? _fbb.CreateVector(_o->ratio) : 0;
  auto _scale = _o->scale.size() ? _fbb.CreateVector(_o->scale) : 0;
  auto _pre_nms_topn = _o->pre_nms_topn;
  auto _post_nms_topn = _o->post_nms_topn;
  auto _nms_thresh = _o->nms_thresh;
  return mindspore::schema::v0::CreateProposal(
      _fbb,
      _feat_stride,
      _base_size,
      _min_size,
      _ratio,
      _scale,
      _pre_nms_topn,
      _post_nms_topn,
      _nms_thresh);
}

inline CustomT *Custom::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<CustomT>(new CustomT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Custom::UnPackTo(CustomT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = custom(); if (_e) { _o->custom.resize(_e->size()); std::copy(_e->begin(), _e->end(), _o->custom.begin()); } }
}

inline flatbuffers::Offset<Custom> Custom::Pack(flatbuffers::FlatBufferBuilder &_fbb, const CustomT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateCustom(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Custom> CreateCustom(flatbuffers::FlatBufferBuilder &_fbb, const CustomT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const CustomT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _custom = _o->custom.size() ? _fbb.CreateVector(_o->custom) : 0;
  return mindspore::schema::v0::CreateCustom(
      _fbb,
      _custom);
}

inline BlackBoxT *BlackBox::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<BlackBoxT>(new BlackBoxT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void BlackBox::UnPackTo(BlackBoxT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = id(); if (_e) _o->id = _e->str(); }
  { auto _e = size(); _o->size = _e; }
  { auto _e = address(); if (_e) { _o->address.resize(_e->size()); std::copy(_e->begin(), _e->end(), _o->address.begin()); } }
}

inline flatbuffers::Offset<BlackBox> BlackBox::Pack(flatbuffers::FlatBufferBuilder &_fbb, const BlackBoxT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateBlackBox(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<BlackBox> CreateBlackBox(flatbuffers::FlatBufferBuilder &_fbb, const BlackBoxT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const BlackBoxT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _id = _o->id.empty() ? 0 : _fbb.CreateString(_o->id);
  auto _size = _o->size;
  auto _address = _o->address.size() ? _fbb.CreateVector(_o->address) : 0;
  return mindspore::schema::v0::CreateBlackBox(
      _fbb,
      _id,
      _size,
      _address);
}

inline LshProjectionT *LshProjection::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<LshProjectionT>(new LshProjectionT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void LshProjection::UnPackTo(LshProjectionT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = type(); _o->type = _e; }
}

inline flatbuffers::Offset<LshProjection> LshProjection::Pack(flatbuffers::FlatBufferBuilder &_fbb, const LshProjectionT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateLshProjection(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<LshProjection> CreateLshProjection(flatbuffers::FlatBufferBuilder &_fbb, const LshProjectionT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const LshProjectionT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _type = _o->type;
  return mindspore::schema::v0::CreateLshProjection(
      _fbb,
      _type);
}

inline HashtableLookupT *HashtableLookup::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<HashtableLookupT>(new HashtableLookupT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void HashtableLookup::UnPackTo(HashtableLookupT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<HashtableLookup> HashtableLookup::Pack(flatbuffers::FlatBufferBuilder &_fbb, const HashtableLookupT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateHashtableLookup(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<HashtableLookup> CreateHashtableLookup(flatbuffers::FlatBufferBuilder &_fbb, const HashtableLookupT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const HashtableLookupT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return mindspore::schema::v0::CreateHashtableLookup(
      _fbb);
}

inline SkipGramT *SkipGram::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<SkipGramT>(new SkipGramT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void SkipGram::UnPackTo(SkipGramT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = includeAllGrams(); _o->includeAllGrams = _e; }
  { auto _e = maxSkipSize(); _o->maxSkipSize = _e; }
  { auto _e = ngramSize(); _o->ngramSize = _e; }
}

inline flatbuffers::Offset<SkipGram> SkipGram::Pack(flatbuffers::FlatBufferBuilder &_fbb, const SkipGramT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateSkipGram(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<SkipGram> CreateSkipGram(flatbuffers::FlatBufferBuilder &_fbb, const SkipGramT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const SkipGramT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _includeAllGrams = _o->includeAllGrams;
  auto _maxSkipSize = _o->maxSkipSize;
  auto _ngramSize = _o->ngramSize;
  return mindspore::schema::v0::CreateSkipGram(
      _fbb,
      _includeAllGrams,
      _maxSkipSize,
      _ngramSize);
}

inline CustomPredictT *CustomPredict::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<CustomPredictT>(new CustomPredictT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void CustomPredict::UnPackTo(CustomPredictT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = outputNum(); _o->outputNum = _e; }
  { auto _e = weightThreshold(); _o->weightThreshold = _e; }
}

inline flatbuffers::Offset<CustomPredict> CustomPredict::Pack(flatbuffers::FlatBufferBuilder &_fbb, const CustomPredictT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateCustomPredict(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<CustomPredict> CreateCustomPredict(flatbuffers::FlatBufferBuilder &_fbb, const CustomPredictT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const CustomPredictT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _outputNum = _o->outputNum;
  auto _weightThreshold = _o->weightThreshold;
  return mindspore::schema::v0::CreateCustomPredict(
      _fbb,
      _outputNum,
      _weightThreshold);
}

inline CustomNormalizeT *CustomNormalize::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<CustomNormalizeT>(new CustomNormalizeT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void CustomNormalize::UnPackTo(CustomNormalizeT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<CustomNormalize> CustomNormalize::Pack(flatbuffers::FlatBufferBuilder &_fbb, const CustomNormalizeT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateCustomNormalize(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<CustomNormalize> CreateCustomNormalize(flatbuffers::FlatBufferBuilder &_fbb, const CustomNormalizeT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const CustomNormalizeT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return mindspore::schema::v0::CreateCustomNormalize(
      _fbb);
}

inline CustomExtractFeaturesT *CustomExtractFeatures::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<CustomExtractFeaturesT>(new CustomExtractFeaturesT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void CustomExtractFeatures::UnPackTo(CustomExtractFeaturesT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<CustomExtractFeatures> CustomExtractFeatures::Pack(flatbuffers::FlatBufferBuilder &_fbb, const CustomExtractFeaturesT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateCustomExtractFeatures(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<CustomExtractFeatures> CreateCustomExtractFeatures(flatbuffers::FlatBufferBuilder &_fbb, const CustomExtractFeaturesT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const CustomExtractFeaturesT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return mindspore::schema::v0::CreateCustomExtractFeatures(
      _fbb);
}

inline AudioSpectrogramT *AudioSpectrogram::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<AudioSpectrogramT>(new AudioSpectrogramT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void AudioSpectrogram::UnPackTo(AudioSpectrogramT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = windowSize(); _o->windowSize = _e; }
  { auto _e = stride(); _o->stride = _e; }
  { auto _e = magSquare(); _o->magSquare = _e; }
}

inline flatbuffers::Offset<AudioSpectrogram> AudioSpectrogram::Pack(flatbuffers::FlatBufferBuilder &_fbb, const AudioSpectrogramT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateAudioSpectrogram(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<AudioSpectrogram> CreateAudioSpectrogram(flatbuffers::FlatBufferBuilder &_fbb, const AudioSpectrogramT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const AudioSpectrogramT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _windowSize = _o->windowSize;
  auto _stride = _o->stride;
  auto _magSquare = _o->magSquare;
  return mindspore::schema::v0::CreateAudioSpectrogram(
      _fbb,
      _windowSize,
      _stride,
      _magSquare);
}

inline MfccT *Mfcc::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<MfccT>(new MfccT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Mfcc::UnPackTo(MfccT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = freqUpperLimit(); _o->freqUpperLimit = _e; }
  { auto _e = freqLowerLimit(); _o->freqLowerLimit = _e; }
  { auto _e = filterBankChannelNum(); _o->filterBankChannelNum = _e; }
  { auto _e = dctCoeffNum(); _o->dctCoeffNum = _e; }
}

inline flatbuffers::Offset<Mfcc> Mfcc::Pack(flatbuffers::FlatBufferBuilder &_fbb, const MfccT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateMfcc(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Mfcc> CreateMfcc(flatbuffers::FlatBufferBuilder &_fbb, const MfccT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const MfccT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _freqUpperLimit = _o->freqUpperLimit;
  auto _freqLowerLimit = _o->freqLowerLimit;
  auto _filterBankChannelNum = _o->filterBankChannelNum;
  auto _dctCoeffNum = _o->dctCoeffNum;
  return mindspore::schema::v0::CreateMfcc(
      _fbb,
      _freqUpperLimit,
      _freqLowerLimit,
      _filterBankChannelNum,
      _dctCoeffNum);
}

inline RfftT *Rfft::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<RfftT>(new RfftT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Rfft::UnPackTo(RfftT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = fftLength(); _o->fftLength = _e; }
}

inline flatbuffers::Offset<Rfft> Rfft::Pack(flatbuffers::FlatBufferBuilder &_fbb, const RfftT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateRfft(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Rfft> CreateRfft(flatbuffers::FlatBufferBuilder &_fbb, const RfftT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const RfftT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _fftLength = _o->fftLength;
  return mindspore::schema::v0::CreateRfft(
      _fbb,
      _fftLength);
}

inline FftRealT *FftReal::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<FftRealT>(new FftRealT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void FftReal::UnPackTo(FftRealT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<FftReal> FftReal::Pack(flatbuffers::FlatBufferBuilder &_fbb, const FftRealT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateFftReal(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<FftReal> CreateFftReal(flatbuffers::FlatBufferBuilder &_fbb, const FftRealT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const FftRealT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return mindspore::schema::v0::CreateFftReal(
      _fbb);
}

inline FftImagT *FftImag::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<FftImagT>(new FftImagT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void FftImag::UnPackTo(FftImagT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<FftImag> FftImag::Pack(flatbuffers::FlatBufferBuilder &_fbb, const FftImagT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateFftImag(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<FftImag> CreateFftImag(flatbuffers::FlatBufferBuilder &_fbb, const FftImagT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const FftImagT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return mindspore::schema::v0::CreateFftImag(
      _fbb);
}

inline DropoutGradT *DropoutGrad::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<DropoutGradT>(new DropoutGradT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void DropoutGrad::UnPackTo(DropoutGradT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = ratio(); _o->ratio = _e; }
}

inline flatbuffers::Offset<DropoutGrad> DropoutGrad::Pack(flatbuffers::FlatBufferBuilder &_fbb, const DropoutGradT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateDropoutGrad(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<DropoutGrad> CreateDropoutGrad(flatbuffers::FlatBufferBuilder &_fbb, const DropoutGradT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const DropoutGradT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _ratio = _o->ratio;
  return mindspore::schema::v0::CreateDropoutGrad(
      _fbb,
      _ratio);
}

inline MaximumGradT *MaximumGrad::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<MaximumGradT>(new MaximumGradT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void MaximumGrad::UnPackTo(MaximumGradT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<MaximumGrad> MaximumGrad::Pack(flatbuffers::FlatBufferBuilder &_fbb, const MaximumGradT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateMaximumGrad(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<MaximumGrad> CreateMaximumGrad(flatbuffers::FlatBufferBuilder &_fbb, const MaximumGradT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const MaximumGradT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return mindspore::schema::v0::CreateMaximumGrad(
      _fbb);
}

inline MinimumGradT *MinimumGrad::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<MinimumGradT>(new MinimumGradT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void MinimumGrad::UnPackTo(MinimumGradT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<MinimumGrad> MinimumGrad::Pack(flatbuffers::FlatBufferBuilder &_fbb, const MinimumGradT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateMinimumGrad(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<MinimumGrad> CreateMinimumGrad(flatbuffers::FlatBufferBuilder &_fbb, const MinimumGradT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const MinimumGradT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return mindspore::schema::v0::CreateMinimumGrad(
      _fbb);
}

inline NonMaxSuppressionT *NonMaxSuppression::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<NonMaxSuppressionT>(new NonMaxSuppressionT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void NonMaxSuppression::UnPackTo(NonMaxSuppressionT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = centerPointBox(); _o->centerPointBox = _e; }
}

inline flatbuffers::Offset<NonMaxSuppression> NonMaxSuppression::Pack(flatbuffers::FlatBufferBuilder &_fbb, const NonMaxSuppressionT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateNonMaxSuppression(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<NonMaxSuppression> CreateNonMaxSuppression(flatbuffers::FlatBufferBuilder &_fbb, const NonMaxSuppressionT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const NonMaxSuppressionT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _centerPointBox = _o->centerPointBox;
  return mindspore::schema::v0::CreateNonMaxSuppression(
      _fbb,
      _centerPointBox);
}

inline InstanceNormT *InstanceNorm::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<InstanceNormT>(new InstanceNormT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void InstanceNorm::UnPackTo(InstanceNormT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = epsilon(); _o->epsilon = _e; }
}

inline flatbuffers::Offset<InstanceNorm> InstanceNorm::Pack(flatbuffers::FlatBufferBuilder &_fbb, const InstanceNormT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateInstanceNorm(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<InstanceNorm> CreateInstanceNorm(flatbuffers::FlatBufferBuilder &_fbb, const InstanceNormT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const InstanceNormT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _epsilon = _o->epsilon;
  return mindspore::schema::v0::CreateInstanceNorm(
      _fbb,
      _epsilon);
}

inline LoopT *Loop::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<LoopT>(new LoopT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Loop::UnPackTo(LoopT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = subGraphIndex(); _o->subGraphIndex = _e; }
}

inline flatbuffers::Offset<Loop> Loop::Pack(flatbuffers::FlatBufferBuilder &_fbb, const LoopT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateLoop(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Loop> CreateLoop(flatbuffers::FlatBufferBuilder &_fbb, const LoopT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const LoopT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _subGraphIndex = _o->subGraphIndex;
  return mindspore::schema::v0::CreateLoop(
      _fbb,
      _subGraphIndex);
}

inline IdentityT *Identity::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<IdentityT>(new IdentityT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Identity::UnPackTo(IdentityT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<Identity> Identity::Pack(flatbuffers::FlatBufferBuilder &_fbb, const IdentityT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateIdentity(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Identity> CreateIdentity(flatbuffers::FlatBufferBuilder &_fbb, const IdentityT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const IdentityT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return mindspore::schema::v0::CreateIdentity(
      _fbb);
}

inline LayerNormT *LayerNorm::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<LayerNormT>(new LayerNormT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void LayerNorm::UnPackTo(LayerNormT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = normalizedShape(); if (_e) { _o->normalizedShape.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->normalizedShape[_i] = _e->Get(_i); } } }
  { auto _e = epsilon(); _o->epsilon = _e; }
  { auto _e = elementwiseAffine(); _o->elementwiseAffine = _e; }
}

inline flatbuffers::Offset<LayerNorm> LayerNorm::Pack(flatbuffers::FlatBufferBuilder &_fbb, const LayerNormT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateLayerNorm(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<LayerNorm> CreateLayerNorm(flatbuffers::FlatBufferBuilder &_fbb, const LayerNormT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const LayerNormT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _normalizedShape = _o->normalizedShape.size() ? _fbb.CreateVector(_o->normalizedShape) : 0;
  auto _epsilon = _o->epsilon;
  auto _elementwiseAffine = _o->elementwiseAffine;
  return mindspore::schema::v0::CreateLayerNorm(
      _fbb,
      _normalizedShape,
      _epsilon,
      _elementwiseAffine);
}

inline WhileT *While::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<WhileT>(new WhileT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void While::UnPackTo(WhileT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = condSubgraphIndex(); _o->condSubgraphIndex = _e; }
  { auto _e = bodySubgraphIndex(); _o->bodySubgraphIndex = _e; }
}

inline flatbuffers::Offset<While> While::Pack(flatbuffers::FlatBufferBuilder &_fbb, const WhileT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateWhile(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<While> CreateWhile(flatbuffers::FlatBufferBuilder &_fbb, const WhileT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const WhileT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _condSubgraphIndex = _o->condSubgraphIndex;
  auto _bodySubgraphIndex = _o->bodySubgraphIndex;
  return mindspore::schema::v0::CreateWhile(
      _fbb,
      _condSubgraphIndex,
      _bodySubgraphIndex);
}

inline UnsortedSegmentSumT *UnsortedSegmentSum::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<UnsortedSegmentSumT>(new UnsortedSegmentSumT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void UnsortedSegmentSum::UnPackTo(UnsortedSegmentSumT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = numSegments(); _o->numSegments = _e; }
}

inline flatbuffers::Offset<UnsortedSegmentSum> UnsortedSegmentSum::Pack(flatbuffers::FlatBufferBuilder &_fbb, const UnsortedSegmentSumT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateUnsortedSegmentSum(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<UnsortedSegmentSum> CreateUnsortedSegmentSum(flatbuffers::FlatBufferBuilder &_fbb, const UnsortedSegmentSumT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const UnsortedSegmentSumT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _numSegments = _o->numSegments;
  return mindspore::schema::v0::CreateUnsortedSegmentSum(
      _fbb,
      _numSegments);
}

inline OnesLikeT *OnesLike::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<OnesLikeT>(new OnesLikeT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void OnesLike::UnPackTo(OnesLikeT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<OnesLike> OnesLike::Pack(flatbuffers::FlatBufferBuilder &_fbb, const OnesLikeT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateOnesLike(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<OnesLike> CreateOnesLike(flatbuffers::FlatBufferBuilder &_fbb, const OnesLikeT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const OnesLikeT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return mindspore::schema::v0::CreateOnesLike(
      _fbb);
}

inline BinaryCrossEntropyT *BinaryCrossEntropy::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<BinaryCrossEntropyT>(new BinaryCrossEntropyT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void BinaryCrossEntropy::UnPackTo(BinaryCrossEntropyT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = reduction(); _o->reduction = _e; }
}

inline flatbuffers::Offset<BinaryCrossEntropy> BinaryCrossEntropy::Pack(flatbuffers::FlatBufferBuilder &_fbb, const BinaryCrossEntropyT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateBinaryCrossEntropy(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<BinaryCrossEntropy> CreateBinaryCrossEntropy(flatbuffers::FlatBufferBuilder &_fbb, const BinaryCrossEntropyT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const BinaryCrossEntropyT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _reduction = _o->reduction;
  return mindspore::schema::v0::CreateBinaryCrossEntropy(
      _fbb,
      _reduction);
}

inline BinaryCrossEntropyGradT *BinaryCrossEntropyGrad::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<BinaryCrossEntropyGradT>(new BinaryCrossEntropyGradT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void BinaryCrossEntropyGrad::UnPackTo(BinaryCrossEntropyGradT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = reduction(); _o->reduction = _e; }
}

inline flatbuffers::Offset<BinaryCrossEntropyGrad> BinaryCrossEntropyGrad::Pack(flatbuffers::FlatBufferBuilder &_fbb, const BinaryCrossEntropyGradT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateBinaryCrossEntropyGrad(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<BinaryCrossEntropyGrad> CreateBinaryCrossEntropyGrad(flatbuffers::FlatBufferBuilder &_fbb, const BinaryCrossEntropyGradT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const BinaryCrossEntropyGradT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _reduction = _o->reduction;
  return mindspore::schema::v0::CreateBinaryCrossEntropyGrad(
      _fbb,
      _reduction);
}

inline LpNormalizationT *LpNormalization::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<LpNormalizationT>(new LpNormalizationT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void LpNormalization::UnPackTo(LpNormalizationT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = axis(); _o->axis = _e; }
  { auto _e = p(); _o->p = _e; }
}

inline flatbuffers::Offset<LpNormalization> LpNormalization::Pack(flatbuffers::FlatBufferBuilder &_fbb, const LpNormalizationT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateLpNormalization(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<LpNormalization> CreateLpNormalization(flatbuffers::FlatBufferBuilder &_fbb, const LpNormalizationT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const LpNormalizationT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _axis = _o->axis;
  auto _p = _o->p;
  return mindspore::schema::v0::CreateLpNormalization(
      _fbb,
      _axis,
      _p);
}

inline SwitchT *Switch::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<SwitchT>(new SwitchT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Switch::UnPackTo(SwitchT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<Switch> Switch::Pack(flatbuffers::FlatBufferBuilder &_fbb, const SwitchT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateSwitch(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Switch> CreateSwitch(flatbuffers::FlatBufferBuilder &_fbb, const SwitchT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const SwitchT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return mindspore::schema::v0::CreateSwitch(
      _fbb);
}

inline PartialT *Partial::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<PartialT>(new PartialT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Partial::UnPackTo(PartialT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = subGraphIndex(); _o->subGraphIndex = _e; }
}

inline flatbuffers::Offset<Partial> Partial::Pack(flatbuffers::FlatBufferBuilder &_fbb, const PartialT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreatePartial(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Partial> CreatePartial(flatbuffers::FlatBufferBuilder &_fbb, const PartialT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const PartialT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _subGraphIndex = _o->subGraphIndex;
  return mindspore::schema::v0::CreatePartial(
      _fbb,
      _subGraphIndex);
}

inline TensorListFromTensorT *TensorListFromTensor::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<TensorListFromTensorT>(new TensorListFromTensorT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void TensorListFromTensor::UnPackTo(TensorListFromTensorT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = elementDType(); _o->elementDType = _e; }
  { auto _e = shapeType(); _o->shapeType = _e; }
}

inline flatbuffers::Offset<TensorListFromTensor> TensorListFromTensor::Pack(flatbuffers::FlatBufferBuilder &_fbb, const TensorListFromTensorT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateTensorListFromTensor(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<TensorListFromTensor> CreateTensorListFromTensor(flatbuffers::FlatBufferBuilder &_fbb, const TensorListFromTensorT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const TensorListFromTensorT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _elementDType = _o->elementDType;
  auto _shapeType = _o->shapeType;
  return mindspore::schema::v0::CreateTensorListFromTensor(
      _fbb,
      _elementDType,
      _shapeType);
}

inline TensorListStackT *TensorListStack::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<TensorListStackT>(new TensorListStackT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void TensorListStack::UnPackTo(TensorListStackT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = numElements(); _o->numElements = _e; }
  { auto _e = elementDType(); _o->elementDType = _e; }
}

inline flatbuffers::Offset<TensorListStack> TensorListStack::Pack(flatbuffers::FlatBufferBuilder &_fbb, const TensorListStackT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateTensorListStack(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<TensorListStack> CreateTensorListStack(flatbuffers::FlatBufferBuilder &_fbb, const TensorListStackT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const TensorListStackT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _numElements = _o->numElements;
  auto _elementDType = _o->elementDType;
  return mindspore::schema::v0::CreateTensorListStack(
      _fbb,
      _numElements,
      _elementDType);
}

inline TensorListGetItemT *TensorListGetItem::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<TensorListGetItemT>(new TensorListGetItemT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void TensorListGetItem::UnPackTo(TensorListGetItemT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = elementDType(); _o->elementDType = _e; }
}

inline flatbuffers::Offset<TensorListGetItem> TensorListGetItem::Pack(flatbuffers::FlatBufferBuilder &_fbb, const TensorListGetItemT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateTensorListGetItem(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<TensorListGetItem> CreateTensorListGetItem(flatbuffers::FlatBufferBuilder &_fbb, const TensorListGetItemT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const TensorListGetItemT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _elementDType = _o->elementDType;
  return mindspore::schema::v0::CreateTensorListGetItem(
      _fbb,
      _elementDType);
}

inline TensorListSetItemT *TensorListSetItem::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<TensorListSetItemT>(new TensorListSetItemT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void TensorListSetItem::UnPackTo(TensorListSetItemT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = elementDType(); _o->elementDType = _e; }
}

inline flatbuffers::Offset<TensorListSetItem> TensorListSetItem::Pack(flatbuffers::FlatBufferBuilder &_fbb, const TensorListSetItemT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateTensorListSetItem(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<TensorListSetItem> CreateTensorListSetItem(flatbuffers::FlatBufferBuilder &_fbb, const TensorListSetItemT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const TensorListSetItemT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _elementDType = _o->elementDType;
  return mindspore::schema::v0::CreateTensorListSetItem(
      _fbb,
      _elementDType);
}

inline TensorListReserveT *TensorListReserve::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<TensorListReserveT>(new TensorListReserveT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void TensorListReserve::UnPackTo(TensorListReserveT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = elementDType(); _o->elementDType = _e; }
  { auto _e = shapeType(); _o->shapeType = _e; }
}

inline flatbuffers::Offset<TensorListReserve> TensorListReserve::Pack(flatbuffers::FlatBufferBuilder &_fbb, const TensorListReserveT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateTensorListReserve(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<TensorListReserve> CreateTensorListReserve(flatbuffers::FlatBufferBuilder &_fbb, const TensorListReserveT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const TensorListReserveT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _elementDType = _o->elementDType;
  auto _shapeType = _o->shapeType;
  return mindspore::schema::v0::CreateTensorListReserve(
      _fbb,
      _elementDType,
      _shapeType);
}

inline AllT *All::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<AllT>(new AllT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void All::UnPackTo(AllT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = keepDims(); _o->keepDims = _e; }
}

inline flatbuffers::Offset<All> All::Pack(flatbuffers::FlatBufferBuilder &_fbb, const AllT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateAll(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<All> CreateAll(flatbuffers::FlatBufferBuilder &_fbb, const AllT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const AllT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _keepDims = _o->keepDims;
  return mindspore::schema::v0::CreateAll(
      _fbb,
      _keepDims);
}

inline AssertT *Assert::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<AssertT>(new AssertT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Assert::UnPackTo(AssertT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = summarize(); _o->summarize = _e; }
}

inline flatbuffers::Offset<Assert> Assert::Pack(flatbuffers::FlatBufferBuilder &_fbb, const AssertT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateAssert(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Assert> CreateAssert(flatbuffers::FlatBufferBuilder &_fbb, const AssertT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const AssertT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _summarize = _o->summarize;
  return mindspore::schema::v0::CreateAssert(
      _fbb,
      _summarize);
}

inline SmoothL1LossT *SmoothL1Loss::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<SmoothL1LossT>(new SmoothL1LossT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void SmoothL1Loss::UnPackTo(SmoothL1LossT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = beta(); _o->beta = _e; }
}

inline flatbuffers::Offset<SmoothL1Loss> SmoothL1Loss::Pack(flatbuffers::FlatBufferBuilder &_fbb, const SmoothL1LossT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateSmoothL1Loss(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<SmoothL1Loss> CreateSmoothL1Loss(flatbuffers::FlatBufferBuilder &_fbb, const SmoothL1LossT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const SmoothL1LossT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _beta = _o->beta;
  return mindspore::schema::v0::CreateSmoothL1Loss(
      _fbb,
      _beta);
}

inline SmoothL1LossGradT *SmoothL1LossGrad::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<SmoothL1LossGradT>(new SmoothL1LossGradT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void SmoothL1LossGrad::UnPackTo(SmoothL1LossGradT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = beta(); _o->beta = _e; }
}

inline flatbuffers::Offset<SmoothL1LossGrad> SmoothL1LossGrad::Pack(flatbuffers::FlatBufferBuilder &_fbb, const SmoothL1LossGradT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateSmoothL1LossGrad(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<SmoothL1LossGrad> CreateSmoothL1LossGrad(flatbuffers::FlatBufferBuilder &_fbb, const SmoothL1LossGradT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const SmoothL1LossGradT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _beta = _o->beta;
  return mindspore::schema::v0::CreateSmoothL1LossGrad(
      _fbb,
      _beta);
}

inline SigmoidCrossEntropyWithLogitsT *SigmoidCrossEntropyWithLogits::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<SigmoidCrossEntropyWithLogitsT>(new SigmoidCrossEntropyWithLogitsT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void SigmoidCrossEntropyWithLogits::UnPackTo(SigmoidCrossEntropyWithLogitsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = beta(); _o->beta = _e; }
}

inline flatbuffers::Offset<SigmoidCrossEntropyWithLogits> SigmoidCrossEntropyWithLogits::Pack(flatbuffers::FlatBufferBuilder &_fbb, const SigmoidCrossEntropyWithLogitsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateSigmoidCrossEntropyWithLogits(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<SigmoidCrossEntropyWithLogits> CreateSigmoidCrossEntropyWithLogits(flatbuffers::FlatBufferBuilder &_fbb, const SigmoidCrossEntropyWithLogitsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const SigmoidCrossEntropyWithLogitsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _beta = _o->beta;
  return mindspore::schema::v0::CreateSigmoidCrossEntropyWithLogits(
      _fbb,
      _beta);
}

inline SigmoidCrossEntropyWithLogitsGradT *SigmoidCrossEntropyWithLogitsGrad::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<SigmoidCrossEntropyWithLogitsGradT>(new SigmoidCrossEntropyWithLogitsGradT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void SigmoidCrossEntropyWithLogitsGrad::UnPackTo(SigmoidCrossEntropyWithLogitsGradT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = beta(); _o->beta = _e; }
}

inline flatbuffers::Offset<SigmoidCrossEntropyWithLogitsGrad> SigmoidCrossEntropyWithLogitsGrad::Pack(flatbuffers::FlatBufferBuilder &_fbb, const SigmoidCrossEntropyWithLogitsGradT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateSigmoidCrossEntropyWithLogitsGrad(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<SigmoidCrossEntropyWithLogitsGrad> CreateSigmoidCrossEntropyWithLogitsGrad(flatbuffers::FlatBufferBuilder &_fbb, const SigmoidCrossEntropyWithLogitsGradT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const SigmoidCrossEntropyWithLogitsGradT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _beta = _o->beta;
  return mindspore::schema::v0::CreateSigmoidCrossEntropyWithLogitsGrad(
      _fbb,
      _beta);
}

inline ReciprocalT *Reciprocal::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<ReciprocalT>(new ReciprocalT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Reciprocal::UnPackTo(ReciprocalT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<Reciprocal> Reciprocal::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ReciprocalT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateReciprocal(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Reciprocal> CreateReciprocal(flatbuffers::FlatBufferBuilder &_fbb, const ReciprocalT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ReciprocalT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return mindspore::schema::v0::CreateReciprocal(
      _fbb);
}

inline MergeT *Merge::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<MergeT>(new MergeT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Merge::UnPackTo(MergeT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<Merge> Merge::Pack(flatbuffers::FlatBufferBuilder &_fbb, const MergeT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateMerge(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Merge> CreateMerge(flatbuffers::FlatBufferBuilder &_fbb, const MergeT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const MergeT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return mindspore::schema::v0::CreateMerge(
      _fbb);
}

inline GeLUT *GeLU::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<GeLUT>(new GeLUT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void GeLU::UnPackTo(GeLUT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = approximate(); _o->approximate = _e; }
}

inline flatbuffers::Offset<GeLU> GeLU::Pack(flatbuffers::FlatBufferBuilder &_fbb, const GeLUT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateGeLU(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<GeLU> CreateGeLU(flatbuffers::FlatBufferBuilder &_fbb, const GeLUT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const GeLUT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _approximate = _o->approximate;
  return mindspore::schema::v0::CreateGeLU(
      _fbb,
      _approximate);
}

inline const flatbuffers::TypeTable *ResizeMethodTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    mindspore::schema::v0::ResizeMethodTypeTable
  };
  static const int64_t values[] = { -1, 0, 1, 2 };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_ENUM, 4, type_codes, type_refs, nullptr, values, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *CoordinateTransformModeTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    mindspore::schema::v0::CoordinateTransformModeTypeTable
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_ENUM, 8, type_codes, type_refs, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *NearestModeTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    mindspore::schema::v0::NearestModeTypeTable
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_ENUM, 5, type_codes, type_refs, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *FormatTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    mindspore::schema::v0::FormatTypeTable
  };
  static const int64_t values[] = { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 100, 101 };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_ENUM, 15, type_codes, type_refs, nullptr, values, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *ActivationTypeTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    mindspore::schema::v0::ActivationTypeTypeTable
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_ENUM, 20, type_codes, type_refs, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *ReduceTypeTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    mindspore::schema::v0::ReduceTypeTypeTable
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_ENUM, 8, type_codes, type_refs, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *PoolModeTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    mindspore::schema::v0::PoolModeTypeTable
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_ENUM, 2, type_codes, type_refs, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *EltwiseModeTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    mindspore::schema::v0::EltwiseModeTypeTable
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_ENUM, 4, type_codes, type_refs, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *PadModeTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    mindspore::schema::v0::PadModeTypeTable
  };
  static const int64_t values[] = { 0, 1, 2, 4, 5 };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_ENUM, 5, type_codes, type_refs, nullptr, values, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *RoundModeTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    mindspore::schema::v0::RoundModeTypeTable
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_ENUM, 2, type_codes, type_refs, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *PaddingModeTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    mindspore::schema::v0::PaddingModeTypeTable
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_ENUM, 4, type_codes, type_refs, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *LshProjectionTypeTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    mindspore::schema::v0::LshProjectionTypeTypeTable
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_ENUM, 3, type_codes, type_refs, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *ReduceModeTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    mindspore::schema::v0::ReduceModeTypeTable
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_ENUM, 8, type_codes, type_refs, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *PadTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_INT, 1, -1 },
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_FLOAT, 0, -1 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    mindspore::schema::v0::PaddingModeTypeTable
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 3, type_codes, type_refs, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *MaximumTypeTable() {
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *MinimumTypeTable() {
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *FlattenTypeTable() {
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *FlattenGradTypeTable() {
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *ConcatTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 }
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 2, type_codes, nullptr, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *SoftMaxTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_INT, 0, -1 }
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 1, type_codes, nullptr, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *ActivationTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_FLOAT, 0, -1 },
    { flatbuffers::ET_FLOAT, 0, -1 },
    { flatbuffers::ET_FLOAT, 0, -1 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    mindspore::schema::v0::ActivationTypeTypeTable
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 4, type_codes, type_refs, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *ActivationGradTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_FLOAT, 0, -1 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    mindspore::schema::v0::ActivationTypeTypeTable
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 2, type_codes, type_refs, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *Conv2DTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_CHAR, 0, 1 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_BOOL, 0, -1 },
    { flatbuffers::ET_CHAR, 0, 2 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    mindspore::schema::v0::FormatTypeTable,
    mindspore::schema::v0::PadModeTypeTable,
    mindspore::schema::v0::ActivationTypeTypeTable
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 17, type_codes, type_refs, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *AdderTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_CHAR, 0, 1 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_BOOL, 0, -1 },
    { flatbuffers::ET_CHAR, 0, 2 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    mindspore::schema::v0::FormatTypeTable,
    mindspore::schema::v0::PadModeTypeTable,
    mindspore::schema::v0::ActivationTypeTypeTable
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 17, type_codes, type_refs, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *Conv2DGradFilterTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_CHAR, 0, 1 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_BOOL, 0, -1 },
    { flatbuffers::ET_INT, 1, -1 },
    { flatbuffers::ET_CHAR, 0, 2 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    mindspore::schema::v0::FormatTypeTable,
    mindspore::schema::v0::PadModeTypeTable,
    mindspore::schema::v0::ActivationTypeTypeTable
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 18, type_codes, type_refs, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *Conv2DGradInputTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_CHAR, 0, 1 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_BOOL, 0, -1 },
    { flatbuffers::ET_INT, 1, -1 },
    { flatbuffers::ET_CHAR, 0, 2 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    mindspore::schema::v0::FormatTypeTable,
    mindspore::schema::v0::PadModeTypeTable,
    mindspore::schema::v0::ActivationTypeTypeTable
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 18, type_codes, type_refs, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *GroupConv2DGradInputTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_CHAR, 0, 1 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_BOOL, 0, -1 },
    { flatbuffers::ET_INT, 1, -1 },
    { flatbuffers::ET_CHAR, 0, 2 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    mindspore::schema::v0::FormatTypeTable,
    mindspore::schema::v0::PadModeTypeTable,
    mindspore::schema::v0::ActivationTypeTypeTable
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 18, type_codes, type_refs, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *FusedBatchNormTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_FLOAT, 0, -1 },
    { flatbuffers::ET_FLOAT, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 }
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 3, type_codes, nullptr, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *BatchNormTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_FLOAT, 0, -1 }
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 1, type_codes, nullptr, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *BiasGradTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_INT, 1, -1 }
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 1, type_codes, nullptr, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *SoftmaxCrossEntropyTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_INT, 1, -1 }
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 1, type_codes, nullptr, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *SparseSoftmaxCrossEntropyTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_INT, 0, -1 }
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 1, type_codes, nullptr, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *make_tupleTypeTable() {
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *PoolingGradTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 1 },
    { flatbuffers::ET_BOOL, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_CHAR, 0, 2 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_CHAR, 0, 3 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    mindspore::schema::v0::FormatTypeTable,
    mindspore::schema::v0::PoolModeTypeTable,
    mindspore::schema::v0::PadModeTypeTable,
    mindspore::schema::v0::RoundModeTypeTable
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 13, type_codes, type_refs, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *ShapeTypeTable() {
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *ConstantOfShapeTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_FLOAT, 1, -1 }
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 2, type_codes, nullptr, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *Nchw2NhwcTypeTable() {
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *Nhwc2NchwTypeTable() {
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *FakeQuantWithMinMaxVarsTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_BOOL, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 }
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 2, type_codes, nullptr, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *BiasAddTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_INT, 1, -1 }
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 1, type_codes, nullptr, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *ROIPoolingTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_FLOAT, 0, -1 }
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 3, type_codes, nullptr, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *PoolingTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 1 },
    { flatbuffers::ET_BOOL, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_CHAR, 0, 2 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_CHAR, 0, 3 },
    { flatbuffers::ET_CHAR, 0, 4 },
    { flatbuffers::ET_INT, 0, -1 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    mindspore::schema::v0::FormatTypeTable,
    mindspore::schema::v0::PoolModeTypeTable,
    mindspore::schema::v0::PadModeTypeTable,
    mindspore::schema::v0::RoundModeTypeTable,
    mindspore::schema::v0::ActivationTypeTypeTable
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 15, type_codes, type_refs, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *DepthwiseConv2DTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_CHAR, 0, 1 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_BOOL, 0, -1 },
    { flatbuffers::ET_CHAR, 0, 2 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    mindspore::schema::v0::FormatTypeTable,
    mindspore::schema::v0::PadModeTypeTable,
    mindspore::schema::v0::ActivationTypeTypeTable
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 16, type_codes, type_refs, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *DeDepthwiseConv2DTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_CHAR, 0, 1 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_BOOL, 0, -1 },
    { flatbuffers::ET_CHAR, 0, 2 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    mindspore::schema::v0::FormatTypeTable,
    mindspore::schema::v0::PadModeTypeTable,
    mindspore::schema::v0::ActivationTypeTypeTable
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 16, type_codes, type_refs, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *ResizeTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 1 },
    { flatbuffers::ET_LONG, 0, -1 },
    { flatbuffers::ET_LONG, 0, -1 },
    { flatbuffers::ET_BOOL, 0, -1 },
    { flatbuffers::ET_BOOL, 0, -1 },
    { flatbuffers::ET_CHAR, 0, 2 },
    { flatbuffers::ET_FLOAT, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_FLOAT, 0, -1 },
    { flatbuffers::ET_CHAR, 0, 3 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    mindspore::schema::v0::FormatTypeTable,
    mindspore::schema::v0::ResizeMethodTypeTable,
    mindspore::schema::v0::CoordinateTransformModeTypeTable,
    mindspore::schema::v0::NearestModeTypeTable
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 11, type_codes, type_refs, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *DetectionPostProcessTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_FLOAT, 0, -1 },
    { flatbuffers::ET_FLOAT, 0, -1 },
    { flatbuffers::ET_FLOAT, 0, -1 },
    { flatbuffers::ET_FLOAT, 0, -1 },
    { flatbuffers::ET_FLOAT, 0, -1 },
    { flatbuffers::ET_FLOAT, 0, -1 },
    { flatbuffers::ET_LONG, 0, -1 },
    { flatbuffers::ET_LONG, 0, -1 },
    { flatbuffers::ET_LONG, 0, -1 },
    { flatbuffers::ET_LONG, 0, -1 },
    { flatbuffers::ET_BOOL, 0, -1 },
    { flatbuffers::ET_BOOL, 0, -1 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    mindspore::schema::v0::FormatTypeTable
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 14, type_codes, type_refs, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *FullConnectionTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_BOOL, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_BOOL, 0, -1 },
    { flatbuffers::ET_CHAR, 0, 0 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    mindspore::schema::v0::ActivationTypeTypeTable
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 4, type_codes, type_refs, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *MeanTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_INT, 1, -1 },
    { flatbuffers::ET_BOOL, 0, -1 }
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 2, type_codes, nullptr, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *DeConv2DTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_CHAR, 0, 1 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_BOOL, 0, -1 },
    { flatbuffers::ET_CHAR, 0, 2 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    mindspore::schema::v0::FormatTypeTable,
    mindspore::schema::v0::PadModeTypeTable,
    mindspore::schema::v0::ActivationTypeTypeTable
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 17, type_codes, type_refs, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *DeConv2DGradFilterTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_CHAR, 0, 1 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_BOOL, 0, -1 },
    { flatbuffers::ET_CHAR, 0, 2 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    mindspore::schema::v0::FormatTypeTable,
    mindspore::schema::v0::PadModeTypeTable,
    mindspore::schema::v0::ActivationTypeTypeTable
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 17, type_codes, type_refs, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *BNGradTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_FLOAT, 0, -1 },
    { flatbuffers::ET_FLOAT, 0, -1 }
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 2, type_codes, nullptr, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *ScaleTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_CHAR, 0, 0 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    mindspore::schema::v0::ActivationTypeTypeTable
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 2, type_codes, type_refs, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *EltwiseTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_CHAR, 0, 0 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    mindspore::schema::v0::EltwiseModeTypeTable
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 1, type_codes, type_refs, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *AddTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_CHAR, 0, 0 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    mindspore::schema::v0::ActivationTypeTypeTable
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 1, type_codes, type_refs, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *SubTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_CHAR, 0, 0 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    mindspore::schema::v0::ActivationTypeTypeTable
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 1, type_codes, type_refs, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *MulTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_CHAR, 0, 0 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    mindspore::schema::v0::ActivationTypeTypeTable
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 1, type_codes, type_refs, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *DivTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_CHAR, 0, 0 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    mindspore::schema::v0::ActivationTypeTypeTable
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 1, type_codes, type_refs, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *AddGradTypeTable() {
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *SubGradTypeTable() {
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *MulGradTypeTable() {
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *DivGradTypeTable() {
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *RealDivTypeTable() {
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *RsqrtTypeTable() {
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *EqualTypeTable() {
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *LessTypeTable() {
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *GreaterTypeTable() {
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *NotEqualTypeTable() {
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *LessEqualTypeTable() {
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *GreaterEqualTypeTable() {
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *MinTypeTable() {
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *SliceTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 1, -1 },
    { flatbuffers::ET_INT, 1, -1 },
    { flatbuffers::ET_INT, 1, -1 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    mindspore::schema::v0::FormatTypeTable
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 4, type_codes, type_refs, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *FloorTypeTable() {
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *AbsTypeTable() {
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *NegTypeTable() {
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *NegGradTypeTable() {
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *ExpTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_FLOAT, 0, -1 },
    { flatbuffers::ET_FLOAT, 0, -1 },
    { flatbuffers::ET_FLOAT, 0, -1 }
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 3, type_codes, nullptr, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *CosTypeTable() {
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *SinTypeTable() {
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *SqrtTypeTable() {
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *SquareTypeTable() {
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *CeilTypeTable() {
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *LogTypeTable() {
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *LogGradTypeTable() {
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *TanTypeTable() {
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *AtanTypeTable() {
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *AsinTypeTable() {
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *ReshapeTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_LONG, 1, -1 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    mindspore::schema::v0::FormatTypeTable
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 2, type_codes, type_refs, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *PowerTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_FLOAT, 0, -1 },
    { flatbuffers::ET_FLOAT, 0, -1 },
    { flatbuffers::ET_FLOAT, 0, -1 }
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 3, type_codes, nullptr, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *PowerGradTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_FLOAT, 0, -1 },
    { flatbuffers::ET_FLOAT, 0, -1 },
    { flatbuffers::ET_FLOAT, 0, -1 }
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 3, type_codes, nullptr, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *ArgMaxTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_BOOL, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_BOOL, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 }
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 5, type_codes, nullptr, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *ArgMinTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_BOOL, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_BOOL, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 }
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 5, type_codes, nullptr, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *NetOutputTypeTable() {
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *MatMulTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_BOOL, 0, -1 },
    { flatbuffers::ET_BOOL, 0, -1 },
    { flatbuffers::ET_BOOL, 0, -1 }
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 3, type_codes, nullptr, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *PReLUTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_BOOL, 0, -1 },
    { flatbuffers::ET_FLOAT, 1, -1 }
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 2, type_codes, nullptr, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *LeakyReLUTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_FLOAT, 0, -1 }
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 1, type_codes, nullptr, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *StridedSliceTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_INT, 1, -1 },
    { flatbuffers::ET_INT, 1, -1 },
    { flatbuffers::ET_INT, 1, -1 },
    { flatbuffers::ET_INT, 1, -1 }
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 9, type_codes, nullptr, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *StackTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_INT, 1, -1 }
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 3, type_codes, nullptr, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *RangeTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 }
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 4, type_codes, nullptr, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *ExpandDimsTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_INT, 0, -1 }
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 1, type_codes, nullptr, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *TileTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_INT, 1, -1 },
    { flatbuffers::ET_INT, 1, -1 }
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 2, type_codes, nullptr, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *CastTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 }
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 2, type_codes, nullptr, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *QuantDTypeCastTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 }
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 2, type_codes, nullptr, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *SplitTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_INT, 1, -1 },
    { flatbuffers::ET_INT, 0, -1 }
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 3, type_codes, nullptr, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *CropTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_LONG, 0, -1 },
    { flatbuffers::ET_LONG, 1, -1 }
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 2, type_codes, nullptr, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *PermuteTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_LONG, 1, -1 }
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 1, type_codes, nullptr, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *ClipTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_FLOAT, 0, -1 },
    { flatbuffers::ET_FLOAT, 0, -1 }
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 2, type_codes, nullptr, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *ConstantTypeTable() {
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *EluTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_FLOAT, 0, -1 }
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 1, type_codes, nullptr, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *BroadcastTypeTable() {
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *BroadcastToTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_INT, 1, -1 }
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 1, type_codes, nullptr, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *LrnTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_FLOAT, 0, -1 },
    { flatbuffers::ET_FLOAT, 0, -1 },
    { flatbuffers::ET_FLOAT, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 }
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 4, type_codes, nullptr, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *ReduceTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_INT, 1, -1 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_BOOL, 0, -1 },
    { flatbuffers::ET_FLOAT, 0, -1 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    mindspore::schema::v0::ReduceModeTypeTable
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 5, type_codes, type_refs, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *TransposeTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_INT, 1, -1 },
    { flatbuffers::ET_BOOL, 0, -1 }
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 2, type_codes, nullptr, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *SqueezeTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_INT, 1, -1 }
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 1, type_codes, nullptr, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *UnsqueezeTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_INT, 1, -1 }
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 1, type_codes, nullptr, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *UpsampleTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_STRING, 0, -1 },
    { flatbuffers::ET_FLOAT, 1, -1 }
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 2, type_codes, nullptr, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *DropoutTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_FLOAT, 0, -1 }
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 1, type_codes, nullptr, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *LocalResponseNormalizationTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_FLOAT, 0, -1 },
    { flatbuffers::ET_FLOAT, 0, -1 },
    { flatbuffers::ET_FLOAT, 0, -1 }
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 4, type_codes, nullptr, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *ZerosLikeTypeTable() {
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *TopKTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_BOOL, 0, -1 }
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 2, type_codes, nullptr, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *SpaceToDepthTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_INT, 0, 0 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    mindspore::schema::v0::FormatTypeTable
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 2, type_codes, type_refs, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *SpaceToBatchTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_INT, 1, -1 },
    { flatbuffers::ET_INT, 1, -1 }
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 2, type_codes, nullptr, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *SparseToDenseTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_BOOL, 0, -1 }
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 1, type_codes, nullptr, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *ReverseSequenceTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 }
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 2, type_codes, nullptr, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *RankTypeTable() {
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *GatherTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 }
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 2, type_codes, nullptr, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *GatherNdTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_INT, 0, -1 }
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 1, type_codes, nullptr, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *FillTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_INT, 1, -1 }
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 1, type_codes, nullptr, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *DepthToSpaceTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_INT, 0, 0 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    mindspore::schema::v0::FormatTypeTable
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 2, type_codes, type_refs, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *BatchToSpaceTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_INT, 1, -1 },
    { flatbuffers::ET_INT, 1, -1 }
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 2, type_codes, nullptr, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *BatchToSpaceNDTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_INT, 1, -1 },
    { flatbuffers::ET_INT, 1, -1 }
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 2, type_codes, nullptr, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *AddNTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_INT, 0, -1 }
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 1, type_codes, nullptr, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *EmbeddingLookupTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_FLOAT, 0, -1 }
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 1, type_codes, nullptr, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *EmbeddingLookupSparseTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_INT, 1, -1 },
    { flatbuffers::ET_FLOAT, 1, -1 },
    { flatbuffers::ET_FLOAT, 0, -1 }
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 3, type_codes, nullptr, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *FloorDivTypeTable() {
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *FloorModTypeTable() {
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *ModTypeTable() {
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *L2NormTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_INT, 1, -1 },
    { flatbuffers::ET_FLOAT, 0, -1 },
    { flatbuffers::ET_CHAR, 0, 0 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    mindspore::schema::v0::ActivationTypeTypeTable
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 3, type_codes, type_refs, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *LogicalAndTypeTable() {
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *LogicalOrTypeTable() {
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *LogicalXorTypeTable() {
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *LogicalNotTypeTable() {
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *MatrixDiagTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_FLOAT, 0, -1 }
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 4, type_codes, nullptr, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *SelectTypeTable() {
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *TfReduceTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_CHAR, 0, 0 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    mindspore::schema::v0::ReduceTypeTypeTable
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 1, type_codes, type_refs, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *ReverseTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_INT, 1, -1 }
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 1, type_codes, nullptr, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *RoundTypeTable() {
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *ScatterTypeTable() {
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *ScatterNDTypeTable() {
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *UniqueTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_INT, 0, -1 }
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 1, type_codes, nullptr, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *UnstackTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 }
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 2, type_codes, nullptr, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *OnnxInt8QuantizeTypeTable() {
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *OnnxInt8DequantizeTypeTable() {
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *FakeQuantWithMinMaxTypeTable() {
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *FakeQuantWithMinMaxPerChannelTypeTable() {
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *BatchNormFoldTypeTable() {
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *MulFoldTypeTable() {
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *AddFoldTypeTable() {
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *SquaredDifferenceTypeTable() {
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *TupleGetItemTypeTable() {
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *ApplyMomentumTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_FLOAT, 0, -1 },
    { flatbuffers::ET_BOOL, 0, -1 }
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 2, type_codes, nullptr, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *SgdTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_FLOAT, 0, -1 },
    { flatbuffers::ET_FLOAT, 0, -1 },
    { flatbuffers::ET_BOOL, 0, -1 }
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 3, type_codes, nullptr, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *AdamTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_BOOL, 0, -1 }
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 1, type_codes, nullptr, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *AssignTypeTable() {
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *AssignAddTypeTable() {
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *WhereTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_BOOL, 1, -1 }
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 1, type_codes, nullptr, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *OneHotTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_INT, 0, -1 }
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 1, type_codes, nullptr, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *LstmTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_BOOL, 0, -1 }
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 1, type_codes, nullptr, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *PriorBoxTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_INT, 1, -1 },
    { flatbuffers::ET_INT, 1, -1 },
    { flatbuffers::ET_FLOAT, 1, -1 },
    { flatbuffers::ET_FLOAT, 1, -1 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_FLOAT, 0, -1 },
    { flatbuffers::ET_FLOAT, 0, -1 },
    { flatbuffers::ET_BOOL, 0, -1 },
    { flatbuffers::ET_BOOL, 0, -1 },
    { flatbuffers::ET_FLOAT, 0, -1 }
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 11, type_codes, nullptr, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *SpaceToBatchNDTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_INT, 1, -1 },
    { flatbuffers::ET_INT, 1, -1 }
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 2, type_codes, nullptr, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *MakeTupleTypeTable() {
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *ToFormatTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 }
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 2, type_codes, nullptr, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *DependTypeTable() {
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *ControlDependTypeTable() {
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *ReturnTypeTable() {
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *ProposalTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_FLOAT, 0, -1 },
    { flatbuffers::ET_FLOAT, 0, -1 },
    { flatbuffers::ET_FLOAT, 0, -1 },
    { flatbuffers::ET_FLOAT, 1, -1 },
    { flatbuffers::ET_FLOAT, 1, -1 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_FLOAT, 0, -1 }
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 8, type_codes, nullptr, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *CustomTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_UCHAR, 1, -1 }
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 1, type_codes, nullptr, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *BlackBoxTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_STRING, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_UCHAR, 1, -1 }
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 3, type_codes, nullptr, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *LshProjectionTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_CHAR, 0, 0 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    mindspore::schema::v0::LshProjectionTypeTypeTable
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 1, type_codes, type_refs, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *HashtableLookupTypeTable() {
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *SkipGramTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_BOOL, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 }
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 3, type_codes, nullptr, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *CustomPredictTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_FLOAT, 0, -1 }
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 2, type_codes, nullptr, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *CustomNormalizeTypeTable() {
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *CustomExtractFeaturesTypeTable() {
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *AudioSpectrogramTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_BOOL, 0, -1 }
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 3, type_codes, nullptr, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *MfccTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_FLOAT, 0, -1 },
    { flatbuffers::ET_FLOAT, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 }
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 4, type_codes, nullptr, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *RfftTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_INT, 0, -1 }
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 1, type_codes, nullptr, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *FftRealTypeTable() {
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *FftImagTypeTable() {
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *DropoutGradTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_FLOAT, 0, -1 }
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 1, type_codes, nullptr, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *MaximumGradTypeTable() {
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *MinimumGradTypeTable() {
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *NonMaxSuppressionTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_INT, 0, -1 }
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 1, type_codes, nullptr, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *InstanceNormTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_FLOAT, 0, -1 }
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 1, type_codes, nullptr, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *LoopTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_INT, 0, -1 }
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 1, type_codes, nullptr, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *IdentityTypeTable() {
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *LayerNormTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_INT, 1, -1 },
    { flatbuffers::ET_FLOAT, 0, -1 },
    { flatbuffers::ET_BOOL, 0, -1 }
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 3, type_codes, nullptr, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *WhileTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 }
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 2, type_codes, nullptr, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *UnsortedSegmentSumTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_INT, 0, -1 }
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 1, type_codes, nullptr, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *OnesLikeTypeTable() {
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *BinaryCrossEntropyTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_INT, 0, -1 }
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 1, type_codes, nullptr, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *BinaryCrossEntropyGradTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_INT, 0, -1 }
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 1, type_codes, nullptr, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *LpNormalizationTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 }
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 2, type_codes, nullptr, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *SwitchTypeTable() {
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *PartialTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_INT, 0, -1 }
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 1, type_codes, nullptr, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *TensorListFromTensorTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 }
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 2, type_codes, nullptr, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *TensorListStackTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 }
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 2, type_codes, nullptr, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *TensorListGetItemTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_INT, 0, -1 }
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 1, type_codes, nullptr, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *TensorListSetItemTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_INT, 0, -1 }
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 1, type_codes, nullptr, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *TensorListReserveTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 }
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 2, type_codes, nullptr, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *AllTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_INT, 0, -1 }
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 1, type_codes, nullptr, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *AssertTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_INT, 0, -1 }
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 1, type_codes, nullptr, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *SmoothL1LossTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_FLOAT, 0, -1 }
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 1, type_codes, nullptr, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *SmoothL1LossGradTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_FLOAT, 0, -1 }
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 1, type_codes, nullptr, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *SigmoidCrossEntropyWithLogitsTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_FLOAT, 0, -1 }
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 1, type_codes, nullptr, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *SigmoidCrossEntropyWithLogitsGradTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_FLOAT, 0, -1 }
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 1, type_codes, nullptr, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *ReciprocalTypeTable() {
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *MergeTypeTable() {
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *GeLUTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_BOOL, 0, -1 }
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 1, type_codes, nullptr, nullptr, nullptr, nullptr
  };
  return &tt;
}

}  // namespace v0
}  // namespace schema
}  // namespace mindspore

#endif  // FLATBUFFERS_GENERATED_OPSV0_MINDSPORE_SCHEMA_V0_H_
