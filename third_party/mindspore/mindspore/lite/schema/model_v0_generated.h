// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_MODELV0_MINDSPORE_SCHEMA_V0_H_
#define FLATBUFFERS_GENERATED_MODELV0_MINDSPORE_SCHEMA_V0_H_

#include "flatbuffers/flatbuffers.h"

#include "ops_v0_generated.h"

namespace mindspore {
namespace schema {
namespace v0 {

struct QuantParam;
struct QuantParamBuilder;

struct Tensor;
struct TensorBuilder;

struct Primitive;
struct PrimitiveBuilder;

struct CNode;
struct CNodeBuilder;

struct SubGraph;
struct SubGraphBuilder;

struct MetaGraph;
struct MetaGraphBuilder;

enum NodeType : int32_t {
  NodeType_ValueNode = 0,
  NodeType_Parameter = 1,
  NodeType_CNode = 2,
  NodeType_MIN = NodeType_ValueNode,
  NodeType_MAX = NodeType_CNode
};

inline const NodeType (&EnumValuesNodeType())[3] {
  static const NodeType values[] = {
    NodeType_ValueNode,
    NodeType_Parameter,
    NodeType_CNode
  };
  return values;
}

inline const char * const *EnumNamesNodeType() {
  static const char * const names[4] = {
    "ValueNode",
    "Parameter",
    "CNode",
    nullptr
  };
  return names;
}

inline const char *EnumNameNodeType(NodeType e) {
  if (flatbuffers::IsOutRange(e, NodeType_ValueNode, NodeType_CNode)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesNodeType()[index];
}

enum PrimitiveType : uint8_t {
  PrimitiveType_NONE = 0,
  PrimitiveType_Concat = 1,
  PrimitiveType_SoftMax = 2,
  PrimitiveType_Activation = 3,
  PrimitiveType_Conv2D = 4,
  PrimitiveType_FusedBatchNorm = 5,
  PrimitiveType_BatchNorm = 6,
  PrimitiveType_BiasAdd = 7,
  PrimitiveType_Pooling = 8,
  PrimitiveType_ROIPooling = 9,
  PrimitiveType_DepthwiseConv2D = 10,
  PrimitiveType_DeDepthwiseConv2D = 11,
  PrimitiveType_Resize = 12,
  PrimitiveType_DetectionPostProcess = 13,
  PrimitiveType_FullConnection = 14,
  PrimitiveType_Mean = 15,
  PrimitiveType_DeConv2D = 16,
  PrimitiveType_Scale = 17,
  PrimitiveType_Reshape = 18,
  PrimitiveType_Eltwise = 19,
  PrimitiveType_NetOutput = 20,
  PrimitiveType_Add = 21,
  PrimitiveType_Sub = 22,
  PrimitiveType_MatMul = 23,
  PrimitiveType_StridedSlice = 24,
  PrimitiveType_Power = 25,
  PrimitiveType_Slice = 26,
  PrimitiveType_Stack = 27,
  PrimitiveType_Mul = 28,
  PrimitiveType_RealDiv = 29,
  PrimitiveType_Pad = 30,
  PrimitiveType_Maximum = 31,
  PrimitiveType_Minimum = 32,
  PrimitiveType_PReLU = 33,
  PrimitiveType_LeakyReLU = 34,
  PrimitiveType_ArgMax = 35,
  PrimitiveType_ArgMin = 36,
  PrimitiveType_Exp = 37,
  PrimitiveType_Crop = 38,
  PrimitiveType_Range = 39,
  PrimitiveType_Rsqrt = 40,
  PrimitiveType_ExpandDims = 41,
  PrimitiveType_Tile = 42,
  PrimitiveType_Cast = 43,
  PrimitiveType_Shape = 44,
  PrimitiveType_Nchw2Nhwc = 45,
  PrimitiveType_Nhwc2Nchw = 46,
  PrimitiveType_QuantDTypeCast = 47,
  PrimitiveType_Split = 48,
  PrimitiveType_Permute = 49,
  PrimitiveType_FakeQuantWithMinMaxVars = 50,
  PrimitiveType_Equal = 51,
  PrimitiveType_Less = 52,
  PrimitiveType_Greater = 53,
  PrimitiveType_NotEqual = 54,
  PrimitiveType_LessEqual = 55,
  PrimitiveType_GreaterEqual = 56,
  PrimitiveType_Min = 57,
  PrimitiveType_Floor = 58,
  PrimitiveType_Abs = 59,
  PrimitiveType_Neg = 60,
  PrimitiveType_Cos = 61,
  PrimitiveType_Sin = 62,
  PrimitiveType_Sqrt = 63,
  PrimitiveType_Square = 64,
  PrimitiveType_Constant = 65,
  PrimitiveType_Log = 66,
  PrimitiveType_Tan = 67,
  PrimitiveType_Atan = 68,
  PrimitiveType_Asin = 69,
  PrimitiveType_Clip = 70,
  PrimitiveType_Transpose = 71,
  PrimitiveType_Squeeze = 72,
  PrimitiveType_Unsqueeze = 73,
  PrimitiveType_Upsample = 74,
  PrimitiveType_Dropout = 75,
  PrimitiveType_Broadcast = 76,
  PrimitiveType_BroadcastTo = 77,
  PrimitiveType_Lrn = 78,
  PrimitiveType_ZerosLike = 79,
  PrimitiveType_TopK = 80,
  PrimitiveType_SpaceToDepth = 81,
  PrimitiveType_SpaceToBatch = 82,
  PrimitiveType_SparseToDense = 83,
  PrimitiveType_ReverseSequence = 84,
  PrimitiveType_Rank = 85,
  PrimitiveType_Gather = 86,
  PrimitiveType_GatherNd = 87,
  PrimitiveType_Fill = 88,
  PrimitiveType_Elu = 89,
  PrimitiveType_DepthToSpace = 90,
  PrimitiveType_BatchToSpace = 91,
  PrimitiveType_AddN = 92,
  PrimitiveType_Ceil = 93,
  PrimitiveType_EmbeddingLookup = 94,
  PrimitiveType_EmbeddingLookupSparse = 95,
  PrimitiveType_FloorDiv = 96,
  PrimitiveType_FloorMod = 97,
  PrimitiveType_L2Norm = 98,
  PrimitiveType_LocalResponseNormalization = 99,
  PrimitiveType_MatrixDiag = 100,
  PrimitiveType_Reduce = 101,
  PrimitiveType_Reverse = 102,
  PrimitiveType_Round = 103,
  PrimitiveType_Select = 104,
  PrimitiveType_Scatter = 105,
  PrimitiveType_ScatterND = 106,
  PrimitiveType_ConstantOfShape = 107,
  PrimitiveType_Unique = 108,
  PrimitiveType_Unstack = 109,
  PrimitiveType_LogicalAnd = 110,
  PrimitiveType_LogicalOr = 111,
  PrimitiveType_LogicalXor = 112,
  PrimitiveType_LogicalNot = 113,
  PrimitiveType_OnnxInt8Quantize = 114,
  PrimitiveType_OnnxInt8Dequantize = 115,
  PrimitiveType_FakeQuantWithMinMax = 116,
  PrimitiveType_FakeQuantWithMinMaxPerChannel = 117,
  PrimitiveType_BatchNormFold = 118,
  PrimitiveType_MulFold = 119,
  PrimitiveType_AddFold = 120,
  PrimitiveType_SquaredDifference = 121,
  PrimitiveType_Flatten = 122,
  PrimitiveType_FlattenGrad = 123,
  PrimitiveType_TupleGetItem = 124,
  PrimitiveType_Div = 125,
  PrimitiveType_Where = 126,
  PrimitiveType_OneHot = 127,
  PrimitiveType_Lstm = 128,
  PrimitiveType_Conv2DGradFilter = 129,
  PrimitiveType_Conv2DGradInput = 130,
  PrimitiveType_PoolingGrad = 131,
  PrimitiveType_BNGrad = 132,
  PrimitiveType_Assign = 133,
  PrimitiveType_ApplyMomentum = 134,
  PrimitiveType_BiasGrad = 135,
  PrimitiveType_SoftmaxCrossEntropy = 136,
  PrimitiveType_AddGrad = 137,
  PrimitiveType_SubGrad = 138,
  PrimitiveType_MulGrad = 139,
  PrimitiveType_DivGrad = 140,
  PrimitiveType_PowerGrad = 141,
  PrimitiveType_ActivationGrad = 142,
  PrimitiveType_PriorBox = 143,
  PrimitiveType_SpaceToBatchND = 144,
  PrimitiveType_Depend = 145,
  PrimitiveType_Return = 146,
  PrimitiveType_MakeTuple = 147,
  PrimitiveType_ToFormat = 148,
  PrimitiveType_Proposal = 149,
  PrimitiveType_Custom = 150,
  PrimitiveType_BlackBox = 151,
  PrimitiveType_NegGrad = 152,
  PrimitiveType_LogGrad = 153,
  PrimitiveType_BatchToSpaceND = 154,
  PrimitiveType_LshProjection = 155,
  PrimitiveType_HashtableLookup = 156,
  PrimitiveType_SkipGram = 157,
  PrimitiveType_DeConv2DGradFilter = 158,
  PrimitiveType_CustomPredict = 159,
  PrimitiveType_CustomNormalize = 160,
  PrimitiveType_CustomExtractFeatures = 161,
  PrimitiveType_AudioSpectrogram = 162,
  PrimitiveType_Mfcc = 163,
  PrimitiveType_Rfft = 164,
  PrimitiveType_FftReal = 165,
  PrimitiveType_FftImag = 166,
  PrimitiveType_Sgd = 167,
  PrimitiveType_Adam = 168,
  PrimitiveType_GroupConv2DGradInput = 169,
  PrimitiveType_Loop = 170,
  PrimitiveType_NonMaxSuppression = 171,
  PrimitiveType_InstanceNorm = 172,
  PrimitiveType_Identity = 173,
  PrimitiveType_LayerNorm = 174,
  PrimitiveType_While = 175,
  PrimitiveType_ControlDepend = 176,
  PrimitiveType_UnsortedSegmentSum = 177,
  PrimitiveType_AssignAdd = 178,
  PrimitiveType_OnesLike = 179,
  PrimitiveType_BinaryCrossEntropyGrad = 180,
  PrimitiveType_BinaryCrossEntropy = 181,
  PrimitiveType_LpNormalization = 182,
  PrimitiveType_DropoutGrad = 183,
  PrimitiveType_MaximumGrad = 184,
  PrimitiveType_MinimumGrad = 185,
  PrimitiveType_Switch = 186,
  PrimitiveType_Partial = 187,
  PrimitiveType_TensorListFromTensor = 188,
  PrimitiveType_TensorListStack = 189,
  PrimitiveType_TensorListGetItem = 190,
  PrimitiveType_TensorListSetItem = 191,
  PrimitiveType_TensorListReserve = 192,
  PrimitiveType_All = 193,
  PrimitiveType_Assert = 194,
  PrimitiveType_Adder = 195,
  PrimitiveType_SparseSoftmaxCrossEntropy = 196,
  PrimitiveType_SmoothL1Loss = 197,
  PrimitiveType_SmoothL1LossGrad = 198,
  PrimitiveType_SigmoidCrossEntropyWithLogits = 199,
  PrimitiveType_SigmoidCrossEntropyWithLogitsGrad = 200,
  PrimitiveType_Reciprocal = 201,
  PrimitiveType_Merge = 202,
  PrimitiveType_Mod = 203,
  PrimitiveType_GeLU = 204,
  PrimitiveType_MIN = PrimitiveType_NONE,
  PrimitiveType_MAX = PrimitiveType_GeLU
};

inline const PrimitiveType (&EnumValuesPrimitiveType())[205] {
  static const PrimitiveType values[] = {
    PrimitiveType_NONE,
    PrimitiveType_Concat,
    PrimitiveType_SoftMax,
    PrimitiveType_Activation,
    PrimitiveType_Conv2D,
    PrimitiveType_FusedBatchNorm,
    PrimitiveType_BatchNorm,
    PrimitiveType_BiasAdd,
    PrimitiveType_Pooling,
    PrimitiveType_ROIPooling,
    PrimitiveType_DepthwiseConv2D,
    PrimitiveType_DeDepthwiseConv2D,
    PrimitiveType_Resize,
    PrimitiveType_DetectionPostProcess,
    PrimitiveType_FullConnection,
    PrimitiveType_Mean,
    PrimitiveType_DeConv2D,
    PrimitiveType_Scale,
    PrimitiveType_Reshape,
    PrimitiveType_Eltwise,
    PrimitiveType_NetOutput,
    PrimitiveType_Add,
    PrimitiveType_Sub,
    PrimitiveType_MatMul,
    PrimitiveType_StridedSlice,
    PrimitiveType_Power,
    PrimitiveType_Slice,
    PrimitiveType_Stack,
    PrimitiveType_Mul,
    PrimitiveType_RealDiv,
    PrimitiveType_Pad,
    PrimitiveType_Maximum,
    PrimitiveType_Minimum,
    PrimitiveType_PReLU,
    PrimitiveType_LeakyReLU,
    PrimitiveType_ArgMax,
    PrimitiveType_ArgMin,
    PrimitiveType_Exp,
    PrimitiveType_Crop,
    PrimitiveType_Range,
    PrimitiveType_Rsqrt,
    PrimitiveType_ExpandDims,
    PrimitiveType_Tile,
    PrimitiveType_Cast,
    PrimitiveType_Shape,
    PrimitiveType_Nchw2Nhwc,
    PrimitiveType_Nhwc2Nchw,
    PrimitiveType_QuantDTypeCast,
    PrimitiveType_Split,
    PrimitiveType_Permute,
    PrimitiveType_FakeQuantWithMinMaxVars,
    PrimitiveType_Equal,
    PrimitiveType_Less,
    PrimitiveType_Greater,
    PrimitiveType_NotEqual,
    PrimitiveType_LessEqual,
    PrimitiveType_GreaterEqual,
    PrimitiveType_Min,
    PrimitiveType_Floor,
    PrimitiveType_Abs,
    PrimitiveType_Neg,
    PrimitiveType_Cos,
    PrimitiveType_Sin,
    PrimitiveType_Sqrt,
    PrimitiveType_Square,
    PrimitiveType_Constant,
    PrimitiveType_Log,
    PrimitiveType_Tan,
    PrimitiveType_Atan,
    PrimitiveType_Asin,
    PrimitiveType_Clip,
    PrimitiveType_Transpose,
    PrimitiveType_Squeeze,
    PrimitiveType_Unsqueeze,
    PrimitiveType_Upsample,
    PrimitiveType_Dropout,
    PrimitiveType_Broadcast,
    PrimitiveType_BroadcastTo,
    PrimitiveType_Lrn,
    PrimitiveType_ZerosLike,
    PrimitiveType_TopK,
    PrimitiveType_SpaceToDepth,
    PrimitiveType_SpaceToBatch,
    PrimitiveType_SparseToDense,
    PrimitiveType_ReverseSequence,
    PrimitiveType_Rank,
    PrimitiveType_Gather,
    PrimitiveType_GatherNd,
    PrimitiveType_Fill,
    PrimitiveType_Elu,
    PrimitiveType_DepthToSpace,
    PrimitiveType_BatchToSpace,
    PrimitiveType_AddN,
    PrimitiveType_Ceil,
    PrimitiveType_EmbeddingLookup,
    PrimitiveType_EmbeddingLookupSparse,
    PrimitiveType_FloorDiv,
    PrimitiveType_FloorMod,
    PrimitiveType_L2Norm,
    PrimitiveType_LocalResponseNormalization,
    PrimitiveType_MatrixDiag,
    PrimitiveType_Reduce,
    PrimitiveType_Reverse,
    PrimitiveType_Round,
    PrimitiveType_Select,
    PrimitiveType_Scatter,
    PrimitiveType_ScatterND,
    PrimitiveType_ConstantOfShape,
    PrimitiveType_Unique,
    PrimitiveType_Unstack,
    PrimitiveType_LogicalAnd,
    PrimitiveType_LogicalOr,
    PrimitiveType_LogicalXor,
    PrimitiveType_LogicalNot,
    PrimitiveType_OnnxInt8Quantize,
    PrimitiveType_OnnxInt8Dequantize,
    PrimitiveType_FakeQuantWithMinMax,
    PrimitiveType_FakeQuantWithMinMaxPerChannel,
    PrimitiveType_BatchNormFold,
    PrimitiveType_MulFold,
    PrimitiveType_AddFold,
    PrimitiveType_SquaredDifference,
    PrimitiveType_Flatten,
    PrimitiveType_FlattenGrad,
    PrimitiveType_TupleGetItem,
    PrimitiveType_Div,
    PrimitiveType_Where,
    PrimitiveType_OneHot,
    PrimitiveType_Lstm,
    PrimitiveType_Conv2DGradFilter,
    PrimitiveType_Conv2DGradInput,
    PrimitiveType_PoolingGrad,
    PrimitiveType_BNGrad,
    PrimitiveType_Assign,
    PrimitiveType_ApplyMomentum,
    PrimitiveType_BiasGrad,
    PrimitiveType_SoftmaxCrossEntropy,
    PrimitiveType_AddGrad,
    PrimitiveType_SubGrad,
    PrimitiveType_MulGrad,
    PrimitiveType_DivGrad,
    PrimitiveType_PowerGrad,
    PrimitiveType_ActivationGrad,
    PrimitiveType_PriorBox,
    PrimitiveType_SpaceToBatchND,
    PrimitiveType_Depend,
    PrimitiveType_Return,
    PrimitiveType_MakeTuple,
    PrimitiveType_ToFormat,
    PrimitiveType_Proposal,
    PrimitiveType_Custom,
    PrimitiveType_BlackBox,
    PrimitiveType_NegGrad,
    PrimitiveType_LogGrad,
    PrimitiveType_BatchToSpaceND,
    PrimitiveType_LshProjection,
    PrimitiveType_HashtableLookup,
    PrimitiveType_SkipGram,
    PrimitiveType_DeConv2DGradFilter,
    PrimitiveType_CustomPredict,
    PrimitiveType_CustomNormalize,
    PrimitiveType_CustomExtractFeatures,
    PrimitiveType_AudioSpectrogram,
    PrimitiveType_Mfcc,
    PrimitiveType_Rfft,
    PrimitiveType_FftReal,
    PrimitiveType_FftImag,
    PrimitiveType_Sgd,
    PrimitiveType_Adam,
    PrimitiveType_GroupConv2DGradInput,
    PrimitiveType_Loop,
    PrimitiveType_NonMaxSuppression,
    PrimitiveType_InstanceNorm,
    PrimitiveType_Identity,
    PrimitiveType_LayerNorm,
    PrimitiveType_While,
    PrimitiveType_ControlDepend,
    PrimitiveType_UnsortedSegmentSum,
    PrimitiveType_AssignAdd,
    PrimitiveType_OnesLike,
    PrimitiveType_BinaryCrossEntropyGrad,
    PrimitiveType_BinaryCrossEntropy,
    PrimitiveType_LpNormalization,
    PrimitiveType_DropoutGrad,
    PrimitiveType_MaximumGrad,
    PrimitiveType_MinimumGrad,
    PrimitiveType_Switch,
    PrimitiveType_Partial,
    PrimitiveType_TensorListFromTensor,
    PrimitiveType_TensorListStack,
    PrimitiveType_TensorListGetItem,
    PrimitiveType_TensorListSetItem,
    PrimitiveType_TensorListReserve,
    PrimitiveType_All,
    PrimitiveType_Assert,
    PrimitiveType_Adder,
    PrimitiveType_SparseSoftmaxCrossEntropy,
    PrimitiveType_SmoothL1Loss,
    PrimitiveType_SmoothL1LossGrad,
    PrimitiveType_SigmoidCrossEntropyWithLogits,
    PrimitiveType_SigmoidCrossEntropyWithLogitsGrad,
    PrimitiveType_Reciprocal,
    PrimitiveType_Merge,
    PrimitiveType_Mod,
    PrimitiveType_GeLU
  };
  return values;
}

inline const char * const *EnumNamesPrimitiveType() {
  static const char * const names[206] = {
    "NONE",
    "Concat",
    "SoftMax",
    "Activation",
    "Conv2D",
    "FusedBatchNorm",
    "BatchNorm",
    "BiasAdd",
    "Pooling",
    "ROIPooling",
    "DepthwiseConv2D",
    "DeDepthwiseConv2D",
    "Resize",
    "DetectionPostProcess",
    "FullConnection",
    "Mean",
    "DeConv2D",
    "Scale",
    "Reshape",
    "Eltwise",
    "NetOutput",
    "Add",
    "Sub",
    "MatMul",
    "StridedSlice",
    "Power",
    "Slice",
    "Stack",
    "Mul",
    "RealDiv",
    "Pad",
    "Maximum",
    "Minimum",
    "PReLU",
    "LeakyReLU",
    "ArgMax",
    "ArgMin",
    "Exp",
    "Crop",
    "Range",
    "Rsqrt",
    "ExpandDims",
    "Tile",
    "Cast",
    "Shape",
    "Nchw2Nhwc",
    "Nhwc2Nchw",
    "QuantDTypeCast",
    "Split",
    "Permute",
    "FakeQuantWithMinMaxVars",
    "Equal",
    "Less",
    "Greater",
    "NotEqual",
    "LessEqual",
    "GreaterEqual",
    "Min",
    "Floor",
    "Abs",
    "Neg",
    "Cos",
    "Sin",
    "Sqrt",
    "Square",
    "Constant",
    "Log",
    "Tan",
    "Atan",
    "Asin",
    "Clip",
    "Transpose",
    "Squeeze",
    "Unsqueeze",
    "Upsample",
    "Dropout",
    "Broadcast",
    "BroadcastTo",
    "Lrn",
    "ZerosLike",
    "TopK",
    "SpaceToDepth",
    "SpaceToBatch",
    "SparseToDense",
    "ReverseSequence",
    "Rank",
    "Gather",
    "GatherNd",
    "Fill",
    "Elu",
    "DepthToSpace",
    "BatchToSpace",
    "AddN",
    "Ceil",
    "EmbeddingLookup",
    "EmbeddingLookupSparse",
    "FloorDiv",
    "FloorMod",
    "L2Norm",
    "LocalResponseNormalization",
    "MatrixDiag",
    "Reduce",
    "Reverse",
    "Round",
    "Select",
    "Scatter",
    "ScatterND",
    "ConstantOfShape",
    "Unique",
    "Unstack",
    "LogicalAnd",
    "LogicalOr",
    "LogicalXor",
    "LogicalNot",
    "OnnxInt8Quantize",
    "OnnxInt8Dequantize",
    "FakeQuantWithMinMax",
    "FakeQuantWithMinMaxPerChannel",
    "BatchNormFold",
    "MulFold",
    "AddFold",
    "SquaredDifference",
    "Flatten",
    "FlattenGrad",
    "TupleGetItem",
    "Div",
    "Where",
    "OneHot",
    "Lstm",
    "Conv2DGradFilter",
    "Conv2DGradInput",
    "PoolingGrad",
    "BNGrad",
    "Assign",
    "ApplyMomentum",
    "BiasGrad",
    "SoftmaxCrossEntropy",
    "AddGrad",
    "SubGrad",
    "MulGrad",
    "DivGrad",
    "PowerGrad",
    "ActivationGrad",
    "PriorBox",
    "SpaceToBatchND",
    "Depend",
    "Return",
    "MakeTuple",
    "ToFormat",
    "Proposal",
    "Custom",
    "BlackBox",
    "NegGrad",
    "LogGrad",
    "BatchToSpaceND",
    "LshProjection",
    "HashtableLookup",
    "SkipGram",
    "DeConv2DGradFilter",
    "CustomPredict",
    "CustomNormalize",
    "CustomExtractFeatures",
    "AudioSpectrogram",
    "Mfcc",
    "Rfft",
    "FftReal",
    "FftImag",
    "Sgd",
    "Adam",
    "GroupConv2DGradInput",
    "Loop",
    "NonMaxSuppression",
    "InstanceNorm",
    "Identity",
    "LayerNorm",
    "While",
    "ControlDepend",
    "UnsortedSegmentSum",
    "AssignAdd",
    "OnesLike",
    "BinaryCrossEntropyGrad",
    "BinaryCrossEntropy",
    "LpNormalization",
    "DropoutGrad",
    "MaximumGrad",
    "MinimumGrad",
    "Switch",
    "Partial",
    "TensorListFromTensor",
    "TensorListStack",
    "TensorListGetItem",
    "TensorListSetItem",
    "TensorListReserve",
    "All",
    "Assert",
    "Adder",
    "SparseSoftmaxCrossEntropy",
    "SmoothL1Loss",
    "SmoothL1LossGrad",
    "SigmoidCrossEntropyWithLogits",
    "SigmoidCrossEntropyWithLogitsGrad",
    "Reciprocal",
    "Merge",
    "Mod",
    "GeLU",
    nullptr
  };
  return names;
}

inline const char *EnumNamePrimitiveType(PrimitiveType e) {
  if (flatbuffers::IsOutRange(e, PrimitiveType_NONE, PrimitiveType_GeLU)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesPrimitiveType()[index];
}

template<typename T> struct PrimitiveTypeTraits {
  static const PrimitiveType enum_value = PrimitiveType_NONE;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::v0::Concat> {
  static const PrimitiveType enum_value = PrimitiveType_Concat;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::v0::SoftMax> {
  static const PrimitiveType enum_value = PrimitiveType_SoftMax;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::v0::Activation> {
  static const PrimitiveType enum_value = PrimitiveType_Activation;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::v0::Conv2D> {
  static const PrimitiveType enum_value = PrimitiveType_Conv2D;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::v0::FusedBatchNorm> {
  static const PrimitiveType enum_value = PrimitiveType_FusedBatchNorm;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::v0::BatchNorm> {
  static const PrimitiveType enum_value = PrimitiveType_BatchNorm;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::v0::BiasAdd> {
  static const PrimitiveType enum_value = PrimitiveType_BiasAdd;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::v0::Pooling> {
  static const PrimitiveType enum_value = PrimitiveType_Pooling;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::v0::ROIPooling> {
  static const PrimitiveType enum_value = PrimitiveType_ROIPooling;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::v0::DepthwiseConv2D> {
  static const PrimitiveType enum_value = PrimitiveType_DepthwiseConv2D;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::v0::DeDepthwiseConv2D> {
  static const PrimitiveType enum_value = PrimitiveType_DeDepthwiseConv2D;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::v0::Resize> {
  static const PrimitiveType enum_value = PrimitiveType_Resize;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::v0::DetectionPostProcess> {
  static const PrimitiveType enum_value = PrimitiveType_DetectionPostProcess;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::v0::FullConnection> {
  static const PrimitiveType enum_value = PrimitiveType_FullConnection;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::v0::Mean> {
  static const PrimitiveType enum_value = PrimitiveType_Mean;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::v0::DeConv2D> {
  static const PrimitiveType enum_value = PrimitiveType_DeConv2D;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::v0::Scale> {
  static const PrimitiveType enum_value = PrimitiveType_Scale;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::v0::Reshape> {
  static const PrimitiveType enum_value = PrimitiveType_Reshape;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::v0::Eltwise> {
  static const PrimitiveType enum_value = PrimitiveType_Eltwise;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::v0::NetOutput> {
  static const PrimitiveType enum_value = PrimitiveType_NetOutput;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::v0::Add> {
  static const PrimitiveType enum_value = PrimitiveType_Add;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::v0::Sub> {
  static const PrimitiveType enum_value = PrimitiveType_Sub;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::v0::MatMul> {
  static const PrimitiveType enum_value = PrimitiveType_MatMul;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::v0::StridedSlice> {
  static const PrimitiveType enum_value = PrimitiveType_StridedSlice;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::v0::Power> {
  static const PrimitiveType enum_value = PrimitiveType_Power;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::v0::Slice> {
  static const PrimitiveType enum_value = PrimitiveType_Slice;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::v0::Stack> {
  static const PrimitiveType enum_value = PrimitiveType_Stack;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::v0::Mul> {
  static const PrimitiveType enum_value = PrimitiveType_Mul;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::v0::RealDiv> {
  static const PrimitiveType enum_value = PrimitiveType_RealDiv;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::v0::Pad> {
  static const PrimitiveType enum_value = PrimitiveType_Pad;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::v0::Maximum> {
  static const PrimitiveType enum_value = PrimitiveType_Maximum;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::v0::Minimum> {
  static const PrimitiveType enum_value = PrimitiveType_Minimum;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::v0::PReLU> {
  static const PrimitiveType enum_value = PrimitiveType_PReLU;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::v0::LeakyReLU> {
  static const PrimitiveType enum_value = PrimitiveType_LeakyReLU;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::v0::ArgMax> {
  static const PrimitiveType enum_value = PrimitiveType_ArgMax;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::v0::ArgMin> {
  static const PrimitiveType enum_value = PrimitiveType_ArgMin;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::v0::Exp> {
  static const PrimitiveType enum_value = PrimitiveType_Exp;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::v0::Crop> {
  static const PrimitiveType enum_value = PrimitiveType_Crop;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::v0::Range> {
  static const PrimitiveType enum_value = PrimitiveType_Range;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::v0::Rsqrt> {
  static const PrimitiveType enum_value = PrimitiveType_Rsqrt;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::v0::ExpandDims> {
  static const PrimitiveType enum_value = PrimitiveType_ExpandDims;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::v0::Tile> {
  static const PrimitiveType enum_value = PrimitiveType_Tile;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::v0::Cast> {
  static const PrimitiveType enum_value = PrimitiveType_Cast;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::v0::Shape> {
  static const PrimitiveType enum_value = PrimitiveType_Shape;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::v0::Nchw2Nhwc> {
  static const PrimitiveType enum_value = PrimitiveType_Nchw2Nhwc;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::v0::Nhwc2Nchw> {
  static const PrimitiveType enum_value = PrimitiveType_Nhwc2Nchw;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::v0::QuantDTypeCast> {
  static const PrimitiveType enum_value = PrimitiveType_QuantDTypeCast;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::v0::Split> {
  static const PrimitiveType enum_value = PrimitiveType_Split;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::v0::Permute> {
  static const PrimitiveType enum_value = PrimitiveType_Permute;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::v0::FakeQuantWithMinMaxVars> {
  static const PrimitiveType enum_value = PrimitiveType_FakeQuantWithMinMaxVars;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::v0::Equal> {
  static const PrimitiveType enum_value = PrimitiveType_Equal;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::v0::Less> {
  static const PrimitiveType enum_value = PrimitiveType_Less;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::v0::Greater> {
  static const PrimitiveType enum_value = PrimitiveType_Greater;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::v0::NotEqual> {
  static const PrimitiveType enum_value = PrimitiveType_NotEqual;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::v0::LessEqual> {
  static const PrimitiveType enum_value = PrimitiveType_LessEqual;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::v0::GreaterEqual> {
  static const PrimitiveType enum_value = PrimitiveType_GreaterEqual;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::v0::Min> {
  static const PrimitiveType enum_value = PrimitiveType_Min;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::v0::Floor> {
  static const PrimitiveType enum_value = PrimitiveType_Floor;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::v0::Abs> {
  static const PrimitiveType enum_value = PrimitiveType_Abs;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::v0::Neg> {
  static const PrimitiveType enum_value = PrimitiveType_Neg;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::v0::Cos> {
  static const PrimitiveType enum_value = PrimitiveType_Cos;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::v0::Sin> {
  static const PrimitiveType enum_value = PrimitiveType_Sin;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::v0::Sqrt> {
  static const PrimitiveType enum_value = PrimitiveType_Sqrt;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::v0::Square> {
  static const PrimitiveType enum_value = PrimitiveType_Square;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::v0::Constant> {
  static const PrimitiveType enum_value = PrimitiveType_Constant;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::v0::Log> {
  static const PrimitiveType enum_value = PrimitiveType_Log;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::v0::Tan> {
  static const PrimitiveType enum_value = PrimitiveType_Tan;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::v0::Atan> {
  static const PrimitiveType enum_value = PrimitiveType_Atan;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::v0::Asin> {
  static const PrimitiveType enum_value = PrimitiveType_Asin;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::v0::Clip> {
  static const PrimitiveType enum_value = PrimitiveType_Clip;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::v0::Transpose> {
  static const PrimitiveType enum_value = PrimitiveType_Transpose;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::v0::Squeeze> {
  static const PrimitiveType enum_value = PrimitiveType_Squeeze;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::v0::Unsqueeze> {
  static const PrimitiveType enum_value = PrimitiveType_Unsqueeze;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::v0::Upsample> {
  static const PrimitiveType enum_value = PrimitiveType_Upsample;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::v0::Dropout> {
  static const PrimitiveType enum_value = PrimitiveType_Dropout;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::v0::Broadcast> {
  static const PrimitiveType enum_value = PrimitiveType_Broadcast;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::v0::BroadcastTo> {
  static const PrimitiveType enum_value = PrimitiveType_BroadcastTo;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::v0::Lrn> {
  static const PrimitiveType enum_value = PrimitiveType_Lrn;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::v0::ZerosLike> {
  static const PrimitiveType enum_value = PrimitiveType_ZerosLike;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::v0::TopK> {
  static const PrimitiveType enum_value = PrimitiveType_TopK;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::v0::SpaceToDepth> {
  static const PrimitiveType enum_value = PrimitiveType_SpaceToDepth;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::v0::SpaceToBatch> {
  static const PrimitiveType enum_value = PrimitiveType_SpaceToBatch;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::v0::SparseToDense> {
  static const PrimitiveType enum_value = PrimitiveType_SparseToDense;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::v0::ReverseSequence> {
  static const PrimitiveType enum_value = PrimitiveType_ReverseSequence;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::v0::Rank> {
  static const PrimitiveType enum_value = PrimitiveType_Rank;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::v0::Gather> {
  static const PrimitiveType enum_value = PrimitiveType_Gather;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::v0::GatherNd> {
  static const PrimitiveType enum_value = PrimitiveType_GatherNd;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::v0::Fill> {
  static const PrimitiveType enum_value = PrimitiveType_Fill;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::v0::Elu> {
  static const PrimitiveType enum_value = PrimitiveType_Elu;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::v0::DepthToSpace> {
  static const PrimitiveType enum_value = PrimitiveType_DepthToSpace;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::v0::BatchToSpace> {
  static const PrimitiveType enum_value = PrimitiveType_BatchToSpace;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::v0::AddN> {
  static const PrimitiveType enum_value = PrimitiveType_AddN;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::v0::Ceil> {
  static const PrimitiveType enum_value = PrimitiveType_Ceil;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::v0::EmbeddingLookup> {
  static const PrimitiveType enum_value = PrimitiveType_EmbeddingLookup;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::v0::EmbeddingLookupSparse> {
  static const PrimitiveType enum_value = PrimitiveType_EmbeddingLookupSparse;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::v0::FloorDiv> {
  static const PrimitiveType enum_value = PrimitiveType_FloorDiv;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::v0::FloorMod> {
  static const PrimitiveType enum_value = PrimitiveType_FloorMod;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::v0::L2Norm> {
  static const PrimitiveType enum_value = PrimitiveType_L2Norm;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::v0::LocalResponseNormalization> {
  static const PrimitiveType enum_value = PrimitiveType_LocalResponseNormalization;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::v0::MatrixDiag> {
  static const PrimitiveType enum_value = PrimitiveType_MatrixDiag;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::v0::Reduce> {
  static const PrimitiveType enum_value = PrimitiveType_Reduce;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::v0::Reverse> {
  static const PrimitiveType enum_value = PrimitiveType_Reverse;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::v0::Round> {
  static const PrimitiveType enum_value = PrimitiveType_Round;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::v0::Select> {
  static const PrimitiveType enum_value = PrimitiveType_Select;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::v0::Scatter> {
  static const PrimitiveType enum_value = PrimitiveType_Scatter;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::v0::ScatterND> {
  static const PrimitiveType enum_value = PrimitiveType_ScatterND;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::v0::ConstantOfShape> {
  static const PrimitiveType enum_value = PrimitiveType_ConstantOfShape;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::v0::Unique> {
  static const PrimitiveType enum_value = PrimitiveType_Unique;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::v0::Unstack> {
  static const PrimitiveType enum_value = PrimitiveType_Unstack;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::v0::LogicalAnd> {
  static const PrimitiveType enum_value = PrimitiveType_LogicalAnd;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::v0::LogicalOr> {
  static const PrimitiveType enum_value = PrimitiveType_LogicalOr;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::v0::LogicalXor> {
  static const PrimitiveType enum_value = PrimitiveType_LogicalXor;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::v0::LogicalNot> {
  static const PrimitiveType enum_value = PrimitiveType_LogicalNot;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::v0::OnnxInt8Quantize> {
  static const PrimitiveType enum_value = PrimitiveType_OnnxInt8Quantize;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::v0::OnnxInt8Dequantize> {
  static const PrimitiveType enum_value = PrimitiveType_OnnxInt8Dequantize;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::v0::FakeQuantWithMinMax> {
  static const PrimitiveType enum_value = PrimitiveType_FakeQuantWithMinMax;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::v0::FakeQuantWithMinMaxPerChannel> {
  static const PrimitiveType enum_value = PrimitiveType_FakeQuantWithMinMaxPerChannel;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::v0::BatchNormFold> {
  static const PrimitiveType enum_value = PrimitiveType_BatchNormFold;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::v0::MulFold> {
  static const PrimitiveType enum_value = PrimitiveType_MulFold;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::v0::AddFold> {
  static const PrimitiveType enum_value = PrimitiveType_AddFold;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::v0::SquaredDifference> {
  static const PrimitiveType enum_value = PrimitiveType_SquaredDifference;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::v0::Flatten> {
  static const PrimitiveType enum_value = PrimitiveType_Flatten;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::v0::FlattenGrad> {
  static const PrimitiveType enum_value = PrimitiveType_FlattenGrad;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::v0::TupleGetItem> {
  static const PrimitiveType enum_value = PrimitiveType_TupleGetItem;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::v0::Div> {
  static const PrimitiveType enum_value = PrimitiveType_Div;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::v0::Where> {
  static const PrimitiveType enum_value = PrimitiveType_Where;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::v0::OneHot> {
  static const PrimitiveType enum_value = PrimitiveType_OneHot;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::v0::Lstm> {
  static const PrimitiveType enum_value = PrimitiveType_Lstm;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::v0::Conv2DGradFilter> {
  static const PrimitiveType enum_value = PrimitiveType_Conv2DGradFilter;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::v0::Conv2DGradInput> {
  static const PrimitiveType enum_value = PrimitiveType_Conv2DGradInput;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::v0::PoolingGrad> {
  static const PrimitiveType enum_value = PrimitiveType_PoolingGrad;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::v0::BNGrad> {
  static const PrimitiveType enum_value = PrimitiveType_BNGrad;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::v0::Assign> {
  static const PrimitiveType enum_value = PrimitiveType_Assign;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::v0::ApplyMomentum> {
  static const PrimitiveType enum_value = PrimitiveType_ApplyMomentum;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::v0::BiasGrad> {
  static const PrimitiveType enum_value = PrimitiveType_BiasGrad;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::v0::SoftmaxCrossEntropy> {
  static const PrimitiveType enum_value = PrimitiveType_SoftmaxCrossEntropy;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::v0::AddGrad> {
  static const PrimitiveType enum_value = PrimitiveType_AddGrad;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::v0::SubGrad> {
  static const PrimitiveType enum_value = PrimitiveType_SubGrad;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::v0::MulGrad> {
  static const PrimitiveType enum_value = PrimitiveType_MulGrad;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::v0::DivGrad> {
  static const PrimitiveType enum_value = PrimitiveType_DivGrad;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::v0::PowerGrad> {
  static const PrimitiveType enum_value = PrimitiveType_PowerGrad;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::v0::ActivationGrad> {
  static const PrimitiveType enum_value = PrimitiveType_ActivationGrad;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::v0::PriorBox> {
  static const PrimitiveType enum_value = PrimitiveType_PriorBox;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::v0::SpaceToBatchND> {
  static const PrimitiveType enum_value = PrimitiveType_SpaceToBatchND;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::v0::Depend> {
  static const PrimitiveType enum_value = PrimitiveType_Depend;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::v0::Return> {
  static const PrimitiveType enum_value = PrimitiveType_Return;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::v0::MakeTuple> {
  static const PrimitiveType enum_value = PrimitiveType_MakeTuple;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::v0::ToFormat> {
  static const PrimitiveType enum_value = PrimitiveType_ToFormat;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::v0::Proposal> {
  static const PrimitiveType enum_value = PrimitiveType_Proposal;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::v0::Custom> {
  static const PrimitiveType enum_value = PrimitiveType_Custom;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::v0::BlackBox> {
  static const PrimitiveType enum_value = PrimitiveType_BlackBox;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::v0::NegGrad> {
  static const PrimitiveType enum_value = PrimitiveType_NegGrad;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::v0::LogGrad> {
  static const PrimitiveType enum_value = PrimitiveType_LogGrad;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::v0::BatchToSpaceND> {
  static const PrimitiveType enum_value = PrimitiveType_BatchToSpaceND;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::v0::LshProjection> {
  static const PrimitiveType enum_value = PrimitiveType_LshProjection;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::v0::HashtableLookup> {
  static const PrimitiveType enum_value = PrimitiveType_HashtableLookup;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::v0::SkipGram> {
  static const PrimitiveType enum_value = PrimitiveType_SkipGram;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::v0::DeConv2DGradFilter> {
  static const PrimitiveType enum_value = PrimitiveType_DeConv2DGradFilter;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::v0::CustomPredict> {
  static const PrimitiveType enum_value = PrimitiveType_CustomPredict;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::v0::CustomNormalize> {
  static const PrimitiveType enum_value = PrimitiveType_CustomNormalize;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::v0::CustomExtractFeatures> {
  static const PrimitiveType enum_value = PrimitiveType_CustomExtractFeatures;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::v0::AudioSpectrogram> {
  static const PrimitiveType enum_value = PrimitiveType_AudioSpectrogram;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::v0::Mfcc> {
  static const PrimitiveType enum_value = PrimitiveType_Mfcc;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::v0::Rfft> {
  static const PrimitiveType enum_value = PrimitiveType_Rfft;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::v0::FftReal> {
  static const PrimitiveType enum_value = PrimitiveType_FftReal;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::v0::FftImag> {
  static const PrimitiveType enum_value = PrimitiveType_FftImag;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::v0::Sgd> {
  static const PrimitiveType enum_value = PrimitiveType_Sgd;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::v0::Adam> {
  static const PrimitiveType enum_value = PrimitiveType_Adam;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::v0::GroupConv2DGradInput> {
  static const PrimitiveType enum_value = PrimitiveType_GroupConv2DGradInput;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::v0::Loop> {
  static const PrimitiveType enum_value = PrimitiveType_Loop;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::v0::NonMaxSuppression> {
  static const PrimitiveType enum_value = PrimitiveType_NonMaxSuppression;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::v0::InstanceNorm> {
  static const PrimitiveType enum_value = PrimitiveType_InstanceNorm;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::v0::Identity> {
  static const PrimitiveType enum_value = PrimitiveType_Identity;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::v0::LayerNorm> {
  static const PrimitiveType enum_value = PrimitiveType_LayerNorm;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::v0::While> {
  static const PrimitiveType enum_value = PrimitiveType_While;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::v0::ControlDepend> {
  static const PrimitiveType enum_value = PrimitiveType_ControlDepend;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::v0::UnsortedSegmentSum> {
  static const PrimitiveType enum_value = PrimitiveType_UnsortedSegmentSum;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::v0::AssignAdd> {
  static const PrimitiveType enum_value = PrimitiveType_AssignAdd;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::v0::OnesLike> {
  static const PrimitiveType enum_value = PrimitiveType_OnesLike;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::v0::BinaryCrossEntropyGrad> {
  static const PrimitiveType enum_value = PrimitiveType_BinaryCrossEntropyGrad;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::v0::BinaryCrossEntropy> {
  static const PrimitiveType enum_value = PrimitiveType_BinaryCrossEntropy;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::v0::LpNormalization> {
  static const PrimitiveType enum_value = PrimitiveType_LpNormalization;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::v0::DropoutGrad> {
  static const PrimitiveType enum_value = PrimitiveType_DropoutGrad;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::v0::MaximumGrad> {
  static const PrimitiveType enum_value = PrimitiveType_MaximumGrad;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::v0::MinimumGrad> {
  static const PrimitiveType enum_value = PrimitiveType_MinimumGrad;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::v0::Switch> {
  static const PrimitiveType enum_value = PrimitiveType_Switch;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::v0::Partial> {
  static const PrimitiveType enum_value = PrimitiveType_Partial;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::v0::TensorListFromTensor> {
  static const PrimitiveType enum_value = PrimitiveType_TensorListFromTensor;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::v0::TensorListStack> {
  static const PrimitiveType enum_value = PrimitiveType_TensorListStack;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::v0::TensorListGetItem> {
  static const PrimitiveType enum_value = PrimitiveType_TensorListGetItem;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::v0::TensorListSetItem> {
  static const PrimitiveType enum_value = PrimitiveType_TensorListSetItem;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::v0::TensorListReserve> {
  static const PrimitiveType enum_value = PrimitiveType_TensorListReserve;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::v0::All> {
  static const PrimitiveType enum_value = PrimitiveType_All;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::v0::Assert> {
  static const PrimitiveType enum_value = PrimitiveType_Assert;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::v0::Adder> {
  static const PrimitiveType enum_value = PrimitiveType_Adder;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::v0::SparseSoftmaxCrossEntropy> {
  static const PrimitiveType enum_value = PrimitiveType_SparseSoftmaxCrossEntropy;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::v0::SmoothL1Loss> {
  static const PrimitiveType enum_value = PrimitiveType_SmoothL1Loss;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::v0::SmoothL1LossGrad> {
  static const PrimitiveType enum_value = PrimitiveType_SmoothL1LossGrad;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::v0::SigmoidCrossEntropyWithLogits> {
  static const PrimitiveType enum_value = PrimitiveType_SigmoidCrossEntropyWithLogits;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::v0::SigmoidCrossEntropyWithLogitsGrad> {
  static const PrimitiveType enum_value = PrimitiveType_SigmoidCrossEntropyWithLogitsGrad;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::v0::Reciprocal> {
  static const PrimitiveType enum_value = PrimitiveType_Reciprocal;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::v0::Merge> {
  static const PrimitiveType enum_value = PrimitiveType_Merge;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::v0::Mod> {
  static const PrimitiveType enum_value = PrimitiveType_Mod;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::v0::GeLU> {
  static const PrimitiveType enum_value = PrimitiveType_GeLU;
};

bool VerifyPrimitiveType(flatbuffers::Verifier &verifier, const void *obj, PrimitiveType type);
bool VerifyPrimitiveTypeVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types);

enum QuantType : int32_t {
  QuantType_QUANT_NONE = 0,
  QuantType_AwareTraining = 1,
  QuantType_WeightQuant = 2,
  QuantType_PostTraining = 3,
  QuantType_MIN = QuantType_QUANT_NONE,
  QuantType_MAX = QuantType_PostTraining
};

inline const QuantType (&EnumValuesQuantType())[4] {
  static const QuantType values[] = {
    QuantType_QUANT_NONE,
    QuantType_AwareTraining,
    QuantType_WeightQuant,
    QuantType_PostTraining
  };
  return values;
}

inline const char * const *EnumNamesQuantType() {
  static const char * const names[5] = {
    "QUANT_NONE",
    "AwareTraining",
    "WeightQuant",
    "PostTraining",
    nullptr
  };
  return names;
}

inline const char *EnumNameQuantType(QuantType e) {
  if (flatbuffers::IsOutRange(e, QuantType_QUANT_NONE, QuantType_PostTraining)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesQuantType()[index];
}

struct QuantParam FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef QuantParamBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SCALE = 4,
    VT_ZEROPOINT = 6,
    VT_MIN = 8,
    VT_MAX = 10,
    VT_NARROWRANGE = 12,
    VT_NUMBITS = 14,
    VT_INITED = 16,
    VT_VARCORR = 18,
    VT_MEANCORR = 20,
    VT_DSTDTYPE = 22,
    VT_ROUNDTYPE = 24,
    VT_MULTIPLIER = 26
  };
  double scale() const {
    return GetField<double>(VT_SCALE, 0.0);
  }
  int32_t zeroPoint() const {
    return GetField<int32_t>(VT_ZEROPOINT, 0);
  }
  double min() const {
    return GetField<double>(VT_MIN, 0.0);
  }
  double max() const {
    return GetField<double>(VT_MAX, 0.0);
  }
  bool narrowRange() const {
    return GetField<uint8_t>(VT_NARROWRANGE, 1) != 0;
  }
  int32_t numBits() const {
    return GetField<int32_t>(VT_NUMBITS, 8);
  }
  bool inited() const {
    return GetField<uint8_t>(VT_INITED, 0) != 0;
  }
  float varCorr() const {
    return GetField<float>(VT_VARCORR, 1.0f);
  }
  float meanCorr() const {
    return GetField<float>(VT_MEANCORR, 0.0f);
  }
  int32_t dstDtype() const {
    return GetField<int32_t>(VT_DSTDTYPE, 32);
  }
  int32_t roundType() const {
    return GetField<int32_t>(VT_ROUNDTYPE, 1);
  }
  int32_t multiplier() const {
    return GetField<int32_t>(VT_MULTIPLIER, 1);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<double>(verifier, VT_SCALE) &&
           VerifyField<int32_t>(verifier, VT_ZEROPOINT) &&
           VerifyField<double>(verifier, VT_MIN) &&
           VerifyField<double>(verifier, VT_MAX) &&
           VerifyField<uint8_t>(verifier, VT_NARROWRANGE) &&
           VerifyField<int32_t>(verifier, VT_NUMBITS) &&
           VerifyField<uint8_t>(verifier, VT_INITED) &&
           VerifyField<float>(verifier, VT_VARCORR) &&
           VerifyField<float>(verifier, VT_MEANCORR) &&
           VerifyField<int32_t>(verifier, VT_DSTDTYPE) &&
           VerifyField<int32_t>(verifier, VT_ROUNDTYPE) &&
           VerifyField<int32_t>(verifier, VT_MULTIPLIER) &&
           verifier.EndTable();
  }
};

struct QuantParamBuilder {
  typedef QuantParam Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_scale(double scale) {
    fbb_.AddElement<double>(QuantParam::VT_SCALE, scale, 0.0);
  }
  void add_zeroPoint(int32_t zeroPoint) {
    fbb_.AddElement<int32_t>(QuantParam::VT_ZEROPOINT, zeroPoint, 0);
  }
  void add_min(double min) {
    fbb_.AddElement<double>(QuantParam::VT_MIN, min, 0.0);
  }
  void add_max(double max) {
    fbb_.AddElement<double>(QuantParam::VT_MAX, max, 0.0);
  }
  void add_narrowRange(bool narrowRange) {
    fbb_.AddElement<uint8_t>(QuantParam::VT_NARROWRANGE, static_cast<uint8_t>(narrowRange), 1);
  }
  void add_numBits(int32_t numBits) {
    fbb_.AddElement<int32_t>(QuantParam::VT_NUMBITS, numBits, 8);
  }
  void add_inited(bool inited) {
    fbb_.AddElement<uint8_t>(QuantParam::VT_INITED, static_cast<uint8_t>(inited), 0);
  }
  void add_varCorr(float varCorr) {
    fbb_.AddElement<float>(QuantParam::VT_VARCORR, varCorr, 1.0f);
  }
  void add_meanCorr(float meanCorr) {
    fbb_.AddElement<float>(QuantParam::VT_MEANCORR, meanCorr, 0.0f);
  }
  void add_dstDtype(int32_t dstDtype) {
    fbb_.AddElement<int32_t>(QuantParam::VT_DSTDTYPE, dstDtype, 32);
  }
  void add_roundType(int32_t roundType) {
    fbb_.AddElement<int32_t>(QuantParam::VT_ROUNDTYPE, roundType, 1);
  }
  void add_multiplier(int32_t multiplier) {
    fbb_.AddElement<int32_t>(QuantParam::VT_MULTIPLIER, multiplier, 1);
  }
  explicit QuantParamBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<QuantParam> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<QuantParam>(end);
    return o;
  }
};

inline flatbuffers::Offset<QuantParam> CreateQuantParam(
    flatbuffers::FlatBufferBuilder &_fbb,
    double scale = 0.0,
    int32_t zeroPoint = 0,
    double min = 0.0,
    double max = 0.0,
    bool narrowRange = true,
    int32_t numBits = 8,
    bool inited = false,
    float varCorr = 1.0f,
    float meanCorr = 0.0f,
    int32_t dstDtype = 32,
    int32_t roundType = 1,
    int32_t multiplier = 1) {
  QuantParamBuilder builder_(_fbb);
  builder_.add_max(max);
  builder_.add_min(min);
  builder_.add_scale(scale);
  builder_.add_multiplier(multiplier);
  builder_.add_roundType(roundType);
  builder_.add_dstDtype(dstDtype);
  builder_.add_meanCorr(meanCorr);
  builder_.add_varCorr(varCorr);
  builder_.add_numBits(numBits);
  builder_.add_zeroPoint(zeroPoint);
  builder_.add_inited(inited);
  builder_.add_narrowRange(narrowRange);
  return builder_.Finish();
}

struct Tensor FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef TensorBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NODETYPE = 4,
    VT_DATATYPE = 6,
    VT_DIMS = 8,
    VT_FORMAT = 10,
    VT_REFCOUNT = 12,
    VT_OFFSET = 14,
    VT_DATA = 16,
    VT_QUANTPARAMS = 18,
    VT_QUANTCLUSTERS = 20,
    VT_NAME = 22
  };
  mindspore::schema::v0::NodeType nodeType() const {
    return static_cast<mindspore::schema::v0::NodeType>(GetField<int32_t>(VT_NODETYPE, 0));
  }
  int32_t dataType() const {
    return GetField<int32_t>(VT_DATATYPE, 0);
  }
  const flatbuffers::Vector<int32_t> *dims() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_DIMS);
  }
  mindspore::schema::v0::Format format() const {
    return static_cast<mindspore::schema::v0::Format>(GetField<int32_t>(VT_FORMAT, 0));
  }
  int32_t refCount() const {
    return GetField<int32_t>(VT_REFCOUNT, 0);
  }
  int32_t offset() const {
    return GetField<int32_t>(VT_OFFSET, 0);
  }
  const flatbuffers::Vector<uint8_t> *data() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_DATA);
  }
  const flatbuffers::Vector<flatbuffers::Offset<mindspore::schema::v0::QuantParam>> *quantParams() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<mindspore::schema::v0::QuantParam>> *>(VT_QUANTPARAMS);
  }
  const flatbuffers::Vector<float> *quantClusters() const {
    return GetPointer<const flatbuffers::Vector<float> *>(VT_QUANTCLUSTERS);
  }
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_NODETYPE) &&
           VerifyField<int32_t>(verifier, VT_DATATYPE) &&
           VerifyOffset(verifier, VT_DIMS) &&
           verifier.VerifyVector(dims()) &&
           VerifyField<int32_t>(verifier, VT_FORMAT) &&
           VerifyField<int32_t>(verifier, VT_REFCOUNT) &&
           VerifyField<int32_t>(verifier, VT_OFFSET) &&
           VerifyOffset(verifier, VT_DATA) &&
           verifier.VerifyVector(data()) &&
           VerifyOffset(verifier, VT_QUANTPARAMS) &&
           verifier.VerifyVector(quantParams()) &&
           verifier.VerifyVectorOfTables(quantParams()) &&
           VerifyOffset(verifier, VT_QUANTCLUSTERS) &&
           verifier.VerifyVector(quantClusters()) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           verifier.EndTable();
  }
};

struct TensorBuilder {
  typedef Tensor Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_nodeType(mindspore::schema::v0::NodeType nodeType) {
    fbb_.AddElement<int32_t>(Tensor::VT_NODETYPE, static_cast<int32_t>(nodeType), 0);
  }
  void add_dataType(int32_t dataType) {
    fbb_.AddElement<int32_t>(Tensor::VT_DATATYPE, dataType, 0);
  }
  void add_dims(flatbuffers::Offset<flatbuffers::Vector<int32_t>> dims) {
    fbb_.AddOffset(Tensor::VT_DIMS, dims);
  }
  void add_format(mindspore::schema::v0::Format format) {
    fbb_.AddElement<int32_t>(Tensor::VT_FORMAT, static_cast<int32_t>(format), 0);
  }
  void add_refCount(int32_t refCount) {
    fbb_.AddElement<int32_t>(Tensor::VT_REFCOUNT, refCount, 0);
  }
  void add_offset(int32_t offset) {
    fbb_.AddElement<int32_t>(Tensor::VT_OFFSET, offset, 0);
  }
  void add_data(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> data) {
    fbb_.AddOffset(Tensor::VT_DATA, data);
  }
  void add_quantParams(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<mindspore::schema::v0::QuantParam>>> quantParams) {
    fbb_.AddOffset(Tensor::VT_QUANTPARAMS, quantParams);
  }
  void add_quantClusters(flatbuffers::Offset<flatbuffers::Vector<float>> quantClusters) {
    fbb_.AddOffset(Tensor::VT_QUANTCLUSTERS, quantClusters);
  }
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(Tensor::VT_NAME, name);
  }
  explicit TensorBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Tensor> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Tensor>(end);
    return o;
  }
};

inline flatbuffers::Offset<Tensor> CreateTensor(
    flatbuffers::FlatBufferBuilder &_fbb,
    mindspore::schema::v0::NodeType nodeType = mindspore::schema::v0::NodeType_ValueNode,
    int32_t dataType = 0,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> dims = 0,
    mindspore::schema::v0::Format format = mindspore::schema::v0::Format_NCHW,
    int32_t refCount = 0,
    int32_t offset = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> data = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<mindspore::schema::v0::QuantParam>>> quantParams = 0,
    flatbuffers::Offset<flatbuffers::Vector<float>> quantClusters = 0,
    flatbuffers::Offset<flatbuffers::String> name = 0) {
  TensorBuilder builder_(_fbb);
  builder_.add_name(name);
  builder_.add_quantClusters(quantClusters);
  builder_.add_quantParams(quantParams);
  builder_.add_data(data);
  builder_.add_offset(offset);
  builder_.add_refCount(refCount);
  builder_.add_format(format);
  builder_.add_dims(dims);
  builder_.add_dataType(dataType);
  builder_.add_nodeType(nodeType);
  return builder_.Finish();
}

inline flatbuffers::Offset<Tensor> CreateTensorDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    mindspore::schema::v0::NodeType nodeType = mindspore::schema::v0::NodeType_ValueNode,
    int32_t dataType = 0,
    const std::vector<int32_t> *dims = nullptr,
    mindspore::schema::v0::Format format = mindspore::schema::v0::Format_NCHW,
    int32_t refCount = 0,
    int32_t offset = 0,
    const std::vector<uint8_t> *data = nullptr,
    const std::vector<flatbuffers::Offset<mindspore::schema::v0::QuantParam>> *quantParams = nullptr,
    const std::vector<float> *quantClusters = nullptr,
    const char *name = nullptr) {
  auto dims__ = dims ? _fbb.CreateVector<int32_t>(*dims) : 0;
  auto data__ = data ? _fbb.CreateVector<uint8_t>(*data) : 0;
  auto quantParams__ = quantParams ? _fbb.CreateVector<flatbuffers::Offset<mindspore::schema::v0::QuantParam>>(*quantParams) : 0;
  auto quantClusters__ = quantClusters ? _fbb.CreateVector<float>(*quantClusters) : 0;
  auto name__ = name ? _fbb.CreateString(name) : 0;
  return mindspore::schema::v0::CreateTensor(
      _fbb,
      nodeType,
      dataType,
      dims__,
      format,
      refCount,
      offset,
      data__,
      quantParams__,
      quantClusters__,
      name__);
}

struct Primitive FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef PrimitiveBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VALUE_TYPE = 4,
    VT_VALUE = 6
  };
  mindspore::schema::v0::PrimitiveType value_type() const {
    return static_cast<mindspore::schema::v0::PrimitiveType>(GetField<uint8_t>(VT_VALUE_TYPE, 0));
  }
  const void *value() const {
    return GetPointer<const void *>(VT_VALUE);
  }
  template<typename T> const T *value_as() const;
  const mindspore::schema::v0::Concat *value_as_Concat() const {
    return value_type() == mindspore::schema::v0::PrimitiveType_Concat ? static_cast<const mindspore::schema::v0::Concat *>(value()) : nullptr;
  }
  const mindspore::schema::v0::SoftMax *value_as_SoftMax() const {
    return value_type() == mindspore::schema::v0::PrimitiveType_SoftMax ? static_cast<const mindspore::schema::v0::SoftMax *>(value()) : nullptr;
  }
  const mindspore::schema::v0::Activation *value_as_Activation() const {
    return value_type() == mindspore::schema::v0::PrimitiveType_Activation ? static_cast<const mindspore::schema::v0::Activation *>(value()) : nullptr;
  }
  const mindspore::schema::v0::Conv2D *value_as_Conv2D() const {
    return value_type() == mindspore::schema::v0::PrimitiveType_Conv2D ? static_cast<const mindspore::schema::v0::Conv2D *>(value()) : nullptr;
  }
  const mindspore::schema::v0::FusedBatchNorm *value_as_FusedBatchNorm() const {
    return value_type() == mindspore::schema::v0::PrimitiveType_FusedBatchNorm ? static_cast<const mindspore::schema::v0::FusedBatchNorm *>(value()) : nullptr;
  }
  const mindspore::schema::v0::BatchNorm *value_as_BatchNorm() const {
    return value_type() == mindspore::schema::v0::PrimitiveType_BatchNorm ? static_cast<const mindspore::schema::v0::BatchNorm *>(value()) : nullptr;
  }
  const mindspore::schema::v0::BiasAdd *value_as_BiasAdd() const {
    return value_type() == mindspore::schema::v0::PrimitiveType_BiasAdd ? static_cast<const mindspore::schema::v0::BiasAdd *>(value()) : nullptr;
  }
  const mindspore::schema::v0::Pooling *value_as_Pooling() const {
    return value_type() == mindspore::schema::v0::PrimitiveType_Pooling ? static_cast<const mindspore::schema::v0::Pooling *>(value()) : nullptr;
  }
  const mindspore::schema::v0::ROIPooling *value_as_ROIPooling() const {
    return value_type() == mindspore::schema::v0::PrimitiveType_ROIPooling ? static_cast<const mindspore::schema::v0::ROIPooling *>(value()) : nullptr;
  }
  const mindspore::schema::v0::DepthwiseConv2D *value_as_DepthwiseConv2D() const {
    return value_type() == mindspore::schema::v0::PrimitiveType_DepthwiseConv2D ? static_cast<const mindspore::schema::v0::DepthwiseConv2D *>(value()) : nullptr;
  }
  const mindspore::schema::v0::DeDepthwiseConv2D *value_as_DeDepthwiseConv2D() const {
    return value_type() == mindspore::schema::v0::PrimitiveType_DeDepthwiseConv2D ? static_cast<const mindspore::schema::v0::DeDepthwiseConv2D *>(value()) : nullptr;
  }
  const mindspore::schema::v0::Resize *value_as_Resize() const {
    return value_type() == mindspore::schema::v0::PrimitiveType_Resize ? static_cast<const mindspore::schema::v0::Resize *>(value()) : nullptr;
  }
  const mindspore::schema::v0::DetectionPostProcess *value_as_DetectionPostProcess() const {
    return value_type() == mindspore::schema::v0::PrimitiveType_DetectionPostProcess ? static_cast<const mindspore::schema::v0::DetectionPostProcess *>(value()) : nullptr;
  }
  const mindspore::schema::v0::FullConnection *value_as_FullConnection() const {
    return value_type() == mindspore::schema::v0::PrimitiveType_FullConnection ? static_cast<const mindspore::schema::v0::FullConnection *>(value()) : nullptr;
  }
  const mindspore::schema::v0::Mean *value_as_Mean() const {
    return value_type() == mindspore::schema::v0::PrimitiveType_Mean ? static_cast<const mindspore::schema::v0::Mean *>(value()) : nullptr;
  }
  const mindspore::schema::v0::DeConv2D *value_as_DeConv2D() const {
    return value_type() == mindspore::schema::v0::PrimitiveType_DeConv2D ? static_cast<const mindspore::schema::v0::DeConv2D *>(value()) : nullptr;
  }
  const mindspore::schema::v0::Scale *value_as_Scale() const {
    return value_type() == mindspore::schema::v0::PrimitiveType_Scale ? static_cast<const mindspore::schema::v0::Scale *>(value()) : nullptr;
  }
  const mindspore::schema::v0::Reshape *value_as_Reshape() const {
    return value_type() == mindspore::schema::v0::PrimitiveType_Reshape ? static_cast<const mindspore::schema::v0::Reshape *>(value()) : nullptr;
  }
  const mindspore::schema::v0::Eltwise *value_as_Eltwise() const {
    return value_type() == mindspore::schema::v0::PrimitiveType_Eltwise ? static_cast<const mindspore::schema::v0::Eltwise *>(value()) : nullptr;
  }
  const mindspore::schema::v0::NetOutput *value_as_NetOutput() const {
    return value_type() == mindspore::schema::v0::PrimitiveType_NetOutput ? static_cast<const mindspore::schema::v0::NetOutput *>(value()) : nullptr;
  }
  const mindspore::schema::v0::Add *value_as_Add() const {
    return value_type() == mindspore::schema::v0::PrimitiveType_Add ? static_cast<const mindspore::schema::v0::Add *>(value()) : nullptr;
  }
  const mindspore::schema::v0::Sub *value_as_Sub() const {
    return value_type() == mindspore::schema::v0::PrimitiveType_Sub ? static_cast<const mindspore::schema::v0::Sub *>(value()) : nullptr;
  }
  const mindspore::schema::v0::MatMul *value_as_MatMul() const {
    return value_type() == mindspore::schema::v0::PrimitiveType_MatMul ? static_cast<const mindspore::schema::v0::MatMul *>(value()) : nullptr;
  }
  const mindspore::schema::v0::StridedSlice *value_as_StridedSlice() const {
    return value_type() == mindspore::schema::v0::PrimitiveType_StridedSlice ? static_cast<const mindspore::schema::v0::StridedSlice *>(value()) : nullptr;
  }
  const mindspore::schema::v0::Power *value_as_Power() const {
    return value_type() == mindspore::schema::v0::PrimitiveType_Power ? static_cast<const mindspore::schema::v0::Power *>(value()) : nullptr;
  }
  const mindspore::schema::v0::Slice *value_as_Slice() const {
    return value_type() == mindspore::schema::v0::PrimitiveType_Slice ? static_cast<const mindspore::schema::v0::Slice *>(value()) : nullptr;
  }
  const mindspore::schema::v0::Stack *value_as_Stack() const {
    return value_type() == mindspore::schema::v0::PrimitiveType_Stack ? static_cast<const mindspore::schema::v0::Stack *>(value()) : nullptr;
  }
  const mindspore::schema::v0::Mul *value_as_Mul() const {
    return value_type() == mindspore::schema::v0::PrimitiveType_Mul ? static_cast<const mindspore::schema::v0::Mul *>(value()) : nullptr;
  }
  const mindspore::schema::v0::RealDiv *value_as_RealDiv() const {
    return value_type() == mindspore::schema::v0::PrimitiveType_RealDiv ? static_cast<const mindspore::schema::v0::RealDiv *>(value()) : nullptr;
  }
  const mindspore::schema::v0::Pad *value_as_Pad() const {
    return value_type() == mindspore::schema::v0::PrimitiveType_Pad ? static_cast<const mindspore::schema::v0::Pad *>(value()) : nullptr;
  }
  const mindspore::schema::v0::Maximum *value_as_Maximum() const {
    return value_type() == mindspore::schema::v0::PrimitiveType_Maximum ? static_cast<const mindspore::schema::v0::Maximum *>(value()) : nullptr;
  }
  const mindspore::schema::v0::Minimum *value_as_Minimum() const {
    return value_type() == mindspore::schema::v0::PrimitiveType_Minimum ? static_cast<const mindspore::schema::v0::Minimum *>(value()) : nullptr;
  }
  const mindspore::schema::v0::PReLU *value_as_PReLU() const {
    return value_type() == mindspore::schema::v0::PrimitiveType_PReLU ? static_cast<const mindspore::schema::v0::PReLU *>(value()) : nullptr;
  }
  const mindspore::schema::v0::LeakyReLU *value_as_LeakyReLU() const {
    return value_type() == mindspore::schema::v0::PrimitiveType_LeakyReLU ? static_cast<const mindspore::schema::v0::LeakyReLU *>(value()) : nullptr;
  }
  const mindspore::schema::v0::ArgMax *value_as_ArgMax() const {
    return value_type() == mindspore::schema::v0::PrimitiveType_ArgMax ? static_cast<const mindspore::schema::v0::ArgMax *>(value()) : nullptr;
  }
  const mindspore::schema::v0::ArgMin *value_as_ArgMin() const {
    return value_type() == mindspore::schema::v0::PrimitiveType_ArgMin ? static_cast<const mindspore::schema::v0::ArgMin *>(value()) : nullptr;
  }
  const mindspore::schema::v0::Exp *value_as_Exp() const {
    return value_type() == mindspore::schema::v0::PrimitiveType_Exp ? static_cast<const mindspore::schema::v0::Exp *>(value()) : nullptr;
  }
  const mindspore::schema::v0::Crop *value_as_Crop() const {
    return value_type() == mindspore::schema::v0::PrimitiveType_Crop ? static_cast<const mindspore::schema::v0::Crop *>(value()) : nullptr;
  }
  const mindspore::schema::v0::Range *value_as_Range() const {
    return value_type() == mindspore::schema::v0::PrimitiveType_Range ? static_cast<const mindspore::schema::v0::Range *>(value()) : nullptr;
  }
  const mindspore::schema::v0::Rsqrt *value_as_Rsqrt() const {
    return value_type() == mindspore::schema::v0::PrimitiveType_Rsqrt ? static_cast<const mindspore::schema::v0::Rsqrt *>(value()) : nullptr;
  }
  const mindspore::schema::v0::ExpandDims *value_as_ExpandDims() const {
    return value_type() == mindspore::schema::v0::PrimitiveType_ExpandDims ? static_cast<const mindspore::schema::v0::ExpandDims *>(value()) : nullptr;
  }
  const mindspore::schema::v0::Tile *value_as_Tile() const {
    return value_type() == mindspore::schema::v0::PrimitiveType_Tile ? static_cast<const mindspore::schema::v0::Tile *>(value()) : nullptr;
  }
  const mindspore::schema::v0::Cast *value_as_Cast() const {
    return value_type() == mindspore::schema::v0::PrimitiveType_Cast ? static_cast<const mindspore::schema::v0::Cast *>(value()) : nullptr;
  }
  const mindspore::schema::v0::Shape *value_as_Shape() const {
    return value_type() == mindspore::schema::v0::PrimitiveType_Shape ? static_cast<const mindspore::schema::v0::Shape *>(value()) : nullptr;
  }
  const mindspore::schema::v0::Nchw2Nhwc *value_as_Nchw2Nhwc() const {
    return value_type() == mindspore::schema::v0::PrimitiveType_Nchw2Nhwc ? static_cast<const mindspore::schema::v0::Nchw2Nhwc *>(value()) : nullptr;
  }
  const mindspore::schema::v0::Nhwc2Nchw *value_as_Nhwc2Nchw() const {
    return value_type() == mindspore::schema::v0::PrimitiveType_Nhwc2Nchw ? static_cast<const mindspore::schema::v0::Nhwc2Nchw *>(value()) : nullptr;
  }
  const mindspore::schema::v0::QuantDTypeCast *value_as_QuantDTypeCast() const {
    return value_type() == mindspore::schema::v0::PrimitiveType_QuantDTypeCast ? static_cast<const mindspore::schema::v0::QuantDTypeCast *>(value()) : nullptr;
  }
  const mindspore::schema::v0::Split *value_as_Split() const {
    return value_type() == mindspore::schema::v0::PrimitiveType_Split ? static_cast<const mindspore::schema::v0::Split *>(value()) : nullptr;
  }
  const mindspore::schema::v0::Permute *value_as_Permute() const {
    return value_type() == mindspore::schema::v0::PrimitiveType_Permute ? static_cast<const mindspore::schema::v0::Permute *>(value()) : nullptr;
  }
  const mindspore::schema::v0::FakeQuantWithMinMaxVars *value_as_FakeQuantWithMinMaxVars() const {
    return value_type() == mindspore::schema::v0::PrimitiveType_FakeQuantWithMinMaxVars ? static_cast<const mindspore::schema::v0::FakeQuantWithMinMaxVars *>(value()) : nullptr;
  }
  const mindspore::schema::v0::Equal *value_as_Equal() const {
    return value_type() == mindspore::schema::v0::PrimitiveType_Equal ? static_cast<const mindspore::schema::v0::Equal *>(value()) : nullptr;
  }
  const mindspore::schema::v0::Less *value_as_Less() const {
    return value_type() == mindspore::schema::v0::PrimitiveType_Less ? static_cast<const mindspore::schema::v0::Less *>(value()) : nullptr;
  }
  const mindspore::schema::v0::Greater *value_as_Greater() const {
    return value_type() == mindspore::schema::v0::PrimitiveType_Greater ? static_cast<const mindspore::schema::v0::Greater *>(value()) : nullptr;
  }
  const mindspore::schema::v0::NotEqual *value_as_NotEqual() const {
    return value_type() == mindspore::schema::v0::PrimitiveType_NotEqual ? static_cast<const mindspore::schema::v0::NotEqual *>(value()) : nullptr;
  }
  const mindspore::schema::v0::LessEqual *value_as_LessEqual() const {
    return value_type() == mindspore::schema::v0::PrimitiveType_LessEqual ? static_cast<const mindspore::schema::v0::LessEqual *>(value()) : nullptr;
  }
  const mindspore::schema::v0::GreaterEqual *value_as_GreaterEqual() const {
    return value_type() == mindspore::schema::v0::PrimitiveType_GreaterEqual ? static_cast<const mindspore::schema::v0::GreaterEqual *>(value()) : nullptr;
  }
  const mindspore::schema::v0::Min *value_as_Min() const {
    return value_type() == mindspore::schema::v0::PrimitiveType_Min ? static_cast<const mindspore::schema::v0::Min *>(value()) : nullptr;
  }
  const mindspore::schema::v0::Floor *value_as_Floor() const {
    return value_type() == mindspore::schema::v0::PrimitiveType_Floor ? static_cast<const mindspore::schema::v0::Floor *>(value()) : nullptr;
  }
  const mindspore::schema::v0::Abs *value_as_Abs() const {
    return value_type() == mindspore::schema::v0::PrimitiveType_Abs ? static_cast<const mindspore::schema::v0::Abs *>(value()) : nullptr;
  }
  const mindspore::schema::v0::Neg *value_as_Neg() const {
    return value_type() == mindspore::schema::v0::PrimitiveType_Neg ? static_cast<const mindspore::schema::v0::Neg *>(value()) : nullptr;
  }
  const mindspore::schema::v0::Cos *value_as_Cos() const {
    return value_type() == mindspore::schema::v0::PrimitiveType_Cos ? static_cast<const mindspore::schema::v0::Cos *>(value()) : nullptr;
  }
  const mindspore::schema::v0::Sin *value_as_Sin() const {
    return value_type() == mindspore::schema::v0::PrimitiveType_Sin ? static_cast<const mindspore::schema::v0::Sin *>(value()) : nullptr;
  }
  const mindspore::schema::v0::Sqrt *value_as_Sqrt() const {
    return value_type() == mindspore::schema::v0::PrimitiveType_Sqrt ? static_cast<const mindspore::schema::v0::Sqrt *>(value()) : nullptr;
  }
  const mindspore::schema::v0::Square *value_as_Square() const {
    return value_type() == mindspore::schema::v0::PrimitiveType_Square ? static_cast<const mindspore::schema::v0::Square *>(value()) : nullptr;
  }
  const mindspore::schema::v0::Constant *value_as_Constant() const {
    return value_type() == mindspore::schema::v0::PrimitiveType_Constant ? static_cast<const mindspore::schema::v0::Constant *>(value()) : nullptr;
  }
  const mindspore::schema::v0::Log *value_as_Log() const {
    return value_type() == mindspore::schema::v0::PrimitiveType_Log ? static_cast<const mindspore::schema::v0::Log *>(value()) : nullptr;
  }
  const mindspore::schema::v0::Tan *value_as_Tan() const {
    return value_type() == mindspore::schema::v0::PrimitiveType_Tan ? static_cast<const mindspore::schema::v0::Tan *>(value()) : nullptr;
  }
  const mindspore::schema::v0::Atan *value_as_Atan() const {
    return value_type() == mindspore::schema::v0::PrimitiveType_Atan ? static_cast<const mindspore::schema::v0::Atan *>(value()) : nullptr;
  }
  const mindspore::schema::v0::Asin *value_as_Asin() const {
    return value_type() == mindspore::schema::v0::PrimitiveType_Asin ? static_cast<const mindspore::schema::v0::Asin *>(value()) : nullptr;
  }
  const mindspore::schema::v0::Clip *value_as_Clip() const {
    return value_type() == mindspore::schema::v0::PrimitiveType_Clip ? static_cast<const mindspore::schema::v0::Clip *>(value()) : nullptr;
  }
  const mindspore::schema::v0::Transpose *value_as_Transpose() const {
    return value_type() == mindspore::schema::v0::PrimitiveType_Transpose ? static_cast<const mindspore::schema::v0::Transpose *>(value()) : nullptr;
  }
  const mindspore::schema::v0::Squeeze *value_as_Squeeze() const {
    return value_type() == mindspore::schema::v0::PrimitiveType_Squeeze ? static_cast<const mindspore::schema::v0::Squeeze *>(value()) : nullptr;
  }
  const mindspore::schema::v0::Unsqueeze *value_as_Unsqueeze() const {
    return value_type() == mindspore::schema::v0::PrimitiveType_Unsqueeze ? static_cast<const mindspore::schema::v0::Unsqueeze *>(value()) : nullptr;
  }
  const mindspore::schema::v0::Upsample *value_as_Upsample() const {
    return value_type() == mindspore::schema::v0::PrimitiveType_Upsample ? static_cast<const mindspore::schema::v0::Upsample *>(value()) : nullptr;
  }
  const mindspore::schema::v0::Dropout *value_as_Dropout() const {
    return value_type() == mindspore::schema::v0::PrimitiveType_Dropout ? static_cast<const mindspore::schema::v0::Dropout *>(value()) : nullptr;
  }
  const mindspore::schema::v0::Broadcast *value_as_Broadcast() const {
    return value_type() == mindspore::schema::v0::PrimitiveType_Broadcast ? static_cast<const mindspore::schema::v0::Broadcast *>(value()) : nullptr;
  }
  const mindspore::schema::v0::BroadcastTo *value_as_BroadcastTo() const {
    return value_type() == mindspore::schema::v0::PrimitiveType_BroadcastTo ? static_cast<const mindspore::schema::v0::BroadcastTo *>(value()) : nullptr;
  }
  const mindspore::schema::v0::Lrn *value_as_Lrn() const {
    return value_type() == mindspore::schema::v0::PrimitiveType_Lrn ? static_cast<const mindspore::schema::v0::Lrn *>(value()) : nullptr;
  }
  const mindspore::schema::v0::ZerosLike *value_as_ZerosLike() const {
    return value_type() == mindspore::schema::v0::PrimitiveType_ZerosLike ? static_cast<const mindspore::schema::v0::ZerosLike *>(value()) : nullptr;
  }
  const mindspore::schema::v0::TopK *value_as_TopK() const {
    return value_type() == mindspore::schema::v0::PrimitiveType_TopK ? static_cast<const mindspore::schema::v0::TopK *>(value()) : nullptr;
  }
  const mindspore::schema::v0::SpaceToDepth *value_as_SpaceToDepth() const {
    return value_type() == mindspore::schema::v0::PrimitiveType_SpaceToDepth ? static_cast<const mindspore::schema::v0::SpaceToDepth *>(value()) : nullptr;
  }
  const mindspore::schema::v0::SpaceToBatch *value_as_SpaceToBatch() const {
    return value_type() == mindspore::schema::v0::PrimitiveType_SpaceToBatch ? static_cast<const mindspore::schema::v0::SpaceToBatch *>(value()) : nullptr;
  }
  const mindspore::schema::v0::SparseToDense *value_as_SparseToDense() const {
    return value_type() == mindspore::schema::v0::PrimitiveType_SparseToDense ? static_cast<const mindspore::schema::v0::SparseToDense *>(value()) : nullptr;
  }
  const mindspore::schema::v0::ReverseSequence *value_as_ReverseSequence() const {
    return value_type() == mindspore::schema::v0::PrimitiveType_ReverseSequence ? static_cast<const mindspore::schema::v0::ReverseSequence *>(value()) : nullptr;
  }
  const mindspore::schema::v0::Rank *value_as_Rank() const {
    return value_type() == mindspore::schema::v0::PrimitiveType_Rank ? static_cast<const mindspore::schema::v0::Rank *>(value()) : nullptr;
  }
  const mindspore::schema::v0::Gather *value_as_Gather() const {
    return value_type() == mindspore::schema::v0::PrimitiveType_Gather ? static_cast<const mindspore::schema::v0::Gather *>(value()) : nullptr;
  }
  const mindspore::schema::v0::GatherNd *value_as_GatherNd() const {
    return value_type() == mindspore::schema::v0::PrimitiveType_GatherNd ? static_cast<const mindspore::schema::v0::GatherNd *>(value()) : nullptr;
  }
  const mindspore::schema::v0::Fill *value_as_Fill() const {
    return value_type() == mindspore::schema::v0::PrimitiveType_Fill ? static_cast<const mindspore::schema::v0::Fill *>(value()) : nullptr;
  }
  const mindspore::schema::v0::Elu *value_as_Elu() const {
    return value_type() == mindspore::schema::v0::PrimitiveType_Elu ? static_cast<const mindspore::schema::v0::Elu *>(value()) : nullptr;
  }
  const mindspore::schema::v0::DepthToSpace *value_as_DepthToSpace() const {
    return value_type() == mindspore::schema::v0::PrimitiveType_DepthToSpace ? static_cast<const mindspore::schema::v0::DepthToSpace *>(value()) : nullptr;
  }
  const mindspore::schema::v0::BatchToSpace *value_as_BatchToSpace() const {
    return value_type() == mindspore::schema::v0::PrimitiveType_BatchToSpace ? static_cast<const mindspore::schema::v0::BatchToSpace *>(value()) : nullptr;
  }
  const mindspore::schema::v0::AddN *value_as_AddN() const {
    return value_type() == mindspore::schema::v0::PrimitiveType_AddN ? static_cast<const mindspore::schema::v0::AddN *>(value()) : nullptr;
  }
  const mindspore::schema::v0::Ceil *value_as_Ceil() const {
    return value_type() == mindspore::schema::v0::PrimitiveType_Ceil ? static_cast<const mindspore::schema::v0::Ceil *>(value()) : nullptr;
  }
  const mindspore::schema::v0::EmbeddingLookup *value_as_EmbeddingLookup() const {
    return value_type() == mindspore::schema::v0::PrimitiveType_EmbeddingLookup ? static_cast<const mindspore::schema::v0::EmbeddingLookup *>(value()) : nullptr;
  }
  const mindspore::schema::v0::EmbeddingLookupSparse *value_as_EmbeddingLookupSparse() const {
    return value_type() == mindspore::schema::v0::PrimitiveType_EmbeddingLookupSparse ? static_cast<const mindspore::schema::v0::EmbeddingLookupSparse *>(value()) : nullptr;
  }
  const mindspore::schema::v0::FloorDiv *value_as_FloorDiv() const {
    return value_type() == mindspore::schema::v0::PrimitiveType_FloorDiv ? static_cast<const mindspore::schema::v0::FloorDiv *>(value()) : nullptr;
  }
  const mindspore::schema::v0::FloorMod *value_as_FloorMod() const {
    return value_type() == mindspore::schema::v0::PrimitiveType_FloorMod ? static_cast<const mindspore::schema::v0::FloorMod *>(value()) : nullptr;
  }
  const mindspore::schema::v0::L2Norm *value_as_L2Norm() const {
    return value_type() == mindspore::schema::v0::PrimitiveType_L2Norm ? static_cast<const mindspore::schema::v0::L2Norm *>(value()) : nullptr;
  }
  const mindspore::schema::v0::LocalResponseNormalization *value_as_LocalResponseNormalization() const {
    return value_type() == mindspore::schema::v0::PrimitiveType_LocalResponseNormalization ? static_cast<const mindspore::schema::v0::LocalResponseNormalization *>(value()) : nullptr;
  }
  const mindspore::schema::v0::MatrixDiag *value_as_MatrixDiag() const {
    return value_type() == mindspore::schema::v0::PrimitiveType_MatrixDiag ? static_cast<const mindspore::schema::v0::MatrixDiag *>(value()) : nullptr;
  }
  const mindspore::schema::v0::Reduce *value_as_Reduce() const {
    return value_type() == mindspore::schema::v0::PrimitiveType_Reduce ? static_cast<const mindspore::schema::v0::Reduce *>(value()) : nullptr;
  }
  const mindspore::schema::v0::Reverse *value_as_Reverse() const {
    return value_type() == mindspore::schema::v0::PrimitiveType_Reverse ? static_cast<const mindspore::schema::v0::Reverse *>(value()) : nullptr;
  }
  const mindspore::schema::v0::Round *value_as_Round() const {
    return value_type() == mindspore::schema::v0::PrimitiveType_Round ? static_cast<const mindspore::schema::v0::Round *>(value()) : nullptr;
  }
  const mindspore::schema::v0::Select *value_as_Select() const {
    return value_type() == mindspore::schema::v0::PrimitiveType_Select ? static_cast<const mindspore::schema::v0::Select *>(value()) : nullptr;
  }
  const mindspore::schema::v0::Scatter *value_as_Scatter() const {
    return value_type() == mindspore::schema::v0::PrimitiveType_Scatter ? static_cast<const mindspore::schema::v0::Scatter *>(value()) : nullptr;
  }
  const mindspore::schema::v0::ScatterND *value_as_ScatterND() const {
    return value_type() == mindspore::schema::v0::PrimitiveType_ScatterND ? static_cast<const mindspore::schema::v0::ScatterND *>(value()) : nullptr;
  }
  const mindspore::schema::v0::ConstantOfShape *value_as_ConstantOfShape() const {
    return value_type() == mindspore::schema::v0::PrimitiveType_ConstantOfShape ? static_cast<const mindspore::schema::v0::ConstantOfShape *>(value()) : nullptr;
  }
  const mindspore::schema::v0::Unique *value_as_Unique() const {
    return value_type() == mindspore::schema::v0::PrimitiveType_Unique ? static_cast<const mindspore::schema::v0::Unique *>(value()) : nullptr;
  }
  const mindspore::schema::v0::Unstack *value_as_Unstack() const {
    return value_type() == mindspore::schema::v0::PrimitiveType_Unstack ? static_cast<const mindspore::schema::v0::Unstack *>(value()) : nullptr;
  }
  const mindspore::schema::v0::LogicalAnd *value_as_LogicalAnd() const {
    return value_type() == mindspore::schema::v0::PrimitiveType_LogicalAnd ? static_cast<const mindspore::schema::v0::LogicalAnd *>(value()) : nullptr;
  }
  const mindspore::schema::v0::LogicalOr *value_as_LogicalOr() const {
    return value_type() == mindspore::schema::v0::PrimitiveType_LogicalOr ? static_cast<const mindspore::schema::v0::LogicalOr *>(value()) : nullptr;
  }
  const mindspore::schema::v0::LogicalXor *value_as_LogicalXor() const {
    return value_type() == mindspore::schema::v0::PrimitiveType_LogicalXor ? static_cast<const mindspore::schema::v0::LogicalXor *>(value()) : nullptr;
  }
  const mindspore::schema::v0::LogicalNot *value_as_LogicalNot() const {
    return value_type() == mindspore::schema::v0::PrimitiveType_LogicalNot ? static_cast<const mindspore::schema::v0::LogicalNot *>(value()) : nullptr;
  }
  const mindspore::schema::v0::OnnxInt8Quantize *value_as_OnnxInt8Quantize() const {
    return value_type() == mindspore::schema::v0::PrimitiveType_OnnxInt8Quantize ? static_cast<const mindspore::schema::v0::OnnxInt8Quantize *>(value()) : nullptr;
  }
  const mindspore::schema::v0::OnnxInt8Dequantize *value_as_OnnxInt8Dequantize() const {
    return value_type() == mindspore::schema::v0::PrimitiveType_OnnxInt8Dequantize ? static_cast<const mindspore::schema::v0::OnnxInt8Dequantize *>(value()) : nullptr;
  }
  const mindspore::schema::v0::FakeQuantWithMinMax *value_as_FakeQuantWithMinMax() const {
    return value_type() == mindspore::schema::v0::PrimitiveType_FakeQuantWithMinMax ? static_cast<const mindspore::schema::v0::FakeQuantWithMinMax *>(value()) : nullptr;
  }
  const mindspore::schema::v0::FakeQuantWithMinMaxPerChannel *value_as_FakeQuantWithMinMaxPerChannel() const {
    return value_type() == mindspore::schema::v0::PrimitiveType_FakeQuantWithMinMaxPerChannel ? static_cast<const mindspore::schema::v0::FakeQuantWithMinMaxPerChannel *>(value()) : nullptr;
  }
  const mindspore::schema::v0::BatchNormFold *value_as_BatchNormFold() const {
    return value_type() == mindspore::schema::v0::PrimitiveType_BatchNormFold ? static_cast<const mindspore::schema::v0::BatchNormFold *>(value()) : nullptr;
  }
  const mindspore::schema::v0::MulFold *value_as_MulFold() const {
    return value_type() == mindspore::schema::v0::PrimitiveType_MulFold ? static_cast<const mindspore::schema::v0::MulFold *>(value()) : nullptr;
  }
  const mindspore::schema::v0::AddFold *value_as_AddFold() const {
    return value_type() == mindspore::schema::v0::PrimitiveType_AddFold ? static_cast<const mindspore::schema::v0::AddFold *>(value()) : nullptr;
  }
  const mindspore::schema::v0::SquaredDifference *value_as_SquaredDifference() const {
    return value_type() == mindspore::schema::v0::PrimitiveType_SquaredDifference ? static_cast<const mindspore::schema::v0::SquaredDifference *>(value()) : nullptr;
  }
  const mindspore::schema::v0::Flatten *value_as_Flatten() const {
    return value_type() == mindspore::schema::v0::PrimitiveType_Flatten ? static_cast<const mindspore::schema::v0::Flatten *>(value()) : nullptr;
  }
  const mindspore::schema::v0::FlattenGrad *value_as_FlattenGrad() const {
    return value_type() == mindspore::schema::v0::PrimitiveType_FlattenGrad ? static_cast<const mindspore::schema::v0::FlattenGrad *>(value()) : nullptr;
  }
  const mindspore::schema::v0::TupleGetItem *value_as_TupleGetItem() const {
    return value_type() == mindspore::schema::v0::PrimitiveType_TupleGetItem ? static_cast<const mindspore::schema::v0::TupleGetItem *>(value()) : nullptr;
  }
  const mindspore::schema::v0::Div *value_as_Div() const {
    return value_type() == mindspore::schema::v0::PrimitiveType_Div ? static_cast<const mindspore::schema::v0::Div *>(value()) : nullptr;
  }
  const mindspore::schema::v0::Where *value_as_Where() const {
    return value_type() == mindspore::schema::v0::PrimitiveType_Where ? static_cast<const mindspore::schema::v0::Where *>(value()) : nullptr;
  }
  const mindspore::schema::v0::OneHot *value_as_OneHot() const {
    return value_type() == mindspore::schema::v0::PrimitiveType_OneHot ? static_cast<const mindspore::schema::v0::OneHot *>(value()) : nullptr;
  }
  const mindspore::schema::v0::Lstm *value_as_Lstm() const {
    return value_type() == mindspore::schema::v0::PrimitiveType_Lstm ? static_cast<const mindspore::schema::v0::Lstm *>(value()) : nullptr;
  }
  const mindspore::schema::v0::Conv2DGradFilter *value_as_Conv2DGradFilter() const {
    return value_type() == mindspore::schema::v0::PrimitiveType_Conv2DGradFilter ? static_cast<const mindspore::schema::v0::Conv2DGradFilter *>(value()) : nullptr;
  }
  const mindspore::schema::v0::Conv2DGradInput *value_as_Conv2DGradInput() const {
    return value_type() == mindspore::schema::v0::PrimitiveType_Conv2DGradInput ? static_cast<const mindspore::schema::v0::Conv2DGradInput *>(value()) : nullptr;
  }
  const mindspore::schema::v0::PoolingGrad *value_as_PoolingGrad() const {
    return value_type() == mindspore::schema::v0::PrimitiveType_PoolingGrad ? static_cast<const mindspore::schema::v0::PoolingGrad *>(value()) : nullptr;
  }
  const mindspore::schema::v0::BNGrad *value_as_BNGrad() const {
    return value_type() == mindspore::schema::v0::PrimitiveType_BNGrad ? static_cast<const mindspore::schema::v0::BNGrad *>(value()) : nullptr;
  }
  const mindspore::schema::v0::Assign *value_as_Assign() const {
    return value_type() == mindspore::schema::v0::PrimitiveType_Assign ? static_cast<const mindspore::schema::v0::Assign *>(value()) : nullptr;
  }
  const mindspore::schema::v0::ApplyMomentum *value_as_ApplyMomentum() const {
    return value_type() == mindspore::schema::v0::PrimitiveType_ApplyMomentum ? static_cast<const mindspore::schema::v0::ApplyMomentum *>(value()) : nullptr;
  }
  const mindspore::schema::v0::BiasGrad *value_as_BiasGrad() const {
    return value_type() == mindspore::schema::v0::PrimitiveType_BiasGrad ? static_cast<const mindspore::schema::v0::BiasGrad *>(value()) : nullptr;
  }
  const mindspore::schema::v0::SoftmaxCrossEntropy *value_as_SoftmaxCrossEntropy() const {
    return value_type() == mindspore::schema::v0::PrimitiveType_SoftmaxCrossEntropy ? static_cast<const mindspore::schema::v0::SoftmaxCrossEntropy *>(value()) : nullptr;
  }
  const mindspore::schema::v0::AddGrad *value_as_AddGrad() const {
    return value_type() == mindspore::schema::v0::PrimitiveType_AddGrad ? static_cast<const mindspore::schema::v0::AddGrad *>(value()) : nullptr;
  }
  const mindspore::schema::v0::SubGrad *value_as_SubGrad() const {
    return value_type() == mindspore::schema::v0::PrimitiveType_SubGrad ? static_cast<const mindspore::schema::v0::SubGrad *>(value()) : nullptr;
  }
  const mindspore::schema::v0::MulGrad *value_as_MulGrad() const {
    return value_type() == mindspore::schema::v0::PrimitiveType_MulGrad ? static_cast<const mindspore::schema::v0::MulGrad *>(value()) : nullptr;
  }
  const mindspore::schema::v0::DivGrad *value_as_DivGrad() const {
    return value_type() == mindspore::schema::v0::PrimitiveType_DivGrad ? static_cast<const mindspore::schema::v0::DivGrad *>(value()) : nullptr;
  }
  const mindspore::schema::v0::PowerGrad *value_as_PowerGrad() const {
    return value_type() == mindspore::schema::v0::PrimitiveType_PowerGrad ? static_cast<const mindspore::schema::v0::PowerGrad *>(value()) : nullptr;
  }
  const mindspore::schema::v0::ActivationGrad *value_as_ActivationGrad() const {
    return value_type() == mindspore::schema::v0::PrimitiveType_ActivationGrad ? static_cast<const mindspore::schema::v0::ActivationGrad *>(value()) : nullptr;
  }
  const mindspore::schema::v0::PriorBox *value_as_PriorBox() const {
    return value_type() == mindspore::schema::v0::PrimitiveType_PriorBox ? static_cast<const mindspore::schema::v0::PriorBox *>(value()) : nullptr;
  }
  const mindspore::schema::v0::SpaceToBatchND *value_as_SpaceToBatchND() const {
    return value_type() == mindspore::schema::v0::PrimitiveType_SpaceToBatchND ? static_cast<const mindspore::schema::v0::SpaceToBatchND *>(value()) : nullptr;
  }
  const mindspore::schema::v0::Depend *value_as_Depend() const {
    return value_type() == mindspore::schema::v0::PrimitiveType_Depend ? static_cast<const mindspore::schema::v0::Depend *>(value()) : nullptr;
  }
  const mindspore::schema::v0::Return *value_as_Return() const {
    return value_type() == mindspore::schema::v0::PrimitiveType_Return ? static_cast<const mindspore::schema::v0::Return *>(value()) : nullptr;
  }
  const mindspore::schema::v0::MakeTuple *value_as_MakeTuple() const {
    return value_type() == mindspore::schema::v0::PrimitiveType_MakeTuple ? static_cast<const mindspore::schema::v0::MakeTuple *>(value()) : nullptr;
  }
  const mindspore::schema::v0::ToFormat *value_as_ToFormat() const {
    return value_type() == mindspore::schema::v0::PrimitiveType_ToFormat ? static_cast<const mindspore::schema::v0::ToFormat *>(value()) : nullptr;
  }
  const mindspore::schema::v0::Proposal *value_as_Proposal() const {
    return value_type() == mindspore::schema::v0::PrimitiveType_Proposal ? static_cast<const mindspore::schema::v0::Proposal *>(value()) : nullptr;
  }
  const mindspore::schema::v0::Custom *value_as_Custom() const {
    return value_type() == mindspore::schema::v0::PrimitiveType_Custom ? static_cast<const mindspore::schema::v0::Custom *>(value()) : nullptr;
  }
  const mindspore::schema::v0::BlackBox *value_as_BlackBox() const {
    return value_type() == mindspore::schema::v0::PrimitiveType_BlackBox ? static_cast<const mindspore::schema::v0::BlackBox *>(value()) : nullptr;
  }
  const mindspore::schema::v0::NegGrad *value_as_NegGrad() const {
    return value_type() == mindspore::schema::v0::PrimitiveType_NegGrad ? static_cast<const mindspore::schema::v0::NegGrad *>(value()) : nullptr;
  }
  const mindspore::schema::v0::LogGrad *value_as_LogGrad() const {
    return value_type() == mindspore::schema::v0::PrimitiveType_LogGrad ? static_cast<const mindspore::schema::v0::LogGrad *>(value()) : nullptr;
  }
  const mindspore::schema::v0::BatchToSpaceND *value_as_BatchToSpaceND() const {
    return value_type() == mindspore::schema::v0::PrimitiveType_BatchToSpaceND ? static_cast<const mindspore::schema::v0::BatchToSpaceND *>(value()) : nullptr;
  }
  const mindspore::schema::v0::LshProjection *value_as_LshProjection() const {
    return value_type() == mindspore::schema::v0::PrimitiveType_LshProjection ? static_cast<const mindspore::schema::v0::LshProjection *>(value()) : nullptr;
  }
  const mindspore::schema::v0::HashtableLookup *value_as_HashtableLookup() const {
    return value_type() == mindspore::schema::v0::PrimitiveType_HashtableLookup ? static_cast<const mindspore::schema::v0::HashtableLookup *>(value()) : nullptr;
  }
  const mindspore::schema::v0::SkipGram *value_as_SkipGram() const {
    return value_type() == mindspore::schema::v0::PrimitiveType_SkipGram ? static_cast<const mindspore::schema::v0::SkipGram *>(value()) : nullptr;
  }
  const mindspore::schema::v0::DeConv2DGradFilter *value_as_DeConv2DGradFilter() const {
    return value_type() == mindspore::schema::v0::PrimitiveType_DeConv2DGradFilter ? static_cast<const mindspore::schema::v0::DeConv2DGradFilter *>(value()) : nullptr;
  }
  const mindspore::schema::v0::CustomPredict *value_as_CustomPredict() const {
    return value_type() == mindspore::schema::v0::PrimitiveType_CustomPredict ? static_cast<const mindspore::schema::v0::CustomPredict *>(value()) : nullptr;
  }
  const mindspore::schema::v0::CustomNormalize *value_as_CustomNormalize() const {
    return value_type() == mindspore::schema::v0::PrimitiveType_CustomNormalize ? static_cast<const mindspore::schema::v0::CustomNormalize *>(value()) : nullptr;
  }
  const mindspore::schema::v0::CustomExtractFeatures *value_as_CustomExtractFeatures() const {
    return value_type() == mindspore::schema::v0::PrimitiveType_CustomExtractFeatures ? static_cast<const mindspore::schema::v0::CustomExtractFeatures *>(value()) : nullptr;
  }
  const mindspore::schema::v0::AudioSpectrogram *value_as_AudioSpectrogram() const {
    return value_type() == mindspore::schema::v0::PrimitiveType_AudioSpectrogram ? static_cast<const mindspore::schema::v0::AudioSpectrogram *>(value()) : nullptr;
  }
  const mindspore::schema::v0::Mfcc *value_as_Mfcc() const {
    return value_type() == mindspore::schema::v0::PrimitiveType_Mfcc ? static_cast<const mindspore::schema::v0::Mfcc *>(value()) : nullptr;
  }
  const mindspore::schema::v0::Rfft *value_as_Rfft() const {
    return value_type() == mindspore::schema::v0::PrimitiveType_Rfft ? static_cast<const mindspore::schema::v0::Rfft *>(value()) : nullptr;
  }
  const mindspore::schema::v0::FftReal *value_as_FftReal() const {
    return value_type() == mindspore::schema::v0::PrimitiveType_FftReal ? static_cast<const mindspore::schema::v0::FftReal *>(value()) : nullptr;
  }
  const mindspore::schema::v0::FftImag *value_as_FftImag() const {
    return value_type() == mindspore::schema::v0::PrimitiveType_FftImag ? static_cast<const mindspore::schema::v0::FftImag *>(value()) : nullptr;
  }
  const mindspore::schema::v0::Sgd *value_as_Sgd() const {
    return value_type() == mindspore::schema::v0::PrimitiveType_Sgd ? static_cast<const mindspore::schema::v0::Sgd *>(value()) : nullptr;
  }
  const mindspore::schema::v0::Adam *value_as_Adam() const {
    return value_type() == mindspore::schema::v0::PrimitiveType_Adam ? static_cast<const mindspore::schema::v0::Adam *>(value()) : nullptr;
  }
  const mindspore::schema::v0::GroupConv2DGradInput *value_as_GroupConv2DGradInput() const {
    return value_type() == mindspore::schema::v0::PrimitiveType_GroupConv2DGradInput ? static_cast<const mindspore::schema::v0::GroupConv2DGradInput *>(value()) : nullptr;
  }
  const mindspore::schema::v0::Loop *value_as_Loop() const {
    return value_type() == mindspore::schema::v0::PrimitiveType_Loop ? static_cast<const mindspore::schema::v0::Loop *>(value()) : nullptr;
  }
  const mindspore::schema::v0::NonMaxSuppression *value_as_NonMaxSuppression() const {
    return value_type() == mindspore::schema::v0::PrimitiveType_NonMaxSuppression ? static_cast<const mindspore::schema::v0::NonMaxSuppression *>(value()) : nullptr;
  }
  const mindspore::schema::v0::InstanceNorm *value_as_InstanceNorm() const {
    return value_type() == mindspore::schema::v0::PrimitiveType_InstanceNorm ? static_cast<const mindspore::schema::v0::InstanceNorm *>(value()) : nullptr;
  }
  const mindspore::schema::v0::Identity *value_as_Identity() const {
    return value_type() == mindspore::schema::v0::PrimitiveType_Identity ? static_cast<const mindspore::schema::v0::Identity *>(value()) : nullptr;
  }
  const mindspore::schema::v0::LayerNorm *value_as_LayerNorm() const {
    return value_type() == mindspore::schema::v0::PrimitiveType_LayerNorm ? static_cast<const mindspore::schema::v0::LayerNorm *>(value()) : nullptr;
  }
  const mindspore::schema::v0::While *value_as_While() const {
    return value_type() == mindspore::schema::v0::PrimitiveType_While ? static_cast<const mindspore::schema::v0::While *>(value()) : nullptr;
  }
  const mindspore::schema::v0::ControlDepend *value_as_ControlDepend() const {
    return value_type() == mindspore::schema::v0::PrimitiveType_ControlDepend ? static_cast<const mindspore::schema::v0::ControlDepend *>(value()) : nullptr;
  }
  const mindspore::schema::v0::UnsortedSegmentSum *value_as_UnsortedSegmentSum() const {
    return value_type() == mindspore::schema::v0::PrimitiveType_UnsortedSegmentSum ? static_cast<const mindspore::schema::v0::UnsortedSegmentSum *>(value()) : nullptr;
  }
  const mindspore::schema::v0::AssignAdd *value_as_AssignAdd() const {
    return value_type() == mindspore::schema::v0::PrimitiveType_AssignAdd ? static_cast<const mindspore::schema::v0::AssignAdd *>(value()) : nullptr;
  }
  const mindspore::schema::v0::OnesLike *value_as_OnesLike() const {
    return value_type() == mindspore::schema::v0::PrimitiveType_OnesLike ? static_cast<const mindspore::schema::v0::OnesLike *>(value()) : nullptr;
  }
  const mindspore::schema::v0::BinaryCrossEntropyGrad *value_as_BinaryCrossEntropyGrad() const {
    return value_type() == mindspore::schema::v0::PrimitiveType_BinaryCrossEntropyGrad ? static_cast<const mindspore::schema::v0::BinaryCrossEntropyGrad *>(value()) : nullptr;
  }
  const mindspore::schema::v0::BinaryCrossEntropy *value_as_BinaryCrossEntropy() const {
    return value_type() == mindspore::schema::v0::PrimitiveType_BinaryCrossEntropy ? static_cast<const mindspore::schema::v0::BinaryCrossEntropy *>(value()) : nullptr;
  }
  const mindspore::schema::v0::LpNormalization *value_as_LpNormalization() const {
    return value_type() == mindspore::schema::v0::PrimitiveType_LpNormalization ? static_cast<const mindspore::schema::v0::LpNormalization *>(value()) : nullptr;
  }
  const mindspore::schema::v0::DropoutGrad *value_as_DropoutGrad() const {
    return value_type() == mindspore::schema::v0::PrimitiveType_DropoutGrad ? static_cast<const mindspore::schema::v0::DropoutGrad *>(value()) : nullptr;
  }
  const mindspore::schema::v0::MaximumGrad *value_as_MaximumGrad() const {
    return value_type() == mindspore::schema::v0::PrimitiveType_MaximumGrad ? static_cast<const mindspore::schema::v0::MaximumGrad *>(value()) : nullptr;
  }
  const mindspore::schema::v0::MinimumGrad *value_as_MinimumGrad() const {
    return value_type() == mindspore::schema::v0::PrimitiveType_MinimumGrad ? static_cast<const mindspore::schema::v0::MinimumGrad *>(value()) : nullptr;
  }
  const mindspore::schema::v0::Switch *value_as_Switch() const {
    return value_type() == mindspore::schema::v0::PrimitiveType_Switch ? static_cast<const mindspore::schema::v0::Switch *>(value()) : nullptr;
  }
  const mindspore::schema::v0::Partial *value_as_Partial() const {
    return value_type() == mindspore::schema::v0::PrimitiveType_Partial ? static_cast<const mindspore::schema::v0::Partial *>(value()) : nullptr;
  }
  const mindspore::schema::v0::TensorListFromTensor *value_as_TensorListFromTensor() const {
    return value_type() == mindspore::schema::v0::PrimitiveType_TensorListFromTensor ? static_cast<const mindspore::schema::v0::TensorListFromTensor *>(value()) : nullptr;
  }
  const mindspore::schema::v0::TensorListStack *value_as_TensorListStack() const {
    return value_type() == mindspore::schema::v0::PrimitiveType_TensorListStack ? static_cast<const mindspore::schema::v0::TensorListStack *>(value()) : nullptr;
  }
  const mindspore::schema::v0::TensorListGetItem *value_as_TensorListGetItem() const {
    return value_type() == mindspore::schema::v0::PrimitiveType_TensorListGetItem ? static_cast<const mindspore::schema::v0::TensorListGetItem *>(value()) : nullptr;
  }
  const mindspore::schema::v0::TensorListSetItem *value_as_TensorListSetItem() const {
    return value_type() == mindspore::schema::v0::PrimitiveType_TensorListSetItem ? static_cast<const mindspore::schema::v0::TensorListSetItem *>(value()) : nullptr;
  }
  const mindspore::schema::v0::TensorListReserve *value_as_TensorListReserve() const {
    return value_type() == mindspore::schema::v0::PrimitiveType_TensorListReserve ? static_cast<const mindspore::schema::v0::TensorListReserve *>(value()) : nullptr;
  }
  const mindspore::schema::v0::All *value_as_All() const {
    return value_type() == mindspore::schema::v0::PrimitiveType_All ? static_cast<const mindspore::schema::v0::All *>(value()) : nullptr;
  }
  const mindspore::schema::v0::Assert *value_as_Assert() const {
    return value_type() == mindspore::schema::v0::PrimitiveType_Assert ? static_cast<const mindspore::schema::v0::Assert *>(value()) : nullptr;
  }
  const mindspore::schema::v0::Adder *value_as_Adder() const {
    return value_type() == mindspore::schema::v0::PrimitiveType_Adder ? static_cast<const mindspore::schema::v0::Adder *>(value()) : nullptr;
  }
  const mindspore::schema::v0::SparseSoftmaxCrossEntropy *value_as_SparseSoftmaxCrossEntropy() const {
    return value_type() == mindspore::schema::v0::PrimitiveType_SparseSoftmaxCrossEntropy ? static_cast<const mindspore::schema::v0::SparseSoftmaxCrossEntropy *>(value()) : nullptr;
  }
  const mindspore::schema::v0::SmoothL1Loss *value_as_SmoothL1Loss() const {
    return value_type() == mindspore::schema::v0::PrimitiveType_SmoothL1Loss ? static_cast<const mindspore::schema::v0::SmoothL1Loss *>(value()) : nullptr;
  }
  const mindspore::schema::v0::SmoothL1LossGrad *value_as_SmoothL1LossGrad() const {
    return value_type() == mindspore::schema::v0::PrimitiveType_SmoothL1LossGrad ? static_cast<const mindspore::schema::v0::SmoothL1LossGrad *>(value()) : nullptr;
  }
  const mindspore::schema::v0::SigmoidCrossEntropyWithLogits *value_as_SigmoidCrossEntropyWithLogits() const {
    return value_type() == mindspore::schema::v0::PrimitiveType_SigmoidCrossEntropyWithLogits ? static_cast<const mindspore::schema::v0::SigmoidCrossEntropyWithLogits *>(value()) : nullptr;
  }
  const mindspore::schema::v0::SigmoidCrossEntropyWithLogitsGrad *value_as_SigmoidCrossEntropyWithLogitsGrad() const {
    return value_type() == mindspore::schema::v0::PrimitiveType_SigmoidCrossEntropyWithLogitsGrad ? static_cast<const mindspore::schema::v0::SigmoidCrossEntropyWithLogitsGrad *>(value()) : nullptr;
  }
  const mindspore::schema::v0::Reciprocal *value_as_Reciprocal() const {
    return value_type() == mindspore::schema::v0::PrimitiveType_Reciprocal ? static_cast<const mindspore::schema::v0::Reciprocal *>(value()) : nullptr;
  }
  const mindspore::schema::v0::Merge *value_as_Merge() const {
    return value_type() == mindspore::schema::v0::PrimitiveType_Merge ? static_cast<const mindspore::schema::v0::Merge *>(value()) : nullptr;
  }
  const mindspore::schema::v0::Mod *value_as_Mod() const {
    return value_type() == mindspore::schema::v0::PrimitiveType_Mod ? static_cast<const mindspore::schema::v0::Mod *>(value()) : nullptr;
  }
  const mindspore::schema::v0::GeLU *value_as_GeLU() const {
    return value_type() == mindspore::schema::v0::PrimitiveType_GeLU ? static_cast<const mindspore::schema::v0::GeLU *>(value()) : nullptr;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_VALUE_TYPE) &&
           VerifyOffset(verifier, VT_VALUE) &&
           VerifyPrimitiveType(verifier, value(), value_type()) &&
           verifier.EndTable();
  }
};

template<> inline const mindspore::schema::v0::Concat *Primitive::value_as<mindspore::schema::v0::Concat>() const {
  return value_as_Concat();
}

template<> inline const mindspore::schema::v0::SoftMax *Primitive::value_as<mindspore::schema::v0::SoftMax>() const {
  return value_as_SoftMax();
}

template<> inline const mindspore::schema::v0::Activation *Primitive::value_as<mindspore::schema::v0::Activation>() const {
  return value_as_Activation();
}

template<> inline const mindspore::schema::v0::Conv2D *Primitive::value_as<mindspore::schema::v0::Conv2D>() const {
  return value_as_Conv2D();
}

template<> inline const mindspore::schema::v0::FusedBatchNorm *Primitive::value_as<mindspore::schema::v0::FusedBatchNorm>() const {
  return value_as_FusedBatchNorm();
}

template<> inline const mindspore::schema::v0::BatchNorm *Primitive::value_as<mindspore::schema::v0::BatchNorm>() const {
  return value_as_BatchNorm();
}

template<> inline const mindspore::schema::v0::BiasAdd *Primitive::value_as<mindspore::schema::v0::BiasAdd>() const {
  return value_as_BiasAdd();
}

template<> inline const mindspore::schema::v0::Pooling *Primitive::value_as<mindspore::schema::v0::Pooling>() const {
  return value_as_Pooling();
}

template<> inline const mindspore::schema::v0::ROIPooling *Primitive::value_as<mindspore::schema::v0::ROIPooling>() const {
  return value_as_ROIPooling();
}

template<> inline const mindspore::schema::v0::DepthwiseConv2D *Primitive::value_as<mindspore::schema::v0::DepthwiseConv2D>() const {
  return value_as_DepthwiseConv2D();
}

template<> inline const mindspore::schema::v0::DeDepthwiseConv2D *Primitive::value_as<mindspore::schema::v0::DeDepthwiseConv2D>() const {
  return value_as_DeDepthwiseConv2D();
}

template<> inline const mindspore::schema::v0::Resize *Primitive::value_as<mindspore::schema::v0::Resize>() const {
  return value_as_Resize();
}

template<> inline const mindspore::schema::v0::DetectionPostProcess *Primitive::value_as<mindspore::schema::v0::DetectionPostProcess>() const {
  return value_as_DetectionPostProcess();
}

template<> inline const mindspore::schema::v0::FullConnection *Primitive::value_as<mindspore::schema::v0::FullConnection>() const {
  return value_as_FullConnection();
}

template<> inline const mindspore::schema::v0::Mean *Primitive::value_as<mindspore::schema::v0::Mean>() const {
  return value_as_Mean();
}

template<> inline const mindspore::schema::v0::DeConv2D *Primitive::value_as<mindspore::schema::v0::DeConv2D>() const {
  return value_as_DeConv2D();
}

template<> inline const mindspore::schema::v0::Scale *Primitive::value_as<mindspore::schema::v0::Scale>() const {
  return value_as_Scale();
}

template<> inline const mindspore::schema::v0::Reshape *Primitive::value_as<mindspore::schema::v0::Reshape>() const {
  return value_as_Reshape();
}

template<> inline const mindspore::schema::v0::Eltwise *Primitive::value_as<mindspore::schema::v0::Eltwise>() const {
  return value_as_Eltwise();
}

template<> inline const mindspore::schema::v0::NetOutput *Primitive::value_as<mindspore::schema::v0::NetOutput>() const {
  return value_as_NetOutput();
}

template<> inline const mindspore::schema::v0::Add *Primitive::value_as<mindspore::schema::v0::Add>() const {
  return value_as_Add();
}

template<> inline const mindspore::schema::v0::Sub *Primitive::value_as<mindspore::schema::v0::Sub>() const {
  return value_as_Sub();
}

template<> inline const mindspore::schema::v0::MatMul *Primitive::value_as<mindspore::schema::v0::MatMul>() const {
  return value_as_MatMul();
}

template<> inline const mindspore::schema::v0::StridedSlice *Primitive::value_as<mindspore::schema::v0::StridedSlice>() const {
  return value_as_StridedSlice();
}

template<> inline const mindspore::schema::v0::Power *Primitive::value_as<mindspore::schema::v0::Power>() const {
  return value_as_Power();
}

template<> inline const mindspore::schema::v0::Slice *Primitive::value_as<mindspore::schema::v0::Slice>() const {
  return value_as_Slice();
}

template<> inline const mindspore::schema::v0::Stack *Primitive::value_as<mindspore::schema::v0::Stack>() const {
  return value_as_Stack();
}

template<> inline const mindspore::schema::v0::Mul *Primitive::value_as<mindspore::schema::v0::Mul>() const {
  return value_as_Mul();
}

template<> inline const mindspore::schema::v0::RealDiv *Primitive::value_as<mindspore::schema::v0::RealDiv>() const {
  return value_as_RealDiv();
}

template<> inline const mindspore::schema::v0::Pad *Primitive::value_as<mindspore::schema::v0::Pad>() const {
  return value_as_Pad();
}

template<> inline const mindspore::schema::v0::Maximum *Primitive::value_as<mindspore::schema::v0::Maximum>() const {
  return value_as_Maximum();
}

template<> inline const mindspore::schema::v0::Minimum *Primitive::value_as<mindspore::schema::v0::Minimum>() const {
  return value_as_Minimum();
}

template<> inline const mindspore::schema::v0::PReLU *Primitive::value_as<mindspore::schema::v0::PReLU>() const {
  return value_as_PReLU();
}

template<> inline const mindspore::schema::v0::LeakyReLU *Primitive::value_as<mindspore::schema::v0::LeakyReLU>() const {
  return value_as_LeakyReLU();
}

template<> inline const mindspore::schema::v0::ArgMax *Primitive::value_as<mindspore::schema::v0::ArgMax>() const {
  return value_as_ArgMax();
}

template<> inline const mindspore::schema::v0::ArgMin *Primitive::value_as<mindspore::schema::v0::ArgMin>() const {
  return value_as_ArgMin();
}

template<> inline const mindspore::schema::v0::Exp *Primitive::value_as<mindspore::schema::v0::Exp>() const {
  return value_as_Exp();
}

template<> inline const mindspore::schema::v0::Crop *Primitive::value_as<mindspore::schema::v0::Crop>() const {
  return value_as_Crop();
}

template<> inline const mindspore::schema::v0::Range *Primitive::value_as<mindspore::schema::v0::Range>() const {
  return value_as_Range();
}

template<> inline const mindspore::schema::v0::Rsqrt *Primitive::value_as<mindspore::schema::v0::Rsqrt>() const {
  return value_as_Rsqrt();
}

template<> inline const mindspore::schema::v0::ExpandDims *Primitive::value_as<mindspore::schema::v0::ExpandDims>() const {
  return value_as_ExpandDims();
}

template<> inline const mindspore::schema::v0::Tile *Primitive::value_as<mindspore::schema::v0::Tile>() const {
  return value_as_Tile();
}

template<> inline const mindspore::schema::v0::Cast *Primitive::value_as<mindspore::schema::v0::Cast>() const {
  return value_as_Cast();
}

template<> inline const mindspore::schema::v0::Shape *Primitive::value_as<mindspore::schema::v0::Shape>() const {
  return value_as_Shape();
}

template<> inline const mindspore::schema::v0::Nchw2Nhwc *Primitive::value_as<mindspore::schema::v0::Nchw2Nhwc>() const {
  return value_as_Nchw2Nhwc();
}

template<> inline const mindspore::schema::v0::Nhwc2Nchw *Primitive::value_as<mindspore::schema::v0::Nhwc2Nchw>() const {
  return value_as_Nhwc2Nchw();
}

template<> inline const mindspore::schema::v0::QuantDTypeCast *Primitive::value_as<mindspore::schema::v0::QuantDTypeCast>() const {
  return value_as_QuantDTypeCast();
}

template<> inline const mindspore::schema::v0::Split *Primitive::value_as<mindspore::schema::v0::Split>() const {
  return value_as_Split();
}

template<> inline const mindspore::schema::v0::Permute *Primitive::value_as<mindspore::schema::v0::Permute>() const {
  return value_as_Permute();
}

template<> inline const mindspore::schema::v0::FakeQuantWithMinMaxVars *Primitive::value_as<mindspore::schema::v0::FakeQuantWithMinMaxVars>() const {
  return value_as_FakeQuantWithMinMaxVars();
}

template<> inline const mindspore::schema::v0::Equal *Primitive::value_as<mindspore::schema::v0::Equal>() const {
  return value_as_Equal();
}

template<> inline const mindspore::schema::v0::Less *Primitive::value_as<mindspore::schema::v0::Less>() const {
  return value_as_Less();
}

template<> inline const mindspore::schema::v0::Greater *Primitive::value_as<mindspore::schema::v0::Greater>() const {
  return value_as_Greater();
}

template<> inline const mindspore::schema::v0::NotEqual *Primitive::value_as<mindspore::schema::v0::NotEqual>() const {
  return value_as_NotEqual();
}

template<> inline const mindspore::schema::v0::LessEqual *Primitive::value_as<mindspore::schema::v0::LessEqual>() const {
  return value_as_LessEqual();
}

template<> inline const mindspore::schema::v0::GreaterEqual *Primitive::value_as<mindspore::schema::v0::GreaterEqual>() const {
  return value_as_GreaterEqual();
}

template<> inline const mindspore::schema::v0::Min *Primitive::value_as<mindspore::schema::v0::Min>() const {
  return value_as_Min();
}

template<> inline const mindspore::schema::v0::Floor *Primitive::value_as<mindspore::schema::v0::Floor>() const {
  return value_as_Floor();
}

template<> inline const mindspore::schema::v0::Abs *Primitive::value_as<mindspore::schema::v0::Abs>() const {
  return value_as_Abs();
}

template<> inline const mindspore::schema::v0::Neg *Primitive::value_as<mindspore::schema::v0::Neg>() const {
  return value_as_Neg();
}

template<> inline const mindspore::schema::v0::Cos *Primitive::value_as<mindspore::schema::v0::Cos>() const {
  return value_as_Cos();
}

template<> inline const mindspore::schema::v0::Sin *Primitive::value_as<mindspore::schema::v0::Sin>() const {
  return value_as_Sin();
}

template<> inline const mindspore::schema::v0::Sqrt *Primitive::value_as<mindspore::schema::v0::Sqrt>() const {
  return value_as_Sqrt();
}

template<> inline const mindspore::schema::v0::Square *Primitive::value_as<mindspore::schema::v0::Square>() const {
  return value_as_Square();
}

template<> inline const mindspore::schema::v0::Constant *Primitive::value_as<mindspore::schema::v0::Constant>() const {
  return value_as_Constant();
}

template<> inline const mindspore::schema::v0::Log *Primitive::value_as<mindspore::schema::v0::Log>() const {
  return value_as_Log();
}

template<> inline const mindspore::schema::v0::Tan *Primitive::value_as<mindspore::schema::v0::Tan>() const {
  return value_as_Tan();
}

template<> inline const mindspore::schema::v0::Atan *Primitive::value_as<mindspore::schema::v0::Atan>() const {
  return value_as_Atan();
}

template<> inline const mindspore::schema::v0::Asin *Primitive::value_as<mindspore::schema::v0::Asin>() const {
  return value_as_Asin();
}

template<> inline const mindspore::schema::v0::Clip *Primitive::value_as<mindspore::schema::v0::Clip>() const {
  return value_as_Clip();
}

template<> inline const mindspore::schema::v0::Transpose *Primitive::value_as<mindspore::schema::v0::Transpose>() const {
  return value_as_Transpose();
}

template<> inline const mindspore::schema::v0::Squeeze *Primitive::value_as<mindspore::schema::v0::Squeeze>() const {
  return value_as_Squeeze();
}

template<> inline const mindspore::schema::v0::Unsqueeze *Primitive::value_as<mindspore::schema::v0::Unsqueeze>() const {
  return value_as_Unsqueeze();
}

template<> inline const mindspore::schema::v0::Upsample *Primitive::value_as<mindspore::schema::v0::Upsample>() const {
  return value_as_Upsample();
}

template<> inline const mindspore::schema::v0::Dropout *Primitive::value_as<mindspore::schema::v0::Dropout>() const {
  return value_as_Dropout();
}

template<> inline const mindspore::schema::v0::Broadcast *Primitive::value_as<mindspore::schema::v0::Broadcast>() const {
  return value_as_Broadcast();
}

template<> inline const mindspore::schema::v0::BroadcastTo *Primitive::value_as<mindspore::schema::v0::BroadcastTo>() const {
  return value_as_BroadcastTo();
}

template<> inline const mindspore::schema::v0::Lrn *Primitive::value_as<mindspore::schema::v0::Lrn>() const {
  return value_as_Lrn();
}

template<> inline const mindspore::schema::v0::ZerosLike *Primitive::value_as<mindspore::schema::v0::ZerosLike>() const {
  return value_as_ZerosLike();
}

template<> inline const mindspore::schema::v0::TopK *Primitive::value_as<mindspore::schema::v0::TopK>() const {
  return value_as_TopK();
}

template<> inline const mindspore::schema::v0::SpaceToDepth *Primitive::value_as<mindspore::schema::v0::SpaceToDepth>() const {
  return value_as_SpaceToDepth();
}

template<> inline const mindspore::schema::v0::SpaceToBatch *Primitive::value_as<mindspore::schema::v0::SpaceToBatch>() const {
  return value_as_SpaceToBatch();
}

template<> inline const mindspore::schema::v0::SparseToDense *Primitive::value_as<mindspore::schema::v0::SparseToDense>() const {
  return value_as_SparseToDense();
}

template<> inline const mindspore::schema::v0::ReverseSequence *Primitive::value_as<mindspore::schema::v0::ReverseSequence>() const {
  return value_as_ReverseSequence();
}

template<> inline const mindspore::schema::v0::Rank *Primitive::value_as<mindspore::schema::v0::Rank>() const {
  return value_as_Rank();
}

template<> inline const mindspore::schema::v0::Gather *Primitive::value_as<mindspore::schema::v0::Gather>() const {
  return value_as_Gather();
}

template<> inline const mindspore::schema::v0::GatherNd *Primitive::value_as<mindspore::schema::v0::GatherNd>() const {
  return value_as_GatherNd();
}

template<> inline const mindspore::schema::v0::Fill *Primitive::value_as<mindspore::schema::v0::Fill>() const {
  return value_as_Fill();
}

template<> inline const mindspore::schema::v0::Elu *Primitive::value_as<mindspore::schema::v0::Elu>() const {
  return value_as_Elu();
}

template<> inline const mindspore::schema::v0::DepthToSpace *Primitive::value_as<mindspore::schema::v0::DepthToSpace>() const {
  return value_as_DepthToSpace();
}

template<> inline const mindspore::schema::v0::BatchToSpace *Primitive::value_as<mindspore::schema::v0::BatchToSpace>() const {
  return value_as_BatchToSpace();
}

template<> inline const mindspore::schema::v0::AddN *Primitive::value_as<mindspore::schema::v0::AddN>() const {
  return value_as_AddN();
}

template<> inline const mindspore::schema::v0::Ceil *Primitive::value_as<mindspore::schema::v0::Ceil>() const {
  return value_as_Ceil();
}

template<> inline const mindspore::schema::v0::EmbeddingLookup *Primitive::value_as<mindspore::schema::v0::EmbeddingLookup>() const {
  return value_as_EmbeddingLookup();
}

template<> inline const mindspore::schema::v0::EmbeddingLookupSparse *Primitive::value_as<mindspore::schema::v0::EmbeddingLookupSparse>() const {
  return value_as_EmbeddingLookupSparse();
}

template<> inline const mindspore::schema::v0::FloorDiv *Primitive::value_as<mindspore::schema::v0::FloorDiv>() const {
  return value_as_FloorDiv();
}

template<> inline const mindspore::schema::v0::FloorMod *Primitive::value_as<mindspore::schema::v0::FloorMod>() const {
  return value_as_FloorMod();
}

template<> inline const mindspore::schema::v0::L2Norm *Primitive::value_as<mindspore::schema::v0::L2Norm>() const {
  return value_as_L2Norm();
}

template<> inline const mindspore::schema::v0::LocalResponseNormalization *Primitive::value_as<mindspore::schema::v0::LocalResponseNormalization>() const {
  return value_as_LocalResponseNormalization();
}

template<> inline const mindspore::schema::v0::MatrixDiag *Primitive::value_as<mindspore::schema::v0::MatrixDiag>() const {
  return value_as_MatrixDiag();
}

template<> inline const mindspore::schema::v0::Reduce *Primitive::value_as<mindspore::schema::v0::Reduce>() const {
  return value_as_Reduce();
}

template<> inline const mindspore::schema::v0::Reverse *Primitive::value_as<mindspore::schema::v0::Reverse>() const {
  return value_as_Reverse();
}

template<> inline const mindspore::schema::v0::Round *Primitive::value_as<mindspore::schema::v0::Round>() const {
  return value_as_Round();
}

template<> inline const mindspore::schema::v0::Select *Primitive::value_as<mindspore::schema::v0::Select>() const {
  return value_as_Select();
}

template<> inline const mindspore::schema::v0::Scatter *Primitive::value_as<mindspore::schema::v0::Scatter>() const {
  return value_as_Scatter();
}

template<> inline const mindspore::schema::v0::ScatterND *Primitive::value_as<mindspore::schema::v0::ScatterND>() const {
  return value_as_ScatterND();
}

template<> inline const mindspore::schema::v0::ConstantOfShape *Primitive::value_as<mindspore::schema::v0::ConstantOfShape>() const {
  return value_as_ConstantOfShape();
}

template<> inline const mindspore::schema::v0::Unique *Primitive::value_as<mindspore::schema::v0::Unique>() const {
  return value_as_Unique();
}

template<> inline const mindspore::schema::v0::Unstack *Primitive::value_as<mindspore::schema::v0::Unstack>() const {
  return value_as_Unstack();
}

template<> inline const mindspore::schema::v0::LogicalAnd *Primitive::value_as<mindspore::schema::v0::LogicalAnd>() const {
  return value_as_LogicalAnd();
}

template<> inline const mindspore::schema::v0::LogicalOr *Primitive::value_as<mindspore::schema::v0::LogicalOr>() const {
  return value_as_LogicalOr();
}

template<> inline const mindspore::schema::v0::LogicalXor *Primitive::value_as<mindspore::schema::v0::LogicalXor>() const {
  return value_as_LogicalXor();
}

template<> inline const mindspore::schema::v0::LogicalNot *Primitive::value_as<mindspore::schema::v0::LogicalNot>() const {
  return value_as_LogicalNot();
}

template<> inline const mindspore::schema::v0::OnnxInt8Quantize *Primitive::value_as<mindspore::schema::v0::OnnxInt8Quantize>() const {
  return value_as_OnnxInt8Quantize();
}

template<> inline const mindspore::schema::v0::OnnxInt8Dequantize *Primitive::value_as<mindspore::schema::v0::OnnxInt8Dequantize>() const {
  return value_as_OnnxInt8Dequantize();
}

template<> inline const mindspore::schema::v0::FakeQuantWithMinMax *Primitive::value_as<mindspore::schema::v0::FakeQuantWithMinMax>() const {
  return value_as_FakeQuantWithMinMax();
}

template<> inline const mindspore::schema::v0::FakeQuantWithMinMaxPerChannel *Primitive::value_as<mindspore::schema::v0::FakeQuantWithMinMaxPerChannel>() const {
  return value_as_FakeQuantWithMinMaxPerChannel();
}

template<> inline const mindspore::schema::v0::BatchNormFold *Primitive::value_as<mindspore::schema::v0::BatchNormFold>() const {
  return value_as_BatchNormFold();
}

template<> inline const mindspore::schema::v0::MulFold *Primitive::value_as<mindspore::schema::v0::MulFold>() const {
  return value_as_MulFold();
}

template<> inline const mindspore::schema::v0::AddFold *Primitive::value_as<mindspore::schema::v0::AddFold>() const {
  return value_as_AddFold();
}

template<> inline const mindspore::schema::v0::SquaredDifference *Primitive::value_as<mindspore::schema::v0::SquaredDifference>() const {
  return value_as_SquaredDifference();
}

template<> inline const mindspore::schema::v0::Flatten *Primitive::value_as<mindspore::schema::v0::Flatten>() const {
  return value_as_Flatten();
}

template<> inline const mindspore::schema::v0::FlattenGrad *Primitive::value_as<mindspore::schema::v0::FlattenGrad>() const {
  return value_as_FlattenGrad();
}

template<> inline const mindspore::schema::v0::TupleGetItem *Primitive::value_as<mindspore::schema::v0::TupleGetItem>() const {
  return value_as_TupleGetItem();
}

template<> inline const mindspore::schema::v0::Div *Primitive::value_as<mindspore::schema::v0::Div>() const {
  return value_as_Div();
}

template<> inline const mindspore::schema::v0::Where *Primitive::value_as<mindspore::schema::v0::Where>() const {
  return value_as_Where();
}

template<> inline const mindspore::schema::v0::OneHot *Primitive::value_as<mindspore::schema::v0::OneHot>() const {
  return value_as_OneHot();
}

template<> inline const mindspore::schema::v0::Lstm *Primitive::value_as<mindspore::schema::v0::Lstm>() const {
  return value_as_Lstm();
}

template<> inline const mindspore::schema::v0::Conv2DGradFilter *Primitive::value_as<mindspore::schema::v0::Conv2DGradFilter>() const {
  return value_as_Conv2DGradFilter();
}

template<> inline const mindspore::schema::v0::Conv2DGradInput *Primitive::value_as<mindspore::schema::v0::Conv2DGradInput>() const {
  return value_as_Conv2DGradInput();
}

template<> inline const mindspore::schema::v0::PoolingGrad *Primitive::value_as<mindspore::schema::v0::PoolingGrad>() const {
  return value_as_PoolingGrad();
}

template<> inline const mindspore::schema::v0::BNGrad *Primitive::value_as<mindspore::schema::v0::BNGrad>() const {
  return value_as_BNGrad();
}

template<> inline const mindspore::schema::v0::Assign *Primitive::value_as<mindspore::schema::v0::Assign>() const {
  return value_as_Assign();
}

template<> inline const mindspore::schema::v0::ApplyMomentum *Primitive::value_as<mindspore::schema::v0::ApplyMomentum>() const {
  return value_as_ApplyMomentum();
}

template<> inline const mindspore::schema::v0::BiasGrad *Primitive::value_as<mindspore::schema::v0::BiasGrad>() const {
  return value_as_BiasGrad();
}

template<> inline const mindspore::schema::v0::SoftmaxCrossEntropy *Primitive::value_as<mindspore::schema::v0::SoftmaxCrossEntropy>() const {
  return value_as_SoftmaxCrossEntropy();
}

template<> inline const mindspore::schema::v0::AddGrad *Primitive::value_as<mindspore::schema::v0::AddGrad>() const {
  return value_as_AddGrad();
}

template<> inline const mindspore::schema::v0::SubGrad *Primitive::value_as<mindspore::schema::v0::SubGrad>() const {
  return value_as_SubGrad();
}

template<> inline const mindspore::schema::v0::MulGrad *Primitive::value_as<mindspore::schema::v0::MulGrad>() const {
  return value_as_MulGrad();
}

template<> inline const mindspore::schema::v0::DivGrad *Primitive::value_as<mindspore::schema::v0::DivGrad>() const {
  return value_as_DivGrad();
}

template<> inline const mindspore::schema::v0::PowerGrad *Primitive::value_as<mindspore::schema::v0::PowerGrad>() const {
  return value_as_PowerGrad();
}

template<> inline const mindspore::schema::v0::ActivationGrad *Primitive::value_as<mindspore::schema::v0::ActivationGrad>() const {
  return value_as_ActivationGrad();
}

template<> inline const mindspore::schema::v0::PriorBox *Primitive::value_as<mindspore::schema::v0::PriorBox>() const {
  return value_as_PriorBox();
}

template<> inline const mindspore::schema::v0::SpaceToBatchND *Primitive::value_as<mindspore::schema::v0::SpaceToBatchND>() const {
  return value_as_SpaceToBatchND();
}

template<> inline const mindspore::schema::v0::Depend *Primitive::value_as<mindspore::schema::v0::Depend>() const {
  return value_as_Depend();
}

template<> inline const mindspore::schema::v0::Return *Primitive::value_as<mindspore::schema::v0::Return>() const {
  return value_as_Return();
}

template<> inline const mindspore::schema::v0::MakeTuple *Primitive::value_as<mindspore::schema::v0::MakeTuple>() const {
  return value_as_MakeTuple();
}

template<> inline const mindspore::schema::v0::ToFormat *Primitive::value_as<mindspore::schema::v0::ToFormat>() const {
  return value_as_ToFormat();
}

template<> inline const mindspore::schema::v0::Proposal *Primitive::value_as<mindspore::schema::v0::Proposal>() const {
  return value_as_Proposal();
}

template<> inline const mindspore::schema::v0::Custom *Primitive::value_as<mindspore::schema::v0::Custom>() const {
  return value_as_Custom();
}

template<> inline const mindspore::schema::v0::BlackBox *Primitive::value_as<mindspore::schema::v0::BlackBox>() const {
  return value_as_BlackBox();
}

template<> inline const mindspore::schema::v0::NegGrad *Primitive::value_as<mindspore::schema::v0::NegGrad>() const {
  return value_as_NegGrad();
}

template<> inline const mindspore::schema::v0::LogGrad *Primitive::value_as<mindspore::schema::v0::LogGrad>() const {
  return value_as_LogGrad();
}

template<> inline const mindspore::schema::v0::BatchToSpaceND *Primitive::value_as<mindspore::schema::v0::BatchToSpaceND>() const {
  return value_as_BatchToSpaceND();
}

template<> inline const mindspore::schema::v0::LshProjection *Primitive::value_as<mindspore::schema::v0::LshProjection>() const {
  return value_as_LshProjection();
}

template<> inline const mindspore::schema::v0::HashtableLookup *Primitive::value_as<mindspore::schema::v0::HashtableLookup>() const {
  return value_as_HashtableLookup();
}

template<> inline const mindspore::schema::v0::SkipGram *Primitive::value_as<mindspore::schema::v0::SkipGram>() const {
  return value_as_SkipGram();
}

template<> inline const mindspore::schema::v0::DeConv2DGradFilter *Primitive::value_as<mindspore::schema::v0::DeConv2DGradFilter>() const {
  return value_as_DeConv2DGradFilter();
}

template<> inline const mindspore::schema::v0::CustomPredict *Primitive::value_as<mindspore::schema::v0::CustomPredict>() const {
  return value_as_CustomPredict();
}

template<> inline const mindspore::schema::v0::CustomNormalize *Primitive::value_as<mindspore::schema::v0::CustomNormalize>() const {
  return value_as_CustomNormalize();
}

template<> inline const mindspore::schema::v0::CustomExtractFeatures *Primitive::value_as<mindspore::schema::v0::CustomExtractFeatures>() const {
  return value_as_CustomExtractFeatures();
}

template<> inline const mindspore::schema::v0::AudioSpectrogram *Primitive::value_as<mindspore::schema::v0::AudioSpectrogram>() const {
  return value_as_AudioSpectrogram();
}

template<> inline const mindspore::schema::v0::Mfcc *Primitive::value_as<mindspore::schema::v0::Mfcc>() const {
  return value_as_Mfcc();
}

template<> inline const mindspore::schema::v0::Rfft *Primitive::value_as<mindspore::schema::v0::Rfft>() const {
  return value_as_Rfft();
}

template<> inline const mindspore::schema::v0::FftReal *Primitive::value_as<mindspore::schema::v0::FftReal>() const {
  return value_as_FftReal();
}

template<> inline const mindspore::schema::v0::FftImag *Primitive::value_as<mindspore::schema::v0::FftImag>() const {
  return value_as_FftImag();
}

template<> inline const mindspore::schema::v0::Sgd *Primitive::value_as<mindspore::schema::v0::Sgd>() const {
  return value_as_Sgd();
}

template<> inline const mindspore::schema::v0::Adam *Primitive::value_as<mindspore::schema::v0::Adam>() const {
  return value_as_Adam();
}

template<> inline const mindspore::schema::v0::GroupConv2DGradInput *Primitive::value_as<mindspore::schema::v0::GroupConv2DGradInput>() const {
  return value_as_GroupConv2DGradInput();
}

template<> inline const mindspore::schema::v0::Loop *Primitive::value_as<mindspore::schema::v0::Loop>() const {
  return value_as_Loop();
}

template<> inline const mindspore::schema::v0::NonMaxSuppression *Primitive::value_as<mindspore::schema::v0::NonMaxSuppression>() const {
  return value_as_NonMaxSuppression();
}

template<> inline const mindspore::schema::v0::InstanceNorm *Primitive::value_as<mindspore::schema::v0::InstanceNorm>() const {
  return value_as_InstanceNorm();
}

template<> inline const mindspore::schema::v0::Identity *Primitive::value_as<mindspore::schema::v0::Identity>() const {
  return value_as_Identity();
}

template<> inline const mindspore::schema::v0::LayerNorm *Primitive::value_as<mindspore::schema::v0::LayerNorm>() const {
  return value_as_LayerNorm();
}

template<> inline const mindspore::schema::v0::While *Primitive::value_as<mindspore::schema::v0::While>() const {
  return value_as_While();
}

template<> inline const mindspore::schema::v0::ControlDepend *Primitive::value_as<mindspore::schema::v0::ControlDepend>() const {
  return value_as_ControlDepend();
}

template<> inline const mindspore::schema::v0::UnsortedSegmentSum *Primitive::value_as<mindspore::schema::v0::UnsortedSegmentSum>() const {
  return value_as_UnsortedSegmentSum();
}

template<> inline const mindspore::schema::v0::AssignAdd *Primitive::value_as<mindspore::schema::v0::AssignAdd>() const {
  return value_as_AssignAdd();
}

template<> inline const mindspore::schema::v0::OnesLike *Primitive::value_as<mindspore::schema::v0::OnesLike>() const {
  return value_as_OnesLike();
}

template<> inline const mindspore::schema::v0::BinaryCrossEntropyGrad *Primitive::value_as<mindspore::schema::v0::BinaryCrossEntropyGrad>() const {
  return value_as_BinaryCrossEntropyGrad();
}

template<> inline const mindspore::schema::v0::BinaryCrossEntropy *Primitive::value_as<mindspore::schema::v0::BinaryCrossEntropy>() const {
  return value_as_BinaryCrossEntropy();
}

template<> inline const mindspore::schema::v0::LpNormalization *Primitive::value_as<mindspore::schema::v0::LpNormalization>() const {
  return value_as_LpNormalization();
}

template<> inline const mindspore::schema::v0::DropoutGrad *Primitive::value_as<mindspore::schema::v0::DropoutGrad>() const {
  return value_as_DropoutGrad();
}

template<> inline const mindspore::schema::v0::MaximumGrad *Primitive::value_as<mindspore::schema::v0::MaximumGrad>() const {
  return value_as_MaximumGrad();
}

template<> inline const mindspore::schema::v0::MinimumGrad *Primitive::value_as<mindspore::schema::v0::MinimumGrad>() const {
  return value_as_MinimumGrad();
}

template<> inline const mindspore::schema::v0::Switch *Primitive::value_as<mindspore::schema::v0::Switch>() const {
  return value_as_Switch();
}

template<> inline const mindspore::schema::v0::Partial *Primitive::value_as<mindspore::schema::v0::Partial>() const {
  return value_as_Partial();
}

template<> inline const mindspore::schema::v0::TensorListFromTensor *Primitive::value_as<mindspore::schema::v0::TensorListFromTensor>() const {
  return value_as_TensorListFromTensor();
}

template<> inline const mindspore::schema::v0::TensorListStack *Primitive::value_as<mindspore::schema::v0::TensorListStack>() const {
  return value_as_TensorListStack();
}

template<> inline const mindspore::schema::v0::TensorListGetItem *Primitive::value_as<mindspore::schema::v0::TensorListGetItem>() const {
  return value_as_TensorListGetItem();
}

template<> inline const mindspore::schema::v0::TensorListSetItem *Primitive::value_as<mindspore::schema::v0::TensorListSetItem>() const {
  return value_as_TensorListSetItem();
}

template<> inline const mindspore::schema::v0::TensorListReserve *Primitive::value_as<mindspore::schema::v0::TensorListReserve>() const {
  return value_as_TensorListReserve();
}

template<> inline const mindspore::schema::v0::All *Primitive::value_as<mindspore::schema::v0::All>() const {
  return value_as_All();
}

template<> inline const mindspore::schema::v0::Assert *Primitive::value_as<mindspore::schema::v0::Assert>() const {
  return value_as_Assert();
}

template<> inline const mindspore::schema::v0::Adder *Primitive::value_as<mindspore::schema::v0::Adder>() const {
  return value_as_Adder();
}

template<> inline const mindspore::schema::v0::SparseSoftmaxCrossEntropy *Primitive::value_as<mindspore::schema::v0::SparseSoftmaxCrossEntropy>() const {
  return value_as_SparseSoftmaxCrossEntropy();
}

template<> inline const mindspore::schema::v0::SmoothL1Loss *Primitive::value_as<mindspore::schema::v0::SmoothL1Loss>() const {
  return value_as_SmoothL1Loss();
}

template<> inline const mindspore::schema::v0::SmoothL1LossGrad *Primitive::value_as<mindspore::schema::v0::SmoothL1LossGrad>() const {
  return value_as_SmoothL1LossGrad();
}

template<> inline const mindspore::schema::v0::SigmoidCrossEntropyWithLogits *Primitive::value_as<mindspore::schema::v0::SigmoidCrossEntropyWithLogits>() const {
  return value_as_SigmoidCrossEntropyWithLogits();
}

template<> inline const mindspore::schema::v0::SigmoidCrossEntropyWithLogitsGrad *Primitive::value_as<mindspore::schema::v0::SigmoidCrossEntropyWithLogitsGrad>() const {
  return value_as_SigmoidCrossEntropyWithLogitsGrad();
}

template<> inline const mindspore::schema::v0::Reciprocal *Primitive::value_as<mindspore::schema::v0::Reciprocal>() const {
  return value_as_Reciprocal();
}

template<> inline const mindspore::schema::v0::Merge *Primitive::value_as<mindspore::schema::v0::Merge>() const {
  return value_as_Merge();
}

template<> inline const mindspore::schema::v0::Mod *Primitive::value_as<mindspore::schema::v0::Mod>() const {
  return value_as_Mod();
}

template<> inline const mindspore::schema::v0::GeLU *Primitive::value_as<mindspore::schema::v0::GeLU>() const {
  return value_as_GeLU();
}

struct PrimitiveBuilder {
  typedef Primitive Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_value_type(mindspore::schema::v0::PrimitiveType value_type) {
    fbb_.AddElement<uint8_t>(Primitive::VT_VALUE_TYPE, static_cast<uint8_t>(value_type), 0);
  }
  void add_value(flatbuffers::Offset<void> value) {
    fbb_.AddOffset(Primitive::VT_VALUE, value);
  }
  explicit PrimitiveBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Primitive> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Primitive>(end);
    return o;
  }
};

inline flatbuffers::Offset<Primitive> CreatePrimitive(
    flatbuffers::FlatBufferBuilder &_fbb,
    mindspore::schema::v0::PrimitiveType value_type = mindspore::schema::v0::PrimitiveType_NONE,
    flatbuffers::Offset<void> value = 0) {
  PrimitiveBuilder builder_(_fbb);
  builder_.add_value(value);
  builder_.add_value_type(value_type);
  return builder_.Finish();
}

struct CNode FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef CNodeBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NAME = 4,
    VT_NODETYPE = 6,
    VT_PRIMITIVE = 8,
    VT_INPUTINDEX = 10,
    VT_OUTPUTINDEX = 12,
    VT_QUANTTYPE = 14
  };
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  mindspore::schema::v0::NodeType nodeType() const {
    return static_cast<mindspore::schema::v0::NodeType>(GetField<int32_t>(VT_NODETYPE, 2));
  }
  const mindspore::schema::v0::Primitive *primitive() const {
    return GetPointer<const mindspore::schema::v0::Primitive *>(VT_PRIMITIVE);
  }
  const flatbuffers::Vector<uint32_t> *inputIndex() const {
    return GetPointer<const flatbuffers::Vector<uint32_t> *>(VT_INPUTINDEX);
  }
  const flatbuffers::Vector<uint32_t> *outputIndex() const {
    return GetPointer<const flatbuffers::Vector<uint32_t> *>(VT_OUTPUTINDEX);
  }
  mindspore::schema::v0::QuantType quantType() const {
    return static_cast<mindspore::schema::v0::QuantType>(GetField<int32_t>(VT_QUANTTYPE, 0));
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyField<int32_t>(verifier, VT_NODETYPE) &&
           VerifyOffset(verifier, VT_PRIMITIVE) &&
           verifier.VerifyTable(primitive()) &&
           VerifyOffset(verifier, VT_INPUTINDEX) &&
           verifier.VerifyVector(inputIndex()) &&
           VerifyOffset(verifier, VT_OUTPUTINDEX) &&
           verifier.VerifyVector(outputIndex()) &&
           VerifyField<int32_t>(verifier, VT_QUANTTYPE) &&
           verifier.EndTable();
  }
};

struct CNodeBuilder {
  typedef CNode Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(CNode::VT_NAME, name);
  }
  void add_nodeType(mindspore::schema::v0::NodeType nodeType) {
    fbb_.AddElement<int32_t>(CNode::VT_NODETYPE, static_cast<int32_t>(nodeType), 2);
  }
  void add_primitive(flatbuffers::Offset<mindspore::schema::v0::Primitive> primitive) {
    fbb_.AddOffset(CNode::VT_PRIMITIVE, primitive);
  }
  void add_inputIndex(flatbuffers::Offset<flatbuffers::Vector<uint32_t>> inputIndex) {
    fbb_.AddOffset(CNode::VT_INPUTINDEX, inputIndex);
  }
  void add_outputIndex(flatbuffers::Offset<flatbuffers::Vector<uint32_t>> outputIndex) {
    fbb_.AddOffset(CNode::VT_OUTPUTINDEX, outputIndex);
  }
  void add_quantType(mindspore::schema::v0::QuantType quantType) {
    fbb_.AddElement<int32_t>(CNode::VT_QUANTTYPE, static_cast<int32_t>(quantType), 0);
  }
  explicit CNodeBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<CNode> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<CNode>(end);
    return o;
  }
};

inline flatbuffers::Offset<CNode> CreateCNode(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    mindspore::schema::v0::NodeType nodeType = mindspore::schema::v0::NodeType_CNode,
    flatbuffers::Offset<mindspore::schema::v0::Primitive> primitive = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint32_t>> inputIndex = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint32_t>> outputIndex = 0,
    mindspore::schema::v0::QuantType quantType = mindspore::schema::v0::QuantType_QUANT_NONE) {
  CNodeBuilder builder_(_fbb);
  builder_.add_quantType(quantType);
  builder_.add_outputIndex(outputIndex);
  builder_.add_inputIndex(inputIndex);
  builder_.add_primitive(primitive);
  builder_.add_nodeType(nodeType);
  builder_.add_name(name);
  return builder_.Finish();
}

inline flatbuffers::Offset<CNode> CreateCNodeDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *name = nullptr,
    mindspore::schema::v0::NodeType nodeType = mindspore::schema::v0::NodeType_CNode,
    flatbuffers::Offset<mindspore::schema::v0::Primitive> primitive = 0,
    const std::vector<uint32_t> *inputIndex = nullptr,
    const std::vector<uint32_t> *outputIndex = nullptr,
    mindspore::schema::v0::QuantType quantType = mindspore::schema::v0::QuantType_QUANT_NONE) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  auto inputIndex__ = inputIndex ? _fbb.CreateVector<uint32_t>(*inputIndex) : 0;
  auto outputIndex__ = outputIndex ? _fbb.CreateVector<uint32_t>(*outputIndex) : 0;
  return mindspore::schema::v0::CreateCNode(
      _fbb,
      name__,
      nodeType,
      primitive,
      inputIndex__,
      outputIndex__,
      quantType);
}

struct SubGraph FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef SubGraphBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NAME = 4,
    VT_INPUTINDICES = 6,
    VT_OUTPUTINDICES = 8,
    VT_NODEINDICES = 10,
    VT_TENSORINDICES = 12
  };
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  const flatbuffers::Vector<uint32_t> *inputIndices() const {
    return GetPointer<const flatbuffers::Vector<uint32_t> *>(VT_INPUTINDICES);
  }
  const flatbuffers::Vector<uint32_t> *outputIndices() const {
    return GetPointer<const flatbuffers::Vector<uint32_t> *>(VT_OUTPUTINDICES);
  }
  const flatbuffers::Vector<uint32_t> *nodeIndices() const {
    return GetPointer<const flatbuffers::Vector<uint32_t> *>(VT_NODEINDICES);
  }
  const flatbuffers::Vector<uint32_t> *tensorIndices() const {
    return GetPointer<const flatbuffers::Vector<uint32_t> *>(VT_TENSORINDICES);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyOffset(verifier, VT_INPUTINDICES) &&
           verifier.VerifyVector(inputIndices()) &&
           VerifyOffset(verifier, VT_OUTPUTINDICES) &&
           verifier.VerifyVector(outputIndices()) &&
           VerifyOffset(verifier, VT_NODEINDICES) &&
           verifier.VerifyVector(nodeIndices()) &&
           VerifyOffset(verifier, VT_TENSORINDICES) &&
           verifier.VerifyVector(tensorIndices()) &&
           verifier.EndTable();
  }
};

struct SubGraphBuilder {
  typedef SubGraph Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(SubGraph::VT_NAME, name);
  }
  void add_inputIndices(flatbuffers::Offset<flatbuffers::Vector<uint32_t>> inputIndices) {
    fbb_.AddOffset(SubGraph::VT_INPUTINDICES, inputIndices);
  }
  void add_outputIndices(flatbuffers::Offset<flatbuffers::Vector<uint32_t>> outputIndices) {
    fbb_.AddOffset(SubGraph::VT_OUTPUTINDICES, outputIndices);
  }
  void add_nodeIndices(flatbuffers::Offset<flatbuffers::Vector<uint32_t>> nodeIndices) {
    fbb_.AddOffset(SubGraph::VT_NODEINDICES, nodeIndices);
  }
  void add_tensorIndices(flatbuffers::Offset<flatbuffers::Vector<uint32_t>> tensorIndices) {
    fbb_.AddOffset(SubGraph::VT_TENSORINDICES, tensorIndices);
  }
  explicit SubGraphBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<SubGraph> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SubGraph>(end);
    return o;
  }
};

inline flatbuffers::Offset<SubGraph> CreateSubGraph(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint32_t>> inputIndices = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint32_t>> outputIndices = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint32_t>> nodeIndices = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint32_t>> tensorIndices = 0) {
  SubGraphBuilder builder_(_fbb);
  builder_.add_tensorIndices(tensorIndices);
  builder_.add_nodeIndices(nodeIndices);
  builder_.add_outputIndices(outputIndices);
  builder_.add_inputIndices(inputIndices);
  builder_.add_name(name);
  return builder_.Finish();
}

inline flatbuffers::Offset<SubGraph> CreateSubGraphDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *name = nullptr,
    const std::vector<uint32_t> *inputIndices = nullptr,
    const std::vector<uint32_t> *outputIndices = nullptr,
    const std::vector<uint32_t> *nodeIndices = nullptr,
    const std::vector<uint32_t> *tensorIndices = nullptr) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  auto inputIndices__ = inputIndices ? _fbb.CreateVector<uint32_t>(*inputIndices) : 0;
  auto outputIndices__ = outputIndices ? _fbb.CreateVector<uint32_t>(*outputIndices) : 0;
  auto nodeIndices__ = nodeIndices ? _fbb.CreateVector<uint32_t>(*nodeIndices) : 0;
  auto tensorIndices__ = tensorIndices ? _fbb.CreateVector<uint32_t>(*tensorIndices) : 0;
  return mindspore::schema::v0::CreateSubGraph(
      _fbb,
      name__,
      inputIndices__,
      outputIndices__,
      nodeIndices__,
      tensorIndices__);
}

struct MetaGraph FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef MetaGraphBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NAME = 4,
    VT_VERSION = 6,
    VT_FMKTYPE = 8,
    VT_INPUTINDEX = 10,
    VT_OUTPUTINDEX = 12,
    VT_MEMPOOLSIZE = 14,
    VT_NODES = 16,
    VT_ALLTENSORS = 18,
    VT_SUBGRAPH = 20
  };
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  const flatbuffers::String *version() const {
    return GetPointer<const flatbuffers::String *>(VT_VERSION);
  }
  int32_t fmkType() const {
    return GetField<int32_t>(VT_FMKTYPE, 0);
  }
  const flatbuffers::Vector<uint32_t> *inputIndex() const {
    return GetPointer<const flatbuffers::Vector<uint32_t> *>(VT_INPUTINDEX);
  }
  const flatbuffers::Vector<uint32_t> *outputIndex() const {
    return GetPointer<const flatbuffers::Vector<uint32_t> *>(VT_OUTPUTINDEX);
  }
  uint32_t mempoolSize() const {
    return GetField<uint32_t>(VT_MEMPOOLSIZE, 0);
  }
  const flatbuffers::Vector<flatbuffers::Offset<mindspore::schema::v0::CNode>> *nodes() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<mindspore::schema::v0::CNode>> *>(VT_NODES);
  }
  const flatbuffers::Vector<flatbuffers::Offset<mindspore::schema::v0::Tensor>> *allTensors() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<mindspore::schema::v0::Tensor>> *>(VT_ALLTENSORS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<mindspore::schema::v0::SubGraph>> *subGraph() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<mindspore::schema::v0::SubGraph>> *>(VT_SUBGRAPH);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyOffset(verifier, VT_VERSION) &&
           verifier.VerifyString(version()) &&
           VerifyField<int32_t>(verifier, VT_FMKTYPE) &&
           VerifyOffset(verifier, VT_INPUTINDEX) &&
           verifier.VerifyVector(inputIndex()) &&
           VerifyOffset(verifier, VT_OUTPUTINDEX) &&
           verifier.VerifyVector(outputIndex()) &&
           VerifyField<uint32_t>(verifier, VT_MEMPOOLSIZE) &&
           VerifyOffset(verifier, VT_NODES) &&
           verifier.VerifyVector(nodes()) &&
           verifier.VerifyVectorOfTables(nodes()) &&
           VerifyOffset(verifier, VT_ALLTENSORS) &&
           verifier.VerifyVector(allTensors()) &&
           verifier.VerifyVectorOfTables(allTensors()) &&
           VerifyOffset(verifier, VT_SUBGRAPH) &&
           verifier.VerifyVector(subGraph()) &&
           verifier.VerifyVectorOfTables(subGraph()) &&
           verifier.EndTable();
  }
};

struct MetaGraphBuilder {
  typedef MetaGraph Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(MetaGraph::VT_NAME, name);
  }
  void add_version(flatbuffers::Offset<flatbuffers::String> version) {
    fbb_.AddOffset(MetaGraph::VT_VERSION, version);
  }
  void add_fmkType(int32_t fmkType) {
    fbb_.AddElement<int32_t>(MetaGraph::VT_FMKTYPE, fmkType, 0);
  }
  void add_inputIndex(flatbuffers::Offset<flatbuffers::Vector<uint32_t>> inputIndex) {
    fbb_.AddOffset(MetaGraph::VT_INPUTINDEX, inputIndex);
  }
  void add_outputIndex(flatbuffers::Offset<flatbuffers::Vector<uint32_t>> outputIndex) {
    fbb_.AddOffset(MetaGraph::VT_OUTPUTINDEX, outputIndex);
  }
  void add_mempoolSize(uint32_t mempoolSize) {
    fbb_.AddElement<uint32_t>(MetaGraph::VT_MEMPOOLSIZE, mempoolSize, 0);
  }
  void add_nodes(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<mindspore::schema::v0::CNode>>> nodes) {
    fbb_.AddOffset(MetaGraph::VT_NODES, nodes);
  }
  void add_allTensors(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<mindspore::schema::v0::Tensor>>> allTensors) {
    fbb_.AddOffset(MetaGraph::VT_ALLTENSORS, allTensors);
  }
  void add_subGraph(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<mindspore::schema::v0::SubGraph>>> subGraph) {
    fbb_.AddOffset(MetaGraph::VT_SUBGRAPH, subGraph);
  }
  explicit MetaGraphBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<MetaGraph> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<MetaGraph>(end);
    return o;
  }
};

inline flatbuffers::Offset<MetaGraph> CreateMetaGraph(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    flatbuffers::Offset<flatbuffers::String> version = 0,
    int32_t fmkType = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint32_t>> inputIndex = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint32_t>> outputIndex = 0,
    uint32_t mempoolSize = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<mindspore::schema::v0::CNode>>> nodes = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<mindspore::schema::v0::Tensor>>> allTensors = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<mindspore::schema::v0::SubGraph>>> subGraph = 0) {
  MetaGraphBuilder builder_(_fbb);
  builder_.add_subGraph(subGraph);
  builder_.add_allTensors(allTensors);
  builder_.add_nodes(nodes);
  builder_.add_mempoolSize(mempoolSize);
  builder_.add_outputIndex(outputIndex);
  builder_.add_inputIndex(inputIndex);
  builder_.add_fmkType(fmkType);
  builder_.add_version(version);
  builder_.add_name(name);
  return builder_.Finish();
}

inline flatbuffers::Offset<MetaGraph> CreateMetaGraphDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *name = nullptr,
    const char *version = nullptr,
    int32_t fmkType = 0,
    const std::vector<uint32_t> *inputIndex = nullptr,
    const std::vector<uint32_t> *outputIndex = nullptr,
    uint32_t mempoolSize = 0,
    const std::vector<flatbuffers::Offset<mindspore::schema::v0::CNode>> *nodes = nullptr,
    const std::vector<flatbuffers::Offset<mindspore::schema::v0::Tensor>> *allTensors = nullptr,
    const std::vector<flatbuffers::Offset<mindspore::schema::v0::SubGraph>> *subGraph = nullptr) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  auto version__ = version ? _fbb.CreateString(version) : 0;
  auto inputIndex__ = inputIndex ? _fbb.CreateVector<uint32_t>(*inputIndex) : 0;
  auto outputIndex__ = outputIndex ? _fbb.CreateVector<uint32_t>(*outputIndex) : 0;
  auto nodes__ = nodes ? _fbb.CreateVector<flatbuffers::Offset<mindspore::schema::v0::CNode>>(*nodes) : 0;
  auto allTensors__ = allTensors ? _fbb.CreateVector<flatbuffers::Offset<mindspore::schema::v0::Tensor>>(*allTensors) : 0;
  auto subGraph__ = subGraph ? _fbb.CreateVector<flatbuffers::Offset<mindspore::schema::v0::SubGraph>>(*subGraph) : 0;
  return mindspore::schema::v0::CreateMetaGraph(
      _fbb,
      name__,
      version__,
      fmkType,
      inputIndex__,
      outputIndex__,
      mempoolSize,
      nodes__,
      allTensors__,
      subGraph__);
}

inline bool VerifyPrimitiveType(flatbuffers::Verifier &verifier, const void *obj, PrimitiveType type) {
  switch (type) {
    case PrimitiveType_NONE: {
      return true;
    }
    case PrimitiveType_Concat: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::Concat *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_SoftMax: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::SoftMax *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_Activation: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::Activation *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_Conv2D: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::Conv2D *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_FusedBatchNorm: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::FusedBatchNorm *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_BatchNorm: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::BatchNorm *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_BiasAdd: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::BiasAdd *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_Pooling: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::Pooling *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_ROIPooling: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::ROIPooling *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_DepthwiseConv2D: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::DepthwiseConv2D *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_DeDepthwiseConv2D: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::DeDepthwiseConv2D *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_Resize: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::Resize *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_DetectionPostProcess: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::DetectionPostProcess *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_FullConnection: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::FullConnection *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_Mean: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::Mean *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_DeConv2D: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::DeConv2D *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_Scale: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::Scale *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_Reshape: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::Reshape *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_Eltwise: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::Eltwise *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_NetOutput: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::NetOutput *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_Add: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::Add *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_Sub: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::Sub *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_MatMul: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::MatMul *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_StridedSlice: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::StridedSlice *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_Power: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::Power *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_Slice: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::Slice *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_Stack: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::Stack *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_Mul: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::Mul *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_RealDiv: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::RealDiv *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_Pad: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::Pad *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_Maximum: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::Maximum *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_Minimum: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::Minimum *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_PReLU: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::PReLU *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_LeakyReLU: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::LeakyReLU *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_ArgMax: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::ArgMax *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_ArgMin: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::ArgMin *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_Exp: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::Exp *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_Crop: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::Crop *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_Range: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::Range *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_Rsqrt: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::Rsqrt *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_ExpandDims: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::ExpandDims *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_Tile: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::Tile *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_Cast: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::Cast *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_Shape: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::Shape *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_Nchw2Nhwc: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::Nchw2Nhwc *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_Nhwc2Nchw: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::Nhwc2Nchw *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_QuantDTypeCast: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::QuantDTypeCast *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_Split: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::Split *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_Permute: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::Permute *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_FakeQuantWithMinMaxVars: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::FakeQuantWithMinMaxVars *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_Equal: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::Equal *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_Less: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::Less *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_Greater: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::Greater *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_NotEqual: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::NotEqual *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_LessEqual: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::LessEqual *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_GreaterEqual: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::GreaterEqual *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_Min: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::Min *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_Floor: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::Floor *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_Abs: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::Abs *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_Neg: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::Neg *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_Cos: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::Cos *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_Sin: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::Sin *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_Sqrt: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::Sqrt *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_Square: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::Square *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_Constant: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::Constant *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_Log: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::Log *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_Tan: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::Tan *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_Atan: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::Atan *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_Asin: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::Asin *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_Clip: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::Clip *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_Transpose: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::Transpose *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_Squeeze: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::Squeeze *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_Unsqueeze: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::Unsqueeze *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_Upsample: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::Upsample *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_Dropout: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::Dropout *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_Broadcast: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::Broadcast *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_BroadcastTo: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::BroadcastTo *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_Lrn: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::Lrn *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_ZerosLike: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::ZerosLike *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_TopK: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::TopK *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_SpaceToDepth: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::SpaceToDepth *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_SpaceToBatch: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::SpaceToBatch *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_SparseToDense: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::SparseToDense *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_ReverseSequence: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::ReverseSequence *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_Rank: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::Rank *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_Gather: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::Gather *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_GatherNd: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::GatherNd *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_Fill: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::Fill *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_Elu: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::Elu *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_DepthToSpace: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::DepthToSpace *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_BatchToSpace: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::BatchToSpace *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_AddN: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::AddN *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_Ceil: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::Ceil *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_EmbeddingLookup: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::EmbeddingLookup *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_EmbeddingLookupSparse: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::EmbeddingLookupSparse *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_FloorDiv: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::FloorDiv *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_FloorMod: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::FloorMod *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_L2Norm: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::L2Norm *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_LocalResponseNormalization: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::LocalResponseNormalization *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_MatrixDiag: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::MatrixDiag *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_Reduce: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::Reduce *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_Reverse: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::Reverse *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_Round: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::Round *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_Select: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::Select *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_Scatter: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::Scatter *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_ScatterND: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::ScatterND *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_ConstantOfShape: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::ConstantOfShape *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_Unique: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::Unique *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_Unstack: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::Unstack *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_LogicalAnd: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::LogicalAnd *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_LogicalOr: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::LogicalOr *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_LogicalXor: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::LogicalXor *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_LogicalNot: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::LogicalNot *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_OnnxInt8Quantize: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::OnnxInt8Quantize *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_OnnxInt8Dequantize: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::OnnxInt8Dequantize *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_FakeQuantWithMinMax: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::FakeQuantWithMinMax *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_FakeQuantWithMinMaxPerChannel: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::FakeQuantWithMinMaxPerChannel *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_BatchNormFold: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::BatchNormFold *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_MulFold: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::MulFold *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_AddFold: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::AddFold *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_SquaredDifference: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::SquaredDifference *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_Flatten: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::Flatten *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_FlattenGrad: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::FlattenGrad *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_TupleGetItem: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::TupleGetItem *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_Div: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::Div *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_Where: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::Where *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_OneHot: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::OneHot *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_Lstm: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::Lstm *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_Conv2DGradFilter: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::Conv2DGradFilter *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_Conv2DGradInput: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::Conv2DGradInput *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_PoolingGrad: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::PoolingGrad *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_BNGrad: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::BNGrad *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_Assign: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::Assign *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_ApplyMomentum: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::ApplyMomentum *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_BiasGrad: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::BiasGrad *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_SoftmaxCrossEntropy: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::SoftmaxCrossEntropy *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_AddGrad: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::AddGrad *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_SubGrad: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::SubGrad *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_MulGrad: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::MulGrad *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_DivGrad: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::DivGrad *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_PowerGrad: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::PowerGrad *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_ActivationGrad: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::ActivationGrad *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_PriorBox: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::PriorBox *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_SpaceToBatchND: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::SpaceToBatchND *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_Depend: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::Depend *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_Return: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::Return *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_MakeTuple: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::MakeTuple *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_ToFormat: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::ToFormat *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_Proposal: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::Proposal *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_Custom: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::Custom *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_BlackBox: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::BlackBox *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_NegGrad: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::NegGrad *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_LogGrad: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::LogGrad *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_BatchToSpaceND: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::BatchToSpaceND *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_LshProjection: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::LshProjection *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_HashtableLookup: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::HashtableLookup *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_SkipGram: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::SkipGram *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_DeConv2DGradFilter: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::DeConv2DGradFilter *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_CustomPredict: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::CustomPredict *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_CustomNormalize: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::CustomNormalize *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_CustomExtractFeatures: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::CustomExtractFeatures *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_AudioSpectrogram: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::AudioSpectrogram *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_Mfcc: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::Mfcc *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_Rfft: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::Rfft *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_FftReal: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::FftReal *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_FftImag: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::FftImag *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_Sgd: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::Sgd *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_Adam: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::Adam *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_GroupConv2DGradInput: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::GroupConv2DGradInput *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_Loop: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::Loop *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_NonMaxSuppression: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::NonMaxSuppression *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_InstanceNorm: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::InstanceNorm *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_Identity: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::Identity *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_LayerNorm: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::LayerNorm *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_While: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::While *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_ControlDepend: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::ControlDepend *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_UnsortedSegmentSum: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::UnsortedSegmentSum *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_AssignAdd: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::AssignAdd *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_OnesLike: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::OnesLike *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_BinaryCrossEntropyGrad: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::BinaryCrossEntropyGrad *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_BinaryCrossEntropy: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::BinaryCrossEntropy *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_LpNormalization: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::LpNormalization *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_DropoutGrad: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::DropoutGrad *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_MaximumGrad: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::MaximumGrad *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_MinimumGrad: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::MinimumGrad *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_Switch: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::Switch *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_Partial: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::Partial *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_TensorListFromTensor: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::TensorListFromTensor *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_TensorListStack: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::TensorListStack *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_TensorListGetItem: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::TensorListGetItem *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_TensorListSetItem: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::TensorListSetItem *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_TensorListReserve: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::TensorListReserve *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_All: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::All *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_Assert: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::Assert *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_Adder: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::Adder *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_SparseSoftmaxCrossEntropy: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::SparseSoftmaxCrossEntropy *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_SmoothL1Loss: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::SmoothL1Loss *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_SmoothL1LossGrad: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::SmoothL1LossGrad *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_SigmoidCrossEntropyWithLogits: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::SigmoidCrossEntropyWithLogits *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_SigmoidCrossEntropyWithLogitsGrad: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::SigmoidCrossEntropyWithLogitsGrad *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_Reciprocal: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::Reciprocal *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_Merge: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::Merge *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_Mod: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::Mod *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_GeLU: {
      auto ptr = reinterpret_cast<const mindspore::schema::v0::GeLU *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return true;
  }
}

inline bool VerifyPrimitiveTypeVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyPrimitiveType(
        verifier,  values->Get(i), types->GetEnum<PrimitiveType>(i))) {
      return false;
    }
  }
  return true;
}

inline const mindspore::schema::v0::MetaGraph *GetMetaGraph(const void *buf) {
  return flatbuffers::GetRoot<mindspore::schema::v0::MetaGraph>(buf);
}

inline const mindspore::schema::v0::MetaGraph *GetSizePrefixedMetaGraph(const void *buf) {
  return flatbuffers::GetSizePrefixedRoot<mindspore::schema::v0::MetaGraph>(buf);
}

inline bool VerifyMetaGraphBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<mindspore::schema::v0::MetaGraph>(nullptr);
}

inline bool VerifySizePrefixedMetaGraphBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<mindspore::schema::v0::MetaGraph>(nullptr);
}

inline void FinishMetaGraphBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<mindspore::schema::v0::MetaGraph> root) {
  fbb.Finish(root);
}

inline void FinishSizePrefixedMetaGraphBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<mindspore::schema::v0::MetaGraph> root) {
  fbb.FinishSizePrefixed(root);
}

}  // namespace v0
}  // namespace schema
}  // namespace mindspore

#endif  // FLATBUFFERS_GENERATED_MODELV0_MINDSPORE_SCHEMA_V0_H_
